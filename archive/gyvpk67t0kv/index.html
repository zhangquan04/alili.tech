<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="ES6 Async/Await 完爆Promise的6个原因"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>ES6 Async/Await 完爆Promise的6个原因 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/gyvpk67t0kv/",
				"appid": "1613049289050283", 
				"title": "ES6 Async/Await 完爆Promise的6个原因 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-16T02:30:08"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/wr9bm1wv9e9/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/sfq54vxwpi9/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fgyvpk67t0kv%2f&text=ES6%20Async%2fAwait%20%e5%ae%8c%e7%88%86Promise%e7%9a%846%e4%b8%aa%e5%8e%9f%e5%9b%a0"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fgyvpk67t0kv%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fgyvpk67t0kv%2f&text=ES6%20Async%2fAwait%20%e5%ae%8c%e7%88%86Promise%e7%9a%846%e4%b8%aa%e5%8e%9f%e5%9b%a0"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fgyvpk67t0kv%2f&title=ES6%20Async%2fAwait%20%e5%ae%8c%e7%88%86Promise%e7%9a%846%e4%b8%aa%e5%8e%9f%e5%9b%a0"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fgyvpk67t0kv%2f&is_video=false&description=ES6%20Async%2fAwait%20%e5%ae%8c%e7%88%86Promise%e7%9a%846%e4%b8%aa%e5%8e%9f%e5%9b%a0"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=ES6%20Async%2fAwait%20%e5%ae%8c%e7%88%86Promise%e7%9a%846%e4%b8%aa%e5%8e%9f%e5%9b%a0&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fgyvpk67t0kv%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fgyvpk67t0kv%2f&title=ES6%20Async%2fAwait%20%e5%ae%8c%e7%88%86Promise%e7%9a%846%e4%b8%aa%e5%8e%9f%e5%9b%a0"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fgyvpk67t0kv%2f&title=ES6%20Async%2fAwait%20%e5%ae%8c%e7%88%86Promise%e7%9a%846%e4%b8%aa%e5%8e%9f%e5%9b%a0"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fgyvpk67t0kv%2f&title=ES6%20Async%2fAwait%20%e5%ae%8c%e7%88%86Promise%e7%9a%846%e4%b8%aa%e5%8e%9f%e5%9b%a0"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fgyvpk67t0kv%2f&title=ES6%20Async%2fAwait%20%e5%ae%8c%e7%88%86Promise%e7%9a%846%e4%b8%aa%e5%8e%9f%e5%9b%a0"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">ES6 Async/Await 完爆Promise的6个原因</h1><div class="meta"><div class="postdate"><time datetime="2019-01-16" itemprop="datePublished">2019-01-16</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e自从Node的7.6版本，已经默认支持async\/await特性了。如果你还没有使用过他，或者对他的用法不太了解，这篇文章会告诉你为什么这个特性“不容错过”。本文辅以大量实例，相信你能很轻松的看懂，并了解Javascript处理异步的一大杀器。\x3c\/p\x3e\n\x3cp\x3e文章灵感和内容借鉴了\x3ca href=\x22https:\/\/hackernoon.com\/6-reasons-why-javascripts-async-await-blows-promises-away-tutorial-c7ec10518dd9\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e6 Reasons Why JavaScript’s Async\/Await Blows Promises Away (Tutorial)\x3c\/a\x3e，英文好的同学可以直接戳原版参考。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e初识Async\/await\x3c\/h2\x3e\n\x3cp\x3e对于还不了解Async\/await特性的同学，下面一段是一个“速成”培训。\x3cbr\x3eAsync\/await 是Javascript编写异步程序的新方法。以往的异步方法无外乎回调函数和Promise。但是Async\/await建立于Promise之上。对于Javascript处理异步，是个老生常谈却历久弥新的话题：\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e从最早的回调函数，到 Promise 对象，再到 Generator 函数，每次都有所改进，但又让人觉得不彻底。它们都有额外的复杂性，都需要理解抽象的底层运行机制。\x3cbr\x3e异步编程的最高境界，就是根本不用关心它是不是异步。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3easync 函数就是隧道尽头的亮光，很多人认为它是异步操作的终极解决方案。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3eAsync\/await语法\x3c\/h2\x3e\n\x3cp\x3e试想一下，我们有一个getJSON方法，该方法发送一个异步请求JSON数据，并返回一个promise对象。这个promise对象的resolve方法传递异步获得的JSON数据。具体例子的使用如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const makeRequest = () =\x3e\n    getJSON()\n        .then(data =\x3e {\n            console.log(data)\n            return \x26quot;done\x26quot;\n        })\n\nmakeRequest()\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e makeRequest = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e\n    getJSON()\n        .then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n            \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data)\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22done\x22\x3c\/span\x3e\n        })\n\nmakeRequest()\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在使用async\/await时，写法如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const makeRequest = async () =\x3e {\n    console.log(await getJSON())\n    return \x26quot;done\x26quot;\n}\n\nmakeRequest()\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs dart\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e makeRequest = \x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e () =\x26gt; {\n    console.log(\x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e getJSON())\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22done\x22\x3c\/span\x3e\n}\n\nmakeRequest()\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e对比两种写法，针对第二种，我需要进一步说明：\x3c\/p\x3e\n\x3cp\x3e1）第二种写法（使用async\/await），在主体函数之前使用了async关键字。在函数体内，使用了await关键字。当然await关键字只能出现在用async声明的函数体内。该函数会隐式地返回一个Promise对象，函数体内的return值，将会作为这个Promise对象resolve时的参数。\x3cbr\x3e可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。\x3c\/p\x3e\n\x3cp\x3e2）示例中，await getJSON() 说明console.log的调用，会等到getJSON()返回的promise对象resolve之后触发。\x3c\/p\x3e\n\x3cp\x3e我们在看一个例子加强一下理解，该例子取自阮一峰大神的《ECMAScript 6 入门》一书：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function timeout(ms) {\n    return new Promise((resolve) =\x3e {\n        setTimeout(resolve, ms);\n    });\n}\n\nasync function asyncPrint(value, ms) {\n    await timeout(ms);\n    console.log(value);\n}\n\nasyncPrint(\x27hello world\x27, 50);\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3etimeout\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ems\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n        setTimeout(resolve, ms);\n    });\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3easyncPrint\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3evalue, ms\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e timeout(ms);\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(value);\n}\n\nasyncPrint(\x3cspan class=\x22hljs-string\x22\x3e\x27hello world\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e50\x3c\/span\x3e);\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面代码指定50毫秒以后，输出hello world。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3eAsync\/await究竟好在哪里？\x3c\/h2\x3e\n\x3cp\x3e那么，同样是处理异步操作，Async\/await究竟好在哪里呢？\x3cbr\x3e我们总结出以下6点。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e简约而干净Concise and clean\x3c\/h3\x3e\n\x3cp\x3e我们看一下上面两处代码的代码量，就可以直观地看出使用Async\/await对于代码量的节省是很明显的。对比Promise，我们不需要书写.then，不需要新建一个匿名函数处理响应，也不需要再把数据赋值给一个我们其实并不需要的变量。同样，我们避免了耦合的出现。这些看似很小的优势其实是很直观的，在下面的代码示例中，将会更加放大。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e错误处理Error handling\x3c\/h3\x3e\n\x3cp\x3eAsync\/await使得处理同步＋异步错误成为了现实。我们同样使用try\/catch结构，但是在promises的情况下，try\/catch难以处理在JSON.parse过程中的问题，原因是这个错误发生在Promise内部。想要处理这种情况下的错误，我们只能再嵌套一层try\/catch，就像这样：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const makeRequest = () =\x3e {\n    try {\n    getJSON()\n        .then(result =\x3e {\n            \/\/ this parse may fail\n            const data = JSON.parse(result)\n            console.log(data)\n        })\n        \/\/ uncomment this block to handle asynchronous errors\n        \/\/ .catch((err) =\x3e {\n        \/\/   console.log(err)\n        \/\/ })\n        } \n    catch (err) {\n        console.log(err)\n    }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e makeRequest = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n    getJSON()\n        .then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ this parse may fail\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e data = \x3cspan class=\x22hljs-built_in\x22\x3eJSON\x3c\/span\x3e.parse(result)\n            \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data)\n        })\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ uncomment this block to handle asynchronous errors\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ .catch((err) =\x26gt; {\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/   console.log(err)\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ })\x3c\/span\x3e\n        } \n    \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e (err) {\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(err)\n    }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e但是，如果用async\/await处理，一切变得简单，解析中的错误也能轻而易举的解决：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 const makeRequest = async () =\x3e {\n      try {\n          \/\/ this parse may fail\n          const data = JSON.parse(await getJSON())\n          console.log(data)\n      } \n      catch (err) {\n          console.log(err)\n      }\n   }\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e makeRequest = \x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e () =\x26gt; {\n      \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ this parse may fail\x3c\/span\x3e\n          \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e data = \x3cspan class=\x22hljs-built_in\x22\x3eJSON\x3c\/span\x3e.parse(\x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e getJSON())\n          \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data)\n      } \n      \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e (err) {\n          \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(err)\n      }\n   }\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e条件判别Conditionals\x3c\/h3\x3e\n\x3cp\x3e想象一下这样的业务需求：我们需要先拉取数据，然后根据得到的数据判断是否输出此数据，或者根据数据内容拉取更多的信息。如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const makeRequest = () =\x3e {\n    return getJSON()\n        .then(data =\x3e {\n            if (data.needsAnotherRequest) {\n                return makeAnotherRequest(data)\n                        .then(moreData =\x3e {\n                            console.log(moreData)\n                            return moreData\n                        })\n            } \n            else {\n                console.log(data)\n                return data\n            }\n        })\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs fortran\x22\x3e\x3ccode\x3econst makeRequest = () =\x26gt; {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e getJSON()\n        .\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e =\x26gt; {\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e.needsAnotherRequest) {\n                \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e makeAnotherRequest(\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e)\n                        .\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(moreData =\x26gt; {\n                            console.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(moreData)\n                            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e moreData\n                        })\n            } \n            \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n                console.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e)\n                \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e\n            }\n        })\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样的代码会让我们看的头疼。这这么多层（6层）嵌套过程中，非常容易“丢失自我”。\x3cbr\x3e使用async\/await，我们就可以轻而易举的写出可读性更高的代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const makeRequest = async () =\x3e {\n    const data = await getJSON()\n    if (data.needsAnotherRequest) {\n        const moreData = await makeAnotherRequest(data);\n        console.log(moreData)\n        return moreData\n    } \n    else {\n        console.log(data)\n        return data    \n    }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs haskell\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-title\x22\x3econst\x3c\/span\x3e makeRequest = async () =\x26gt; {\n    const \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e = await getJSON()\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e.needsAnotherRequest) {\n        \x3cspan class=\x22hljs-title\x22\x3econst\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emoreData\x3c\/span\x3e = \x3cspan class=\x22hljs-title\x22\x3eawait\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emakeAnotherRequest\x3c\/span\x3e(\x3cspan class=\x22hljs-title\x22\x3edata\x3c\/span\x3e);\n        \x3cspan class=\x22hljs-title\x22\x3econsole\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3elog\x3c\/span\x3e(\x3cspan class=\x22hljs-title\x22\x3emoreData\x3c\/span\x3e)\n        \x3cspan class=\x22hljs-title\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emoreData\x3c\/span\x3e\n    } \x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        console.log(\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e)\x3c\/span\x3e\n        return \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e    \x3c\/span\x3e\n    }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e中间值Intermediate values\x3c\/h3\x3e\n\x3cp\x3e一个经常出现的场景是，我们先调起promise1，然后根据返回值，调用promise2，之后再根据这两个Promises得值，调取promise3。使用Promise，我们不难实现：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const makeRequest = () =\x3e {\n    return promise1()\n        .then(value1 =\x3e {\n            \/\/ do something\n            return promise2(value1)\n                .then(value2 =\x3e {\n                    \/\/ do something          \n                    return promise3(value1, value2)\n                })\n        })\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs ceylon\x22\x3e\x3ccode\x3econst makeRequest = () =\x26gt; {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e promise\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e()\n        .\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e =\x26gt; {\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ do something\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e promise\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e)\n                .\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e =\x26gt; {\n                    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ do something          \x3c\/span\x3e\n                    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e promise\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e)\n                })\n        })\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果你难以忍受这样的代码，我们可以优化我们的Promise，方案是使用Promise.all来避免很深的嵌套。\x3cbr\x3e就像这样：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\nconst makeRequest = () =\x3e {\n    return promise1()\n        .then(value1 =\x3e {\n            \/\/ do something\n            return Promise.all([value1, promise2(value1)])\n        })\n        .then(([value1, value2]) =\x3e {\n            \/\/ do something          \n            return promise3(value1, value2)\n        })\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs ceylon\x22\x3e\x3ccode\x3e\nconst makeRequest = () =\x26gt; {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e promise\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e()\n        .\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e =\x26gt; {\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ do something\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e Promise.all([\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, promise\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e)])\n        })\n        .\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(([\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e]) =\x26gt; {\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ do something          \x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e promise\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e)\n        })\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3ePromise.all这个方法牺牲了语义性，但是得到了更好的可读性。\x3cbr\x3e但是其实，把value1 \x26amp; value2一起放到一个数组中，是很“蛋疼”的，某种意义上也是多余的。\x3c\/p\x3e\n\x3cp\x3e同样的场景，使用async\/await会非常简单：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const makeRequest = async () =\x3e {\n    const value1 = await promise1()\n    const value2 = await promise2(value1)\n    return promise3(value1, value2)\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs dart\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e makeRequest = \x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e () =\x26gt; {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e value1 = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e promise1()\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e value2 = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e promise2(value1)\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e promise3(value1, value2)\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e错误堆栈信息Error stacks\x3c\/h3\x3e\n\x3cp\x3e想象一下我们链式调用了很多promises，一级接一级。紧接着，这条promises链中某处出错，如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const makeRequest = () =\x3e {\n    return callAPromise()\n        .then(() =\x3e callAPromise())\n        .then(() =\x3e callAPromise())\n        .then(() =\x3e callAPromise())\n        .then(() =\x3e callAPromise())\n        .then(() =\x3e {\n            throw new Error(\x26quot;oops\x26quot;);\n        })\n}\n\nmakeRequest()\n    .catch(err =\x3e {\n        console.log(err);\n        \/\/ output\n        \/\/ Error: oops at callAPromise.then.then.then.then.then (index.js:8:13)\n    })\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3econst makeRequest = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e callAPromise()\n        .\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e callAPromise())\n        .\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e callAPromise())\n        .\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e callAPromise())\n        .\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e callAPromise())\n        .\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n            \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Error(\x3cspan class=\x22hljs-string\x22\x3e\x22oops\x22\x3c\/span\x3e);\n        })\n}\n\nmakeRequest()\n    .\x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e(err =\x26gt; {\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(err);\n        \x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e output\n        \x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e Error: oops at callAPromise.\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e (index.js:\x3cspan class=\x22hljs-number\x22\x3e8\x3c\/span\x3e:\x3cspan class=\x22hljs-number\x22\x3e13\x3c\/span\x3e)\n    })\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e此链条的错误堆栈信息并没用线索指示错误到底出现在哪里。更糟糕的事，他还会误导开发者：错误信息中唯一出现的函数名称其实根本就是无辜的。\x3cbr\x3e我们再看一下async\/await的展现：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const makeRequest = async () =\x3e {\n    await callAPromise()\n    await callAPromise()\n    await callAPromise()\n    await callAPromise()\n    await callAPromise()\n    throw new Error(\x26quot;oops\x26quot;);\n}\n\nmakeRequest()\n    .catch(err =\x3e {\n        console.log(err);\n        \/\/ output\n        \/\/ Error: oops at makeRequest (index.js:7:9)\n    })\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e makeRequest = \x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e () =\x26gt; {\n    \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e callAPromise()\n    \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e callAPromise()\n    \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e callAPromise()\n    \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e callAPromise()\n    \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e callAPromise()\n    \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22oops\x22\x3c\/span\x3e);\n}\n\nmakeRequest()\n    .catch(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(err);\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ output\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Error: oops at makeRequest (index.js:7:9)\x3c\/span\x3e\n    })\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e也许这样的对比，对于在本地开发阶段区别不是很大。但是想象一下在服务器端，线上代码的错误日志情况下，将会变得非常有意义。你一定会觉得上面这样的错误信息，比“错误出自一个then的then的then。。。”有用的多。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e调试Debugging\x3c\/h3\x3e\n\x3cp\x3e最后一点，但是也是很重要的一点，使用async\/await来debug会变得非常简单。\x3cbr\x3e在一个返回表达式的箭头函数中，我们不能设置断点，这就会造成下面的局面：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const makeRequest = () =\x3e {\n    return callAPromise()\n        .then(()=\x3ecallAPromise())\n        .then(()=\x3ecallAPromise())\n        .then(()=\x3ecallAPromise())\n        .then(()=\x3ecallAPromise())\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3econst makeRequest = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e callAPromise()\n        .\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3ecallAPromise())\n        .\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3ecallAPromise())\n        .\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3ecallAPromise())\n        .\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3ecallAPromise())\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们无法在每一行设置断点。但是使用async\/await时：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const makeRequest = async () =\x3e {\n    await callAPromise()\n    await callAPromise()\n    await callAPromise()\n    await callAPromise()\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs dart\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e makeRequest = \x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e () =\x26gt; {\n    \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e callAPromise()\n    \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e callAPromise()\n    \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e callAPromise()\n    \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e callAPromise()\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader9\x22\x3e总结\x3c\/h2\x3e\n\x3cp\x3eAsync\/await是近些年来JavaScript最具革命性的新特性之一。他让读者意识到使用Promise存在的一些问题，并提供了自身来代替Promise的方案。\x3cbr\x3e当然，对这个新特性也有一定的担心，体现在：\x3cbr\x3e他使得异步代码变的不再明显，我们好不容易已经学会并习惯了使用回调函数或者.then来处理异步。新的特性当然需要时间成本去学习和体会；\x3cbr\x3e退回来说，熟悉C#语言的程序员一定会懂得这些学习成本是完全值得的。\x3c\/p\x3e\n\x3cp\x3eHappy Coding!\x3c\/p\x3e\n\x3cp\x3ePS: 作者\x3ca href=\x22https:\/\/github.com\/HOUCe\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eGithub仓库\x3c\/a\x3e，欢迎通过代码各种形式交流。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>ES6 Async/Await 完爆Promise的6个原因</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000009070711">https://segmentfault.com/a/1190000009070711</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/gyvpk67t0kv/" target="_blank">https://alili.tech/archive/gyvpk67t0kv/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>