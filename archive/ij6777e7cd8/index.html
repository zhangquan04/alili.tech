<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="对象扩展符简易指南"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>对象扩展符简易指南 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/ij6777e7cd8/",
				"appid": "1613049289050283", 
				"title": "对象扩展符简易指南 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-19T02:30:10"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/af2564pj3rr/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/wqwm3twjm7/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fij6777e7cd8%2f&text=%e5%af%b9%e8%b1%a1%e6%89%a9%e5%b1%95%e7%ac%a6%e7%ae%80%e6%98%93%e6%8c%87%e5%8d%97"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fij6777e7cd8%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fij6777e7cd8%2f&text=%e5%af%b9%e8%b1%a1%e6%89%a9%e5%b1%95%e7%ac%a6%e7%ae%80%e6%98%93%e6%8c%87%e5%8d%97"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fij6777e7cd8%2f&title=%e5%af%b9%e8%b1%a1%e6%89%a9%e5%b1%95%e7%ac%a6%e7%ae%80%e6%98%93%e6%8c%87%e5%8d%97"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fij6777e7cd8%2f&is_video=false&description=%e5%af%b9%e8%b1%a1%e6%89%a9%e5%b1%95%e7%ac%a6%e7%ae%80%e6%98%93%e6%8c%87%e5%8d%97"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e5%af%b9%e8%b1%a1%e6%89%a9%e5%b1%95%e7%ac%a6%e7%ae%80%e6%98%93%e6%8c%87%e5%8d%97&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fij6777e7cd8%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fij6777e7cd8%2f&title=%e5%af%b9%e8%b1%a1%e6%89%a9%e5%b1%95%e7%ac%a6%e7%ae%80%e6%98%93%e6%8c%87%e5%8d%97"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fij6777e7cd8%2f&title=%e5%af%b9%e8%b1%a1%e6%89%a9%e5%b1%95%e7%ac%a6%e7%ae%80%e6%98%93%e6%8c%87%e5%8d%97"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fij6777e7cd8%2f&title=%e5%af%b9%e8%b1%a1%e6%89%a9%e5%b1%95%e7%ac%a6%e7%ae%80%e6%98%93%e6%8c%87%e5%8d%97"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fij6777e7cd8%2f&title=%e5%af%b9%e8%b1%a1%e6%89%a9%e5%b1%95%e7%ac%a6%e7%ae%80%e6%98%93%e6%8c%87%e5%8d%97"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">对象扩展符简易指南</h1><div class="meta"><div class="postdate"><time datetime="2019-01-19" itemprop="datePublished">2019-01-19</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n            \x3cp\x3e合并多个 Javascript 对象是常见的工作，但不好的是，至少到目前，Javascript 仍然没有一种方便的方法来完成这个工作。至少现在是这样。\x3c\/p\x3e\n\x3cp\x3e在 ES5 时代，你可以使用 Lodash 的 \x3ccode\x3e_.extend(target, [sources])\x3c\/code\x3e 方法，而 ES2015 则引入了 \x3ccode\x3eObject.assign(target, [sources])\x3c\/code\x3e 方法。\x3c\/p\x3e\n\x3cp\x3e幸运的是，\x3ca href=\x22https:\/\/github.com\/tc39\/proposal-object-rest-spread\x22\x3e对象扩展符\x3c\/a\x3e (an ECMASript proposal at stage 3) 是一个很大的进步，提供了简单方便的如下简介方便的语法。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/@panzerdp\/FearlessLovableUintagroundsquirrel\x22\x3eRun demo\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e cat = {   \n  \x3cspan class=\x22hljs-attr\x22\x3elegs\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3esound\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27meow\x27\x3c\/span\x3e\n};\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e dog = {  \n  ...cat,\n  \x3cspan class=\x22hljs-attr\x22\x3esound\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27woof\x27\x3c\/span\x3e\n};\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(dog); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; { legs: 4, sounds: \x27woof\x27 }  \x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面的例子中，\x3ccode\x3e...cat\x3c\/code\x3e 复制 \x3ccode\x3ecat\x3c\/code\x3e 的属性到一个新对象 \x3ccode\x3edog\x3c\/code\x3e 中，\x3ccode\x3ecat\x3c\/code\x3e 中原来的属性 \x3ccode\x3esound\x3c\/code\x3e 被覆盖，最终值为 \x3ccode\x3ewoof\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e本篇文章将介绍对象 spread 和 rest 语法。包括如何实现对象克隆，对象合并，以及如何覆盖属性值。\x3c\/p\x3e\n\x3cp\x3e下面是关于可枚举属性的简单和概括，以及如何分辨对象自有属性和继承属性。\x3c\/p\x3e\n\x3ch3\x3e1. 可枚举以及自有属性\x3c\/h3\x3e\n\x3cp\x3eJavascript 里的对象是键值对的组合。\x3c\/p\x3e\n\x3cp\x3e键名通常是一个字符串或者一个 symbol 。值可以是一个原始类型的值(string, boolean, number, \x3ccode\x3eundefined\x3c\/code\x3e 或者 \x3ccode\x3enull\x3c\/code\x3e)，一个对象或者一个函数。\x3c\/p\x3e\n\x3cp\x3e下面这个例子将通过对象字面量语法创建一个对象。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs ebnf\x22\x3e\x3cspan class=\x22hljs-attribute\x22\x3econst person\x3c\/span\x3e = {  \n  name: \x3cspan class=\x22hljs-string\x22\x3e\x27Dave\x27\x3c\/span\x3e,\n  surname: \x3cspan class=\x22hljs-string\x22\x3e\x27Bowman\x27\x3c\/span\x3e\n};\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3eperson\x3c\/code\x3e 这个对象描述了一个人的名和姓氏。\x3c\/p\x3e\n\x3ch4\x3e1.1 可枚举属性\x3c\/h4\x3e\n\x3cp\x3e描述一个属性有几种描述符，如 writable、enumerable 和configurable 。你可以看这篇文章\x3ca href=\x22http:\/\/2ality.com\/2012\/10\/javascript-properties.html\x22\x3eObject properties in JavaScript\x3c\/a\x3e了解更多细节。\x3c\/p\x3e\n\x3cp\x3e\x3cem\x3eEnumerable\x3c\/em\x3e 描述符是一个布尔值，表示这个属性是否可以被枚举。\x3c\/p\x3e\n\x3cp\x3e你可以通过 \x3ccode\x3eObject.keys()\x3c\/code\x3e 方法来枚举一个对象的自有属性和可枚举属性，通过 \x3ccode\x3efor..in\x3c\/code\x3e 语句来枚举所有可枚举的属性。\x3c\/p\x3e\n\x3cp\x3e以对象字面量的形式创建对象 \x3ccode\x3e{ prop1: \x27val1\x27, prop2: \x27val2\x27 }\x3c\/code\x3e 时显式声明的属性都是可枚举的。接下来看看之前创建的 \x3ccode\x3eperson\x3c\/code\x3e 对象有哪些可枚举的属性。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/@panzerdp\/UnrulyYearlyAmericanlobster\x22\x3eRun demo\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs livecodeserver\x22\x3econst \x3cspan class=\x22hljs-built_in\x22\x3ekeys\x3c\/span\x3e = Object.\x3cspan class=\x22hljs-built_in\x22\x3ekeys\x3c\/span\x3e(person);  \nconsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(\x3cspan class=\x22hljs-built_in\x22\x3ekeys\x3c\/span\x3e);\x3cspan class=\x22hljs-comment\x22\x3e \/\/ =\x26gt; [\x27name\x27, \x27surname\x27]  \x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3e.name\x3c\/code\x3e 和 \x3ccode\x3e.surname\x3c\/code\x3e 是 \x3ccode\x3eperson\x3c\/code\x3e 对象的可枚举属性\x3c\/p\x3e\n\x3cp\x3e接下来是有趣的一部分。\x3cem\x3e对象扩展符复制了原对象的所有可枚举属性。\x3c\/em\x3e\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/@panzerdp\/DependentUnevenIberianmidwifetoad\x22\x3eRun demo\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs xquery\x22\x3econsole.log({ ...person }; \/\/ =\x26gt; { name: \x3cspan class=\x22hljs-string\x22\x3e\x27Dave\x27\x3c\/span\x3e, surname: \x3cspan class=\x22hljs-string\x22\x3e\x27Bowman\x27\x3c\/span\x3e }  \n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e下面我们在 \x3ccode\x3eperson\x3c\/code\x3e 对象上创建一个不可枚举属性 \x3ccode\x3e.age\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/@panzerdp\/SameFirmBlackrhino\x22\x3eRun demo\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperty(person, \x3cspan class=\x22hljs-string\x22\x3e\x27age\x27\x3c\/span\x3e, {  \n  \x3cspan class=\x22hljs-attr\x22\x3eenumerable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Make the property non-enumerable\x3c\/span\x3e\n  value: \x3cspan class=\x22hljs-number\x22\x3e25\x3c\/span\x3e\n});\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(person[\x3cspan class=\x22hljs-string\x22\x3e\x27age\x27\x3c\/span\x3e]); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; 25\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e clone = {  \n  ...person\n};\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(clone); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; { name: \x27Dave\x27, surname: \x27Bowman\x27 }  \x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e目标对象 \x3ccode\x3eclone\x3c\/code\x3e 从源对象 \x3ccode\x3eperson\x3c\/code\x3e 上创建了可枚举属性 \x3ccode\x3e.name\x3c\/code\x3e 和 \x3ccode\x3e.surname\x3c\/code\x3e ，但是不可枚举属性 \x3ccode\x3e.age\x3c\/code\x3e 则被忽略掉。\x3c\/p\x3e\n\x3ch3\x3e1.2 自有属性\x3c\/h3\x3e\n\x3cp\x3eJavascript 内有原型继承机制，因此一个对象上既有 \x3cstrong\x3e自有\x3c\/strong\x3e属性，也有从\x3cstrong\x3e继承\x3c\/strong\x3e属性。\x3c\/p\x3e\n\x3cp\x3e对象字面量显式声明的属性都是\x3cstrong\x3e自有\x3c\/strong\x3e属性，存在于原型链上的属性都是 \x3cstrong\x3e继承\x3c\/strong\x3e 属性。\x3c\/p\x3e\n\x3cp\x3e下面将创建一个 \x3ccode\x3epersonB\x3c\/code\x3e 对象，并将 \x3ccode\x3eperson\x3c\/code\x3e 对象设置成其原型对象。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/@panzerdp\/MonumentalUnimportantAmericancrayfish\x22\x3eRun demo\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e personB = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.create(person, {  \n  \x3cspan class=\x22hljs-attr\x22\x3eprofession\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-attr\x22\x3evalue\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Astronaut\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3eenumerable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n  }\n});\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(personB.hasOwnProperty(\x3cspan class=\x22hljs-string\x22\x3e\x27profession\x27\x3c\/span\x3e)); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; true  \x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(personB.hasOwnProperty(\x3cspan class=\x22hljs-string\x22\x3e\x27name\x27\x3c\/span\x3e));       \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; false  \x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(personB.hasOwnProperty(\x3cspan class=\x22hljs-string\x22\x3e\x27surname\x27\x3c\/span\x3e));    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; false  \x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e现在 \x3ccode\x3epersonB\x3c\/code\x3e 上有自有的 \x3ccode\x3e.profession\x3c\/code\x3e 属性，以及从原型对象 \x3ccode\x3eperson\x3c\/code\x3e 上继承来的 \x3ccode\x3e.name\x3c\/code\x3e 和 \x3ccode\x3e.surname\x3c\/code\x3e 属性。\x3c\/p\x3e\n\x3cp\x3e\x3cem\x3e对象扩展符从源对象上复制\x3cstrong\x3e自有\x3c\/strong\x3e属性，而会忽略继承的属性\x3c\/em\x3e\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/@panzerdp\/OccasionalThirstyMinibeast\x22\x3eRun demo\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs cpp\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e cloneB = {  \n  ...personB\n};\nconsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(cloneB); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; { profession: \x27Astronaut\x27 }  \x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3e...personB\x3c\/code\x3e 只从 \x3ccode\x3epersonB\x3c\/code\x3e 上复制了 \x3ccode\x3e.profession\x3c\/code\x3e 这个自有属性，而继承属性 \x3ccode\x3e.name\x3c\/code\x3e 和 \x3ccode\x3e.surname\x3c\/code\x3e 则被忽略。\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3e总结： 对象扩展符号只会从源对象上复制 \x3cstrong\x3e自有和可枚举属性\x3c\/strong\x3e，这和 \x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/JavaScript\/Reference\/Global_Objects\/Object\/keys\x22\x3eObject.keys()\x3c\/a\x3e 方法的返回值一样。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3ch3\x3e2. 对象扩展属性\x3c\/h3\x3e\n\x3cp\x3e在对象字面量里，\x3cstrong\x3e对象扩展符\x3c\/strong\x3e将\x3cstrong\x3e源对象\x3c\/strong\x3e里的自有属性和可枚举属性复制进\x3cstrong\x3e目标对象\x3c\/strong\x3e内。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs qml\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e targetObject = {  \n  ...sourceObject,\n  \x3cspan class=\x22hljs-keyword\x22\x3eproperty\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Value\x27\x3c\/span\x3e\n};\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e顺便说一下，很多时候，对象扩展符与 \x3ccode\x3eObject.assign()\x3c\/code\x3e 等价，上面的代码也可以用这样实现：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs qml\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e targetObject = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.assign(  \n  { }, \n  sourceObject,\n  { \x3cspan class=\x22hljs-keyword\x22\x3eproperty\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Value\x27\x3c\/span\x3e }\n);\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e一个对象字面量里可以使用多个对象扩展符，与普通的属性声明同时使用：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs clean\x22\x3econst targetObject = {  \n  ...sourceObject1,\n  property1: \x3cspan class=\x22hljs-string\x22\x3e\x27Value 1\x27\x3c\/span\x3e,\n  ...sourceObject2,\n  ...sourceObject3,\n  property2: \x3cspan class=\x22hljs-string\x22\x3e\x27Value 2\x27\x3c\/span\x3e\n};\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e2.1 对象扩展规则：后面的属性会覆盖前面的\x3c\/h4\x3e\n\x3cp\x3e当同时扩展多个对象时，这个对象内可能会存在同名属性，那么最终生成的对象的属性值是怎么计算的，规则很简单：\x3cstrong\x3e后扩展的属性会覆盖之前扩展的属性\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e来看一些简单的例子。下面的代码会实例化一只 cat 。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs ebnf\x22\x3e\x3cspan class=\x22hljs-attribute\x22\x3econst cat\x3c\/span\x3e = {  \n  sound: \x3cspan class=\x22hljs-string\x22\x3e\x27meow\x27\x3c\/span\x3e,\n  legs: 4\n};\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e现在我们要变一个魔术，将这只猫变成一只狗，注意 \x3ccode\x3e.sound\x3c\/code\x3e 属性值如何变化。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/@panzerdp\/LightgraySleepyRooster\x22\x3eRun demo\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs lasso\x22\x3econst dog = {  \n  \x3cspan class=\x22hljs-params\x22\x3e...\x3c\/span\x3ecat,\n  \x3cspan class=\x22hljs-params\x22\x3e...\x3c\/span\x3e{\n    sound: \x3cspan class=\x22hljs-string\x22\x3e\x27woof\x27\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ `\x26lt;----- Overwrites cat.sound\x3c\/span\x3e\n  }\n};\nconsole.\x3cspan class=\x22hljs-keyword\x22\x3elog\x3c\/span\x3e(dog); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt;` { sound: \x27woof\x27, legs: 4 }  \x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e后面声明的 \x3ccode\x3e·woof·\x3c\/code\x3e 属性值覆盖了前面的在 \x3ccode\x3ecat\x3c\/code\x3e 对象声明的属性值 \x3ccode\x3e\x27meow\x27\x3c\/code\x3e , 符合之前所说的规则: 对于同名属性，后声明的值覆盖先声明的值。\x3c\/p\x3e\n\x3cp\x3e这个规则同样适用于对象的初始化\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/@panzerdp\/CloudyTotalAnophelesmosquito\x22\x3eRun demo\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs coffeescript\x22\x3econst anotherDog = {  \n  ...cat,\n  sound: \x3cspan class=\x22hljs-string\x22\x3e\x27woof\x27\x3c\/span\x3e \x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e `\x3cspan class=\x22javascript\x22\x3e\x26lt;---- Overwrites cat.sound\n};\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(anotherDog); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt;\x3c\/span\x3e\x3c\/span\x3e` { sound: \x3cspan class=\x22hljs-string\x22\x3e\x27woof\x27\x3c\/span\x3e, legs: \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e }  \n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面代码里，\x3ccode\x3esound: \x27woof\x27\x3c\/code\x3e 同样覆盖了之前声明的 \x3ccode\x3e\x27 meow\x27\x3c\/code\x3e 值。\x3c\/p\x3e\n\x3cp\x3e现在，交换一下扩展对象的位置，输出了不同的结果。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/@panzerdp\/CharmingAwfulChimneyswift\x22\x3eRun demo\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs lasso\x22\x3econst stillCat = {  \n  \x3cspan class=\x22hljs-params\x22\x3e...\x3c\/span\x3e{\n    sound: \x3cspan class=\x22hljs-string\x22\x3e\x27woof\x27\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ `\x26lt;---- Is overwritten by cat.sound\x3c\/span\x3e\n  },\n  \x3cspan class=\x22hljs-params\x22\x3e...\x3c\/span\x3ecat\n};\nconsole.\x3cspan class=\x22hljs-keyword\x22\x3elog\x3c\/span\x3e(stillCat); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt;` { sound: \x27meow\x27, legs: 4 }  \x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3ecat\x3c\/code\x3e 对象仍然是 \x3ccode\x3ecat\x3c\/code\x3e 对象。虽然第一个源对象内的 \x3ccode\x3e.sound\x3c\/code\x3e 属性值是 \x3ccode\x3e\x27woof\x27\x3c\/code\x3e ，但是被之后 \x3ccode\x3ecat\x3c\/code\x3e 对象的 \x3ccode\x3e\x27meow\x27\x3c\/code\x3e 覆盖。\x3c\/p\x3e\n\x3cp\x3e普通属性和对象扩展的相对位置非常重要，这将直接影响到对象克隆，对象合并，以及填充默认属性的结果。\x3c\/p\x3e\n\x3cp\x3e下面分别详细介绍。\x3c\/p\x3e\n\x3ch3\x3e2.2 克隆对象\x3c\/h3\x3e\n\x3cp\x3e用对象扩展符克隆一个对象非常简洁，下面的代码克隆了一个 \x3ccode\x3ebird\x3c\/code\x3e 对象。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/@panzerdp\/InsubstantialUnnaturalJabiru\x22\x3eRun demo\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs lua\x22\x3econst bird = {  \n  \x3cspan class=\x22hljs-built_in\x22\x3etype\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27pigeon\x27\x3c\/span\x3e,\n  color: \x3cspan class=\x22hljs-string\x22\x3e\x27white\x27\x3c\/span\x3e\n};\n\nconst birdClone = {  \n  ...bird\n};\n\nconsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(birdClone); \/\/ =\x26gt; { \x3cspan class=\x22hljs-built_in\x22\x3etype\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27pigeon\x27\x3c\/span\x3e, color: \x3cspan class=\x22hljs-string\x22\x3e\x27white\x27\x3c\/span\x3e }  \nconsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(bird === birdClone); \/\/ =\x26gt; \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e  \n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3e...bird\x3c\/code\x3e 将 \x3ccode\x3ebird\x3c\/code\x3e 对象的自有和可枚举属性复制到目标对象 \x3ccode\x3ebirdClone\x3c\/code\x3e 内。\x3c\/p\x3e\n\x3cp\x3e虽然克隆看起来很简单，但仍然要注意其中的几个细微之处。\x3c\/p\x3e\n\x3ch4\x3e浅复制\x3c\/h4\x3e\n\x3cp\x3e对象扩展只是对对象进行了 \x3cem\x3e浅复制\x3c\/em\x3e, 只有对象自身被复制，而嵌套的对象结构 \x3cem\x3e没有被复制\x3c\/em\x3e。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3elaptop\x3c\/code\x3e 对象有一个嵌套对象 \x3ccode\x3elaptop.screen\x3c\/code\x3e。现在我们来克隆 \x3ccode\x3elaptop\x3c\/code\x3e对象来看看其内部的嵌套对象怎么变化。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/@panzerdp\/WellmadeEnlightenedTurtle\x22\x3eRun demo\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs yaml\x22\x3e\x3cspan class=\x22hljs-string\x22\x3econst\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3elaptop\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e=\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e{\x3c\/span\x3e  \n\x3cspan class=\x22hljs-attr\x22\x3e  name:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27MacBook Pro\x27\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e,\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e  screen:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e{\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e    size:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e17\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e,\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e    isRetina:\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n  \x3cspan class=\x22hljs-string\x22\x3e}\x3c\/span\x3e\n\x3cspan class=\x22hljs-string\x22\x3e};\x3c\/span\x3e\n\x3cspan class=\x22hljs-string\x22\x3econst\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3elaptopClone\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e=\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e{\x3c\/span\x3e  \n  \x3cspan class=\x22hljs-string\x22\x3e...laptop\x3c\/span\x3e\n\x3cspan class=\x22hljs-string\x22\x3e};\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-string\x22\x3econsole.log(laptop\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e===\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3elaptopClone);\x3c\/span\x3e               \x3cspan class=\x22hljs-string\x22\x3e\/\/\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e=\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e  \n\x3cspan class=\x22hljs-string\x22\x3econsole.log(laptop.screen\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e===\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3elaptopClone.screen);\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\/\/\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e=\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e  \n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e第一个比较语句 \x3ccode\x3elaptop === laptopClone\x3c\/code\x3e 的值为 \x3ccode\x3efalse\x3c\/code\x3e, 说明主对象被正确克隆。\x3c\/p\x3e\n\x3cp\x3e然而 \x3ccode\x3elaptop.screen === laptopClone.screen\x3c\/code\x3e 的计算结果为 \x3ccode\x3etrue\x3c\/code\x3e ，说明 \x3ccode\x3elaptopClone.screen\x3c\/code\x3e 没有被复制，而是 \x3ccode\x3elaptop.screen\x3c\/code\x3e 和 \x3ccode\x3elaptopClone.screen\x3c\/code\x3e 引用了同一个嵌套对象。\x3c\/p\x3e\n\x3cp\x3e好的一点是，你可以在对象的任何一层使用对象扩展符，只需要再多做一点工作就同样可以克隆一个嵌套对象。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/@panzerdp\/CyanSoreColt\x22\x3eRun demo\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs gauss\x22\x3econst laptopDeepClone = {  \n  ...laptop,\n  \x3cspan class=\x22hljs-keyword\x22\x3escreen\x3c\/span\x3e: {\n     ...laptop.\x3cspan class=\x22hljs-keyword\x22\x3escreen\x3c\/span\x3e\n  }\n};\n\nconsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(laptop === laptopDeepClone);               \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; false  \x3c\/span\x3e\nconsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(laptop.\x3cspan class=\x22hljs-keyword\x22\x3escreen\x3c\/span\x3e === laptopDeepClone.\x3cspan class=\x22hljs-keyword\x22\x3escreen\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; false  \x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e使用 \x3ccode\x3e...laptop.screen\x3c\/code\x3e 使嵌套对象也被克隆，现在 \x3ccode\x3elaptopDeepClone\x3c\/code\x3e 完全克隆了 \x3ccode\x3elaptop\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch4\x3e原型失去了\x3c\/h4\x3e\n\x3cp\x3e下面的代码声明了一个 \x3ccode\x3eGame\x3c\/code\x3e 类，并创造了一个 \x3ccode\x3edoom\x3c\/code\x3e实例。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/@panzerdp\/TediousProbableMuskox\x22\x3eRun demo\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eGame\x3c\/span\x3e \x3c\/span\x3e{  \n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(name) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name;\n  }\n\n  getMessage() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e`I like \x3cspan class=\x22hljs-subst\x22\x3e${\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name}\x3c\/span\x3e!`\x3c\/span\x3e;\n  }\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e doom = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Game(\x3cspan class=\x22hljs-string\x22\x3e\x27Doom\x27\x3c\/span\x3e);  \n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(doom \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e Game); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; true  \x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(doom.name);            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; \x22Doom\x22  \x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(doom.getMessage());    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; \x22I like Doom!\x22  \x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e现在我们克隆一个通过构造函数创建的 \x3ccode\x3edoom\x3c\/code\x3e 实例，结果可能与你想的不同。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/@panzerdp\/HummingFatalEthiopianwolf\x22\x3eRun demo\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e doomClone = {  \n  ...doom\n};\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(doomClone \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e Game); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; false  \x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(doomClone.name);            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; \x22Doom\x22  \x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(doomClone.getMessage());  \n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ TypeError: doomClone.getMessage is not a function\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3e...doom\x3c\/code\x3e 将自有属性 \x3ccode\x3e.name\x3c\/code\x3e 属性复制到 \x3ccode\x3edoomClone\x3c\/code\x3e 内。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3edoomClone\x3c\/code\x3e 现在只是一个普通的 JavaScript 对象，它的原型是 \x3ccode\x3eObject.prototype\x3c\/code\x3e 而不是预想中的\x3ccode\x3eGame.prototype\x3c\/code\x3e。\x3cem\x3e对象扩展不保留源对象的原型。\x3c\/em\x3e\x3c\/p\x3e\n\x3cp\x3e因此调用 \x3ccode\x3edoomClone.getMessage()\x3c\/code\x3e 方法会抛出一个 \x3ccode\x3eTypeError\x3c\/code\x3e 错误，因此 \x3ccode\x3edoomClone\x3c\/code\x3e 没有继承 \x3ccode\x3egetMessage()\x3c\/code\x3e 方法。\x3c\/p\x3e\n\x3cp\x3e当然我们可以手动在克隆对象上加上 \x3ccode\x3e__proto__\x3c\/code\x3e 属性来结局这个问题。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/@panzerdp\/PreciousGroundedJuliabutterfly\x22\x3eRun demo\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e doomFullClone = {  \n  ...doom,\n  \x3cspan class=\x22hljs-attr\x22\x3e__proto__\x3c\/span\x3e: Game.prototype\n};\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(doomFullClone \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e Game); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; true  \x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(doomFullClone.name);            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; \x22Doom\x22  \x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(doomFullClone.getMessage());    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; \x22I like Doom!\x22  \x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e对象字面量内部的 \x3ccode\x3e__proto__\x3c\/code\x3e 属性确保了 \x3ccode\x3edoomFullClone\x3c\/code\x3e 的原型为 \x3ccode\x3eGame.prototype\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e\x3cem\x3e尽量不要尝试这种方法\x3c\/em\x3e。\x3ccode\x3e__proto__\x3c\/code\x3e 属性已经废弃，这里使用它只是为了论证前面的观点。\x3c\/p\x3e\n\x3cp\x3e对象扩展的目的是以浅复制的方式扩展自有和可枚举属性，因此不保留源对象的原型似乎也说得过去。\x3c\/p\x3e\n\x3cp\x3e例外，这里用 \x3ccode\x3eObject.assign()\x3c\/code\x3e 来克隆 \x3ccode\x3edoom\x3c\/code\x3e 更加合理。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/@panzerdp\/DecentUnsteadyGavial\x22\x3eRun demo\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e doomFullClone = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.assign(\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Game(), doom);\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(doomFullClone \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e Game); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; true  \x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(doomFullClone.name);            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; \x22Doom\x22  \x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(doomFullClone.getMessage());    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; \x22I like Doom!\x22  \x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样，就保留了原型。\x3c\/p\x3e\n\x3ch4\x3e2.3 不可变对象更新\x3c\/h4\x3e\n\x3cp\x3e在一个应用里，同一个对象可能会用于多个地方，直接修改这个对象会带来意想不到的副作用，并且追踪这个修改及其困难。\x3c\/p\x3e\n\x3cp\x3e一个好的方式是使操作不可变。不可变性使修改对象更为可控，更有利于书写。\x3ca href=\x22https:\/\/medium.com\/@jamesjefferyuk\/javascript-what-are-pure-functions-4d4d5392d49c\x22\x3epure functions\x3c\/a\x3e。即时是在复杂的应用场景，由于单向数据流，更容易确定对象的来源和改变的原因。\x3c\/p\x3e\n\x3cp\x3e使用对象扩展能更方便的以不可变方式来修改一个对象。假设现在你有一个对象来描述一本书的信息。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs ebnf\x22\x3e\x3cspan class=\x22hljs-attribute\x22\x3econst book\x3c\/span\x3e = {  \n  name: \x3cspan class=\x22hljs-string\x22\x3e\x27JavaScript: The Definitive Guide\x27\x3c\/span\x3e,\n  author: \x3cspan class=\x22hljs-string\x22\x3e\x27David Flanagan\x27\x3c\/span\x3e,\n  edition: 5,\n  year: 2008\n};\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e现在，书第六版即将出版，我们用对象扩展的处理这个场景。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/@panzerdp\/DistantWrongYak\x22\x3eRun demo\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs haxe\x22\x3econst \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eerBook\x3c\/span\x3e = {  \n  ...book,\n  edition: \x3cspan class=\x22hljs-type\x22\x3e6\x3c\/span\x3e,  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;----- Overwrites book.edition\x3c\/span\x3e\n  year: \x3cspan class=\x22hljs-type\x22\x3e2011   \x3c\/span\x3e\/\/ \x26lt;----- Overwrites book.year\n};\n\nconsole.log(\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eerBook\x3c\/span\x3e);  \n\x3cspan class=\x22hljs-comment\x22\x3e\/*\n{\n  name: \x27JavaScript: The Definitive Guide\x27,\n  author: \x27David Flanagan\x27,\n  edition: 6,\n  year: 2011\n}\n*\/\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3enewerBook\x3c\/code\x3e 对象内的 \x3ccode\x3e...book\x3c\/code\x3e 扩展了 \x3ccode\x3ebook\x3c\/code\x3e 对象的属性。手动创建的可枚举属性 \x3ccode\x3eediton: 6\x3c\/code\x3e 和 \x3ccode\x3eyear: 2011\x3c\/code\x3e 更新了原有的同名属性。\x3c\/p\x3e\n\x3cp\x3e重要的属性一般在末尾来指定，以便覆盖前面已经创建的同名属性。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3enewerBook\x3c\/code\x3e 是一个更新了某些属性的新的对象，并且我们没有改变原有的 \x3ccode\x3ebook\x3c\/code\x3e 对象，满足了不可变性的要求。\x3c\/p\x3e\n\x3ch4\x3e2.4 合并对象\x3c\/h4\x3e\n\x3cp\x3e使用对象扩展符合并多个对象非常简单。\x3c\/p\x3e\n\x3cp\x3e现在我们合并3个对象来创建一个“合成对象”。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/@panzerdp\/LightseagreenMatureItaliangreyhound\x22\x3eRun demo\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs processing\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e part1 = {  \n  \x3cspan class=\x22hljs-built_in\x22\x3ecolor\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27white\x27\x3c\/span\x3e\n};\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e part2 = {  \n  model: \x3cspan class=\x22hljs-string\x22\x3e\x27Honda\x27\x3c\/span\x3e\n};\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e part3 = {  \n  \x3cspan class=\x22hljs-built_in\x22\x3eyear\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e2005\x3c\/span\x3e\n};\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e car = {  \n  ...part1,\n  ...part2,\n  ...part3\n};\nconsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(car); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ { color: \x27white\x27, model: \x27Honda\x27, year: 2005 }  \x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面的例子中，我们使用 \x3ccode\x3epart1\x3c\/code\x3e、\x3ccode\x3epart2\x3c\/code\x3e、\x3ccode\x3epart3\x3c\/code\x3e 3个对象合并成了一个 \x3ccode\x3ecar\x3c\/code\x3e 对象。\x3c\/p\x3e\n\x3cp\x3e另外，不要忘了之前讲的规则，\x3ccode\x3e后面的属性值会覆盖前面的同名属性值\x3c\/code\x3e。这是我们合并有同名属性对象的计算依据。\x3c\/p\x3e\n\x3cp\x3e现在我们稍微改变一下之前的代码。给 \x3ccode\x3epart1\x3c\/code\x3e 和 \x3ccode\x3epart3\x3c\/code\x3e 增加一个 \x3ccode\x3e.configuration\x3c\/code\x3e 属性。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/@panzerdp\/RuralUnkemptDrake\x22\x3eRun demo\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs processing\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e part1 = {  \n  \x3cspan class=\x22hljs-built_in\x22\x3ecolor\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27white\x27\x3c\/span\x3e,\n  configuration: \x3cspan class=\x22hljs-string\x22\x3e\x27sedan\x27\x3c\/span\x3e\n};\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e part2 = {  \n  model: \x3cspan class=\x22hljs-string\x22\x3e\x27Honda\x27\x3c\/span\x3e\n};\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e part3 = {  \n  \x3cspan class=\x22hljs-built_in\x22\x3eyear\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e2005\x3c\/span\x3e,\n  configuration: \x3cspan class=\x22hljs-string\x22\x3e\x27hatchback\x27\x3c\/span\x3e\n};\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e car = {  \n  ...part1,\n  ...part2,\n  ...part3 \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;--- part3.configuration overwrites part1.configuration\x3c\/span\x3e\n};\nconsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(car);  \n\x3cspan class=\x22hljs-comment\x22\x3e\/*\n{ \n  color: \x27white\x27, \n  model: \x27Honda\x27, \n  year: 2005,\n  configuration: \x27hatchback\x27  `\x26lt;--- part3.configuration\n}\n*\/\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3e...part1\x3c\/code\x3e 将 \x3ccode\x3econfiguration\x3c\/code\x3e 属性设置成了 \x3ccode\x3e\x27sedan\x27\x3c\/code\x3e。然而之后的扩展符 \x3ccode\x3e...part3\x3c\/code\x3e 覆盖了之前的同名 \x3ccode\x3e.configuration\x3c\/code\x3e，最终生成的对象值为 \x3ccode\x3e\x27hatchback\x27\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch3\x3e2.5 给对象设置默认值\x3c\/h3\x3e\n\x3cp\x3e一个对象在程序运行时可能会有多套不同的属性值，有些属性可能会被设置，有些则可能被忽略。\x3c\/p\x3e\n\x3cp\x3e这种情况通常发生在一个配置对象上。用户可以指定一个重要的属性值，不重要的属性则使用默认值。\x3c\/p\x3e\n\x3cp\x3e现在我们来实现一个 \x3ccode\x3emultline(str, config)\x3c\/code\x3e 方法，将\x3ccode\x3estr\x3c\/code\x3e 按照给定的长度分割成多行。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3econfig\x3c\/code\x3e 对象接受下面3个可选的参数。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3ccode\x3ewidth\x3c\/code\x3e: 分割的字符长度，默认是 \x3ccode\x3e10\x3c\/code\x3e。\x3c\/li\x3e\n\x3cli\x3e\x3ccode\x3enewLine\x3c\/code\x3e: 添加到每一行结尾的的字符， 默认是 \x3ccode\x3e\\n\x3c\/code\x3e。\x3c\/li\x3e\n\x3cli\x3e\x3ccode\x3eindent\x3c\/code\x3e: 每一行开头的缩进符，默认是空字符串 \x3ccode\x3e\x27\x27\x3c\/code\x3e。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e下面是一些 \x3ccode\x3emultline()\x3c\/code\x3e 运行的例子。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/@panzerdp\/FrankFirsthandBullfrog\x22\x3eRun demo\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs less\x22\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3emultiline\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27Hello World!\x27\x3c\/span\x3e);  \n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt;` \x27Hello Worl\\nd!\x27\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-selector-tag\x22\x3emultiline\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27Hello World!\x27\x3c\/span\x3e, { \x3cspan class=\x22hljs-attribute\x22\x3ewidth\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e6\x3c\/span\x3e });  \n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; \x27Hello \\nWorld!\x27\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-selector-tag\x22\x3emultiline\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27Hello World!\x27\x3c\/span\x3e, { \x3cspan class=\x22hljs-attribute\x22\x3ewidth\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e6\x3c\/span\x3e, \x3cspan class=\x22hljs-attribute\x22\x3enewLine\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27*\x27\x3c\/span\x3e });  \n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; \x27Hello *World!\x27\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-selector-tag\x22\x3emultiline\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27Hello World!\x27\x3c\/span\x3e, { \x3cspan class=\x22hljs-attribute\x22\x3ewidth\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e6\x3c\/span\x3e, \x3cspan class=\x22hljs-attribute\x22\x3enewLine\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27*\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-attribute\x22\x3eindent\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27_\x27\x3c\/span\x3e });  \n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; \x27_Hello *_World!\x27\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3econfig\x3c\/code\x3e 参数接受几套不同的属性值：你可以指定1，2或者3个属性值，甚至不指定任何一个属性。\x3c\/p\x3e\n\x3cp\x3e使用对象扩展语法来填充配置对象非常简单，在对象字面量里，首先扩展默认值对象，然后是配置对象，如下所示：\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/@panzerdp\/FrankFirsthandBullfrog\x22\x3eRun demo\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emultiline\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3estr, config = {}\x3c\/span\x3e) \x3c\/span\x3e{  \n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e defaultConfig = {\n    \x3cspan class=\x22hljs-attr\x22\x3ewidth\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3enewLine\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27\\n\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3eindent\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e\n  };\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e safeConfig = {\n    ...defaultConfig,\n    ...config\n  };\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e result = \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Implementation of multiline() using\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ safeConfig.width, safeConfig.newLine, safeConfig.indent\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e result;\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们来仔细了解一下 \x3ccode\x3esafeConfig\x3c\/code\x3e 对象。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3e...defaultConfig\x3c\/code\x3e 首先将默认对象的属性复制，随后，\x3ccode\x3e...config\x3c\/code\x3e 里用户自定义的值覆盖了之前的默认属性值。\x3c\/p\x3e\n\x3cp\x3e这样 \x3ccode\x3esafeConfig\x3c\/code\x3e 值就拥有了所有 \x3ccode\x3emultiline()\x3c\/code\x3e 需要的配置参数。无论调用 \x3ccode\x3emultiline()\x3c\/code\x3e 函数时，输入的 \x3ccode\x3econfig\x3c\/code\x3e 是否缺失了某些属性，都可以保证 \x3ccode\x3esafeConfig\x3c\/code\x3e 拥有所有的必备参数。\x3c\/p\x3e\n\x3cp\x3e显而易见，对象扩展实现了我们想要的 给对象设置默认值。\x3c\/p\x3e\n\x3ch4\x3e2.6 更加深入\x3c\/h4\x3e\n\x3cp\x3e对象扩展更有用的一点是用于嵌套对象，当更新一个复杂对象时，更具有可读性，比 \x3ccode\x3eObject.assign()\x3c\/code\x3e 更值得推荐。\x3c\/p\x3e\n\x3cp\x3e下面的 \x3ccode\x3ebox\x3c\/code\x3e 对象定义一个盒子及盒子内的物品。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs processing\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ebox\x3c\/span\x3e = {  \n  \x3cspan class=\x22hljs-built_in\x22\x3ecolor\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27red\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-built_in\x22\x3esize\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-built_in\x22\x3ewidth\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e200\x3c\/span\x3e, \n    \x3cspan class=\x22hljs-built_in\x22\x3eheight\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e100\x3c\/span\x3e \n  },\n  items: [\x3cspan class=\x22hljs-string\x22\x3e\x27pencil\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27notebook\x27\x3c\/span\x3e]\n};\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3ebox.size\x3c\/code\x3e 描述了这个盒子的尺寸，\x3ccode\x3ebox.items\x3c\/code\x3e 列举了盒子内的物品。\x3c\/p\x3e\n\x3cp\x3e为了使盒子看起来更高，我们增大 \x3ccode\x3ebox.size.height\x3c\/code\x3e 的值，只需要在嵌套对象上使用 \x3ccode\x3e对象扩展符\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/@panzerdp\/DemandingShoddyInsect\x22\x3eRun demo\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs processing\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e biggerBox = {  \n  ...\x3cspan class=\x22hljs-built_in\x22\x3ebox\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-built_in\x22\x3esize\x3c\/span\x3e: {\n    ...\x3cspan class=\x22hljs-built_in\x22\x3ebox\x3c\/span\x3e.\x3cspan class=\x22hljs-built_in\x22\x3esize\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-built_in\x22\x3eheight\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e200\x3c\/span\x3e\n  }\n};\nconsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(biggerBox);  \n\x3cspan class=\x22hljs-comment\x22\x3e\/*\n{\n  color: \x27red\x27,\n  size: {\n    width: 200, \n    height: 200 \x26lt;----- Updated value\n  },\n  items: [\x27pencil\x27, \x27notebook\x27]\n}\n*\/\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3e...box\x3c\/code\x3e 确保了 \x3ccode\x3ebiggerBox\x3c\/code\x3e 获得了 源对象 \x3ccode\x3ebox\x3c\/code\x3e 上的全部属性。\x3c\/p\x3e\n\x3cp\x3e更新 \x3ccode\x3ebox.size\x3c\/code\x3e 的 height 值需要额外一个 \x3ccode\x3e{...box.size, height: 200}\x3c\/code\x3e 对象，该对象接收 \x3ccode\x3ebox.size\x3c\/code\x3e 的全部属性，并将 height 值更新至 \x3ccode\x3e200\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e只需要一个语句就能更新对象的多处属性。\x3c\/p\x3e\n\x3cp\x3e现在如果我们还想把颜色改成 \x3ccode\x3eblack\x3c\/code\x3e ,增加盒子的宽度到 \x3ccode\x3e400\x3c\/code\x3e, 并且再放一把尺子到盒子内，应该怎么办？同样很简单。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/@panzerdp\/ElectricLinearMayfly\x22\x3eRun demo\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs processing\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e blackBox = {  \n  ...\x3cspan class=\x22hljs-built_in\x22\x3ebox\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-built_in\x22\x3ecolor\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27black\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-built_in\x22\x3esize\x3c\/span\x3e: {\n    ...\x3cspan class=\x22hljs-built_in\x22\x3ebox\x3c\/span\x3e.\x3cspan class=\x22hljs-built_in\x22\x3esize\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-built_in\x22\x3ewidth\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e400\x3c\/span\x3e\n  },\n  items: [\n    ...\x3cspan class=\x22hljs-built_in\x22\x3ebox\x3c\/span\x3e.items,\n    \x3cspan class=\x22hljs-string\x22\x3e\x27ruler\x27\x3c\/span\x3e\n  ]\n};\nconsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(blackBox);  \n\x3cspan class=\x22hljs-comment\x22\x3e\/*\n{\n  color: \x27black\x27, \x26lt;----- Updated value\n  size: {\n    width: 400, \x26lt;----- Updated value\n    height: 100 \n  },\n  items: [\x27pencil\x27, \x27notebook\x27, \x27ruler\x27] `\x26lt;----- A new item ruler\n}\n*\/\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e2.7 扩展 \x3ccode\x3eundefined\x3c\/code\x3e、\x3ccode\x3enull\x3c\/code\x3e 和 \x3ccode\x3e原始类型值\x3c\/code\x3e\x3c\/h4\x3e\n\x3cp\x3e如果在 \x3ccode\x3eundefined\x3c\/code\x3e、\x3ccode\x3enull\x3c\/code\x3e 和 \x3ccode\x3e原始类型值\x3c\/code\x3e 上使用原始类型的值，不会复制任何属性，也不会抛出错误，只是简单的返回一个空对象。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/@panzerdp\/ForcefulFeminineKissingbug\x22\x3eRun demo\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e nothing = \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e;  \n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e missingObject = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;  \n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e two = \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log({ ...nothing });       \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; { }  \x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log({ ...missingObject }); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; { }  \x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log({ ...two });           \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; { }  \x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如上所示：从 \x3ccode\x3enothing\x3c\/code\x3e, \x3ccode\x3emissingObject\x3c\/code\x3e 和 \x3ccode\x3etwo\x3c\/code\x3e不会复制任何属性。\x3c\/p\x3e\n\x3cp\x3e当然，这只是一个演示，毕竟根本没有理由在一个原始类型的值上面使用对象扩展符。\x3c\/p\x3e\n\x3ch4\x3e3. 剩余属性\x3c\/h4\x3e\n\x3cp\x3e当使用解构赋值将对象的属性值赋值给变量后，剩余的属性值将会被集合进一个剩余对象内。\x3c\/p\x3e\n\x3cp\x3e下面的代码演示了怎么使用 rest 属性。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/repl.it\/@panzerdp\/PrimaryRawHagfish\x22\x3eRun demo\x3c\/a\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs processing\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e style = {  \n  \x3cspan class=\x22hljs-built_in\x22\x3ewidth\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e300\x3c\/span\x3e,\n  marginLeft: \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e,\n  marginRight: \x3cspan class=\x22hljs-number\x22\x3e30\x3c\/span\x3e\n};\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e { \x3cspan class=\x22hljs-built_in\x22\x3ewidth\x3c\/span\x3e, ...margin } = style;\n\nconsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(\x3cspan class=\x22hljs-built_in\x22\x3ewidth\x3c\/span\x3e);  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; 300  \x3c\/span\x3e\nconsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(margin); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ =\x26gt; { marginLeft: 10, marginRight: 30 }  \x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e通过解构赋值，我们定义了一个新的变量 \x3ccode\x3ewidth\x3c\/code\x3e ，并将它的值设置为 \x3ccode\x3estyle.width\x3c\/code\x3e。而解构赋值声明内的 \x3ccode\x3e...margin\x3c\/code\x3e 则获得了 \x3ccode\x3estyle\x3c\/code\x3e 对象的其余属性，\x3ccode\x3emargin\x3c\/code\x3e 对象获取了 \x3ccode\x3emarginLeft\x3c\/code\x3e 和 \x3ccode\x3emarginRight\x3c\/code\x3e 属性。\x3c\/p\x3e\n\x3cp\x3erest 操作符同样只会获取自有属性和可枚举属性。\x3c\/p\x3e\n\x3cp\x3e注意，在解构赋值内，rest 操作符只能放到最后，因此 \x3ccode\x3econst { ...margin , width } = style\x3c\/code\x3e 无效，并会抛出一个 \x3ccode\x3eSyntaxError: Rest element must be last element\x3c\/code\x3e 错误。\x3c\/p\x3e\n\x3ch3\x3e4. 结论\x3c\/h3\x3e\n\x3cp\x3e对象扩展需要以下几点：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e它只会提取对象的自有属性和可枚举属性\x3c\/li\x3e\n\x3cli\x3e后定义的属性值会覆盖之前定义过的同名属性值\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e同时，对象扩展使用上方便简洁，能更好的处理嵌套对象，保持不可变性，在实现对象克隆和填充默认属性值上也使用方便。\x3c\/p\x3e\n\x3cp\x3e而 \x3ccode\x3erest\x3c\/code\x3e 操作符在解构赋值时可以收集剩余的属性。\x3c\/p\x3e\n\n          \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>对象扩展符简易指南</p><h2 id="原文链接">原文链接</h2><p><a href="https://www.zcfy.cc/article/an-easy-guide-to-object-rest-spread-properties-in-javascript">https://www.zcfy.cc/article/an-easy-guide-to-object-rest-spread-properties-in-javascript</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/ij6777e7cd8/" target="_blank">https://alili.tech/archive/ij6777e7cd8/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>