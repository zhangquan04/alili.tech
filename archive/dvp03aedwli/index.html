<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="vuex 2.0源码解读（一）"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>vuex 2.0源码解读（一） | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/dvp03aedwli/",
				"appid": "1613049289050283", 
				"title": "vuex 2.0源码解读（一） | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-02T02:30:11"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/wob9zu76vv/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/qkbhncttwlb/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fdvp03aedwli%2f&text=vuex%202.0%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb%ef%bc%88%e4%b8%80%ef%bc%89"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fdvp03aedwli%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fdvp03aedwli%2f&text=vuex%202.0%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb%ef%bc%88%e4%b8%80%ef%bc%89"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fdvp03aedwli%2f&title=vuex%202.0%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb%ef%bc%88%e4%b8%80%ef%bc%89"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fdvp03aedwli%2f&is_video=false&description=vuex%202.0%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb%ef%bc%88%e4%b8%80%ef%bc%89"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=vuex%202.0%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb%ef%bc%88%e4%b8%80%ef%bc%89&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fdvp03aedwli%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fdvp03aedwli%2f&title=vuex%202.0%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb%ef%bc%88%e4%b8%80%ef%bc%89"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fdvp03aedwli%2f&title=vuex%202.0%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb%ef%bc%88%e4%b8%80%ef%bc%89"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fdvp03aedwli%2f&title=vuex%202.0%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb%ef%bc%88%e4%b8%80%ef%bc%89"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fdvp03aedwli%2f&title=vuex%202.0%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb%ef%bc%88%e4%b8%80%ef%bc%89"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">vuex 2.0源码解读（一）</h1><div class="meta"><div class="postdate"><time datetime="2019-02-02" itemprop="datePublished">2019-02-02</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e\x3cp\x3e转载请注明出处 \x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000007108052\x22\x3ehttps:\/\/segmentfault.com\/a\/11...\x3c\/a\x3e\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3evuex2.0 和 vuex1.x 相比，API改变的还是很多的，但基本思想没什么改变。vuex2.0 的源码挺短，四五百行的样子，两三天就能读完。我是国庆期间断断续续看完的，写一下自己的理解。这里使用的vuex版本是 2.0.0-rc6。在看这篇文章之前，建议先看一遍官方的vuex2.0 文档，了解基本概念，不然之后的内容理解起来会很费劲。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e引入 vuex 文件\x3c\/h2\x3e\n\x3cp\x3e要想使用 vuex 有几种方式, 这里不细讲。\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3eCDN\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cscript src=\x27path\/vue.js\x27\x3e\x3cscript\x3e \x3c!-- 必须先引入 vue --\x3e\n\x3cscript src=\x27path\/vuex.js\x27\x3e\x3c\/script\x3e \x3c!-- 平时学习时建议使用完整版 --\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22xml hljs\x22\x3e\x3ccode class=\x22html\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3esrc\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x27path\/vue.js\x27\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22handlebars\x22\x3e\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22handlebars\x22\x3e\x3cspan class=\x22xml\x22\x3e \x3cspan class=\x22hljs-comment\x22\x3e\x26lt;!-- 必须先引入 vue --\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3esrc\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x27path\/vuex.js\x27\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22undefined\x22\x3e\x3c\/span\x3e\x3c\/span\x3e\x3c\/span\x3e\x3c\/span\x3e\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\x26lt;!-- 平时学习时建议使用完整版 --\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3eES6语法 \x2b webpack\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import Vuex from \x27vuex\x27\nvar store = new Vuex.Store({})\nVuex.mapState({})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e Vuex \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27vuex\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e store = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Vuex.Store({})\nVuex.mapState({})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e或者\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import { Store, mapState } from \x27vuex\x27\nvar store = new Store({})\nmapState({})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { Store, mapState } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27vuex\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e store = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Store({})\nmapState({})\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3eStore构造函数\x3c\/h2\x3e\n\x3cp\x3evuex 只暴露出了6个方法，分别是\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var index = {\nStore: Store,\ninstall: install,\nmapState: mapState,\nmapMutations: mapMutations,\nmapGetters: mapGetters,\nmapActions: mapActions\n}\n\nreturn index;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e index = {\n\x3cspan class=\x22hljs-attr\x22\x3eStore\x3c\/span\x3e: Store,\n\x3cspan class=\x22hljs-attr\x22\x3einstall\x3c\/span\x3e: install,\n\x3cspan class=\x22hljs-attr\x22\x3emapState\x3c\/span\x3e: mapState,\n\x3cspan class=\x22hljs-attr\x22\x3emapMutations\x3c\/span\x3e: mapMutations,\n\x3cspan class=\x22hljs-attr\x22\x3emapGetters\x3c\/span\x3e: mapGetters,\n\x3cspan class=\x22hljs-attr\x22\x3emapActions\x3c\/span\x3e: mapActions\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e index;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e其中 \x3ccode\x3einstall\x3c\/code\x3e 方法是配合 \x3ccode\x3eVue.use\x3c\/code\x3e 方法使用的，用于在 Vue 中注册 Vuex ,和数据流关系不大。其他的几种方法就是我们常用的。\x3c\/p\x3e\n\x3cp\x3e先看看 Store 方法，学习 vuex 最先接触到的就是 \x3ccode\x3enew Store({})\x3c\/code\x3e 了。那么就先看看这个 Store 构造函数。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var Store = function Store (options) {\n  var this$1 = this; \/\/ 指向返回的store实例\n  if ( options === void 0 ) options = {};\n\n  \/\/ 使用构造函数之前，必须保证vuex已注册，使用Vue.use(Vuex)注册vuex\n  assert(Vue, \x26quot;must call Vue.use(Vuex) before creating a store instance.\x26quot;)\n  \/\/ 需要使用的浏览器支持Promise\n  assert(typeof Promise !== \x27undefined\x27, \x26quot;vuex requires a Promise polyfill in this browser.\x26quot;)\n\n  var state = options.state; if ( state === void 0 ) state = {};\n  var plugins = options.plugins; if ( plugins === void 0 ) plugins = [];\n  var strict = options.strict; if ( strict === void 0 ) strict = false;\n\n  \/\/ store internal state\n  \/\/ store的内部状态(属性)\n  this._options = options\n  this._committing = false\n  this._actions = Object.create(null)  \/\/ 保存actions\n  this._mutations = Object.create(null) \/\/ 保存mutations\n  this._wrappedGetters = Object.create(null) \/\/ 保存包装后的getters\n  this._runtimeModules = Object.create(null) \n  this._subscribers = []\n  this._watcherVM = new Vue()\n\n  \/\/ bind commit and dispatch to self\n  var store = this\n  var ref = this;\n  var dispatch = ref.dispatch; \/\/ 引用的是Store.prototype.dispatch\n  var commit = ref.commit; \/\/ 引用的是Store.prototype.commit \n  this.dispatch = function boundDispatch (type, payload) { \/\/ 绑定上下文对象\n    return dispatch.call(store, type, payload)\n  }\n  this.commit = function boundCommit (type, payload, options) {\n    return commit.call(store, type, payload, options)\n  }\n\n  \/\/ strict mode\n  this.strict = strict \/\/ 是否开启严格模式\n\n  \/\/ init root module.\n  \/\/ this also recursively registers all sub-modules\n  \/\/ and collects all module getters inside this._wrappedGetters\n  \/\/ 初始化 root module\n  \/\/ 同时也会递归初始化所有子module\n  \/\/ 并且收集所有的getters至this._wrappedGetters\n  installModule(this, state, [], options)\n\n  \/\/ initialize the store vm, which is responsible for the reactivity\n  \/\/ (also registers _wrappedGetters as computed properties)\n  \/\/ 重置vm实例状态\n  \/\/ 同时在这里把getters转化为computed(计算属性)\n  resetStoreVM(this, state)\n\n  \/\/ apply plugins\n  plugins.concat(devtoolPlugin).forEach(function (plugin) { return plugin(this$1); })\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Store = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eStore\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eoptions\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e$\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 指向返回的store实例\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( options === \x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e ) options = {};\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 使用构造函数之前，必须保证vuex已注册，使用Vue.use(Vuex)注册vuex\x3c\/span\x3e\n  assert(Vue, \x3cspan class=\x22hljs-string\x22\x3e\x22must call Vue.use(Vuex) before creating a store instance.\x22\x3c\/span\x3e)\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 需要使用的浏览器支持Promise\x3c\/span\x3e\n  assert(\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e !== \x3cspan class=\x22hljs-string\x22\x3e\x27undefined\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22vuex requires a Promise polyfill in this browser.\x22\x3c\/span\x3e)\n\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e state = options.state; \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( state === \x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e ) state = {};\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e plugins = options.plugins; \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( plugins === \x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e ) plugins = [];\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e strict = options.strict; \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( strict === \x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e ) strict = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ store internal state\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ store的内部状态(属性)\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._options = options\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._committing = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._actions = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.create(\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e)  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 保存actions\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._mutations = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.create(\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 保存mutations\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._wrappedGetters = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.create(\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 保存包装后的getters\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._runtimeModules = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.create(\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) \n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._subscribers = []\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._watcherVM = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Vue()\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ bind commit and dispatch to self\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e store = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e ref = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e dispatch = ref.dispatch; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 引用的是Store.prototype.dispatch\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e commit = ref.commit; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 引用的是Store.prototype.commit \x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.dispatch = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eboundDispatch\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3etype, payload\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 绑定上下文对象\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e dispatch.call(store, type, payload)\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.commit = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eboundCommit\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3etype, payload, options\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e commit.call(store, type, payload, options)\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ strict mode\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.strict = strict \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 是否开启严格模式\x3c\/span\x3e\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ init root module.\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ this also recursively registers all sub-modules\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ and collects all module getters inside this._wrappedGetters\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 初始化 root module\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 同时也会递归初始化所有子module\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 并且收集所有的getters至this._wrappedGetters\x3c\/span\x3e\n  installModule(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, state, [], options)\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ initialize the store vm, which is responsible for the reactivity\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ (also registers _wrappedGetters as computed properties)\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 重置vm实例状态\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 同时在这里把getters转化为computed(计算属性)\x3c\/span\x3e\n  resetStoreVM(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, state)\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ apply plugins\x3c\/span\x3e\n  plugins.concat(devtoolPlugin).forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eplugin\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e plugin(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e$\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e); })\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e一开始会有两个判断条件，判断 vuex 是否已经注册，和当前浏览器是否支持 \x3ccode\x3ePromise\x3c\/code\x3e, \x3ccode\x3eassert\x3c\/code\x3e 方法也挺简单，如果传入的第一个参数为假值，则抛出一个错误。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function assert (condition, msg) {\n  if (!condition) { throw new Error((\x26quot;[vuex] \x26quot; \x2b msg)) }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode class=\x22javascipt\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eassert\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3econdition, msg\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!condition) { \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e((\x3cspan class=\x22hljs-string\x22\x3e\x22[vuex] \x22\x3c\/span\x3e \x2b msg)) }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e接着往下看，接着会定义 \x3ccode\x3estate\x3c\/code\x3e, \x3ccode\x3eplugins\x3c\/code\x3e,\x3ccode\x3estrict\x3c\/code\x3e三个变量，分别是你传入的 options 对应的选项。之后就是定义返回的 store 实例的一些内部状态。先不要管它们具体是什么，这个之后会慢慢讲，这里先看看 Store 构造函数都做了些什么。再之后就是绑定 \x3ccode\x3edispatch\x3c\/code\x3e 和 \x3ccode\x3ecommit\x3c\/code\x3e 方法到 \x3ccode\x3estore\x3c\/code\x3e 实例上。接下来就是整个 vuex 的核心方法 \x3ccode\x3einstallModule\x3c\/code\x3e 了，之后重置 \x3ccode\x3evm\x3c\/code\x3e 实例的状态。\x3c\/p\x3e\n\x3cp\x3e简单点说，当你使用 Store 构造函数，它实际上做了这么几件事，首先定义给 \x3ccode\x3estore\x3c\/code\x3e 实例定义一些内部属性，之后就是绑定 \x3ccode\x3edispatch\x3c\/code\x3e 和 \x3ccode\x3ecommit\x3c\/code\x3e 的上下文对象永远是 \x3ccode\x3estore\x3c\/code\x3e 实例上，之后 \x3ccode\x3einstallModule\x3c\/code\x3e 根据传入的 \x3ccode\x3eoptions\x3c\/code\x3e ‘充实’ 内部状态等等。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3einstallModule\x3c\/h3\x3e\n\x3cp\x3e很重要的一个方法。贴上代码\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/*\n * store 就是 store 实例\n * rootState 是使用构造函数options中定义的 state 对象\n * path 路径\n * module 传入的options\n *\/\nfunction installModule (store, rootState, path, module, hot) {\n  var isRoot = !path.length  \/\/ 是否是root\n  var state = module.state;\n  var actions = module.actions;\n  var mutations = module.mutations;\n  var getters = module.getters;\n  var modules = module.modules;\n\n  \/\/ set state\n  if (!isRoot \x26amp;\x26amp; !hot) { \n    \/\/ 找到要注册的 path 的上一级 state\n    var parentState = getNestedState(rootState, path.slice(0, -1))\n    \/\/ 定义 module 的 name\n    var moduleName = path[path.length - 1]\n    \/\/ store._withCommit方法之后会讲\n    \/\/ 这里先理解为 执行传入的函数\n    store._withCommit(function () {\n      \/\/ 使用Vue.set方法\n      \/\/ parentState[moduleName] = state\n      \/\/ 并且state变成响应式的\n      Vue.set(parentState, moduleName, state || {})\n    })\n  }\n  \/\/ 之后设置 mutations, actions, getters, modules\n  if (mutations) {\n    Object.keys(mutations).forEach(function (key) {\n      registerMutation(store, key, mutations[key], path)\n    })\n  }\n\n  if (actions) {\n    Object.keys(actions).forEach(function (key) {\n      registerAction(store, key, actions[key], path)\n    })\n  }\n\n  if (getters) {\n    wrapGetters(store, getters, path)\n  }\n\n  if (modules) {\n    Object.keys(modules).forEach(function (key) {\n      installModule(store, rootState, path.concat(key), modules[key], hot)\n    })\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/*\n * store 就是 store 实例\n * rootState 是使用构造函数options中定义的 state 对象\n * path 路径\n * module 传入的options\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3einstallModule\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3estore, rootState, path, module, hot\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e isRoot = !path.length  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 是否是root\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e state = \x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.state;\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e actions = \x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.actions;\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e mutations = \x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.mutations;\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e getters = \x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.getters;\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e modules = \x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.modules;\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ set state\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!isRoot \x26amp;\x26amp; !hot) { \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 找到要注册的 path 的上一级 state\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e parentState = getNestedState(rootState, path.slice(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e))\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 定义 module 的 name\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e moduleName = path[path.length - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e]\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ store._withCommit方法之后会讲\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里先理解为 执行传入的函数\x3c\/span\x3e\n    store._withCommit(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 使用Vue.set方法\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ parentState[moduleName] = state\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 并且state变成响应式的\x3c\/span\x3e\n      Vue.set(parentState, moduleName, state || {})\n    })\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 之后设置 mutations, actions, getters, modules\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (mutations) {\n    \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.keys(mutations).forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ekey\x3c\/span\x3e) \x3c\/span\x3e{\n      registerMutation(store, key, mutations[key], path)\n    })\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (actions) {\n    \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.keys(actions).forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ekey\x3c\/span\x3e) \x3c\/span\x3e{\n      registerAction(store, key, actions[key], path)\n    })\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (getters) {\n    wrapGetters(store, getters, path)\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (modules) {\n    \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.keys(modules).forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ekey\x3c\/span\x3e) \x3c\/span\x3e{\n      installModule(store, rootState, path.concat(key), modules[key], hot)\n    })\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里有个很重要的概念要理解，什么是 \x3cstrong\x3epath\x3c\/strong\x3e. vuex 的一个 store 实例可以拆分成很多个 module ,不同的 module 可以理解成一个子代的 store 实例（事实上，module 确实和 store 具有一样的结构）,这是一种模块化的概念。因此这里的 path 可以理解成是表示一种层级关系，当你有了一个 root state 之后，根据这个 root state 和 path 可以找到 path 路径对应的一个 local state， 每一个 module 下的 mutations 和 actions 改变的都是这个local state，而不是 root state.\x3c\/p\x3e\n\x3cp\x3e这里在 Store 构造函数里传入的 path 路径为 \x3ccode\x3e[]\x3c\/code\x3e,说明注册的是一个root state. 再看看上一段代码的最后\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22if (modules) {\n    Object.keys(modules).forEach(function (key) {\n      installModule(store, rootState, path.concat(key), modules[key], hot)\n   })\n }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (modules) {\n    \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.keys(modules).forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ekey\x3c\/span\x3e) \x3c\/span\x3e{\n      installModule(store, rootState, path.concat(key), modules[key], hot)\n   })\n }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果传入的options 中有 modules 选项，重复调用 \x3ccode\x3einstallModule\x3c\/code\x3e, 这里传入的函数的 path 参数是 \x3ccode\x3epath.concat(key)\x3c\/code\x3e, 所以应该很好理解了。\x3c\/p\x3e\n\x3cp\x3e简单看一下 \x3ccode\x3egetNestedState\x3c\/code\x3e 方法。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/*\n * state: Object, path: Array\n * 假设path = [\x27a\x27, \x27b\x27, \x27c\x27]\n * 函数返回结果是state[a][b][c]\n *\/\nfunction getNestedState (state, path) {\n  return path.length\n    ? path.reduce(function (state, key) { return state[key]; }, state)\n    : state\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/*\n * state: Object, path: Array\n * 假设path = [\x27a\x27, \x27b\x27, \x27c\x27]\n * 函数返回结果是state[a][b][c]\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3egetNestedState\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3estate, path\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e path.length\n    ? path.reduce(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3estate, key\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e state[key]; }, state)\n    : state\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3ereduce 方法接受一个函数，函数的参数分别是上一次计算后的值，和当前值，reduce 方法的第二个参数 state 是初始计算值。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3eregisterMutation\x3c\/h3\x3e\n\x3cp\x3e如果 \x3ccode\x3emutations\x3c\/code\x3e 选项存在，那么就注册这个 \x3ccode\x3emutations\x3c\/code\x3e ，看一下它的实现。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/*\n * 注册mutations，也就是给store._mutations添加属性\n * 这里说一下handler\n * handler 是 mutations[key]\n * 也就是传入 Store构造函数的 mutations \n *\/\nfunction registerMutation (store, type, handler, path) {\n  if ( path === void 0 ) path = [];\n\n  \/\/ 在_mutations中找到对应type的mutation数组\n  \/\/ 如果是第一次创建，就初始化为一个空数组\n  var entry = store._mutations[type] || (store._mutations[type] = [])\n  \/\/ 推入一个对原始mutations[key]包装过的函数\n  entry.push(function wrappedMutationHandler (payload) {\n    \/\/ store.state表示root state, 先获取path路径下的local state\n    \/\/ mutation应该是对path路径下的state的修改\n    \/\/ 函数接受一个payload参数\n    \/\/ 初始的handler，接受一个state he payload 参数\n    handler(getNestedState(store.state, path), payload)\n  })\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/*\n * 注册mutations，也就是给store._mutations添加属性\n * 这里说一下handler\n * handler 是 mutations[key]\n * 也就是传入 Store构造函数的 mutations \n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eregisterMutation\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3estore, type, handler, path\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( path === \x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e ) path = [];\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 在_mutations中找到对应type的mutation数组\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果是第一次创建，就初始化为一个空数组\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e entry = store._mutations[type] || (store._mutations[type] = [])\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 推入一个对原始mutations[key]包装过的函数\x3c\/span\x3e\n  entry.push(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ewrappedMutationHandler\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3epayload\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ store.state表示root state, 先获取path路径下的local state\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ mutation应该是对path路径下的state的修改\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 函数接受一个payload参数\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 初始的handler，接受一个state he payload 参数\x3c\/span\x3e\n    handler(getNestedState(store.state, path), payload)\n  })\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e逻辑很简单，所有的 mutations 都经过处理后，保存在了 store._mutations 对象里。 _mutations  的结构为\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22_mutations: {\n    type1: [wrappedFunction1, wrappedFuction2, ...],\n    type2: [wrappedFunction1, wrappedFuction2, ...],\n    ...\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e_mutations: {\n    \x3cspan class=\x22hljs-attr\x22\x3etype1\x3c\/span\x3e: [wrappedFunction1, wrappedFuction2, ...],\n    \x3cspan class=\x22hljs-attr\x22\x3etype2\x3c\/span\x3e: [wrappedFunction1, wrappedFuction2, ...],\n    ...\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3eregisterAction\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function registerAction (store, type, handler, path) {\n  if ( path === void 0 ) path = [];\n\n  var entry = store._actions[type] || (store._actions[type] = [])\n  var dispatch = store.dispatch;\n  var commit = store.commit;\n  entry.push(function wrappedActionHandler (payload, cb) {\n    var res = handler({\n      dispatch: dispatch,\n      commit: commit,\n      getters: store.getters,\n      state: getNestedState(store.state, path),\n      rootState: store.state\n    }, payload, cb)\n    \/\/ 如果 res 不是 promise 对象 ，将其转化为promise对象\n    \/\/ 这是因为store.dispatch 方法里的 Promise.all()方法。\n    if (!isPromise(res)) {\n      res = Promise.resolve(res)\n    }\n    if (store._devtoolHook) {\n      return res.catch(function (err) {\n        store._devtoolHook.emit(\x27vuex:error\x27, err)\n        throw err\n      })\n    } else {\n      return res\n    }\n  })\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eregisterAction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3estore, type, handler, path\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( path === \x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e ) path = [];\n\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e entry = store._actions[type] || (store._actions[type] = [])\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e dispatch = store.dispatch;\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e commit = store.commit;\n  entry.push(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ewrappedActionHandler\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3epayload, cb\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e res = handler({\n      \x3cspan class=\x22hljs-attr\x22\x3edispatch\x3c\/span\x3e: dispatch,\n      \x3cspan class=\x22hljs-attr\x22\x3ecommit\x3c\/span\x3e: commit,\n      \x3cspan class=\x22hljs-attr\x22\x3egetters\x3c\/span\x3e: store.getters,\n      \x3cspan class=\x22hljs-attr\x22\x3estate\x3c\/span\x3e: getNestedState(store.state, path),\n      \x3cspan class=\x22hljs-attr\x22\x3erootState\x3c\/span\x3e: store.state\n    }, payload, cb)\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果 res 不是 promise 对象 ，将其转化为promise对象\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这是因为store.dispatch 方法里的 Promise.all()方法。\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!isPromise(res)) {\n      res = \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.resolve(res)\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (store._devtoolHook) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e res.catch(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e) \x3c\/span\x3e{\n        store._devtoolHook.emit(\x3cspan class=\x22hljs-string\x22\x3e\x27vuex:error\x27\x3c\/span\x3e, err)\n        \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e err\n      })\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e res\n    }\n  })\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里同样是\x27充实\x27 store._actions 对象，每一种 action type 都对应一个数组，数组里存放的包装后的 handler 函数，由于涉及到 promise，这里我想在下一节结合 store 的 dispatch 实例方法一起讲。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3ewrapGetters\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/*\n * 包装getters函数\n * store增加一个 _wrappedGetters 属性\n * moduleGetters: 传入的options.getters\n * modulePath: 传入 installModule 函数的 path \n *\/\nfunction wrapGetters (store, moduleGetters, modulePath) {\n  Object.keys(moduleGetters).forEach(function (getterKey) {\n    var rawGetter = moduleGetters[getterKey] \/\/ 原始的getter\n    if (store._wrappedGetters[getterKey]) { \/\/ 如果已经存在，警告\n      console.error((\x26quot;[vuex] duplicate getter key: \x26quot; \x2b getterKey))\n      return\n    }\n    store._wrappedGetters[getterKey] = function wrappedGetter (store) {\n        \/\/ 接受三个参数\n        \/\/ local state\n        \/\/  全局的 getters\n        \/\/ 全局的 state\n      return rawGetter(\n        getNestedState(store.state, modulePath), \/\/ local state\n        store.getters, \/\/ getters\n        store.state \/\/ root state\n      )\n    }\n  })\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/*\n * 包装getters函数\n * store增加一个 _wrappedGetters 属性\n * moduleGetters: 传入的options.getters\n * modulePath: 传入 installModule 函数的 path \n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ewrapGetters\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3estore, moduleGetters, modulePath\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.keys(moduleGetters).forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3egetterKey\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e rawGetter = moduleGetters[getterKey] \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 原始的getter\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (store._wrappedGetters[getterKey]) { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果已经存在，警告\x3c\/span\x3e\n      \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.error((\x3cspan class=\x22hljs-string\x22\x3e\x22[vuex] duplicate getter key: \x22\x3c\/span\x3e \x2b getterKey))\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n    }\n    store._wrappedGetters[getterKey] = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ewrappedGetter\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3estore\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 接受三个参数\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ local state\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/  全局的 getters\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 全局的 state\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e rawGetter(\n        getNestedState(store.state, modulePath), \x3cspan class=\x22hljs-comment\x22\x3e\/\/ local state\x3c\/span\x3e\n        store.getters, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ getters\x3c\/span\x3e\n        store.state \x3cspan class=\x22hljs-comment\x22\x3e\/\/ root state\x3c\/span\x3e\n      )\n    }\n  })\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e注意 这里的所有 getters 都储存在了全局的一个 _wrappedGetters 对象中，同样属性名是各个 getterKey ,属性值同样是一个函数，执行这个函数，将会返回原始 getter 的执行结果。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3einstall modules\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22if (modules) {\n    Object.keys(modules).forEach(function (key) {\n      installModule(store, rootState, path.concat(key), modules[key], hot)\n   })\n }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (modules) {\n    \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.keys(modules).forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ekey\x3c\/span\x3e) \x3c\/span\x3e{\n      installModule(store, rootState, path.concat(key), modules[key], hot)\n   })\n }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果 options 中有 modules 选项，那么就递归调用 \x3ccode\x3einstallModule\x3c\/code\x3e 方法，注意这里的 path 改变。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3eresetStoreVM\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function resetStoreVM (store, state) {\n  var oldVm = store._vm \/\/ 原来的_vm\n\n  \/\/ bind store public getters\n  store.getters = {} \/\/ 初始化 store 的 getters 属性为一个空数组。\n  var wrappedGetters = store._wrappedGetters\n  var computed = {} \n  Object.keys(wrappedGetters).forEach(function (key) {\n    var fn = wrappedGetters[key]\n    \/\/ use computed to leverage its lazy-caching mechanism\n    \/\/ 将wrappedGetter中的属性转移到 computed 中\n    computed[key] = function () { return fn(store); }\n    \/\/ store.getters[key] = store._vm[key]\n    Object.defineProperty(store.getters, key, {\n      get: function () { return store._vm[key]; }\n    })\n  })\n  \/\/ use a Vue instance to store the state tree\n  \/\/ suppress warnings just in case the user has added\n  \/\/ some funky global mixins\n  \/\/ 设为 silent 模式\n  var silent = Vue.config.silent\n  Vue.config.silent = true\n  \/\/ 初始化一个 store._vm 实例\n  store._vm = new Vue({\n    data: { state: state },\n    computed: computed\n  })\n  Vue.config.silent = silent\n\n  \/\/ enable strict mode for new vm\n  \/\/ 启用严格模式\n  if (store.strict) {\n    enableStrictMode(store)\n  }\n\n  if (oldVm) {\n    \/\/ dispatch changes in all subscribed watchers\n    \/\/ to force getter re-evaluation.\n    store._withCommit(function () {\n      oldVm.state = null\n    })\n    \/\/ 执行destroy 方法，通知所有的watchers 改变，并重新计算getters的值。\n    Vue.nextTick(function () { return oldVm.$destroy(); })\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eresetStoreVM\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3estore, state\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e oldVm = store._vm \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 原来的_vm\x3c\/span\x3e\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ bind store public getters\x3c\/span\x3e\n  store.getters = {} \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 初始化 store 的 getters 属性为一个空数组。\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e wrappedGetters = store._wrappedGetters\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e computed = {} \n  \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.keys(wrappedGetters).forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ekey\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e fn = wrappedGetters[key]\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ use computed to leverage its lazy-caching mechanism\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将wrappedGetter中的属性转移到 computed 中\x3c\/span\x3e\n    computed[key] = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e fn(store); }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ store.getters[key] = store._vm[key]\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperty(store.getters, key, {\n      \x3cspan class=\x22hljs-attr\x22\x3eget\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e store._vm[key]; }\n    })\n  })\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ use a Vue instance to store the state tree\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ suppress warnings just in case the user has added\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ some funky global mixins\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 设为 silent 模式\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e silent = Vue.config.silent\n  Vue.config.silent = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 初始化一个 store._vm 实例\x3c\/span\x3e\n  store._vm = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Vue({\n    \x3cspan class=\x22hljs-attr\x22\x3edata\x3c\/span\x3e: { \x3cspan class=\x22hljs-attr\x22\x3estate\x3c\/span\x3e: state },\n    \x3cspan class=\x22hljs-attr\x22\x3ecomputed\x3c\/span\x3e: computed\n  })\n  Vue.config.silent = silent\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ enable strict mode for new vm\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 启用严格模式\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (store.strict) {\n    enableStrictMode(store)\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (oldVm) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ dispatch changes in all subscribed watchers\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ to force getter re-evaluation.\x3c\/span\x3e\n    store._withCommit(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n      oldVm.state = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e\n    })\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 执行destroy 方法，通知所有的watchers 改变，并重新计算getters的值。\x3c\/span\x3e\n    Vue.nextTick(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e oldVm.$destroy(); })\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这个方法在 \x3ccode\x3einstallModule\x3c\/code\x3e 方法之后执行，来看看它都做了什么。简单点说，就是给 store 增加了一个 _vm 属性，指向一个新的 vue 实例，传入的选项包括一个 state 和 computed, computed 来自store 的 getters 属性。同时给 store 增加了一个 getters 属性，且 \x3ccode\x3estore.getters[key] = store._vm[key]\x3c\/code\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3emapState\x3c\/h2\x3e\n\x3cp\x3e在讲 \x3ccode\x3emapState\x3c\/code\x3e 之前，先说一下基础方法 \x3ccode\x3enormalizeMap\x3c\/code\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/*\n * 如果map是一个数组 [\x27type1\x27, \x27type2\x27, ...]\n * 转化为[\n *   {\n *     key: type1,\n *     val: type1\n *   },\n *   {\n *     key: type2,\n *     val: type2\n *   },\n *   ...\n * ]\n * 如果map是一个对象 {type1: fn1, type2: fn2, ...}\n * 转化为 [\n *   {\n *     key: type1,\n *     val: fn1\n *   },\n *   {\n *     key: type2,\n *     val: fn2\n *   },\n *   ...\n * ]\n *\/\nfunction normalizeMap (map) {\n  return Array.isArray(map)\n    ? map.map(function (key) { return ({ key: key, val: key }); })\n    : Object.keys(map).map(function (key) { return ({ key: key, val: map[key] }); })\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/*\n * 如果map是一个数组 [\x27type1\x27, \x27type2\x27, ...]\n * 转化为[\n *   {\n *     key: type1,\n *     val: type1\n *   },\n *   {\n *     key: type2,\n *     val: type2\n *   },\n *   ...\n * ]\n * 如果map是一个对象 {type1: fn1, type2: fn2, ...}\n * 转化为 [\n *   {\n *     key: type1,\n *     val: fn1\n *   },\n *   {\n *     key: type2,\n *     val: fn2\n *   },\n *   ...\n * ]\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3enormalizeMap\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3emap\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.isArray(map)\n    ? map.map(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ekey\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e ({ \x3cspan class=\x22hljs-attr\x22\x3ekey\x3c\/span\x3e: key, \x3cspan class=\x22hljs-attr\x22\x3eval\x3c\/span\x3e: key }); })\n    : \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.keys(map).map(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ekey\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e ({ \x3cspan class=\x22hljs-attr\x22\x3ekey\x3c\/span\x3e: key, \x3cspan class=\x22hljs-attr\x22\x3eval\x3c\/span\x3e: map[key] }); })\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3enormalizeMap\x3c\/code\x3e 函数接受一个对象或者数组，最后都转化成一个数组形式，数组元素是包含 key 和 value 两个属性的对象。\x3c\/p\x3e\n\x3cp\x3e再来看看 \x3ccode\x3emapState\x3c\/code\x3e 方法。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/*\n * states: Object | Array\n * 返回一个对象\n * 对象的属性名对应于传入的 states 的属性名或者数组元素\n * 属性值都是一个函数\n * 执行这个函数的返回值根据 val 的不同而不同\n *\/\nfunction mapState (states) {\n  var res = {}\n  normalizeMap(states).forEach(function (ref) {\n    var key = ref.key; \n    var val = ref.val; \n\n    res[key] = function mappedState () {\n      return typeof val === \x27function\x27 \/\/ 如果是函数，返回函数执行后的结果\n        ? val.call(this, this.$store.state, this.$store.getters)\n        : this.$store.state[val] \/\/ 如果不是函数，而是一个字符串，直接在state中读取。\n    }\n  })\n  return res \n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/*\n * states: Object | Array\n * 返回一个对象\n * 对象的属性名对应于传入的 states 的属性名或者数组元素\n * 属性值都是一个函数\n * 执行这个函数的返回值根据 val 的不同而不同\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emapState\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3estates\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e res = {}\n  normalizeMap(states).forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eref\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e key = ref.key; \n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e val = ref.val; \n\n    res[key] = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emappedState\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e val === \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果是函数，返回函数执行后的结果\x3c\/span\x3e\n        ? val.call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$store.state, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$store.getters)\n        : \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$store.state[val] \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果不是函数，而是一个字符串，直接在state中读取。\x3c\/span\x3e\n    }\n  })\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e res \n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3emapState\x3c\/code\x3e 函数执行的结果是返回一个对象，属性名对应于传入的 states 对象或者数组元素。属性值是一个函数，执行这个函数将返回相应的 state .\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader9\x22\x3emapMutations\x3c\/h2\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/*\n * mutations: Array\n * 返回一个对象\n * 属性名为 mutation 类型\n * 属性值为一个函数\n * 执行这个函数后将触发指定的 mutation \n *\/\nfunction mapMutations (mutations) {\n  var res = {}\n  normalizeMap(mutations).forEach(function (ref) {\n    var key = ref.key; \/\/ mutation type\n    var val = ref.val; \/\/ mutation type\n\n    res[key] = function mappedMutation () {\n      var args = [], len = arguments.length;\n      while ( len-- ) args[ len ] = arguments[ len ]; \/\/ 一个数组缓存传入的参数\n\n      \/\/ val作为commit函数的第一个参数type， 剩下的参数依次是payload 和 options\n      return this.$store.commit.apply(this.$store, [val].concat(args))\n    }\n  })\n  return res\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/*\n * mutations: Array\n * 返回一个对象\n * 属性名为 mutation 类型\n * 属性值为一个函数\n * 执行这个函数后将触发指定的 mutation \n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emapMutations\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3emutations\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e res = {}\n  normalizeMap(mutations).forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eref\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e key = ref.key; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ mutation type\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e val = ref.val; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ mutation type\x3c\/span\x3e\n\n    res[key] = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emappedMutation\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e args = [], len = \x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e.length;\n      \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e ( len-- ) args[ len ] = \x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e[ len ]; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 一个数组缓存传入的参数\x3c\/span\x3e\n\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ val作为commit函数的第一个参数type， 剩下的参数依次是payload 和 options\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$store.commit.apply(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$store, [val].concat(args))\n    }\n  })\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e res\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e注意这里传入的 \x3ccode\x3emutations\x3c\/code\x3e 只能是一个数组，数组元素的 \x3ccode\x3emutation type\x3c\/code\x3e . 函数的作用的也很简单，传入一个 \x3ccode\x3emutations\x3c\/code\x3e 数组，返回一个对象，属性名是 \x3ccode\x3emutation\x3c\/code\x3e 的类型，属性值是一个函数，执行这个函数，将调用 \x3ccode\x3ecommit\x3c\/code\x3e 来触发对应的 \x3ccode\x3emutation\x3c\/code\x3e 从而改变state。另外注意这里的 \x3ccode\x3ethis\x3c\/code\x3e 指向的 store 的 \x3ccode\x3e_vm\x3c\/code\x3e 。\x3ccode\x3emapState\x3c\/code\x3e 是在 Vue 实例中调用的。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader10\x22\x3emapActions\x3c\/h2\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function mapActions (actions) {\n  var res = {}\n  normalizeMap(actions).forEach(function (ref) {\n    var key = ref.key;\n    var val = ref.val;\n\n    res[key] = function mappedAction () {\n      var args = [], len = arguments.length;\n      while ( len-- ) args[ len ] = arguments[ len ];\n\n      return this.$store.dispatch.apply(this.$store, [val].concat(args))\n    }\n  })\n  return res\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emapActions\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eactions\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e res = {}\n  normalizeMap(actions).forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eref\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e key = ref.key;\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e val = ref.val;\n\n    res[key] = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emappedAction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e args = [], len = \x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e.length;\n      \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e ( len-- ) args[ len ] = \x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e[ len ];\n\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$store.dispatch.apply(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$store, [val].concat(args))\n    }\n  })\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e res\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3emapActions\x3c\/code\x3e 函数和 \x3ccode\x3emapMutations\x3c\/code\x3e 函数几乎如出一辙。唯一的区别即使这里应该使用 \x3ccode\x3edispatch\x3c\/code\x3e 方法来触发 \x3ccode\x3eaction\x3c\/code\x3e.\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader11\x22\x3emapGetters\x3c\/h2\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/*\n * getters: Array\n *\/\nfunction mapGetters (getters) {\n  var res = {}\n  normalizeMap(getters).forEach(function (ref) {\n    var key = ref.key;\n    var val = ref.val; \n\n    res[key] = function mappedGetter () {\n      \/\/ 如果在getters中不存在，报错\n      if (!(val in this.$store.getters)) {\n        console.error((\x26quot;[vuex] unknown getter: \x26quot; \x2b val))\n      }\n      \/\/ 根据 val 在 getters 对象里找对应的属性值\n      return this.$store.getters[val]\n    }\n  })\n  return res\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/*\n * getters: Array\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emapGetters\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3egetters\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e res = {}\n  normalizeMap(getters).forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eref\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e key = ref.key;\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e val = ref.val; \n\n    res[key] = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emappedGetter\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果在getters中不存在，报错\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!(val \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$store.getters)) {\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.error((\x3cspan class=\x22hljs-string\x22\x3e\x22[vuex] unknown getter: \x22\x3c\/span\x3e \x2b val))\n      }\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 根据 val 在 getters 对象里找对应的属性值\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$store.getters[val]\n    }\n  })\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e res\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里 \x3ccode\x3egetters\x3c\/code\x3e 同样接受一个数组，同样返回一个对象。\x3c\/p\x3e\n\x3cp\x3e以上讲了四种 \x3ccode\x3emap***\x3c\/code\x3e 方法，这四种方法可以都返回一个对象，因此可以 ES6 新特性 \x3ccode\x3e...\x3c\/code\x3e 解构符。如\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n    ...mapState(options)\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e{\n    ...mapState(options)\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e关于 \x3ccode\x3e...\x3c\/code\x3e 解构符号, 举个小例子就明白了\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var obj1 = {\n    a: 1,\n    b: 2,\n    c: 3\n}\nvar obj2 = {\n    ...obj1,\n    d: 4\n}\n\/\/ obj2 = { a: 1, b: 2, c: 3, d: 4 }\n\/\/ 同样可以用于数组\nvar arr1 = [\x27a\x27, \x27b\x27, \x27c\x27]\nvar arr2 = [...arr1, \x27d\x27]\n\/\/ arr2 = [\x27a\x27, \x27b\x27, \x27c\x27, \x27d\x27] \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj1 = {\n    \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3eb\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3ec\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e\n}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj2 = {\n    ...obj1,\n    \x3cspan class=\x22hljs-attr\x22\x3ed\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ obj2 = { a: 1, b: 2, c: 3, d: 4 }\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 同样可以用于数组\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e arr1 = [\x3cspan class=\x22hljs-string\x22\x3e\x27a\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27b\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27c\x27\x3c\/span\x3e]\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e arr2 = [...arr1, \x3cspan class=\x22hljs-string\x22\x3e\x27d\x27\x3c\/span\x3e]\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ arr2 = [\x27a\x27, \x27b\x27, \x27c\x27, \x27d\x27] \x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader12\x22\x3einstall\x3c\/h2\x3e\n\x3cp\x3e\x3ccode\x3einstall\x3c\/code\x3e 方法与 vuex 数据流关系不大，主要是用于在 Vue 中注册 Vuex，这里为了保持篇幅的完整性，简单介绍一下。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function install (_Vue) {\n  if (Vue) { \n  \/\/ 报错，已经使用了 Vue.use(Vuex)方法注册了\n    console.error(\n      \x27[vuex] already installed. Vue.use(Vuex) should be called only once.\x27\n    )\n    return\n  }\n  Vue = _Vue\n  applyMixin(Vue)\n}\n\n\/\/ auto install in dist mode\n\/\/ 在浏览器环境写，会自动调用 install 方法\nif (typeof window !== \x27undefined\x27 \x26amp;\x26amp; window.Vue) {\n  install(window.Vue)\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3einstall\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e_Vue\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (Vue) { \n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 报错，已经使用了 Vue.use(Vuex)方法注册了\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.error(\n      \x3cspan class=\x22hljs-string\x22\x3e\x27[vuex] already installed. Vue.use(Vuex) should be called only once.\x27\x3c\/span\x3e\n    )\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n  }\n  Vue = _Vue\n  applyMixin(Vue)\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ auto install in dist mode\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 在浏览器环境写，会自动调用 install 方法\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e !== \x3cspan class=\x22hljs-string\x22\x3e\x27undefined\x27\x3c\/span\x3e \x26amp;\x26amp; \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.Vue) {\n  install(\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.Vue)\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e没什么难度，那就再看一下 applyMixin 方法\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function applyMixin (Vue) {\n  var version = Number(Vue.version.split(\x27.\x27)[0])\n  \/\/ 检查使用的 Vue 版本，初始化时的生命周期钩子函数是 init 还是 beforeCreate\n  if (version \x3e= 2) {\n    var usesInit = Vue.config._lifecycleHooks.indexOf(\x27init\x27) \x3e -1\n    Vue.mixin(usesInit ? { init: vuexInit } : { beforeCreate: vuexInit })\n  } else {\n    \/\/ override init and inject vuex init procedure\n    \/\/ for 1.x backwards compatibility.\n    \/\/ 保存之前的 Vue.prototype._init\n    var _init = Vue.prototype._init\n\n    \/\/ 重新设置Vue.prototype._init\n    Vue.prototype._init = function (options) {\n      if ( options === void 0 ) options = {};\n      \/\/  初始化时先初始化vuexInit\n      \/\/ options.init: Array  表示一组要执行的钩子函数\n      \/\/  options.init钩子函数之前加上了 vueInit\n      options.init = options.init\n        ? [vuexInit].concat(options.init)\n        : vuexInit\n      _init.call(this, options)\n    }\n  }\n  \n  \/*\n   * Vuex init hook, injected into each instances init hooks list.\n   *\/\n\n  function vuexInit () {\n    var options = this.$options\n    \/\/ store injection\n    \/\/ 如果自己有store选项，用自己的\n    \/\/ 否则查找父组件的\n    if (options.store) {\n      this.$store = options.store\n    } else if (options.parent \x26amp;\x26amp; options.parent.$store) {\n      this.$store = options.parent.$store\n    }\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eapplyMixin\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eVue\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e version = \x3cspan class=\x22hljs-built_in\x22\x3eNumber\x3c\/span\x3e(Vue.version.split(\x3cspan class=\x22hljs-string\x22\x3e\x27.\x27\x3c\/span\x3e)[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e])\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 检查使用的 Vue 版本，初始化时的生命周期钩子函数是 init 还是 beforeCreate\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (version \x26gt;= \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e usesInit = Vue.config._lifecycleHooks.indexOf(\x3cspan class=\x22hljs-string\x22\x3e\x27init\x27\x3c\/span\x3e) \x26gt; \x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e\n    Vue.mixin(usesInit ? { \x3cspan class=\x22hljs-attr\x22\x3einit\x3c\/span\x3e: vuexInit } : { \x3cspan class=\x22hljs-attr\x22\x3ebeforeCreate\x3c\/span\x3e: vuexInit })\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ override init and inject vuex init procedure\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ for 1.x backwards compatibility.\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 保存之前的 Vue.prototype._init\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e _init = Vue.prototype._init\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 重新设置Vue.prototype._init\x3c\/span\x3e\n    Vue.prototype._init = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eoptions\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( options === \x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e ) options = {};\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/  初始化时先初始化vuexInit\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ options.init: Array  表示一组要执行的钩子函数\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/  options.init钩子函数之前加上了 vueInit\x3c\/span\x3e\n      options.init = options.init\n        ? [vuexInit].concat(options.init)\n        : vuexInit\n      _init.call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, options)\n    }\n  }\n  \n  \x3cspan class=\x22hljs-comment\x22\x3e\/*\n   * Vuex init hook, injected into each instances init hooks list.\n   *\/\x3c\/span\x3e\n\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3evuexInit\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e options = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$options\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ store injection\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果自己有store选项，用自己的\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 否则查找父组件的\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (options.store) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$store = options.store\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (options.parent \x26amp;\x26amp; options.parent.$store) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$store = options.parent.$store\n    }\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e注释写的很清楚了，那么再看看什么有是 \x3ccode\x3evuexInit\x3c\/code\x3e 函数, \x3ccode\x3evuexInit\x3c\/code\x3e 函数是 vuex 的生命周期钩子函数。函数传递了两个信息，(1)子组件可以有自己单独的store，但是一般不这么做 (2) 如果子组件没有自己的 store ,就会查找父组件的。这也印证了 根组件的 store 会注入到所有的后代组件。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader13\x22\x3e小结\x3c\/h2\x3e\n\x3cp\x3e以上讲解了 Vuex 暴露出的 6 种方法，也是 Vuex 里的用的最多的几种方法，之后还会解读一下其他一些方法，比如 store 的一些实例方法。\x3c\/p\x3e\n\x3cp\x3e另外本文的 \x3cstrong\x3egithub\x3c\/strong\x3e 的地址为： \x3ca href=\x22https:\/\/github.com\/zengxiaotao\/learnVuex2.0\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3elearnVuex2.0\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e转载请注明\x3ca href=\x22https:\/\/github.com\/zengxiaotao\/learnVuex2.0\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e原链接\x3c\/a\x3e\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e全文完\x3c\/p\x3e\x3c\/blockquote\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>vuex 2.0源码解读（一）</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000007108052">https://segmentfault.com/a/1190000007108052</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/dvp03aedwli/" target="_blank">https://alili.tech/archive/dvp03aedwli/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>