<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="Vue的数据依赖实现原理简析"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>Vue的数据依赖实现原理简析 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/jokghb33ky/",
				"appid": "1613049289050283", 
				"title": "Vue的数据依赖实现原理简析 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-10T02:30:08"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/k0g3tvhjls/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/78jbamcw392/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fjokghb33ky%2f&text=Vue%e7%9a%84%e6%95%b0%e6%8d%ae%e4%be%9d%e8%b5%96%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86%e7%ae%80%e6%9e%90"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fjokghb33ky%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fjokghb33ky%2f&text=Vue%e7%9a%84%e6%95%b0%e6%8d%ae%e4%be%9d%e8%b5%96%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86%e7%ae%80%e6%9e%90"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fjokghb33ky%2f&title=Vue%e7%9a%84%e6%95%b0%e6%8d%ae%e4%be%9d%e8%b5%96%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86%e7%ae%80%e6%9e%90"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fjokghb33ky%2f&is_video=false&description=Vue%e7%9a%84%e6%95%b0%e6%8d%ae%e4%be%9d%e8%b5%96%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86%e7%ae%80%e6%9e%90"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=Vue%e7%9a%84%e6%95%b0%e6%8d%ae%e4%be%9d%e8%b5%96%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86%e7%ae%80%e6%9e%90&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fjokghb33ky%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fjokghb33ky%2f&title=Vue%e7%9a%84%e6%95%b0%e6%8d%ae%e4%be%9d%e8%b5%96%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86%e7%ae%80%e6%9e%90"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fjokghb33ky%2f&title=Vue%e7%9a%84%e6%95%b0%e6%8d%ae%e4%be%9d%e8%b5%96%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86%e7%ae%80%e6%9e%90"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fjokghb33ky%2f&title=Vue%e7%9a%84%e6%95%b0%e6%8d%ae%e4%be%9d%e8%b5%96%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86%e7%ae%80%e6%9e%90"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fjokghb33ky%2f&title=Vue%e7%9a%84%e6%95%b0%e6%8d%ae%e4%be%9d%e8%b5%96%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86%e7%ae%80%e6%9e%90"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">Vue的数据依赖实现原理简析</h1><div class="meta"><div class="postdate"><time datetime="2019-01-10" itemprop="datePublished">2019-01-10</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e首先让我们从最简单的一个实例\x3ccode\x3eVue\x3c\/code\x3e入手:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    const app = new Vue({\n        \/\/ options  传入一个选项obj.这个obj即对于这个vue实例的初始化\n    })\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e app = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Vue({\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ options  传入一个选项obj.这个obj即对于这个vue实例的初始化\x3c\/span\x3e\n    })\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e通过查阅文档，我们可以知道这个\x3ccode\x3eoptions\x3c\/code\x3e可以接受:\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cp\x3e选项\/数据\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3edata\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eprops\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3epropsData(方便测试使用)\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ecomputed\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3emethods\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ewatch\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e选项 \/ DOM\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e选项 \/ 生命周期钩子\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e选项 \/ 资源\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e选项 \/ 杂项\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e具体未展开的内容请自行查阅相关文档，接下来让我们来看看传入的\x3ccode\x3e选项\/数据\x3c\/code\x3e是如何管理数据之间的相互依赖的。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    const app = new Vue({\n        el: \x27#app\x27,\n        props: {\n          a: {\n            type: Object,\n            default () {\n              return {\n                key1: \x27a\x27,\n                key2: {\n                    a: \x27b\x27\n                }\n              }\n            }\n          }\n        },\n        data: {\n          msg1: \x27Hello world!\x27,\n          arr: {\n            arr1: 1\n          }\n        },\n        watch: {\n          a (newVal, oldVal) {\n            console.log(newVal, oldVal)\n          }\n        },\n        methods: {\n          go () {\n            console.log(\x27This is simple demo\x27)\n          }\n        }\n    })\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e app = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Vue({\n        \x3cspan class=\x22hljs-attr\x22\x3eel\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27#app\x27\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3eprops\x3c\/span\x3e: {\n          \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: {\n            \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e: \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e,\n            \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e () {\n              \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n                \x3cspan class=\x22hljs-attr\x22\x3ekey1\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27a\x27\x3c\/span\x3e,\n                \x3cspan class=\x22hljs-attr\x22\x3ekey2\x3c\/span\x3e: {\n                    \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27b\x27\x3c\/span\x3e\n                }\n              }\n            }\n          }\n        },\n        \x3cspan class=\x22hljs-attr\x22\x3edata\x3c\/span\x3e: {\n          \x3cspan class=\x22hljs-attr\x22\x3emsg1\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Hello world!\x27\x3c\/span\x3e,\n          \x3cspan class=\x22hljs-attr\x22\x3earr\x3c\/span\x3e: {\n            \x3cspan class=\x22hljs-attr\x22\x3earr1\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n          }\n        },\n        \x3cspan class=\x22hljs-attr\x22\x3ewatch\x3c\/span\x3e: {\n          a (newVal, oldVal) {\n            \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(newVal, oldVal)\n          }\n        },\n        \x3cspan class=\x22hljs-attr\x22\x3emethods\x3c\/span\x3e: {\n          go () {\n            \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27This is simple demo\x27\x3c\/span\x3e)\n          }\n        }\n    })\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们使用\x3ccode\x3eVue\x3c\/code\x3e这个构造函数去实例化了一个\x3ccode\x3evue\x3c\/code\x3e实例\x3ccode\x3eapp\x3c\/code\x3e。传入了\x3ccode\x3eprops\x3c\/code\x3e, \x3ccode\x3edata\x3c\/code\x3e, \x3ccode\x3ewatch\x3c\/code\x3e, \x3ccode\x3emethods\x3c\/code\x3e等属性。在实例化的过程中，\x3ccode\x3eVue\x3c\/code\x3e提供的构造函数就使用我们传入的\x3ccode\x3eoptions\x3c\/code\x3e去完成数据的依赖管理，初始化的过程只有一次，但是在你自己的程序当中，数据的依赖管理的次数不止一次。\x3c\/p\x3e\n\x3cp\x3e那\x3ccode\x3eVue\x3c\/code\x3e的构造函数到底是怎么实现的呢？\x3ca href=\x22https:\/\/github.com\/vuejs\/vue\/blob\/v2.1.10\/src\/core\/instance\/index.js\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eVue\x3c\/a\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 构造函数\nfunction Vue (options) {\n  if (process.env.NODE_ENV !== \x27production\x27 \x26amp;\x26amp;\n    !(this instanceof Vue)) {\n    warn(\x27Vue is a constructor and should be called with the `new` keyword\x27)\n  }\n  this._init(options)\n}\n\n\/\/ 对Vue这个class进行mixin,即在原型上添加方法\n\/\/ Vue.prototype.* = function () {}\ninitMixin(Vue)\nstateMixin(Vue)\neventsMixin(Vue)\nlifecycleMixin(Vue)\nrenderMixin(Vue)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 构造函数\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eVue\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eoptions\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (process.env.NODE_ENV !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e \x26amp;\x26amp;\n    !(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e Vue)) {\n    warn(\x3cspan class=\x22hljs-string\x22\x3e\x27Vue is a constructor and should be called with the `new` keyword\x27\x3c\/span\x3e)\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._init(options)\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 对Vue这个class进行mixin,即在原型上添加方法\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Vue.prototype.* = function () {}\x3c\/span\x3e\ninitMixin(Vue)\nstateMixin(Vue)\neventsMixin(Vue)\nlifecycleMixin(Vue)\nrenderMixin(Vue)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当我们调用\x3ccode\x3enew Vue\x3c\/code\x3e的时候，事实上就调用的\x3ccode\x3eVue\x3c\/code\x3e原型上的\x3ccode\x3e_init\x3c\/code\x3e方法.\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 原型上提供_init方法,新建一个vue实例并传入options参数\n  Vue.prototype._init = function (options?: Object) {\n    const vm: Component = this\n    \/\/ a uid\n    vm._uid = uid\x2b\x2b\n\n    let startTag, endTag\n    \/\/ a flag to avoid this being observed\n    vm._isVue = true\n    \/\/ merge options\n    if (options \x26amp;\x26amp; options._isComponent) {\n      \/\/ optimize internal component instantiation\n      \/\/ since dynamic options merging is pretty slow, and none of the\n      \/\/ internal component options needs special treatment.\n      initInternalComponent(vm, options)\n    } else {\n      \/\/ 将传入的这些options选项挂载到vm.$options属性上\n      vm.$options = mergeOptions(\n        \/\/ components\/filter\/directive\n        resolveConstructorOptions(vm.constructor),\n        \/\/ this._init()传入的options\n        options || {},\n        vm\n      )\n    }\n    \/* istanbul ignore else *\/\n    if (process.env.NODE_ENV !== \x27production\x27) {\n      initProxy(vm)\n    } else {\n      vm._renderProxy = vm\n    }\n    \/\/ expose real self\n    vm._self = vm     \/\/ 自身的实例\n    \/\/ 接下来所有的操作都是在这个实例上添加方法\n    initLifecycle(vm)  \/\/ lifecycle初始化\n    initEvents(vm)     \/\/ events初始化 vm._events, 主要是提供vm实例上的$on\/$emit\/$off\/$off等方法\n    initRender(vm)     \/\/ 初始化渲染函数,在vm上绑定$createElement方法\n    callHook(vm, \x27beforeCreate\x27)  \/\/ 钩子函数的执行, beforeCreate\n    initInjections(vm) \/\/ resolve injections before data\/props\n    initState(vm)      \/\/ Observe data添加对data的监听, 将data转化为getters\/setters\n    initProvide(vm) \/\/ resolve provide after data\/props\n    callHook(vm, \x27created\x27) \/\/ 钩子函数的执行, created\n\n    \/\/ vm挂载的根元素\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el)\n    }\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 原型上提供_init方法,新建一个vue实例并传入options参数\x3c\/span\x3e\n  Vue.prototype._init = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eoptions?: Object\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e vm: Component = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ a uid\x3c\/span\x3e\n    vm._uid = uid\x2b\x2b\n\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e startTag, endTag\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ a flag to avoid this being observed\x3c\/span\x3e\n    vm._isVue = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ merge options\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (options \x26amp;\x26amp; options._isComponent) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ optimize internal component instantiation\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ since dynamic options merging is pretty slow, and none of the\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ internal component options needs special treatment.\x3c\/span\x3e\n      initInternalComponent(vm, options)\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将传入的这些options选项挂载到vm.$options属性上\x3c\/span\x3e\n      vm.$options = mergeOptions(\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ components\/filter\/directive\x3c\/span\x3e\n        resolveConstructorOptions(vm.constructor),\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ this._init()传入的options\x3c\/span\x3e\n        options || {},\n        vm\n      )\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/* istanbul ignore else *\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (process.env.NODE_ENV !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e) {\n      initProxy(vm)\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      vm._renderProxy = vm\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ expose real self\x3c\/span\x3e\n    vm._self = vm     \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 自身的实例\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 接下来所有的操作都是在这个实例上添加方法\x3c\/span\x3e\n    initLifecycle(vm)  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ lifecycle初始化\x3c\/span\x3e\n    initEvents(vm)     \x3cspan class=\x22hljs-comment\x22\x3e\/\/ events初始化 vm._events, 主要是提供vm实例上的$on\/$emit\/$off\/$off等方法\x3c\/span\x3e\n    initRender(vm)     \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 初始化渲染函数,在vm上绑定$createElement方法\x3c\/span\x3e\n    callHook(vm, \x3cspan class=\x22hljs-string\x22\x3e\x27beforeCreate\x27\x3c\/span\x3e)  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 钩子函数的执行, beforeCreate\x3c\/span\x3e\n    initInjections(vm) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ resolve injections before data\/props\x3c\/span\x3e\n    initState(vm)      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Observe data添加对data的监听, 将data转化为getters\/setters\x3c\/span\x3e\n    initProvide(vm) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ resolve provide after data\/props\x3c\/span\x3e\n    callHook(vm, \x3cspan class=\x22hljs-string\x22\x3e\x27created\x27\x3c\/span\x3e) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 钩子函数的执行, created\x3c\/span\x3e\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ vm挂载的根元素\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (vm.$options.el) {\n      vm.$mount(vm.$options.el)\n    }\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e其中在\x3ccode\x3ethis._init()\x3c\/code\x3e方法中调用\x3ccode\x3einitState(vm)\x3c\/code\x3e,完成对\x3ccode\x3evm\x3c\/code\x3e这个实例的数据的监听,也是本文所要展开说的具体内容。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export function initState (vm: Component) {\n  \/\/ 首先在vm上初始化一个_watchers数组，缓存这个vm上的所有watcher\n  vm._watchers = []\n  \/\/ 获取options,包括在new Vue传入的，同时还包括了Vue所继承的options\n  const opts = vm.$options\n  \/\/ 初始化props属性\n  if (opts.props) initProps(vm, opts.props)\n  \/\/ 初始化methods属性\n  if (opts.methods) initMethods(vm, opts.methods)\n  \/\/ 初始化data属性\n  if (opts.data) {\n    initData(vm)\n  } else {\n    observe(vm._data = {}, true \/* asRootData *\/)\n  }\n  \/\/ 初始化computed属性\n  if (opts.computed) initComputed(vm, opts.computed)\n  \/\/ 初始化watch属性\n  if (opts.watch) initWatch(vm, opts.watch)\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3einitState\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3evm: Component\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 首先在vm上初始化一个_watchers数组，缓存这个vm上的所有watcher\x3c\/span\x3e\n  vm._watchers = []\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 获取options,包括在new Vue传入的，同时还包括了Vue所继承的options\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e opts = vm.$options\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 初始化props属性\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (opts.props) initProps(vm, opts.props)\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 初始化methods属性\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (opts.methods) initMethods(vm, opts.methods)\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 初始化data属性\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (opts.data) {\n    initData(vm)\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n    observe(vm._data = {}, \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/* asRootData *\/\x3c\/span\x3e)\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 初始化computed属性\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (opts.computed) initComputed(vm, opts.computed)\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 初始化watch属性\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (opts.watch) initWatch(vm, opts.watch)\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3einitProps\x3c\/h2\x3e\n\x3cp\x3e我们在实例化\x3ccode\x3eapp\x3c\/code\x3e的时候，在构造函数里面传入的\x3ccode\x3eoptions\x3c\/code\x3e中有\x3ccode\x3eprops\x3c\/code\x3e属性：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    props: {\n      a: {\n        type: Object,\n        default () {\n          return {\n            key1: \x27a\x27,\n            key2: {\n                a: \x27b\x27\n            }\n          }\n        }\n      }\n    }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e    props: {\n      \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: {\n        \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e: \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e () {\n          \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n            \x3cspan class=\x22hljs-attr\x22\x3ekey1\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27a\x27\x3c\/span\x3e,\n            \x3cspan class=\x22hljs-attr\x22\x3ekey2\x3c\/span\x3e: {\n                \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27b\x27\x3c\/span\x3e\n            }\n          }\n        }\n      }\n    }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function initProps (vm: Component, propsOptions: Object) {\n  \/\/ propsData主要是为了方便测试使用\n  const propsData = vm.$options.propsData || {}\n  \/\/ 新建vm._props对象，可以通过app实例去访问\n  const props = vm._props = {}\n  \/\/ cache prop keys so that future props updates can iterate using Array\n  \/\/ instead of dynamic object key enumeration.\n  \/\/ 缓存的prop key\n  const keys = vm.$options._propKeys = []\n  const isRoot = !vm.$parent\n  \/\/ root instance props should be converted\n  observerState.shouldConvert = isRoot\n  for (const key in propsOptions) {\n    \/\/ this._init传入的options中的props属性\n    keys.push(key)\n    \/\/ 注意这个validateProp方法，不仅完成了prop属性类型验证的，同时将prop的值都转化为了getter\/setter,并返回一个observer\n    const value = validateProp(key, propsOptions, propsData, vm)\n   \n    \/\/ 将这个key对应的值转化为getter\/setter\n      defineReactive(props, key, value)\n    \/\/ static props are already proxied on the component\x27s prototype\n    \/\/ during Vue.extend(). We only need to proxy props defined at\n    \/\/ instantiation here.\n    \/\/ 如果在vm这个实例上没有key属性，那么就通过proxy转化为proxyGetter\/proxySetter, 并挂载到vm实例上，可以通过app._props[key]这种形式去访问\n    if (!(key in vm)) {\n      proxy(vm, `_props`, key)\n    }\n  }\n  observerState.shouldConvert = true\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3einitProps\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3evm: Component, propsOptions: Object\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ propsData主要是为了方便测试使用\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e propsData = vm.$options.propsData || {}\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 新建vm._props对象，可以通过app实例去访问\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e props = vm._props = {}\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ cache prop keys so that future props updates can iterate using Array\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ instead of dynamic object key enumeration.\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 缓存的prop key\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e keys = vm.$options._propKeys = []\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e isRoot = !vm.$parent\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ root instance props should be converted\x3c\/span\x3e\n  observerState.shouldConvert = isRoot\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e key \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e propsOptions) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ this._init传入的options中的props属性\x3c\/span\x3e\n    keys.push(key)\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 注意这个validateProp方法，不仅完成了prop属性类型验证的，同时将prop的值都转化为了getter\/setter,并返回一个observer\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e value = validateProp(key, propsOptions, propsData, vm)\n   \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将这个key对应的值转化为getter\/setter\x3c\/span\x3e\n      defineReactive(props, key, value)\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ static props are already proxied on the component\x27s prototype\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ during Vue.extend(). We only need to proxy props defined at\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ instantiation here.\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果在vm这个实例上没有key属性，那么就通过proxy转化为proxyGetter\/proxySetter, 并挂载到vm实例上，可以通过app._props[key]这种形式去访问\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!(key \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e vm)) {\n      proxy(vm, \x3cspan class=\x22hljs-string\x22\x3e`_props`\x3c\/span\x3e, key)\n    }\n  }\n  observerState.shouldConvert = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e接下来看下\x3ccode\x3evalidateProp(key, propsOptions, propsData, vm)\x3c\/code\x3e方法内部到底发生了什么。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export function validateProp (\n  key: string,\n  propOptions: Object,    \/\/ $options.props属性\n  propsData: Object,      \/\/ $options.propsData属性\n  vm?: Component\n): any {\n  const prop = propOptions[key]\n  \/\/ 如果在propsData测试props上没有缓存的key\n  const absent = !hasOwn(propsData, key)\n  let value = propsData[key]\n  \/\/ 处理boolean类型的数据\n  \/\/ handle boolean props\n  if (isType(Boolean, prop.type)) {\n    if (absent \x26amp;\x26amp; !hasOwn(prop, \x27default\x27)) {\n      value = false\n    } else if (!isType(String, prop.type) \x26amp;\x26amp; (value === \x27\x27 || value === hyphenate(key))) {\n      value = true\n    }\n  }\n  \/\/ check default value\n  if (value === undefined) {\n    \/\/ default属性值，是基本类型还是function\n    \/\/ getPropsDefaultValue见下面第一段代码\n    value = getPropDefaultValue(vm, prop, key)\n    \/\/ since the default value is a fresh copy,\n    \/\/ make sure to observe it.\n    const prevShouldConvert = observerState.shouldConvert\n    observerState.shouldConvert = true\n    \/\/ 将value的所有属性转化为getter\/setter形式\n    \/\/ 并添加value的依赖\n    \/\/ observe方法的分析见下面第二段代码\n    observe(value)\n    observerState.shouldConvert = prevShouldConvert\n  }\n  if (process.env.NODE_ENV !== \x27production\x27) {\n    assertProp(prop, key, value, vm, absent)\n  }\n  return value\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3evalidateProp\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\n  key: string,\n  propOptions: Object,    \x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e $options.props属性\n  propsData: Object,      \x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e $options.propsData属性\n  vm?: Component\n\x3c\/span\x3e): \x3cspan class=\x22hljs-title\x22\x3eany\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e prop = propOptions[key]\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果在propsData测试props上没有缓存的key\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e absent = !hasOwn(propsData, key)\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e value = propsData[key]\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 处理boolean类型的数据\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ handle boolean props\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isType(\x3cspan class=\x22hljs-built_in\x22\x3eBoolean\x3c\/span\x3e, prop.type)) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (absent \x26amp;\x26amp; !hasOwn(prop, \x3cspan class=\x22hljs-string\x22\x3e\x27default\x27\x3c\/span\x3e)) {\n      value = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!isType(\x3cspan class=\x22hljs-built_in\x22\x3eString\x3c\/span\x3e, prop.type) \x26amp;\x26amp; (value === \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e || value === hyphenate(key))) {\n      value = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n    }\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ check default value\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (value === \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ default属性值，是基本类型还是function\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ getPropsDefaultValue见下面第一段代码\x3c\/span\x3e\n    value = getPropDefaultValue(vm, prop, key)\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ since the default value is a fresh copy,\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ make sure to observe it.\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e prevShouldConvert = observerState.shouldConvert\n    observerState.shouldConvert = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将value的所有属性转化为getter\/setter形式\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 并添加value的依赖\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ observe方法的分析见下面第二段代码\x3c\/span\x3e\n    observe(value)\n    observerState.shouldConvert = prevShouldConvert\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (process.env.NODE_ENV !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e) {\n    assertProp(prop, key, value, vm, absent)\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e value\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 获取prop的默认值\nfunction getPropDefaultValue (vm: ?Component, prop: PropOptions, key: string): any {\n  \/\/ no default, return undefined\n  \/\/ 如果没有default属性的话，那么就返回undefined\n  if (!hasOwn(prop, \x27default\x27)) {\n    return undefined\n  }\n  const def = prop.default\n  \/\/ the raw prop value was also undefined from previous render,\n  \/\/ return previous default value to avoid unnecessary watcher trigger\n  if (vm \x26amp;\x26amp; vm.$options.propsData \x26amp;\x26amp;\n    vm.$options.propsData[key] === undefined \x26amp;\x26amp;\n    vm._props[key] !== undefined) {\n    return vm._props[key]\n  }\n  \/\/ call factory function for non-Function types\n  \/\/ a value is Function if its prototype is function even across different execution context\n  \/\/ 如果是function 则调用def.call(vm)\n  \/\/ 否则就返回default属性对应的值\n  return typeof def === \x27function\x27 \x26amp;\x26amp; getType(prop.type) !== \x27Function\x27\n    ? def.call(vm)\n    : def\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 获取prop的默认值\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3egetPropDefaultValue\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3evm: ?Component, prop: PropOptions, key: string\x3c\/span\x3e): \x3cspan class=\x22hljs-title\x22\x3eany\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ no default, return undefined\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果没有default属性的话，那么就返回undefined\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!hasOwn(prop, \x3cspan class=\x22hljs-string\x22\x3e\x27default\x27\x3c\/span\x3e)) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e def = prop.default\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ the raw prop value was also undefined from previous render,\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ return previous default value to avoid unnecessary watcher trigger\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (vm \x26amp;\x26amp; vm.$options.propsData \x26amp;\x26amp;\n    vm.$options.propsData[key] === \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e \x26amp;\x26amp;\n    vm._props[key] !== \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e vm._props[key]\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ call factory function for non-Function types\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ a value is Function if its prototype is function even across different execution context\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果是function 则调用def.call(vm)\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 否则就返回default属性对应的值\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e def === \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e \x26amp;\x26amp; getType(prop.type) !== \x3cspan class=\x22hljs-string\x22\x3e\x27Function\x27\x3c\/span\x3e\n    ? def.call(vm)\n    : def\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3eVue\x3c\/code\x3e提供了一个\x3ccode\x3eobserve\x3c\/code\x3e方法,在其内部实例化了一个\x3ccode\x3eObserver\x3c\/code\x3e类，并返回\x3ccode\x3eObserver\x3c\/code\x3e的实例。每一个\x3ccode\x3eObserver\x3c\/code\x3e实例对应记录了\x3ccode\x3eprops\x3c\/code\x3e中这个的\x3ccode\x3edefault value\x3c\/code\x3e的所有依赖(仅限\x3ccode\x3eobject\x3c\/code\x3e类型)，这个\x3ccode\x3eObserver\x3c\/code\x3e实际上就是一个观察者，它维护了一个数组\x3ccode\x3ethis.subs = []\x3c\/code\x3e用以收集相关的\x3ccode\x3esubs(订阅者)\x3c\/code\x3e(即这个观察者的依赖)。通过将\x3ccode\x3edefault value\x3c\/code\x3e转化为\x3ccode\x3egetter\/setter\x3c\/code\x3e形式，同时添加一个自定义\x3ccode\x3e__ob__\x3c\/code\x3e属性，这个属性就对应\x3ccode\x3eObserver\x3c\/code\x3e实例。\x3c\/p\x3e\n\x3cp\x3e说起来有点绕，还是让我们看看我们给的\x3ccode\x3edemo\x3c\/code\x3e里传入的\x3ccode\x3eoptions\x3c\/code\x3e配置:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    props: {\n      a: {\n        type: Object,\n        default () {\n          return {\n            key1: \x27a\x27,\n            key2: {\n                a: \x27b\x27\n            }\n          }\n        }\n      }\n    }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e    props: {\n      \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: {\n        \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e: \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e () {\n          \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n            \x3cspan class=\x22hljs-attr\x22\x3ekey1\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27a\x27\x3c\/span\x3e,\n            \x3cspan class=\x22hljs-attr\x22\x3ekey2\x3c\/span\x3e: {\n                \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27b\x27\x3c\/span\x3e\n            }\n          }\n        }\n      }\n    }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在往上数的第二段代码里面的方法\x3ccode\x3eobervse(value)\x3c\/code\x3e，即对\x3ccode\x3e{key1: \x27a\x27, key2: {a: \x27b\x27\x22}}\x22\x3c\/code\x3e进行依赖的管理，同时将这个\x3ccode\x3eobj\x3c\/code\x3e所有的属性值都转化为\x3ccode\x3egetter\/setter\x3c\/code\x3e形式。此外，\x3ccode\x3eVue\x3c\/code\x3e还会将\x3ccode\x3eprops\x3c\/code\x3e属性都代理到\x3ccode\x3evm\x3c\/code\x3e实例上，通过\x3ccode\x3evm.key1\x3c\/code\x3e,\x3ccode\x3evm.key2\x3c\/code\x3e就可以访问到这个属性。\x3c\/p\x3e\n\x3cp\x3e此外，还需要了解下在\x3ccode\x3eVue\x3c\/code\x3e中管理依赖的一个非常重要的类: \x3ccode\x3eDep\x3c\/code\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export default class Dep { \n  constructor () {\n    this.id = uid\x2b\x2b\n    this.subs = []\n  }\n  addSub () {...}  \/\/ 添加订阅者(依赖)\n  removeSub () {...}  \/\/ 删除订阅者(依赖)\n  depend () {...}  \/\/ 检查当前Dep.target是否存在以及判断这个watcher已经被添加到了相应的依赖当中，如果没有则添加订阅者(依赖)，如果已经被添加了那么就不做处理\n  notify () {...}  \/\/ 通知订阅者(依赖)更新\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eDep\x3c\/span\x3e \x3c\/span\x3e{ \n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e () {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.id = uid\x2b\x2b\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.subs = []\n  }\n  addSub () {...}  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 添加订阅者(依赖)\x3c\/span\x3e\n  removeSub () {...}  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 删除订阅者(依赖)\x3c\/span\x3e\n  depend () {...}  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 检查当前Dep.target是否存在以及判断这个watcher已经被添加到了相应的依赖当中，如果没有则添加订阅者(依赖)，如果已经被添加了那么就不做处理\x3c\/span\x3e\n  notify () {...}  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 通知订阅者(依赖)更新\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在\x3ccode\x3eVue\x3c\/code\x3e的整个生命周期当中，你所定义的响应式的数据上都会绑定一个\x3ccode\x3eDep\x3c\/code\x3e实例去管理其依赖。它实际上就是\x3ccode\x3e观察者\x3c\/code\x3e和\x3ccode\x3e订阅者\x3c\/code\x3e联系的一个桥梁。\x3c\/p\x3e\n\x3cp\x3e刚才谈到了对于依赖的管理，它的核心之一就是观察者\x3ccode\x3eObserver\x3c\/code\x3e这个类：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export class Observer {\n  value: any;\n  dep: Dep;\n  vmCount: number; \/\/ number of vms that has this object as root $data\n\n  constructor (value: any) {\n    this.value = value\n    \/\/ dep记录了和这个value值的相关依赖\n    this.dep = new Dep()\n    this.vmCount = 0\n    \/\/ value其实就是vm._data, 即在vm._data上添加__ob__属性\n    def(value, \x27__ob__\x27, this)\n    \/\/ 如果是数组\n    if (Array.isArray(value)) {\n      \/\/ 首先判断是否能使用__proto__属性\n      const augment = hasProto\n        ? protoAugment\n        : copyAugment\n      augment(value, arrayMethods, arrayKeys)\n      \/\/ 遍历数组，并将obj类型的属性改为getter\/setter实现\n      this.observeArray(value)\n    } else {\n      \/\/ 遍历obj上的属性，将每个属性改为getter\/setter实现\n      this.walk(value)\n    }\n  }\n\n  \/**\n   * Walk through each property and convert them into\n   * getter\/setters. This method should only be called when\n   * value type is Object.\n   *\/\n  \/\/ 将每个property对应的属性都转化为getter\/setters,只能是当这个value的类型为Object时\n  walk (obj: Object) {\n    const keys = Object.keys(obj)\n    for (let i = 0; i \x3c keys.length; i\x2b\x2b) {\n      defineReactive(obj, keys[i], obj[keys[i]])\n    }\n  }\n\n  \/**\n   * Observe a list of Array items.\n   *\/\n  \/\/ 监听array中的item\n  observeArray (items: Array\x3cany\x3e) {\n    for (let i = 0, l = items.length; i \x3c l; i\x2b\x2b) {\n      observe(items[i])\n    }\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eObserver\x3c\/span\x3e \x3c\/span\x3e{\n  value: any;\n  dep: Dep;\n  vmCount: number; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ number of vms that has this object as root $data\x3c\/span\x3e\n\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e (value: any) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.value = value\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ dep记录了和这个value值的相关依赖\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.dep = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Dep()\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.vmCount = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ value其实就是vm._data, 即在vm._data上添加__ob__属性\x3c\/span\x3e\n    def(value, \x3cspan class=\x22hljs-string\x22\x3e\x27__ob__\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e)\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果是数组\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.isArray(value)) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 首先判断是否能使用__proto__属性\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e augment = hasProto\n        ? protoAugment\n        : copyAugment\n      augment(value, arrayMethods, arrayKeys)\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 遍历数组，并将obj类型的属性改为getter\/setter实现\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.observeArray(value)\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 遍历obj上的属性，将每个属性改为getter\/setter实现\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.walk(value)\n    }\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/**\n   * Walk through each property and convert them into\n   * getter\/setters. This method should only be called when\n   * value type is Object.\n   *\/\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将每个property对应的属性都转化为getter\/setters,只能是当这个value的类型为Object时\x3c\/span\x3e\n  walk (obj: \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e keys = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.keys(obj)\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; keys.length; i\x2b\x2b) {\n      defineReactive(obj, keys[i], obj[keys[i]])\n    }\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/**\n   * Observe a list of Array items.\n   *\/\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 监听array中的item\x3c\/span\x3e\n  observeArray (items: \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e\x26lt;any\x26gt;) {\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, l = items.length; i \x26lt; l; i\x2b\x2b) {\n      observe(items[i])\n    }\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3ewalk\x3c\/code\x3e方法里面调用\x3ccode\x3edefineReactive\x3c\/code\x3e方法：通过遍历这个\x3ccode\x3eobject\x3c\/code\x3e的\x3ccode\x3ekey\x3c\/code\x3e，并将对应的\x3ccode\x3evalue\x3c\/code\x3e转化为\x3ccode\x3egetter\/setter\x3c\/code\x3e形式，通过闭包维护一个\x3ccode\x3edep\x3c\/code\x3e，在\x3ccode\x3egetter\x3c\/code\x3e方法当中定义了这个\x3ccode\x3ekey\x3c\/code\x3e是如何进行依赖的收集，在\x3ccode\x3esetter\x3c\/code\x3e方法中定义了当这个\x3ccode\x3ekey\x3c\/code\x3e对应的值改变后，如何完成相关依赖数据的更新。但是从源码当中，我们却发现当\x3ccode\x3egetter\x3c\/code\x3e函数被调用的时候并非就一定会完成依赖的收集，其中还有一层判断，就是\x3ccode\x3eDep.target\x3c\/code\x3e是否存在。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\n\/**\n * Define a reactive property on an Object.\n *\/\nexport function defineReactive (\n  obj: Object,\n  key: string,\n  val: any,\n  customSetter?: Function\n) {\n  \/\/ 每个属性新建一个dep实例，管理这个属性的依赖\n  const dep = new Dep()\n    \n  \/\/ 或者属性描述符\n  const property = Object.getOwnPropertyDescriptor(obj, key)\n  \/\/ 如果这个属性是不可配的，即无法更改\n  if (property \x26amp;\x26amp; property.configurable === false) {\n    return\n  }\n\n  \/\/ cater for pre-defined getter\/setters\n  const getter = property \x26amp;\x26amp; property.get\n  const setter = property \x26amp;\x26amp; property.set\n\n  \/\/ 递归去将val转化为getter\/setter\n  \/\/ childOb将子属性也转化为Observer\n  let childOb = observe(val)\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    \/\/ 定义getter --\x3e\x3e reactiveGetter\n    get: function reactiveGetter () {\n      const value = getter ? getter.call(obj) : val\n      \/\/ 定义相应的依赖\n      if (Dep.target) {\n        \/\/ Dep.target.addDep(this)\n        \/\/ 即添加watch函数\n        \/\/ dep.depend()及调用了dep.addSub()只不过中间需要判断是否这个id的dep已经被包含在内了\n        dep.depend()\n        \/\/ childOb也添加依赖\n        if (childOb) {\n          childOb.dep.depend()\n        }\n        if (Array.isArray(value)) {\n          dependArray(value)\n        }\n      }\n      return value\n    },\n    \/\/ 定义setter --\x3e\x3e reactiveSetter\n    set: function reactiveSetter (newVal) {\n      const value = getter ? getter.call(obj) : val\n      \/* eslint-disable no-self-compare *\/\n      if (newVal === value || (newVal !== newVal \x26amp;\x26amp; value !== value)) {\n        return\n      }\n      if (setter) {\n        setter.call(obj, newVal)\n      } else {\n        val = newVal\n      }\n      \/\/ 对得到的新值进行observe\n      childOb = observe(newVal)\n      \/\/ 相应的依赖进行更新\n      dep.notify()\n    }\n  })\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * Define a reactive property on an Object.\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3edefineReactive\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\n  obj: Object,\n  key: string,\n  val: any,\n  customSetter?: Function\n\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 每个属性新建一个dep实例，管理这个属性的依赖\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e dep = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Dep()\n    \n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 或者属性描述符\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e property = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.getOwnPropertyDescriptor(obj, key)\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果这个属性是不可配的，即无法更改\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (property \x26amp;\x26amp; property.configurable === \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ cater for pre-defined getter\/setters\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e getter = property \x26amp;\x26amp; property.get\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e setter = property \x26amp;\x26amp; property.set\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 递归去将val转化为getter\/setter\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ childOb将子属性也转化为Observer\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e childOb = observe(val)\n  \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperty(obj, key, {\n    \x3cspan class=\x22hljs-attr\x22\x3eenumerable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3econfigurable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 定义getter --\x26gt;\x26gt; reactiveGetter\x3c\/span\x3e\n    get: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ereactiveGetter\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e value = getter ? getter.call(obj) : val\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 定义相应的依赖\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (Dep.target) {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Dep.target.addDep(this)\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 即添加watch函数\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ dep.depend()及调用了dep.addSub()只不过中间需要判断是否这个id的dep已经被包含在内了\x3c\/span\x3e\n        dep.depend()\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ childOb也添加依赖\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (childOb) {\n          childOb.dep.depend()\n        }\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.isArray(value)) {\n          dependArray(value)\n        }\n      }\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e value\n    },\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 定义setter --\x26gt;\x26gt; reactiveSetter\x3c\/span\x3e\n    set: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ereactiveSetter\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3enewVal\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e value = getter ? getter.call(obj) : val\n      \x3cspan class=\x22hljs-comment\x22\x3e\/* eslint-disable no-self-compare *\/\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (newVal === value || (newVal !== newVal \x26amp;\x26amp; value !== value)) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n      }\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (setter) {\n        setter.call(obj, newVal)\n      } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        val = newVal\n      }\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 对得到的新值进行observe\x3c\/span\x3e\n      childOb = observe(newVal)\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 相应的依赖进行更新\x3c\/span\x3e\n      dep.notify()\n    }\n  })\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在上文中提到了\x3ccode\x3eDep\x3c\/code\x3e类是链接\x3ccode\x3e观察者\x3c\/code\x3e和\x3ccode\x3e订阅者\x3c\/code\x3e的桥梁。同时在\x3ccode\x3eDep\x3c\/code\x3e的实现当中还有一个非常重要的属性就是\x3ccode\x3eDep.target\x3c\/code\x3e，它事实就上就是一个订阅者，只有当\x3ccode\x3eDep.target\x3c\/code\x3e(订阅者)存在的时候，调用属性的\x3ccode\x3egetter\x3c\/code\x3e函数的时候才能完成依赖的收集工作。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Dep.target = null\nconst targetStack = []\n\nexport function pushTarget (_target: Watcher) {\n  if (Dep.target) targetStack.push(Dep.target)\n  Dep.target = _target\n}\n\nexport function popTarget () {\n  Dep.target = targetStack.pop()\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eDep.target = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e targetStack = []\n\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3epushTarget\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e_target: Watcher\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (Dep.target) targetStack.push(Dep.target)\n  Dep.target = _target\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3epopTarget\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  Dep.target = targetStack.pop()\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e那么\x3ccode\x3eVue\x3c\/code\x3e是如何来实现\x3ccode\x3e订阅者\x3c\/code\x3e的呢？\x3ccode\x3eVue\x3c\/code\x3e里面定义了一个类: \x3ccode\x3eWatcher\x3c\/code\x3e，在\x3ccode\x3eVue\x3c\/code\x3e的整个生命周期当中，会有4类地方会实例化\x3ccode\x3eWatcher\x3c\/code\x3e：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eVue\x3c\/code\x3e实例化的过程中有\x3ccode\x3ewatch\x3c\/code\x3e选项\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eVue\x3c\/code\x3e实例化的过程中有\x3ccode\x3ecomputed\x3c\/code\x3e计算属性选项\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eVue\x3c\/code\x3e原型上有挂载\x3ccode\x3e$watch\x3c\/code\x3e方法: Vue.prototype.$watch，可以直接通过实例调用\x3ccode\x3ethis.$watch\x3c\/code\x3e方法\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eVue\x3c\/code\x3e生成了\x3ccode\x3erender\x3c\/code\x3e函数，更新视图时\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22constructor (\n    vm: Component,\n    expOrFn: string | Function,\n    cb: Function,\n    options?: Object\n  ) {\n    \/\/ 缓存这个实例vm\n    this.vm = vm\n    \/\/ vm实例中的_watchers中添加这个watcher\n    vm._watchers.push(this)\n    \/\/ options\n    if (options) {\n      this.deep = !!options.deep\n      this.user = !!options.user\n      this.lazy = !!options.lazy\n      this.sync = !!options.sync\n    } else {\n      this.deep = this.user = this.lazy = this.sync = false\n    }\n    this.cb = cb\n    this.id = \x2b\x2buid \/\/ uid for batching\n    this.active = true\n    this.dirty = this.lazy \/\/ for lazy watchers\n    ....\n    \/\/ parse expression for getter\n    if (typeof expOrFn === \x27function\x27) {\n      this.getter = expOrFn\n    } else {\n      this.getter = parsePath(expOrFn)\n      if (!this.getter) {\n        this.getter = function () {}\n      }\n    }\n    \/\/ 通过get方法去获取最新的值\n    \/\/ 如果lazy为true, 初始化的时候为undefined\n    this.value = this.lazy\n      ? undefined\n      : this.get()\n  }\n  get () {...}\n  addDep () {...}\n  update () {...}\n  run () {...}\n  evaluate () {...}\n  run () {...}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e (\n    vm: Component,\n    expOrFn: string | Function,\n    cb: Function,\n    options?: Object\n  ) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 缓存这个实例vm\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.vm = vm\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ vm实例中的_watchers中添加这个watcher\x3c\/span\x3e\n    vm._watchers.push(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e)\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ options\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (options) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.deep = !!options.deep\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.user = !!options.user\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.lazy = !!options.lazy\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.sync = !!options.sync\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.deep = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.user = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.lazy = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.sync = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.cb = cb\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.id = \x2b\x2buid \x3cspan class=\x22hljs-comment\x22\x3e\/\/ uid for batching\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.active = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.dirty = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.lazy \x3cspan class=\x22hljs-comment\x22\x3e\/\/ for lazy watchers\x3c\/span\x3e\n    ....\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ parse expression for getter\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e expOrFn === \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getter = expOrFn\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getter = parsePath(expOrFn)\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getter) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getter = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{}\n      }\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 通过get方法去获取最新的值\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果lazy为true, 初始化的时候为undefined\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.value = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.lazy\n      ? \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e\n      : \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.get()\n  }\n  get () {...}\n  addDep () {...}\n  update () {...}\n  run () {...}\n  evaluate () {...}\n  run () {...}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3eWatcher\x3c\/code\x3e接收的参数当中\x3ccode\x3eexpOrFn\x3c\/code\x3e定义了用以获取\x3ccode\x3ewatcher\x3c\/code\x3e的\x3ccode\x3egetter\x3c\/code\x3e函数。\x3ccode\x3eexpOrFn\x3c\/code\x3e可以有2种类型：\x3ccode\x3estring\x3c\/code\x3e或\x3ccode\x3efunction\x3c\/code\x3e.若为\x3ccode\x3estring\x3c\/code\x3e类型，首先会通过\x3ccode\x3eparsePath\x3c\/code\x3e方法去对\x3ccode\x3estring\x3c\/code\x3e进行分割(仅支持\x3ccode\x3e.\x3c\/code\x3e号形式的对象访问)。在除了\x3ccode\x3ecomputed\x3c\/code\x3e选项外，其他几种实例化\x3ccode\x3ewatcher\x3c\/code\x3e的方式都是在实例化过程中完成求值及依赖的收集工作：\x3ccode\x3ethis.value = this.lazy ? undefined : this.get()\x3c\/code\x3e.在\x3ccode\x3eWatcher\x3c\/code\x3e的\x3ccode\x3eget\x3c\/code\x3e方法中:\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e!!!前方高能\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22get () {\n \/\/ pushTarget即设置当前的需要被执行的watcher\n    pushTarget(this)\n    let value\n    const vm = this.vm\n    if (this.user) {\n      try {\n        \/\/ $watch(function () {})\n        \/\/ 调用this.getter的时候，触发了属性的getter函数\n        \/\/ 在getter中进行了依赖的管理\n        value = this.getter.call(vm, vm)\n        console.log(value)\n      } catch (e) {\n        handleError(e, vm, `getter for watcher \x26quot;${this.expression}\x26quot;`)\n      }\n    } else {\n      \/\/ 如果是新建模板函数，则会动态计算模板与data中绑定的变量，这个时候就调用了getter函数，那么就完成了dep的收集\n      \/\/ 调用getter函数，则同时会调用函数内部的getter的函数，进行dep收集工作\n      value = this.getter.call(vm, vm)\n    }\n    \/\/ \x26quot;touch\x26quot; every property so they are all tracked as\n    \/\/ dependencies for deep watching\n    \/\/ 让每个属性都被作为dependencies而tracked, 这样是为了deep watching\n    if (this.deep) {\n      traverse(value)\n    }\n    popTarget()\n    this.cleanupDeps()\n    return value    \n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eget () {\n \x3cspan class=\x22hljs-comment\x22\x3e\/\/ pushTarget即设置当前的需要被执行的watcher\x3c\/span\x3e\n    pushTarget(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e)\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e value\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e vm = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.vm\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.user) {\n      \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ $watch(function () {})\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 调用this.getter的时候，触发了属性的getter函数\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 在getter中进行了依赖的管理\x3c\/span\x3e\n        value = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getter.call(vm, vm)\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(value)\n      } \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e (e) {\n        handleError(e, vm, \x3cspan class=\x22hljs-string\x22\x3e`getter for watcher \x22\x3cspan class=\x22hljs-subst\x22\x3e${\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.expression}\x3c\/span\x3e\x22`\x3c\/span\x3e)\n      }\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果是新建模板函数，则会动态计算模板与data中绑定的变量，这个时候就调用了getter函数，那么就完成了dep的收集\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 调用getter函数，则同时会调用函数内部的getter的函数，进行dep收集工作\x3c\/span\x3e\n      value = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getter.call(vm, vm)\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22touch\x22 every property so they are all tracked as\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ dependencies for deep watching\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 让每个属性都被作为dependencies而tracked, 这样是为了deep watching\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.deep) {\n      traverse(value)\n    }\n    popTarget()\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.cleanupDeps()\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e value    \n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e一进入\x3ccode\x3eget\x3c\/code\x3e方法，首先进行\x3ccode\x3epushTarget(this)\x3c\/code\x3e的操作，此时\x3ccode\x3eVue\x3c\/code\x3e当中\x3ccode\x3eDep.target = 当前这个watcher\x3c\/code\x3e,接下来进行\x3ccode\x3evalue = this.getter.call(vm, vm)\x3c\/code\x3e操作，在这个操作中就完成了依赖的收集工作。还是拿文章一开始的\x3ccode\x3edemo\x3c\/code\x3e来说，在\x3ccode\x3evue\x3c\/code\x3e实例化的时候传入了\x3ccode\x3ewatch\x3c\/code\x3e选项：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    props: {\n      a: {\n        type: Object,\n        default () {\n          return {\n            key1: \x27a\x27,\n            key2: {\n                a: \x27b\x27\n            }\n          }\n        }\n      }\n    },\n   watch: {\n        a (newVal, oldVal) {\n            console.log(newVal, oldVal)\n        }\n    }, \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e    props: {\n      \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: {\n        \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e: \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e () {\n          \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n            \x3cspan class=\x22hljs-attr\x22\x3ekey1\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27a\x27\x3c\/span\x3e,\n            \x3cspan class=\x22hljs-attr\x22\x3ekey2\x3c\/span\x3e: {\n                \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27b\x27\x3c\/span\x3e\n            }\n          }\n        }\n      }\n    },\n   \x3cspan class=\x22hljs-attr\x22\x3ewatch\x3c\/span\x3e: {\n        a (newVal, oldVal) {\n            \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(newVal, oldVal)\n        }\n    }, \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在\x3ccode\x3eVue\x3c\/code\x3e的\x3ccode\x3einitState()\x3c\/code\x3e开始执行后，首先会初始化\x3ccode\x3eprops\x3c\/code\x3e的属性为\x3ccode\x3egetter\/setter\x3c\/code\x3e函数，然后在进行\x3ccode\x3einitWatch\x3c\/code\x3e初始化的时候，这个时候初始化\x3ccode\x3ewatcher\x3c\/code\x3e实例，并调用\x3ccode\x3eget()\x3c\/code\x3e方法，设置\x3ccode\x3eDep.target = 当前这个watcher实例\x3c\/code\x3e，进而到\x3ccode\x3evalue = this.getter.call(vm, vm)\x3c\/code\x3e的操作。在调用\x3ccode\x3ethis.getter.call(vm, vm)\x3c\/code\x3e的方法中，便会访问\x3ccode\x3eprops\x3c\/code\x3e选项中的\x3ccode\x3ea\x3c\/code\x3e属性即其\x3ccode\x3egetter\x3c\/code\x3e函数。在\x3ccode\x3ea\x3c\/code\x3e属性的\x3ccode\x3egetter\x3c\/code\x3e函数执行过程中，因为\x3ccode\x3eDep.target\x3c\/code\x3e已经存在，那么就进入了\x3ccode\x3e依赖收集\x3c\/code\x3e的过程:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22if (Dep.target) {\n    \/\/ Dep.target.addDep(this)\n    \/\/ 即添加watch函数\n    \/\/ dep.depend()及调用了dep.addSub()只不过中间需要判断是否这个id的dep已经被包含在内了\n    dep.depend()\n    \/\/ childOb也添加依赖\n    if (childOb) {\n      childOb.dep.depend()\n    }\n    if (Array.isArray(value)) {\n      dependArray(value)\n    }\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (Dep.target) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Dep.target.addDep(this)\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 即添加watch函数\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ dep.depend()及调用了dep.addSub()只不过中间需要判断是否这个id的dep已经被包含在内了\x3c\/span\x3e\n    dep.depend()\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ childOb也添加依赖\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (childOb) {\n      childOb.dep.depend()\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.isArray(value)) {\n      dependArray(value)\n    }\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3edep\x3c\/code\x3e是一开始初始化的过程中，这个属性上的\x3ccode\x3edep\x3c\/code\x3e属性。调用\x3ccode\x3edep.depend()\x3c\/code\x3e函数：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  depend () {\n    if (Dep.target) {\n      \/\/ Dep.target为一个watcher\n      Dep.target.addDep(this)\n    }\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e  depend () {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (Dep.target) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Dep.target为一个watcher\x3c\/span\x3e\n      Dep.target.addDep(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e)\n    }\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3eDep.target\x3c\/code\x3e也就刚才的那个\x3ccode\x3ewatcher\x3c\/code\x3e实例，这里也就相当于调用了\x3ccode\x3ewatcher\x3c\/code\x3e实例的\x3ccode\x3eaddDep\x3c\/code\x3e方法: \x3ccode\x3ewatcher.addDep(this)\x3c\/code\x3e，并将\x3ccode\x3edep\x3c\/code\x3e观察者传入。在\x3ccode\x3eaddDep\x3c\/code\x3e方法中完成依赖收集:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22addDep (dep: Dep) {\n    const id = dep.id\n    if (!this.newDepIds.has(id)) {\n      this.newDepIds.add(id)\n      this.newDeps.push(dep)\n      if (!this.depIds.has(id)) {\n        dep.addSub(this)\n      }\n    }\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eaddDep (dep: Dep) {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e id = dep.id\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.newDepIds.has(id)) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.newDepIds.add(id)\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.newDeps.push(dep)\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.depIds.has(id)) {\n        dep.addSub(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e)\n      }\n    }\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这个时候依赖完成了收集，当你去修改\x3ccode\x3ea\x3c\/code\x3e属性的值时，会调用\x3ccode\x3ea\x3c\/code\x3e属性的\x3ccode\x3esetter\x3c\/code\x3e函数，里面会执行\x3ccode\x3edep.notify()\x3c\/code\x3e，它会遍历所有的订阅者，然后调用订阅者上的\x3ccode\x3eupdate\x3c\/code\x3e函数。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3einitData\x3c\/code\x3e过程和\x3ccode\x3einitProps\x3c\/code\x3e类似，具体可参见源码。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3einitComputed\x3c\/h2\x3e\n\x3cp\x3e以上就是在\x3ccode\x3einitProps\x3c\/code\x3e过程中\x3ccode\x3eVue\x3c\/code\x3e是如何进行依赖收集的，\x3ccode\x3einitData\x3c\/code\x3e的过程和\x3ccode\x3einitProps\x3c\/code\x3e类似，下来再来看看\x3ccode\x3einitComputed\x3c\/code\x3e的过程.\x3cbr\x3e在\x3ccode\x3ecomputed\x3c\/code\x3e属性初始化的过程当中，会为每个属性实例化一个\x3ccode\x3ewatcher\x3c\/code\x3e:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const computedWatcherOptions = { lazy: true }\n\nfunction initComputed (vm: Component, computed: Object) {\n  \/\/ 新建_computedWatchers属性\n  const watchers = vm._computedWatchers = Object.create(null)\n\n  for (const key in computed) {\n    const userDef = computed[key]\n    \/\/ 如果computed为funtion，即取这个function为getter函数\n    \/\/ 如果computed为非function.则可以单独为这个属性定义getter\/setter属性\n    let getter = typeof userDef === \x27function\x27 ? userDef : userDef.get\n    \/\/ create internal watcher for the computed property.\n    \/\/ lazy属性为true\n    \/\/ 注意这个地方传入的getter参数\n    \/\/ 实例化的过程当中不去完成依赖的收集工作\n    watchers[key] = new Watcher(vm, getter, noop, computedWatcherOptions)\n\n    \/\/ component-defined computed properties are already defined on the\n    \/\/ component prototype. We only need to define computed properties defined\n    \/\/ at instantiation here.\n    if (!(key in vm)) {\n      defineComputed(vm, key, userDef)\n    } \n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e computedWatcherOptions = { \x3cspan class=\x22hljs-attr\x22\x3elazy\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e }\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3einitComputed\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3evm: Component, computed: Object\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 新建_computedWatchers属性\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e watchers = vm._computedWatchers = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.create(\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e)\n\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e key \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e computed) {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e userDef = computed[key]\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果computed为funtion，即取这个function为getter函数\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果computed为非function.则可以单独为这个属性定义getter\/setter属性\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e getter = \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e userDef === \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e ? userDef : userDef.get\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ create internal watcher for the computed property.\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ lazy属性为true\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 注意这个地方传入的getter参数\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 实例化的过程当中不去完成依赖的收集工作\x3c\/span\x3e\n    watchers[key] = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Watcher(vm, getter, noop, computedWatcherOptions)\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ component-defined computed properties are already defined on the\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ component prototype. We only need to define computed properties defined\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ at instantiation here.\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!(key \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e vm)) {\n      defineComputed(vm, key, userDef)\n    } \n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e但是这个\x3ccode\x3ewatcher\x3c\/code\x3e在实例化的过程中，由于传入了\x3ccode\x3e{lazy: true}\x3c\/code\x3e的配置选项，那么一开始是不会进行求值与依赖收集的: \x3ccode\x3ethis.value = this.lazy ? undefined : this.get()\x3c\/code\x3e.在\x3ccode\x3einitComputed\x3c\/code\x3e的过程中，\x3ccode\x3eVue\x3c\/code\x3e会将\x3ccode\x3ecomputed\x3c\/code\x3e属性定义到\x3ccode\x3evm\x3c\/code\x3e实例上，同时将这个属性定义为\x3ccode\x3egetter\/setter\x3c\/code\x3e。当你访问\x3ccode\x3ecomputed\x3c\/code\x3e属性的时候调用\x3ccode\x3egetter\x3c\/code\x3e函数：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function createComputedGetter (key) {\n  return function computedGetter () {\n    const watcher = this._computedWatchers \x26amp;\x26amp; this._computedWatchers[key]\n    if (watcher) {\n      \/\/ 是否需要重新计算\n      if (watcher.dirty) {\n        watcher.evaluate()\n      }\n      \/\/ 管理依赖\n      if (Dep.target) {\n        watcher.depend()\n      }\n      return watcher.value\n    }\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecreateComputedGetter\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ekey\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecomputedGetter\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e watcher = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._computedWatchers \x26amp;\x26amp; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._computedWatchers[key]\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (watcher) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 是否需要重新计算\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (watcher.dirty) {\n        watcher.evaluate()\n      }\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 管理依赖\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (Dep.target) {\n        watcher.depend()\n      }\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e watcher.value\n    }\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在\x3ccode\x3ewatcher\x3c\/code\x3e存在的情况下，首先判断\x3ccode\x3ewatcher.dirty\x3c\/code\x3e属性，这个属性主要是用于判断这个\x3ccode\x3ecomputed\x3c\/code\x3e属性是否需要重新求值，因为在上一轮的依赖收集的过程当中，观察者已经将这个\x3ccode\x3ewatcher\x3c\/code\x3e添加到依赖数组当中了，如果观察者发生了变化，就会\x3ccode\x3edep.notify()\x3c\/code\x3e，通知所有的\x3ccode\x3ewatcher\x3c\/code\x3e，而对于\x3ccode\x3ecomputed\x3c\/code\x3e的\x3ccode\x3ewatcher\x3c\/code\x3e接收到变化的请求后，会将\x3ccode\x3ewatcher.dirty = true\x3c\/code\x3e即表明观察者发生了变化，当再次调用\x3ccode\x3ecomputed\x3c\/code\x3e属性的\x3ccode\x3egetter\x3c\/code\x3e函数的时候便会重新计算，否则还是使用之前缓存的值。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3einitWatch\x3c\/h2\x3e\n\x3cp\x3e\x3ccode\x3einitWatch\x3c\/code\x3e的过程中其实就是实例化\x3ccode\x3enew Watcher\x3c\/code\x3e完成观察者的依赖收集的过程，在内部的实现当中是调用了原型上的\x3ccode\x3eVue.prototype.$watch\x3c\/code\x3e方法。这个方法也适用于\x3ccode\x3evm\x3c\/code\x3e实例，即在\x3ccode\x3evm\x3c\/code\x3e实例内部调用\x3ccode\x3ethis.$watch\x3c\/code\x3e方法去实例化\x3ccode\x3ewatcher\x3c\/code\x3e，完成依赖的收集，同时监听\x3ccode\x3eexpOrFn\x3c\/code\x3e的变化。\x3c\/p\x3e\n\x3cp\x3e总结：\x3c\/p\x3e\n\x3cp\x3e以上就是在\x3ccode\x3eVue\x3c\/code\x3e实例初始化的过程中实现依赖管理的分析。大致的总结下就是：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3einitState\x3c\/code\x3e的过程中，将\x3ccode\x3eprops\x3c\/code\x3e,\x3ccode\x3ecomputed\x3c\/code\x3e,\x3ccode\x3edata\x3c\/code\x3e等属性通过\x3ccode\x3eObject.defineProperty\x3c\/code\x3e来改造其\x3ccode\x3egetter\/setter\x3c\/code\x3e属性，并为每一个响应式属性实例化一个\x3ccode\x3eobserver\x3c\/code\x3e观察者。这个\x3ccode\x3eobserver\x3c\/code\x3e内部\x3ccode\x3edep\x3c\/code\x3e记录了这个响应式属性的所有依赖。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e当响应式属性调用\x3ccode\x3esetter\x3c\/code\x3e函数时，通过\x3ccode\x3edep.notify()\x3c\/code\x3e方法去遍历所有的依赖，调用\x3ccode\x3ewatcher.update()\x3c\/code\x3e去完成数据的动态响应。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e这篇文章主要从初始化的数据层面上分析了\x3ccode\x3eVue\x3c\/code\x3e是如何管理依赖来到达数据的动态响应。下一篇文章来分析下\x3ccode\x3eVue\x3c\/code\x3e中模板中的指令和响应式数据是如何关联来实现由数据驱动视图，以及数据是如何响应视图变化的。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>Vue的数据依赖实现原理简析</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000010014281">https://segmentfault.com/a/1190000010014281</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/jokghb33ky/" target="_blank">https://alili.tech/archive/jokghb33ky/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>