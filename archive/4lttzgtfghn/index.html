<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="无痛学会各种 2 的 Vue2&#43;Vuex2&#43;Webpack2 前后端同构渲染"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>无痛学会各种 2 的 Vue2&#43;Vuex2&#43;Webpack2 前后端同构渲染 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/4lttzgtfghn/",
				"appid": "1613049289050283", 
				"title": "无痛学会各种 2 的 Vue2&#43;Vuex2&#43;Webpack2 前后端同构渲染 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-02T02:30:10"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/tvv1g58zxb9/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/7fi9v4z9vuv/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f4lttzgtfghn%2f&text=%e6%97%a0%e7%97%9b%e5%ad%a6%e4%bc%9a%e5%90%84%e7%a7%8d%202%20%e7%9a%84%20Vue2%2bVuex2%2bWebpack2%20%e5%89%8d%e5%90%8e%e7%ab%af%e5%90%8c%e6%9e%84%e6%b8%b2%e6%9f%93"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f4lttzgtfghn%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f4lttzgtfghn%2f&text=%e6%97%a0%e7%97%9b%e5%ad%a6%e4%bc%9a%e5%90%84%e7%a7%8d%202%20%e7%9a%84%20Vue2%2bVuex2%2bWebpack2%20%e5%89%8d%e5%90%8e%e7%ab%af%e5%90%8c%e6%9e%84%e6%b8%b2%e6%9f%93"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f4lttzgtfghn%2f&title=%e6%97%a0%e7%97%9b%e5%ad%a6%e4%bc%9a%e5%90%84%e7%a7%8d%202%20%e7%9a%84%20Vue2%2bVuex2%2bWebpack2%20%e5%89%8d%e5%90%8e%e7%ab%af%e5%90%8c%e6%9e%84%e6%b8%b2%e6%9f%93"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f4lttzgtfghn%2f&is_video=false&description=%e6%97%a0%e7%97%9b%e5%ad%a6%e4%bc%9a%e5%90%84%e7%a7%8d%202%20%e7%9a%84%20Vue2%2bVuex2%2bWebpack2%20%e5%89%8d%e5%90%8e%e7%ab%af%e5%90%8c%e6%9e%84%e6%b8%b2%e6%9f%93"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e6%97%a0%e7%97%9b%e5%ad%a6%e4%bc%9a%e5%90%84%e7%a7%8d%202%20%e7%9a%84%20Vue2%2bVuex2%2bWebpack2%20%e5%89%8d%e5%90%8e%e7%ab%af%e5%90%8c%e6%9e%84%e6%b8%b2%e6%9f%93&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f4lttzgtfghn%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f4lttzgtfghn%2f&title=%e6%97%a0%e7%97%9b%e5%ad%a6%e4%bc%9a%e5%90%84%e7%a7%8d%202%20%e7%9a%84%20Vue2%2bVuex2%2bWebpack2%20%e5%89%8d%e5%90%8e%e7%ab%af%e5%90%8c%e6%9e%84%e6%b8%b2%e6%9f%93"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f4lttzgtfghn%2f&title=%e6%97%a0%e7%97%9b%e5%ad%a6%e4%bc%9a%e5%90%84%e7%a7%8d%202%20%e7%9a%84%20Vue2%2bVuex2%2bWebpack2%20%e5%89%8d%e5%90%8e%e7%ab%af%e5%90%8c%e6%9e%84%e6%b8%b2%e6%9f%93"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f4lttzgtfghn%2f&title=%e6%97%a0%e7%97%9b%e5%ad%a6%e4%bc%9a%e5%90%84%e7%a7%8d%202%20%e7%9a%84%20Vue2%2bVuex2%2bWebpack2%20%e5%89%8d%e5%90%8e%e7%ab%af%e5%90%8c%e6%9e%84%e6%b8%b2%e6%9f%93"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f4lttzgtfghn%2f&title=%e6%97%a0%e7%97%9b%e5%ad%a6%e4%bc%9a%e5%90%84%e7%a7%8d%202%20%e7%9a%84%20Vue2%2bVuex2%2bWebpack2%20%e5%89%8d%e5%90%8e%e7%ab%af%e5%90%8c%e6%9e%84%e6%b8%b2%e6%9f%93"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">无痛学会各种 2 的 Vue2&#43;Vuex2&#43;Webpack2 前后端同构渲染</h1><div class="meta"><div class="postdate"><time datetime="2019-02-02" itemprop="datePublished">2019-02-02</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e新增：哈哈，最近又推出了 vue 的文章，在这里放个链接~\x3cbr\x3e\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000009846314\x22\x3e手把手教你从零写一个简单的 VUE\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e感谢有人看我扯技术，这篇文章主要介绍最近非常火的vue2前端框架的特点和vue2\x2bvuex2\x2bwebpack2各种2的前后端同构渲染架构搭建流程，最后会附上代码，文章想到啥写啥，如果存在错误，或者大家有什么意见建议，欢迎大家指出来\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader0\x22\x3eVue2 和 Vue1 的对比\x3c\/h3\x3e\n\x3cp\x3evue2出来之后，基本上逛论坛逛技术群都能看到各种文章，各种讨论 ，一时间大家都在学习vue2了 ，我今年年初就开始接触vue，最初也是在react ，angular，vue 之中对比选择，最终选择了vue，因为其对前端比较友好（使用正常的模板，而不是JSX）、概念及学习成本相对简单(对于团队开发，引入技术必须要考虑其学习成本)，下面介绍下我理解的vue2和vue1的不同之处 ，如有不足，欢迎补充:\x3c\/p\x3e\n\x3cp\x3e1.\x3cem\x3e引入了\x3ccode\x3evirtual Dom\x3c\/code\x3e\x3c\/em\x3e\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3e在vue1中，数据和视图的绑定流程是通过 \x3ccode\x3eObject.defineProperty\x3c\/code\x3e将数据转化为\x3ccode\x3egetter\/setter\x3c\/code\x3e,\x3ccode\x3egetter\/setter\x3c\/code\x3e中加入\x3ccode\x3ewatcher\x3c\/code\x3e，当对数据进行操作的时候，\x3ccode\x3esetter\x3c\/code\x3e的\x3ccode\x3ewatch\x3c\/code\x3e被触发重新计算，然后更新和这个数据有关联的dom元素，这就是vue1的数据驱动视图原理\x3cbr\x3e在vue2中，数据的绑定和触发和vue1相同，基本原理都是通过\x3ccode\x3eObject.defineProperty\x3c\/code\x3e对数据加入\x27钩子\x27，以便在数据发生变化的时候得以响应，而在响应之后，不像vue1一样直接更新dom元素，而是放入\x3ccode\x3evirtual Dom\x3c\/code\x3e中，进行比对计算，然后对dom元素做相应的处理。下面是vue1和vue2的响应流程对比\x3c\/p\x3e\n\x3cp\x3e\x3cem\x3evue:\x3c\/em\x3e\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVx1bI?w=1560\x26amp;h=874\x22 src=\x22https:\/\/static.alili.tech\/img\/bVx1bI?w=1560\x26amp;h=874\x22 alt=\x22vue的响应式原理\x22 title=\x22vue的响应式原理\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cem\x3evue2:\x3c\/em\x3e\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVEx1j?w=1200\x26amp;h=750\x22 src=\x22https:\/\/static.alili.tech\/img\/bVEx1j?w=1200\x26amp;h=750\x22 alt=\x22vue2的响应式原理\x22 title=\x22vue2的响应式原理\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cem\x3e关于\x3ccode\x3evirtual Dom\x3c\/code\x3e\x3c\/em\x3e: 虚拟dom最初是在react上面认识的，其实做的事情就是在js内存中建立好dom的结构，然后再更新虚拟dom时做差异比对，将差异的地方真正更新到页面中，做到最小化页面的渲染。当然，也不是说对于所有情景，虚拟dom的性能都是最好的，毕竟比起直接操作dom元素，他还是需要在内存中进行计算，因此对于少量的元素更新，可能其性能比起直接操作dom元素要差。当然虚拟dom的引入，不只是在性能方面的考虑，虚拟dom可以带来编程的变化，比如你可以使用\x3ccode\x3erender\x3c\/code\x3e方法直接创建新的节点,虚拟dom也是vue2可以进行服务端渲染的关键，由于虚拟dom是在内存重点，vue2的ssr可以将虚拟dom直接生成html的字符串，从而实现ssr。除此之外，vue2 从模板到 virtuel-DOM 的编译阶段使用了一些高阶优化：\x3c\/p\x3e\n\x3cp\x3e(1). 它会检测出静态的 \x3ccode\x3eclass\x3c\/code\x3e 名和 \x3ccode\x3eattributes\x3c\/code\x3e 这样它们在初始化渲染之后就永远都不会再被比对。    \x3cbr\x3e   (2). 它会检测出最大静态子树 (就是不需要动态性的子树) 并且从渲染函数中萃取出来。这样在每次重渲染的时候，它就会直接重用完全相同的 \x3ccode\x3evirtual nodes\x3c\/code\x3e 同时跳过比对。\x3cbr\x3e   这些高阶优化通常只会在使用 \x3ccode\x3eJSX\x3c\/code\x3e 时通过 \x3ccode\x3eBabel plugin\x3c\/code\x3e 来做，但是 vue2 即使在使用浏览器内的编译器时也能做到。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e2.\x3cem\x3e组件事件传递机制的改变，组件数据双向绑定的去除\x3c\/em\x3e\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3evue2组件废除了\x3ccode\x3e$dispath\/$broadcast\x3c\/code\x3e父子组件的事件传播方式，废除了过滤器，\x3ccode\x3eprops\x3c\/code\x3e参数等的数据双向绑定以及处理功能，说明作者希望使用者通过建立全局的状态管理，事件管理机制，通过使用事件中心，允许组件自由交流，无论组件处于组件树的哪一层，将状态管理集中在一起处理，官方提供的\x3ccode\x3evuex\x3c\/code\x3e就是用来几种管理状态的。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e3.\x3cem\x3e服务端渲染 \x3ccode\x3essr:server-side-render\x3c\/code\x3e\x3c\/em\x3e\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3e由于\x3ccode\x3evirtual dom\x3c\/code\x3e的引入，使得vue的服务端渲染成为了可能，下面是官方 \x3ccode\x3evue-server-renderer\x3c\/code\x3e提供的渲染流程图:\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVDOf4?w=1946\x26amp;h=892\x22 src=\x22https:\/\/static.alili.tech\/img\/bVDOf4?w=1946\x26amp;h=892\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e可以看出vue的\x3ccode\x3eserver-side-render\x3c\/code\x3e有三部分组成，一部分是页面的源码（source），还有node层的渲染部分和浏览器端的渲染部分。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3esource\x3c\/code\x3e分为两种\x3ccode\x3eentry point\x3c\/code\x3e,一个是前端页面的入口\x3ccode\x3eclient entry\x3c\/code\x3e,主要是实例化Vue对象，将其挂载到页面中；另外一个是后端渲染服务入口\x3ccode\x3eserver entry\x3c\/code\x3e,主要是控服务端渲染模块回调，返回一个Promise对象，最终返回一个Vue对象（经过测试，直接返回Vue对象也是可以的）;\x3c\/p\x3e\n\x3cp\x3e前面的\x3ccode\x3esource\x3c\/code\x3e部分就是业务开发的代码，开发完成之后通过 \x3ccode\x3ewebpack\x3c\/code\x3e 进行构建，生成对应的bundle，这里不再赘述\x3ccode\x3eclient bundle\x3c\/code\x3e,就是一个可在浏览器端执行的打包文件；这里说下\x3ccode\x3eserver bundle\x3c\/code\x3e, vue2提供 \x3ccode\x3evue-server-renderer\x3c\/code\x3e模块，模块可以提供两种render: \x3ccode\x3erendererer\/bundleRenderer\x3c\/code\x3e ,下面分别介绍下这两种render。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3erenderer\x3c\/code\x3e接收一个vue对象 ，然后进行渲染，这种对于简单的vue对象,可以这么去做，但是对于复杂的项目，如果使用这种直接require一个vue对象，这个对于服务端代码的结构和逻辑都不太友好，首先模块的状态会一直延续在每个请求渲染请求，我们需要去管理和避免这次渲染请求的状态影响到后面的请求,因此\x3ccode\x3evue-server-renderer\x3c\/code\x3e提供了另外一种渲染模式，通过一个 \x3ccode\x3ebundleRenderer\x3c\/code\x3e去做渲染。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3ebundleRenderer\x3c\/code\x3e是较为复杂项目进行服务端渲染官方推荐的方式，通过webpack以\x3ccode\x3eserver entry\x3c\/code\x3e按照一定的要求打包生成一个 \x3ccode\x3eserver-bundle\x3c\/code\x3e,它相当于一个可以给服务端用的app的打包压缩文件，每一次调用都会重新初始化 vue对象，保证了每次请求都是独立的，对于开发者来说，只需要专注于当前业务就可以，不用为服务端渲染开发更多的逻辑代码。\x3cbr\x3e   renderer生成完成之后，都存在两个接口，分别是\x3ccode\x3erenderToString\x3c\/code\x3e和\x3ccode\x3erenderToStream\x3c\/code\x3e，一个是一次性将页面渲染成字符串文件，另外一个是流式渲染，适用于支持流的web服务器，可以是请求服务的速度更快\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e4.除了上面说的那些不同，vue2在生命周期管理，动画机制等地方都与vue有些差别，具体请浏览\x3ca href=\x22http:\/\/vuejs.org\/guide\/migration.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3emigration\x3c\/a\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3eVuex2 和 Vuex 、Webpack2 和 Webpack 的不同之处\x3c\/h3\x3e\n\x3ch4\x3evuex\x3c\/h4\x3e\n\x3cblockquote\x3e\n\x3cp\x3e相对于 vue2和vue 较大改动，vue的状态管理工具    vuex的改动不是很大，底层改动由于时间关系还没有来得及细究，但是在使用方面多了几个 Helper，利用ES6的展开函数可以更加方便的使用\x3ccode\x3estate,getters,mutations,actions\x3c\/code\x3e。下面简单介绍下vuex各个部分的概念\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3estate\x3c\/code\x3e是一个全局的状态存储，数据会存储在其中，vue组件可以直接访问其中的值，但是只可以读，不可以进行写操作\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3egetter\x3c\/code\x3e,有些时候我们需要对获取的数据进行加工，而不是直接获取state中的数据，这时候可以通过getter定义函数，返回对应的数据\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3emutations\x3c\/code\x3e是vuex中唯一一个可以修改数据的地方，\x3ccode\x3emutations\x3c\/code\x3e可以定义事件函数，在vue组件中可以通过commit发射事件，调用函数。需要注意的是，\x3ccode\x3emutations\x3c\/code\x3e中的操作必须是同步的，不可以存在异步操作的情况。\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eactions\x3c\/code\x3e和 \x3ccode\x3emutation\x3c\/code\x3e比较相似，不同的是actions中不直接修改state，而是通过commit调用mutations修改数据，而且actions中可以存在异步处理逻辑\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/blockquote\x3e\n\x3ch4\x3ewebpack\x3c\/h4\x3e\n\x3cblockquote\x3e\n\x3cp\x3e\x3ccode\x3ewebpack2\x3c\/code\x3e 和 \x3ccode\x3ewebpack\x3c\/code\x3e对比，有以下的新特性:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3eES6 Modules : webpack 2 已经支持原生的 ES6 的模块加载器了，这意味着 webpack 2 能够理解和处理 import和export了，而不用把他们转化成 CommonJS 来处理了。\x3c\/li\x3e\n\x3cli\x3e用 ES6 来做代码拆分 : ES6 的模块加载器定义了System.import这一个方法，System.import能够在运行时动态加载 ES6 模块。\x3c\/li\x3e\n\x3cli\x3e混合使用 ES6 和 AMD 和 CommonJS (Mixing ES6 with AMD and CommonJS)\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e更加具体的新特性可以浏览\x3ca href=\x22http:\/\/gold.xitu.io\/entry\/56b0623cc14061005a028d08\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e链接地址\x3c\/a\x3e\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e从零开始搭项目\x3c\/h3\x3e\n\x3cblockquote\x3e\n\x3cp\x3e好了，前面扯了那么多东西，估计没什么人看，我们还是回归题目，开始敲代码吧，哈哈，接下来我会使用vue2 \x2b vuex2 \x2b webpack2 搭建一个简单的 ssr项目，能够直出页面，还能够保存成静态文件。虽然官方页面响应的实例\x3ca href=\x22https:\/\/github.com\/vuejs\/vue-hackernews-2.0\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3evue-hackernews-2.0\x3c\/a\x3e，但是如果一开始把代码下下来，还是不太容易理解的，所以我参考其例子，从零开始搭建项目,源码在文章的最后\x3c\/p\x3e\n\x3cp\x3e首先当然是使用\x3ccode\x3enpm init\x3c\/code\x3e新建一个项目\x3cbr\x3e然后往\x3ccode\x3epackage.json\x3c\/code\x3e中写入下列依赖\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVEx3y?w=1040\x26amp;h=780\x22 src=\x22https:\/\/static.alili.tech\/img\/bVEx3y?w=1040\x26amp;h=780\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e然后运行 \x3ccode\x3enpm i\x3c\/code\x3e ,然后去上个厕所，喝杯茶也行，等所有的依赖安装完毕\x3cbr\x3e介绍下一些模块的作用 \x3ccode\x3evue，vuex\x3c\/code\x3e 为vue项目使用的基本框架，\x3ccode\x3eexpress,vue-server-renderer,serialize-javascript\x3c\/code\x3e为服务端渲染使用的模块，\x3ccode\x3ebabel-*\x3c\/code\x3e为ES6转换成ES5模块，其他的\x3ccode\x3ewebpack*,*-loader\x3c\/code\x3e为webpack构建所需要的模块，如果需要项目学习webpack的使用，可以阅读\x3ca href=\x22https:\/\/webpack.github.io\/docs\/roadmap.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e官方文档\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e安装阶段完成了，下面进入愉快的编码阶段了，其实按照流程应该是编码同时搞定打包、开发环境配置等工作的，为了文章的效果，就分开说了\x3c\/p\x3e\n\x3cp\x3e制作的页面是一个没有什么业务情景的页面(请原谅我，想到什么就写什么代码了)，主要是为了演示组件的引用流程，vuex状态管理以及引用，状态改变之后的视图更新，异步操作的视图更新，所以，当你下了源码，大概页面，你会看到下面这个奇奇怪怪的东西：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVEx5X?w=1808\x26amp;h=886\x22 src=\x22https:\/\/static.alili.tech\/img\/bVEx5X?w=1808\x26amp;h=886\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e好了不要在意这些细节了，我们来看看这个怪怪的东西是怎么出来的，先展示下项目最终的目录结构：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVEyeg?w=742\x26amp;h=984\x22 src=\x22https:\/\/static.alili.tech\/img\/bVEyeg?w=742\x26amp;h=984\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e其中\x3ccode\x3eindex.html\x3c\/code\x3e就是页面最终生成页的模板页，里面有简单的头部信息和占位符，可以在服务端渲染后进行内容替换\x3cbr\x3e\x3ccode\x3eapp.js\x3c\/code\x3e就是页面的逻辑入口文件，Vue对象在这里实例化，其中使用的store，route可以在实例化中传入\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVEx6Y?w=538\x26amp;h=416\x22 src=\x22https:\/\/static.alili.tech\/img\/bVEx6Y?w=538\x26amp;h=416\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e可以看到\x3ccode\x3eapp.js\x3c\/code\x3e引用了\x3ccode\x3eApp.vue\x3c\/code\x3e组件,\x3ccode\x3e.vue\x3c\/code\x3e是vue官方推出的单文件开发方式，配合webpack的\x3ccode\x3evue-loader\x3c\/code\x3e可以方便的实现模块化开发，\x3ccode\x3e.vue\x3c\/code\x3e文件在打包的时候会被编译成为一个js对象，里面包含一个\x3ccode\x3erender\x3c\/code\x3e方法，用于渲染页面，下面是\x3ccode\x3eApp.vue\x3c\/code\x3e文件\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVEx7w?w=1450\x26amp;h=1622\x22 src=\x22https:\/\/static.alili.tech\/img\/bVEx7w?w=1450\x26amp;h=1622\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e可以看到页面包含三个部分\x3ccode\x3etemplate 、script 、style\x3c\/code\x3e，其中template为组件使用的模板，现在vue2除了使用template，还可以使用JSX和js模板，但是相对其他两种，template对于前端开发者来说还是比较直观的，script为组件的逻辑部分，使用es6的进行模块化，构建的时候会使用Vue.extend生成一个组件，style为页面的样式部分，可以指定\x3ccode\x3elang\x3c\/code\x3e来声明使用的样式语法类型，可以用原生的css，也可以用stylus，sass等等，只要配置不同的webpack loader进行进行编译就行了，另外可以指定 \x3ccode\x3escoped\x3c\/code\x3e,使得组件中的样式只对组件生效，不会影响其他组件，不用担心命名重复的问题，其原理是在生成的时候为标签生成一段随机数(没研究过生成数的算法)，并且为选择器加上对应随机数的属性选择器。\x3c\/p\x3e\n\x3cp\x3e可以看到组件\x3ccode\x3eimport\x3c\/code\x3e另外一个\x3ccode\x3eList.vue\x3c\/code\x3e组件，并且在\x3ccode\x3ecomponents\x3c\/code\x3e中进行了引用，\x3ccode\x3etemplate\x3c\/code\x3e中进行了引用，这就实现了组件的嵌套和复用，下面是\x3ccode\x3eList.vue\x3c\/code\x3e文件\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVEx9h?w=1688\x26amp;h=1382\x22 src=\x22https:\/\/static.alili.tech\/img\/bVEx9h?w=1688\x26amp;h=1382\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e这个文件使用了vuex管理的数据，在此前的版本的vuex中，在组件使用数据需要写很多的\x3ccode\x3ecomputed,methods\x3c\/code\x3e,在新版本的可以配合ES6的展开函数和vuex的helper，简写很多函数，组件部分内容就说到这里了，可能有人会说啥是computed，啥是methods，这些通通自己看\x3ca href=\x22http:\/\/vuejs.org\/api\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e文档\x3c\/a\x3e，\x3cbr\x3e总的来说，写一个组件需要了解下面几点:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e模板指令，例如\x3ccode\x3ev-for，v-bind,v-on\x3c\/code\x3e等\x3c\/li\x3e\n\x3cli\x3e数据使用配置属性\x3ccode\x3edata,computed,props，watch\x3c\/code\x3e等\x3c\/li\x3e\n\x3cli\x3e组件的生命周期属性\x3ccode\x3ecreated,mounted\x3c\/code\x3e等\x3c\/li\x3e\n\x3cli\x3e全局方法\x3ccode\x3eVue.set,Vue.nextTick\x3c\/code\x3e等\x3c\/li\x3e\n\x3cli\x3e进阶开发: 动画效果，自定义指令，自定义插件，混合组件开发\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e下面说下用vuex做状态管理，下面是\x3ccode\x3estore\/index.js\x3c\/code\x3e文件\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVEyak?w=1358\x26amp;h=1290\x22 src=\x22https:\/\/static.alili.tech\/img\/bVEyak?w=1358\x26amp;h=1290\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e可以看到使用vuex需要在\x3ccode\x3eVue.use\x3c\/code\x3e中引入，然后实例化一个\x3ccode\x3eVuex.Store\x3c\/code\x3e对象就可以了,对象中需要定义\x3ccode\x3estate,actions,mutations,getters\x3c\/code\x3e等内容，这样子就可以建立一个全局的状态管理机制，可以从应用的顶端去处理数据，各个组件中对数据进行操作也是通过事件直接传递到Vuex中进行数据更新，然后再进行响应到其他使用同个数据的组件中，进行视图更新。\x3c\/p\x3e\n\x3cp\x3e项目的逻辑代码已经完成了，但是对照上面ssr的概念，会发现还少了两个webpack的\x3ccode\x3eentry point\x3c\/code\x3e，一个是前端代码的入口，可以是供服务端渲染的入口,下面是前端\x3ccode\x3eclient-entry.js\x3c\/code\x3e文件 \x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVEybl?w=986\x26amp;h=278\x22 src=\x22https:\/\/static.alili.tech\/img\/bVEybl?w=986\x26amp;h=278\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e文件引入了\x3ccode\x3eapp.js\x3c\/code\x3e,判断如果在服务端渲染时已经写入状态，则将vuex的状态进行替换，使得服务端渲染的html和vuex管理的数据是同步的。然后将vue实例挂载到html指定的节点中。\x3c\/p\x3e\n\x3cp\x3e下面是\x3ccode\x3eserver-entry.js\x3c\/code\x3e文件\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVEybU?w=658\x26amp;h=245\x22 src=\x22https:\/\/static.alili.tech\/img\/bVEybU?w=658\x26amp;h=245\x22 alt=\x22aaa\x22 title=\x22aaa\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e这里面服务端会传过来一个context对象，可以从获取信息，也可以写入信息，可以看到将现有的vuex state赋值给context，给服务端渲染使用，最后返回vue对象(文档中写着需要返回一个Promise对象，对象中再返回一个vue对象，经过实验直接返回也是可以的，如果应用中存在异步操作会影响视图和vuex数据状态，那么应该返回一个Promise对象，使得服务端得到的vue对象是最后数据和视图同步统一的)\x3c\/p\x3e\n\x3cp\x3e代码撸完了，下面要让他跑起来了，配置分为两部分，一个是webpack打包的配置，一个是服务端渲染服务器的搭建，这里使用express进行服务器的简单搭建，不涉及任何负载均衡和性能优化问题，下面分别说说这两个部分 :\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3ewebpack打包：webpack打包主要有三个文件\x3ccode\x3ewebpack.base.config.js\x3c\/code\x3e,\x3ccode\x3ewebpack.client.config.js\x3c\/code\x3e,\x3ccode\x3ewebpack.server.cofnig.js\x3c\/code\x3e,其中\x3ccode\x3ebase\x3c\/code\x3e主要配置了对应文件类型的loader，还有指定了entry的切割点，将业务代码和库，\x3ccode\x3eclient\x3c\/code\x3e指定了\x3ccode\x3eclient-entry.js\x3c\/code\x3e作为entry point ，还将库文件和业务文件进行分别打包，还有一些图片处理，代码压缩的工作。\x3ccode\x3eserver\x3c\/code\x3e指定了\x3ccode\x3eserver-entry.js\x3c\/code\x3e作为entry point,并且指定了打包了类型标准是\x3ccode\x3ecommonjs2\x3c\/code\x3e，供服务端渲染模块使用。\x3c\/li\x3e\n\x3cli\x3e而在开发过程中，可以使用\x3ccode\x3ewebpack-hot-middleware\/client\x3c\/code\x3e,\x3ccode\x3ewebpack-hot-middleware\x3c\/code\x3e去实现代码的watch和重新构建双端的代码的流程，是得开发更加便捷，具体配置在\x3ccode\x3esetup-dev-server.js\x3c\/code\x3e中\x3c\/li\x3e\n\x3cli\x3e最后说一下服务端渲染的服务器配置，服务端部分使用\x3ccode\x3evue-server-renderer\x3c\/code\x3e模块的\x3ccode\x3ecreateBundleRenderer\x3c\/code\x3e通过传入刚才webpack生成的\x3ccode\x3eserver-bundler\x3c\/code\x3e去生成一个\x3ccode\x3ebundleRenderer\x3c\/code\x3e,就可以调用\x3ccode\x3erenderToStream\x3c\/code\x3e或者\x3ccode\x3erenderToString\x3c\/code\x3e渲染页面了，具体配置在\x3ccode\x3eserver.js\x3c\/code\x3e中\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e具体怎么跑起项目可以看下\x3ccode\x3epackage.json\x3c\/code\x3e的scripts属性，其中\x3ccode\x3edev\x3c\/code\x3e是开发用，\x3ccode\x3estart\x3c\/code\x3e是正式环境动态生成页面用，\x3ccode\x3ebuild\x3c\/code\x3e可以直接生成\x3ccode\x3eclient-bundler\x3c\/code\x3e和\x3ccode\x3eserver-bundler\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e基本上比较完整的vue2 前段端同构渲染已经介绍完了，下面说下我对框架的看法，前端框架这个东西基本上就是一时火一个，我们在学习新东西的同时也应该不忘老本，要有自己的技术栈和工作流，就像《人月神话》中的一句话说的好，\x3cstrong\x3e没有解决任何事情的银弹\x3c\/strong\x3e，对于不同的项目，不同的业务情景，应该采取不同的框架，使用最合适的开发架构去开发。\x3c\/p\x3e\n\x3cp\x3e附上代码 \x3ca href=\x22https:\/\/github.com\/qbright\/vue2_vuex2_webpack2_ssr\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e点我点我\x3c\/a\x3e，给个star呗~\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e最后也没啥好说的了，要不给大家拜个早年吧，祝大家代码没bug，哈哈\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>无痛学会各种 2 的 Vue2+Vuex2+Webpack2 前后端同构渲染</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000007244289">https://segmentfault.com/a/1190000007244289</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/4lttzgtfghn/" target="_blank">https://alili.tech/archive/4lttzgtfghn/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>