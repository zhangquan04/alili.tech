<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="Angular 开发者常犯的错误"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>Angular 开发者常犯的错误 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/fd5iyba4a4u/",
				"appid": "1613049289050283", 
				"title": "Angular 开发者常犯的错误 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-06T02:30:10"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/87mbez8d2ry/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/1x5dijwdrnk/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2ffd5iyba4a4u%2f&text=Angular%20%e5%bc%80%e5%8f%91%e8%80%85%e5%b8%b8%e7%8a%af%e7%9a%84%e9%94%99%e8%af%af"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2ffd5iyba4a4u%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2ffd5iyba4a4u%2f&text=Angular%20%e5%bc%80%e5%8f%91%e8%80%85%e5%b8%b8%e7%8a%af%e7%9a%84%e9%94%99%e8%af%af"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2ffd5iyba4a4u%2f&title=Angular%20%e5%bc%80%e5%8f%91%e8%80%85%e5%b8%b8%e7%8a%af%e7%9a%84%e9%94%99%e8%af%af"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2ffd5iyba4a4u%2f&is_video=false&description=Angular%20%e5%bc%80%e5%8f%91%e8%80%85%e5%b8%b8%e7%8a%af%e7%9a%84%e9%94%99%e8%af%af"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=Angular%20%e5%bc%80%e5%8f%91%e8%80%85%e5%b8%b8%e7%8a%af%e7%9a%84%e9%94%99%e8%af%af&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2ffd5iyba4a4u%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2ffd5iyba4a4u%2f&title=Angular%20%e5%bc%80%e5%8f%91%e8%80%85%e5%b8%b8%e7%8a%af%e7%9a%84%e9%94%99%e8%af%af"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2ffd5iyba4a4u%2f&title=Angular%20%e5%bc%80%e5%8f%91%e8%80%85%e5%b8%b8%e7%8a%af%e7%9a%84%e9%94%99%e8%af%af"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2ffd5iyba4a4u%2f&title=Angular%20%e5%bc%80%e5%8f%91%e8%80%85%e5%b8%b8%e7%8a%af%e7%9a%84%e9%94%99%e8%af%af"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2ffd5iyba4a4u%2f&title=Angular%20%e5%bc%80%e5%8f%91%e8%80%85%e5%b8%b8%e7%8a%af%e7%9a%84%e9%94%99%e8%af%af"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">Angular 开发者常犯的错误</h1><div class="meta"><div class="postdate"><time datetime="2019-01-06" itemprop="datePublished">2019-01-06</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e阅读 Angular 6\/RxJS 最新教程，请访问\x3ca href=\x22http:\/\/www.semlinker.com\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e前端修仙之路\x3c\/a\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e本文基于 \x3ca href=\x22https:\/\/hackernoon.com\/top-common-mistakes-of-angular-developers-2a36524f2c21\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eTop Common Mistakes of Angular Developers\x3c\/a\x3e  这篇文章的内容进行整理和扩展，建议有兴趣的读者直接阅读原文。如果你刚接触 Angular，也可以参考一下 \x3ca href=\x22https:\/\/github.com\/semlinker\/angular-faq\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eAngular 常见问题汇总\x3c\/a\x3e 这篇文章。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader0\x22\x3eAngular vs Angular 2 vs Angular 4\x3c\/h3\x3e\n\x3cp\x3eAngular 1.x 版本统称为 AngularJS，Angular 2\x2b (4\/5) 统称为 Angular。\x3c\/p\x3e\n\x3cp\x3e第三方库的命名也有一定的规则。假设早期版本的命名以 \x3ccode\x3eng-\x3c\/code\x3e 作为前缀，当 Angular 2 发布后，该库名称会使用 \x3ccode\x3eng2-\x3c\/code\x3e 作为前缀。但当 Angular 4 发布以后，新的命名规则就随之出现了。新的术语是使用 \x3ccode\x3engx-\x3c\/code\x3e 作为前缀，因为 Angular 使用语义版本，每六个月会发布一个新版本。因此，举个例子，当我们把 \x3ccode\x3eng2-bootstrap\x3c\/code\x3e 更名为 \x3ccode\x3engx-bootstrap\x3c\/code\x3e 后，今后就不需要再频繁更换库的名称了。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3engOnChanges vs ngDoCheck\x3c\/h3\x3e\n\x3cp\x3eAngularJS 使用 \x3ccode\x3ewatcher\x3c\/code\x3e 和 \x3ccode\x3elistener\x3c\/code\x3e 的概念。watcher 是一个函数，返回被监测的值。通常情况下，这些值是对象模型的属性值。但也不总是数据模型的属性 - 我们可以跟踪组件的状态、计算新值等。如果该函数返回的值与前一次的值不一样，Angular 就会调用 \x3ccode\x3elistener\x3c\/code\x3e，通常它用来更新 UI 状态。\x3c\/p\x3e\n\x3cp\x3eAngular 移除了 \x3ccode\x3ewatch\x3c\/code\x3e 和 \x3ccode\x3escope\x3c\/code\x3e，现在我们将使用组件的输入属性。除此之外，Angular 为我们提供了 \x3ccode\x3engOnChanges\x3c\/code\x3e 生命周期钩子。为了提高变化检测的性能，对于对象比较，Angular 内部直接使用 \x3ccode\x3e===\x3c\/code\x3e 运算符进行值比较。因此当输入属性是引用类型，当改变对象内部属性时，是不会调用 \x3ccode\x3engOnChanges\x3c\/code\x3e 生命周期钩子的。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ JS has NaN !== NaN\nexport function looseIdentical(a: any, b: any): boolean {\n  return a === b || typeof a === \x27number\x27 \x26amp;\x26amp; typeof b === \x27number\x27\n    \x26amp;\x26amp; isNaN(a) \x26amp;\x26amp; isNaN(b);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ JS has NaN !== NaN\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3elooseIdentical\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ea: any, b: any\x3c\/span\x3e): \x3cspan class=\x22hljs-title\x22\x3eboolean\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e a === b || \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e a === \x3cspan class=\x22hljs-string\x22\x3e\x27number\x27\x3c\/span\x3e \x26amp;\x26amp; \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e b === \x3cspan class=\x22hljs-string\x22\x3e\x27number\x27\x3c\/span\x3e\n    \x26amp;\x26amp; \x3cspan class=\x22hljs-built_in\x22\x3eisNaN\x3c\/span\x3e(a) \x26amp;\x26amp; \x3cspan class=\x22hljs-built_in\x22\x3eisNaN\x3c\/span\x3e(b);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e许多开发人员不知道这一点，陷入这个陷阱。为了解决这个问题，有各种解决方案：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e使用 \x3ccode\x3engDoCheck\x3c\/code\x3e 生命周期钩子\x3c\/li\x3e\n\x3cli\x3e使用不可变的数据结构\x3c\/li\x3e\n\x3cli\x3e把输入对象拆分为多个输入 (即不是直接传递引用对象，而是把内部属性抽离成独立的字段)\x3c\/li\x3e\n\x3cli\x3e使用 \x3ccode\x3esubscriptions\x3c\/code\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e使用 \x3ccode\x3engDoCheck\x3c\/code\x3e 生命周期挂钩是解决此问题的常用方法。当变化检测运行时会自动调用此钩子。在使用此生命周期钩子时，你要小心控制该钩子的内部逻辑，因为通常每分钟会触发多次变化检测 (可以参考下面的源码)。\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3ccode\x3engStyle\x3c\/code\x3e 指令内部也实现了 \x3ccode\x3eDoCheck\x3c\/code\x3e 接口，然后利用 \x3ccode\x3eKeyValueDiffer\x3c\/code\x3e 对象来检测对象的变化 (如内部属性的新增、修改、移除操作)。\x3c\/blockquote\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ packages\/core\/src\/view\/provider.ts\n\/\/ 变化检测: \n\/\/ checkAndUpdateView -\x3e Services.updateDirectives(view, CheckType.CheckAndUpdate)\nfunction checkAndUpdateDirectiveInline(\n    view: ViewData, \n    def: NodeDef, \n    v0: any, v1: any, v2: any,\n    v3: any, v4: any, v5: any, \n    v6: any, v7: any, v8: any, \n    v9: any): boolean {\n  const providerData = asProviderData(view, def.index);\n  const directive = providerData.instance;\n  let changed = false;\n  let changes: SimpleChanges = undefined !;\n  const bindLen = def.bindings.length;\n  \/\/ 判断输入属性值是否改变，若发生改变则更新changes对象相应的属性。 \n  if (bindLen \x3e 0 \x26amp;\x26amp; checkBinding(view, def, 0, v0)) {\n    changed = true;\n    changes = updateProp(view, providerData, def, 0, v0, changes);\n  }\n  \/\/ ...\n  if (bindLen \x3e 9 \x26amp;\x26amp; checkBinding(view, def, 9, v9)) {\n    changed = true;\n    changes = updateProp(view, providerData, def, 9, v9, changes);\n  }\n  \/\/ 若输入属性发生变化才会调用ngOnChanges生命周期钩子\n  if (changes) {\n    directive.ngOnChanges(changes);\n  }\n  \/\/ 若首次执行变化检测及实现OnInit生命周期钩子，则调用ngOnInit生命周期钩子 \n  if ((view.state \x26amp; ViewState.FirstCheck) \x26amp;\x26amp; (def.flags \x26amp; NodeFlags.OnInit)) {\n    directive.ngOnInit();\n  }\n  \/\/ 若实现DoCheck接口，则调用ngDoCheck生命周期钩子\n  if (def.flags \x26amp; NodeFlags.DoCheck) {\n    directive.ngDoCheck();\n  }\n  return changed; \/\/ 返回SimpleChanges对象\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ packages\/core\/src\/view\/provider.ts\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 变化检测: \x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ checkAndUpdateView -\x26gt; Services.updateDirectives(view, CheckType.CheckAndUpdate)\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3echeckAndUpdateDirectiveInline\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\n    view: ViewData, \n    def: NodeDef, \n    v0: \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e, v1: \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e, v2: \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e,\n    v3: \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e, v4: \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e, v5: \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e, \n    v6: \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e, v7: \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e, v8: \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e, \n    v9: \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e\x3c\/span\x3e): \x3cspan class=\x22hljs-title\x22\x3eboolean\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e providerData = asProviderData(view, def.index);\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e directive = providerData.instance;\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e changed = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e changes: SimpleChanges = \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e !;\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e bindLen = def.bindings.length;\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 判断输入属性值是否改变，若发生改变则更新changes对象相应的属性。 \x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (bindLen \x26gt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e \x26amp;\x26amp; checkBinding(view, def, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, v0)) {\n    changed = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n    changes = updateProp(view, providerData, def, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, v0, changes);\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (bindLen \x26gt; \x3cspan class=\x22hljs-number\x22\x3e9\x3c\/span\x3e \x26amp;\x26amp; checkBinding(view, def, \x3cspan class=\x22hljs-number\x22\x3e9\x3c\/span\x3e, v9)) {\n    changed = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n    changes = updateProp(view, providerData, def, \x3cspan class=\x22hljs-number\x22\x3e9\x3c\/span\x3e, v9, changes);\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 若输入属性发生变化才会调用ngOnChanges生命周期钩子\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (changes) {\n    directive.ngOnChanges(changes);\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 若首次执行变化检测及实现OnInit生命周期钩子，则调用ngOnInit生命周期钩子 \x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ((view.state \x26amp; ViewState.FirstCheck) \x26amp;\x26amp; (def.flags \x26amp; NodeFlags.OnInit)) {\n    directive.ngOnInit();\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 若实现DoCheck接口，则调用ngDoCheck生命周期钩子\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (def.flags \x26amp; NodeFlags.DoCheck) {\n    directive.ngDoCheck();\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e changed; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 返回SimpleChanges对象\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e未及时释放资源\x3c\/h3\x3e\n\x3cp\x3e你可能知道当你订阅 Observable 对象或设置事件监听时，在某个时间点，你需要执行取消订阅操作，进而释放操作系统的内存。否则，你的应用程序可能会出现内存泄露。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22@Component({ ... })\nexport class HeroComponent implements OnInit, OnDestroy {\n  heroForm: FormGroup;\n  valueChanges$: Observable;\n\n  ngOnInit() {\n    this.valueChanges$ = this.heroForm.valueChanges.subscribe(...);\n  }\n\n  ngOnDestroy() {\n    this.valueChanges$.unsubscribe();\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3e@Component\x3c\/span\x3e({ ... })\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e HeroComponent \x3cspan class=\x22hljs-keyword\x22\x3eimplements\x3c\/span\x3e OnInit, OnDestroy {\n  heroForm: FormGroup;\n  valueChanges$: Observable;\n\n  ngOnInit() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.valueChanges$ = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.heroForm.valueChanges.subscribe(...);\n  }\n\n  ngOnDestroy() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.valueChanges$.unsubscribe();\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e大多数情况下，当你在组件类中执行订阅操作，你可以在 \x3ccode\x3engOnDestroy\x3c\/code\x3e 生命周期钩子中，执行取消订阅的操作。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e额外取消订阅操作\x3c\/h3\x3e\n\x3cp\x3e上面介绍了在某些场景下需要手动执行取消订阅操作，进而释放相应的资源。但有些场景下，无需我们开发者手动执行额外的取消订阅操作。因为在这些场景下，Angular 内部会自动执行取消订阅操作。比如，使用 \x3ccode\x3easync\x3c\/code\x3e 的场景：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22@Component({\n  selector: \x27heroes-garden\x27,\n  template: `\x3chero [hero]=\x26quot;heroes$ | async\x26quot;\x3e\x3c\/todos\x3e`\n})\nexport class HeroesGardenComponent implements OnInit, OnDestroy {\n  heroesChanged$: Observable;\n\n  ngOnInit() {\n    this.heroesChanged$ = this.store.select(\x27heroes\x27);\n  }\n\n  ngOnDestroy() {\n    this.heroesChanged$.unsubscribe();\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3e@Component\x3c\/span\x3e({\n  selector: \x3cspan class=\x22hljs-string\x22\x3e\x27heroes-garden\x27\x3c\/span\x3e,\n  template: \x3cspan class=\x22hljs-string\x22\x3e`\x26lt;hero [hero]=\x22heroes$ | async\x22\x26gt;\x26lt;\/todos\x26gt;`\x3c\/span\x3e\n})\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e HeroesGardenComponent \x3cspan class=\x22hljs-keyword\x22\x3eimplements\x3c\/span\x3e OnInit, OnDestroy {\n  heroesChanged$: Observable;\n\n  ngOnInit() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.heroesChanged$ = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.store.select(\x3cspan class=\x22hljs-string\x22\x3e\x27heroes\x27\x3c\/span\x3e);\n  }\n\n  ngOnDestroy() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.heroesChanged$.unsubscribe();\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e除了使用 \x3ccode\x3easync\x3c\/code\x3e 的场景外，还有以下场景会自动取消订阅：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eObserver.timer(1000).subscribe(...)\x3c\/li\x3e\n\x3cli\x3ehttp.get(\x27\x3ca href=\x22https:\/\/segmentfault.com\/u\/\x22\x3ehttps:\/\/segmentfault.com\/u\/\x3c\/a\x3e\x27).subscribe(...)\x3c\/li\x3e\n\x3cli\x3eRxJS 中的 take()、takeWhile()、first() 等操作符\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e若想进一步了解手动释放资源和自动释放资源的场景，可以参考专栏 \x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000010104703\x22 target=\x22_blank\x22\x3eAngular 中何时取消订阅\x3c\/a\x3e 这篇文章。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e@Component.providers vs @NgModule.providers\x3c\/h3\x3e\n\x3cp\x3e分层依赖注入作为 Angular 的新机制的一部分，让我们可以灵活地控制依赖注入。在 AngularJS 中，服务都是单例的，而 Angular 2.x 以上的版本，我们可以多次实例化一个服务。\x3c\/p\x3e\n\x3cp\x3e假设我们已经定义了一个 \x3ccode\x3eHeroesService\x3c\/code\x3e 服务，用来获取英雄信息：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22@Injectable()\nexport class HeroesService {\n  heroes: Hero[] = [];\n  \n  constructor(private http: Http) {\n    this.http.get(\x27http:\/\/give-me-heroes.com\x27)\n      .map(res =\x3e res.json())\n      .subscribe((heroes: Hero[]) =\x3e {\n         this.heroes = heroes;\n    });\n  }\n\n  getHeroes() {\n    return this.heroes;\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3e@Injectable\x3c\/span\x3e()\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e HeroesService {\n  heroes: Hero[] = [];\n  \n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eprivate\x3c\/span\x3e http: Http\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.http.get(\x3cspan class=\x22hljs-string\x22\x3e\x27http:\/\/give-me-heroes.com\x27\x3c\/span\x3e)\n      .map(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eres\x3c\/span\x3e =\x26gt;\x3c\/span\x3e res.json())\n      .subscribe(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eheroes: Hero[]\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n         \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.heroes = heroes;\n    });\n  }\n\n  getHeroes() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.heroes;\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e正如你所见，我们在构造函数中获取英雄的数据，此外我们定义了 \x3ccode\x3egetHeroes()\x3c\/code\x3e 方法，用来获取英雄信息。\x3c\/p\x3e\n\x3cp\x3e现在我们来使用刚创建的 \x3ccode\x3eHeroesService\x3c\/code\x3e 服务：\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e在组件中声明服务\x3c\/li\x3e\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22@Component({\n  selector: \x27hero\x27,\n  template: \x27...\x27,\n  providers: [HeroesService]\n})\nexport class HeroComponent {\n  constructor(private heroesService: HeroesService) {}\n}\n\n@NgModule({\n  declarations: [HeroComponent]\n}\nexport class HeroesModule { ... }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3e@Component\x3c\/span\x3e({\n  selector: \x3cspan class=\x22hljs-string\x22\x3e\x27hero\x27\x3c\/span\x3e,\n  template: \x3cspan class=\x22hljs-string\x22\x3e\x27...\x27\x3c\/span\x3e,\n  providers: [HeroesService]\n})\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e HeroComponent {\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eprivate\x3c\/span\x3e heroesService: HeroesService\x3c\/span\x3e) {}\n}\n\n\x3cspan class=\x22hljs-meta\x22\x3e@NgModule\x3c\/span\x3e({\n  declarations: [HeroComponent]\n}\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e HeroesModule { ... }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在 \x3ccode\x3eHeroComponent \x3c\/code\x3e 中，我们在 \x3ccode\x3e@Component.providers\x3c\/code\x3e 数组中声明 \x3ccode\x3eHeroesService\x3c\/code\x3e 服务，然后在 \x3ccode\x3eHeroComponent\x3c\/code\x3e 组件类的构造函数中注入该服务。使用这种方式会有问题，每当实例化新的 \x3ccode\x3eHeroComponent\x3c\/code\x3e 组件时，都会创建一个新的 \x3ccode\x3eHeroService\x3c\/code\x3e 实例，这会导致发送多次 Http 请求。\x3c\/p\x3e\n\x3cp\x3e解决上述问题的一种方案是在 \x3ccode\x3e@NgModule.providers\x3c\/code\x3e 中声明服务。\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e在模块中声明服务\x3c\/li\x3e\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22@Component({\n  selector: \x27hero\x27,\n  template: \x27...\x27\n})\nexport class HeroComponent {\n  constructor(private heroesService: HeroesService) {}\n}\n\n@NgModule({\n  declarations: [HeroComponent],\n  providers: [HeroesService]\n}\nexport class HeroesModule { ... }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3e@Component\x3c\/span\x3e({\n  selector: \x3cspan class=\x22hljs-string\x22\x3e\x27hero\x27\x3c\/span\x3e,\n  template: \x3cspan class=\x22hljs-string\x22\x3e\x27...\x27\x3c\/span\x3e\n})\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e HeroComponent {\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eprivate\x3c\/span\x3e heroesService: HeroesService\x3c\/span\x3e) {}\n}\n\n\x3cspan class=\x22hljs-meta\x22\x3e@NgModule\x3c\/span\x3e({\n  declarations: [HeroComponent],\n  providers: [HeroesService]\n}\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e HeroesModule { ... }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e采用这种方式的话，对于多个 \x3ccode\x3eHeroComponent\x3c\/code\x3e 组件，\x3ccode\x3eHeroesService\x3c\/code\x3e 服务只会被实例化一次。因为，当在模块中声明 \x3ccode\x3eprovider\x3c\/code\x3e ，它所相关的依赖对象，将是单例的，其它的模块都能够使用它。我们不需要通过 \x3ccode\x3e@NgModule.exports\x3c\/code\x3e 数组来导出对应的 \x3ccode\x3eprovider\x3c\/code\x3e，它会被自动导出。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e直接操作 DOM\x3c\/h3\x3e\n\x3cp\x3eAngular 不再是简单的 Web 框架，Angular 是一个平台，它的一个优点是允许我们将应用程序代码与渲染器分离，从而编写可以在浏览器、服务器上运行的应用程序，甚至可以编写原生应用。\x3c\/p\x3e\n\x3cp\x3e此外解耦后，也为我们提供更多的能力，如使用 AOT (Ahead of time) 或 Web Worker。AOT 意味着在构建阶段进行模板编译，AOT 编译模式的开发流程：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e使用 TypeScript 开发 Angular 应用\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e运行 ngc 编译应用程序\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e使用 Angular Compiler 编译模板，一般输出 TypeScript 代码\x3c\/li\x3e\n\x3cli\x3e运行 tsc 编译 TypeScript 代码\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e使用 Webpack 或 Gulp 等其他工具构建项目，如代码压缩、合并等\x3c\/li\x3e\n\x3cli\x3e部署应用\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e除此之外 AOT 还有以下优点：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e在客户端我们不需要导入体积庞大的 angular 编译器，这样可以减少我们 JavaScript 脚本库的大小\x3c\/li\x3e\n\x3cli\x3e使用 AOT 编译后的应用，不再包含任何 HTML 片段，取而代之的是编译生成的 TypeScript 代码，这样的话 TypeScript 编译器就能提前发现错误。总而言之，采用 AOT 编译模式，我们的模板是类型安全的。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e如果我们现在或将来要使用这种功能，我们需要遵守一定的规则。其中一个规则是不能使用 jQuery，document 对象或 ElementRef.nativeElement 来直接操作 DOM。具体示例如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22@Component({ ... })\nexport class HeroComponent {\n  constructor(private _elementRef: ElementRef) {}\n\n  doBadThings() {\n    $(\x27.bad-with-jquery\x27).click();\n    this._elementRef.nativeElement.xyz = \x27bad with native element\x27;\n    document.getElementById(\x27bad-with-document\x27);\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3e@Component\x3c\/span\x3e({ ... })\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e HeroComponent {\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eprivate\x3c\/span\x3e _elementRef: ElementRef\x3c\/span\x3e) {}\n\n  doBadThings() {\n    $(\x3cspan class=\x22hljs-string\x22\x3e\x27.bad-with-jquery\x27\x3c\/span\x3e).click();\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._elementRef.nativeElement.xyz = \x3cspan class=\x22hljs-string\x22\x3e\x27bad with native element\x27\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.getElementById(\x3cspan class=\x22hljs-string\x22\x3e\x27bad-with-document\x27\x3c\/span\x3e);\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如你所见，\x3ccode\x3edoBadThings()\x3c\/code\x3e 方法中有三行代码，这三行代码演示了直接操作 DOM 的三种方式。在 Angular 中我们推荐通过 \x3ccode\x3eRenderer2\x3c\/code\x3e 服务执行 DOM 操作 (Angular 2 中使用 Renderer)。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22@Component({ ... })\nexport class HeroComponent {\n  constructor(\n    private _renderer2: Renderer2,\n    private _elementRef: ElementRef) {}\n\n  doGoodThings() {\n    this._renderer2.setElementProperty(this._elementRef,\n      \x27some-property\x27, true);\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3e@Component\x3c\/span\x3e({ ... })\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e HeroComponent {\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eprivate\x3c\/span\x3e _renderer2: Renderer2,\n    \x3cspan class=\x22hljs-keyword\x22\x3eprivate\x3c\/span\x3e _elementRef: ElementRef\x3c\/span\x3e) {}\n\n  doGoodThings() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._renderer2.setElementProperty(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._elementRef,\n      \x3cspan class=\x22hljs-string\x22\x3e\x27some-property\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e);\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面代码中，我们通过依赖注入方式注入 \x3ccode\x3eRenderer2\x3c\/code\x3e 和 \x3ccode\x3eElementRef\x3c\/code\x3e 实例，然后在 \x3ccode\x3edoGoodThings()\x3c\/code\x3e 方法中调用 \x3ccode\x3eRenderer2\x3c\/code\x3e 实例提供的 \x3ccode\x3esetElementProperty()\x3c\/code\x3e 方法来设置元素的属性。 此外，为了方便开发者获取视图中的元素，Angular 为我们提供了 \x3ccode\x3e@ViewChild\x3c\/code\x3e、\x3ccode\x3e@ViewChildren\x3c\/code\x3e、\x3ccode\x3e@ContentChild\x3c\/code\x3e 和 \x3ccode\x3e@ContentChildren\x3c\/code\x3e 等装饰器。\x3c\/p\x3e\n\x3cp\x3e渲染器是视图层的封装。当我们在浏览器中时，将使用默认渲染器。当应用程序在不同平台 (如 WebWorker ) 上运行时，渲染器将被替换为平台对应的渲染器。此渲染器需要实现 \x3ccode\x3eRenderer2\x3c\/code\x3e 抽象类，并利用 DI (依赖注入) 机制作为默认的 Renderer 对象注入到组件或服务中。\x3c\/p\x3e\n\x3cp\x3e若想深入了解 Angular 渲染器，可以参考专栏 \x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000010326100\x22\x3eAngular Renderer (渲染器)\x3c\/a\x3e 这篇文章。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e多次声明同一个组件\x3c\/h3\x3e\n\x3cp\x3e组件是 Angular 应用程序中的常见构建块。每个组件都需要在 \x3ccode\x3e@NgModule.declarations\x3c\/code\x3e 数组中声明，才能够使用。\x3c\/p\x3e\n\x3cp\x3e在 Angular 中是不允许在多个模块中声明同一个组件，如果一个组件在多个模块中声明的话，那么 Angular 编译器将会抛出异常。例如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22@Component({\n  selector: \x27hero\x27,\n  template: \x27...\x27,\n})\nexport class HeroComponent { ... }\n\n@NgModule({\n  declarations: [HeroComponent]\n}\nexport class HeroesModule { ... }\n\n@NgModule({\n  declarations: [HeroComponent]\n}\nexport class AnotherModule { ... }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3e@Component\x3c\/span\x3e({\n  selector: \x3cspan class=\x22hljs-string\x22\x3e\x27hero\x27\x3c\/span\x3e,\n  template: \x3cspan class=\x22hljs-string\x22\x3e\x27...\x27\x3c\/span\x3e,\n})\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e HeroComponent { ... }\n\n\x3cspan class=\x22hljs-meta\x22\x3e@NgModule\x3c\/span\x3e({\n  declarations: [HeroComponent]\n}\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e HeroesModule { ... }\n\n\x3cspan class=\x22hljs-meta\x22\x3e@NgModule\x3c\/span\x3e({\n  declarations: [HeroComponent]\n}\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e AnotherModule { ... }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如你所见，\x3ccode\x3eHeroComponent\x3c\/code\x3e 组件在 HeroesModule 以及 AnotherModule 中进行声明。在多个模块中使用同一个组件是允许的。但当这种情况发生时，我们应该考虑模块之间的关系是什么。如果一个模块作为另一个模块的子模块，那么针对上面的场景解决方案将是：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e在子模块的 \x3ccode\x3e@NgModule.declaration\x3c\/code\x3e 中声明 \x3ccode\x3eHeroComponent\x3c\/code\x3e 组件\x3c\/li\x3e\n\x3cli\x3e通过子模块的 \x3ccode\x3e@NgModule.exports\x3c\/code\x3e 数组中导出该组件\x3c\/li\x3e\n\x3cli\x3e在父模块的 \x3ccode\x3e@NgModule.imports\x3c\/code\x3e 数组中导入子模块\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e而对于其它情况，我们可以创建一个新的模块，如 \x3ccode\x3eSharedModule\x3c\/code\x3e  模块。具体步骤如下：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e在 SharedModule 中声明和导出 HeroComponent\x3c\/li\x3e\n\x3cli\x3e在需要使用 HeroComponent 的模块中导入 SharedModule\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22NgModule({\n  declarations: [HeroComponent],\n  exports: [HeroComponent]\n}\nexport class SharedModule { ... }\n\nNgModule({\n  imports: [SharedModule]\n}\nexport class HeroesModule { ... }\n\n@NgModule({\n  imports: [SharedModule]\n}\nexport class AnotherModule { ... }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3eNgModule({\n  declarations: [HeroComponent],\n  exports: [HeroComponent]\n}\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e SharedModule { ... }\n\nNgModule({\n  imports: [SharedModule]\n}\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e HeroesModule { ... }\n\n\x3cspan class=\x22hljs-meta\x22\x3e@NgModule\x3c\/span\x3e({\n  imports: [SharedModule]\n}\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e AnotherModule { ... }\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3e参考资源\x3c\/h2\x3e\n\x3cul\x3e\x3cli\x3e\x3ca href=\x22https:\/\/hackernoon.com\/top-common-mistakes-of-angular-developers-2a36524f2c21\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3etop-common-mistakes-of-angular-developers\x3c\/a\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>Angular 开发者常犯的错误</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000010438679">https://segmentfault.com/a/1190000010438679</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/fd5iyba4a4u/" target="_blank">https://alili.tech/archive/fd5iyba4a4u/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>