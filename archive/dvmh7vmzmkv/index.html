<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="Announcing TypeScript 2.8"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>Announcing TypeScript 2.8 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/dvmh7vmzmkv/",
				"appid": "1613049289050283", 
				"title": "Announcing TypeScript 2.8 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-20T02:30:11"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/17zeizkggnl/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/hsrdqx00qrt/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fdvmh7vmzmkv%2f&text=Announcing%20TypeScript%202.8"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fdvmh7vmzmkv%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fdvmh7vmzmkv%2f&text=Announcing%20TypeScript%202.8"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fdvmh7vmzmkv%2f&title=Announcing%20TypeScript%202.8"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fdvmh7vmzmkv%2f&is_video=false&description=Announcing%20TypeScript%202.8"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=Announcing%20TypeScript%202.8&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fdvmh7vmzmkv%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fdvmh7vmzmkv%2f&title=Announcing%20TypeScript%202.8"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fdvmh7vmzmkv%2f&title=Announcing%20TypeScript%202.8"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fdvmh7vmzmkv%2f&title=Announcing%20TypeScript%202.8"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fdvmh7vmzmkv%2f&title=Announcing%20TypeScript%202.8"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">Announcing TypeScript 2.8</h1><div class="meta"><div class="postdate"><time datetime="2019-01-20" itemprop="datePublished">2019-01-20</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n            \x3cp\x3eTypeScript 2.8 在这里，我们带来一些你会十分喜爱的功能!\x3c\/p\x3e\n\x3cp\x3e你熟悉 TypeScript 吗？ 它是一种将可选的静态类型添加到JavaScript的语言。\n这些静态类型会让你的代码不犯拼写错误以及其他的愚蠢错误。\n基于围绕这些类型所构建的组件，还可以实现代码自动补全和项目索引等更多美妙的功能。\n把你的代码交给 TypeScript 编译器运行后，将只剩下清晰，可读性强且符合标准的JavaScript代码。\n也可以将你的代码重写为大部分仅支持 es5 甚至 es3 旧版浏览器所能运行的代码。想要了解 TypeScript 的更多相关信息 , \x3ca href=\x22https:\/\/www.typescriptlang.org\/docs\/home.html\x22\x3e请查看我们的文档\x3c\/a\x3e.\x3c\/p\x3e\n\x3cp\x3e如果你现在急不可待，你可以通过 \x3ca href=\x22https:\/\/www.nuget.org\/packages\/Microsoft.TypeScript.MSBuild\x22\x3eNuGet\x3c\/a\x3e 下载或者运行以下指令：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs cmake\x22\x3enpm \x3cspan class=\x22hljs-keyword\x22\x3einstall\x3c\/span\x3e -g typescript\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e你能获得以下编辑器支持：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/gist.github.com\/DanielRosenwasser\/download.microsoft.com\/download\/6\/D\/8\/6D8381B0-03C1-4BD2-AE65-30FF0A4C62DA\/2.8.1-TS-release-dev14update3-20180323.2\/TypeScript_Dev14Full.exe\x22\x3eVisual Studio 2015\x3c\/a\x3e (requires update 3)\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22http:\/\/download.microsoft.com\/download\/7\/0\/A\/70A6AC0E-8934-4396-A43E-445059F430EA\/2.8.1-TS-release-dev14update3-20180323.2\/TypeScript_SDK.exe\x22\x3eVisual Studio 2017\x3c\/a\x3e (requires 15.2 or later)\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/packagecontrol.io\/packages\/TypeScript\x22\x3eSublime Text 3 via PackageControl\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3eVisual Studio Code with the next release, or \x3ca href=\x22https:\/\/code.visualstudio.com\/Docs\/languages\/typescript#_using-newer-typescript-versions\x22\x3eby following instructions here\x3c\/a\x3e.\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e对 \x3ca href=\x22https:\/\/github.com\/Microsoft\/TypeScript\/wiki\/TypeScript-Editor-Support\x22\x3e其他编辑器\x3c\/a\x3e 的支持更新时间可能会不同， 但会尽快提供。\x3c\/p\x3e\n\x3cp\x3e为了快速浏览我们在此版本中发布的内容，我们将其组合成列表放在一起便于浏览:\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/blogs.msdn.microsoft.com\/#conditional-types\x22\x3eConditional types\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/blogs.msdn.microsoft.com\/#declaration-only-emit\x22\x3eDeclaration-only emit\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/blogs.msdn.microsoft.com\/#jsx-pragma-comments\x22\x3e\x3ccode\x3e@jsx\x3c\/code\x3e pragma comments\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/blogs.msdn.microsoft.com\/#jsx-namespace-resolution\x22\x3e\x3ccode\x3eJSX\x3c\/code\x3e now resolved within factory functions\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/blogs.msdn.microsoft.com\/#granular-control-mapped-type-modifiers\x22\x3eGranular control on mapped type modifiers\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/blogs.msdn.microsoft.com\/#organize-imports\x22\x3eOrganize imports\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/blogs.msdn.microsoft.com\/#uninitialized-properties\x22\x3eFixing uninitialized properties\x3c\/a\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e如果你升级版本，你需要记住一些细微部分的 \x3ca href=\x22https:\/\/gist.github.com\/DanielRosenwasser\/6f1913483c5699155ad0777dc37a59b1#breaking-changes\x22\x3e调整\x3c\/a\x3e .\x3c\/p\x3e\n\x3cp\x3e除此之外，让我们来看看 TypeScript 2.8带来的新功能吧！!\x3c\/p\x3e\n\x3ch2\x3e条件类型 （Conditional types）\x3c\/h2\x3e\n\x3cp\x3e条件类型是 TypeScript 中的一个新构造，它允许我们根据其他类型来选择类型。\n它们的表现形式是：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs groovy\x22\x3eA \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e B ? C : D\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e其中a，b，c和d是所有类型。\n你应将其看作 \x22 当类型a可赋值给b时，那么这种类型是c;\n否则，它是d。\x22\n如果你曾在JavaScript中使用过条件语法，你将会感到很熟悉。\x3c\/p\x3e\n\x3cp\x3e我们举两个具体的例子：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs typescript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3einterface\x3c\/span\x3e Animal {\n    live(): \x3cspan class=\x22hljs-built_in\x22\x3evoid\x3c\/span\x3e;\n}\n\x3cspan class=\x22hljs-keyword\x22\x3einterface\x3c\/span\x3e Dog \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e Animal {\n    woof(): \x3cspan class=\x22hljs-built_in\x22\x3evoid\x3c\/span\x3e;\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 类型是 \x27number\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e Foo = Dog \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e Animal ? \x3cspan class=\x22hljs-built_in\x22\x3enumber\x3c\/span\x3e : \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e;\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 类型是 \x27string\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e Bar = \x3cspan class=\x22hljs-built_in\x22\x3eRegExp\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e Dog ? \x3cspan class=\x22hljs-built_in\x22\x3enumber\x3c\/span\x3e : \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e;\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e你可能会想知道改变为什么会立即生效。我们可以知道 \x3ccode\x3eFoo\x3c\/code\x3e 是数字，而 \x3ccode\x3eBar\x3c\/code\x3e 会是字符串，所以我们不妨明确地写出它。但条件类型的真正强大之处来自于它们与泛型的使用。\x3c\/p\x3e\n\x3cp\x3e例如，让我们来看看以下几个方法：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs typescript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3einterface\x3c\/span\x3e Id { id: \x3cspan class=\x22hljs-built_in\x22\x3enumber\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/* other fields *\/\x3c\/span\x3e }\n\x3cspan class=\x22hljs-keyword\x22\x3einterface\x3c\/span\x3e Name { name: \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/* other fields *\/\x3c\/span\x3e }\n\n\x3cspan class=\x22hljs-keyword\x22\x3edeclare\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecreateLabel\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eid: \x3cspan class=\x22hljs-built_in\x22\x3enumber\x3c\/span\x3e\x3c\/span\x3e): \x3cspan class=\x22hljs-title\x22\x3eId\x3c\/span\x3e\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3edeclare\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecreateLabel\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename: \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e\x3c\/span\x3e): \x3cspan class=\x22hljs-title\x22\x3eName\x3c\/span\x3e\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3edeclare\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecreateLabel\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename: \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e | \x3cspan class=\x22hljs-built_in\x22\x3enumber\x3c\/span\x3e\x3c\/span\x3e): \x3cspan class=\x22hljs-title\x22\x3eId\x3c\/span\x3e | \x3cspan class=\x22hljs-title\x22\x3eName\x3c\/span\x3e\x3c\/span\x3e;\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e这些用于\x3ccode\x3ecreatelabel\x3c\/code\x3e的重载，向我们展示了一个根据其输入类型作出选择的单个javascript函数。请注意以下两点：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e如果一个资源必须在整个api中反复进行同样的选择，这会变得很麻烦。\x3c\/li\x3e\n\x3cli\x3e我们必须创建三个重载：一个用于确定类型的每个案例，另一个用于最常见的案例。\n对于我们必须处理的其他情况，重载次数会呈指数级增长。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e相反，我们可以使用条件类型将我们的两个重载忽略到一个，并创建一个类型别名，以便我们可以重用该逻辑。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs scala\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eIdOrName\x26lt;T\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3enumber\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e|\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3estring\x26gt;=T\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3enumber\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e?\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eId\x3c\/span\x3e \x3c\/span\x3e: \x3cspan class=\x22hljs-type\x22\x3eName\x3c\/span\x3e;\ndeclare function createLabel\x26lt;\x3cspan class=\x22hljs-type\x22\x3eT\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e number | string\x26gt;(idOrName: \x3cspan class=\x22hljs-type\x22\x3eT\x3c\/span\x3e): \x3cspan class=\x22hljs-type\x22\x3eT\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e number ? \x3cspan class=\x22hljs-type\x22\x3eId\x3c\/span\x3e : \x3cspan class=\x22hljs-type\x22\x3eName\x3c\/span\x3e;\nlet a = createLabel(\x3cspan class=\x22hljs-string\x22\x3e\x22typescript\x22\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Name\x3c\/span\x3e\nlet b = createLabel(\x3cspan class=\x22hljs-number\x22\x3e2.8\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Id\x3c\/span\x3e\nlet c = createLabel(\x3cspan class=\x22hljs-string\x22\x3e\x22\x22\x3c\/span\x3e as any);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Id | Name\x3c\/span\x3e\nlet d = createLabel(\x3cspan class=\x22hljs-string\x22\x3e\x22\x22\x3c\/span\x3e as never);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ never\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e如同JavaScript可以根据一个值的特性在运行时做出决定一般，条件类型让 TypeScript 根据其他类型的特征在类型系统中作出判断。\x3c\/p\x3e\n\x3cp\x3e作为另一个例子，我们也可以编写一个名为\x3ccode\x3eflatten\x3c\/code\x3e的类型，将数组类型平移为它们的元素类型，但是另外保留它们：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs excel\x22\x3e\/\/ 如果我们有一个数组，当我们用 \x27number\x27 索引时，将会得到这个类型。\n\/\/ 否则，单独留下类型。\n\x3cspan class=\x22hljs-built_in\x22\x3etype\x3c\/span\x3e Flatten`\x26lt;\x3cspan class=\x22hljs-built_in\x22\x3eT\x3c\/span\x3e\x26gt;`\n= \x3cspan class=\x22hljs-built_in\x22\x3eT\x3c\/span\x3e extends any[] ? \x3cspan class=\x22hljs-built_in\x22\x3eT\x3c\/span\x3e[number] \x3cspan class=\x22hljs-symbol\x22\x3e:\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eT\x3c\/span\x3e;\n\x3c\/code\x3e\x3c\/pre\x3e\x3ch3\x3e在条件类型内的推断\x3c\/h3\x3e\n\x3cp\x3e条件类型也为我们提供了一种方法，通过使用 \x3ccode\x3einfer\x3c\/code\x3e 关键字从我们在真正分支中比较的类型推断出来。例如，我们可以在\x3ccode\x3eflatten\x3c\/code\x3e中推断出元素类型，而不用去动手取出它\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs excel\x22\x3e\/\/ 我们可以使用 \x27(infer U)[]\x27 而不是 \x27Array`\x26lt;infer U\x26gt;`\x27\n\x3cspan class=\x22hljs-built_in\x22\x3etype\x3c\/span\x3e Flatten`\x26lt;\x3cspan class=\x22hljs-built_in\x22\x3eT\x3c\/span\x3e\x26gt;`\n= \x3cspan class=\x22hljs-built_in\x22\x3eT\x3c\/span\x3e extends Array`\x26lt;infer U\x26gt;`\n? U \x3cspan class=\x22hljs-symbol\x22\x3e:\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eT\x3c\/span\x3e;\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e在这里，我们已经声明式地引入了一个名为\x3ccode\x3eu\x3c\/code\x3e 的新的泛型类型变量，而不是指定如何检索 \x3ccode\x3et\x3c\/code\x3e的元素类型。这使我们不再考虑如何获取想要的类型。\x3c\/p\x3e\n\x3ch3\x3e通过条件分配给联合体（ unions ）\x3c\/h3\x3e\n\x3cp\x3e当条件类型对单个类型参数起作用时，它们分布在各个联合体中。 所以在下面的例子中，\x3ccode\x3eBar\x3c\/code\x3e的类型是 \x3ccode\x3estring [] | number []\x3c\/code\x3e 因为\x3ccode\x3eFoo\x3c\/code\x3e应用于联合类型\x3ccode\x3estring |number\x3c\/code\x3e。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs applescript\x22\x3etype Foo`\x26lt;T\x26gt;`= T extends any ? T[] : never;\n\/**\n * Foo distributes \x3cspan class=\x22hljs-keyword\x22\x3eon\x3c\/span\x3e \x27\x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e | \x3cspan class=\x22hljs-built_in\x22\x3enumber\x3c\/span\x3e\x27 \x3cspan class=\x22hljs-keyword\x22\x3eto\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethe\x3c\/span\x3e type\n *\n *    (\x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e extends any ? \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e[] : never) |\n *    (\x3cspan class=\x22hljs-built_in\x22\x3enumber\x3c\/span\x3e extends any ? \x3cspan class=\x22hljs-built_in\x22\x3enumber\x3c\/span\x3e[] : never)\n * \n * which boils down \x3cspan class=\x22hljs-keyword\x22\x3eto\x3c\/span\x3e\n *\n *    \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e[] | \x3cspan class=\x22hljs-built_in\x22\x3enumber\x3c\/span\x3e[]\n *\/\ntype Bar = Foo\x26lt;\x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e | \x3cspan class=\x22hljs-built_in\x22\x3enumber\x3c\/span\x3e\x26gt;;\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e如果你想要避免在联合体（unions）中发布内容，则可以使用中括号括住“extends”关键字的两侧：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs typescript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e Foo\x3cspan class=\x22hljs-string\x22\x3e`\x26lt;T\x26gt;`\x3c\/span\x3e = [T] \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e [\x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e] ? T[] : never;\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Boils down to Array\x26lt;string | number\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e Bar = Foo\x26lt;\x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e | \x3cspan class=\x22hljs-built_in\x22\x3enumber\x3c\/span\x3e\x26gt;;\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e虽然条件类型起初可能看起来有点吓人，但当你需要进一步推动类型系统以获得准确类型时，我们相信它们将为你带来大量的灵活性。\x3c\/p\x3e\n\x3ch3\x3e新的内置助手\x3c\/h3\x3e\n\x3cp\x3eTypeScript 2.8 在\x3ccode\x3elib.d.ts\x3c\/code\x3e中提供了几种利用条件类型的新类型别名：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs scala\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这些都已经内置到lib.d.ts中！\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * Exclude from T those types that are assignable to U\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eExclude\x3c\/span\x3e`\x3cspan class=\x22hljs-title\x22\x3e\x26lt;T\x3c\/span\x3e, \x3cspan class=\x22hljs-title\x22\x3eU\x26gt;\x3c\/span\x3e` \x3c\/span\x3e= \x3cspan class=\x22hljs-type\x22\x3eT\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eU\x3c\/span\x3e ? never : \x3cspan class=\x22hljs-type\x22\x3eT\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * Extract from T those types that are assignable to U\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eExtract\x3c\/span\x3e`\x3cspan class=\x22hljs-title\x22\x3e\x26lt;T\x3c\/span\x3e, \x3cspan class=\x22hljs-title\x22\x3eU\x26gt;\x3c\/span\x3e` \x3c\/span\x3e= \x3cspan class=\x22hljs-type\x22\x3eT\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eU\x3c\/span\x3e ? \x3cspan class=\x22hljs-type\x22\x3eT\x3c\/span\x3e : never;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * Exclude null and undefined from T\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eNonNullable\x3c\/span\x3e`\x3cspan class=\x22hljs-title\x22\x3e\x26lt;T\x26gt;\x3c\/span\x3e` \x3c\/span\x3e= \x3cspan class=\x22hljs-type\x22\x3eT\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e | undefined ? never : \x3cspan class=\x22hljs-type\x22\x3eT\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * Obtain the return type of a function type\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReturnType\x3c\/span\x3e`\x3cspan class=\x22hljs-title\x22\x3e\x26lt;T\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e...args: any[]\x3c\/span\x3e) \x3cspan class=\x22hljs-title\x22\x3e=\x26gt;\x3c\/span\x3e` \x3cspan class=\x22hljs-title\x22\x3eany\x26gt;\x3c\/span\x3e \x3c\/span\x3e= \x3cspan class=\x22hljs-type\x22\x3eT\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e (...args: any[]) =\x26gt; infer \x3cspan class=\x22hljs-type\x22\x3eR\x3c\/span\x3e ? \x3cspan class=\x22hljs-type\x22\x3eR\x3c\/span\x3e : any;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * Obtain the return type of a constructor function type\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eInstanceType\x3c\/span\x3e`\x3cspan class=\x22hljs-title\x22\x3e\x26lt;T\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3enew\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e...args: any[]\x3c\/span\x3e) \x3cspan class=\x22hljs-title\x22\x3e=\x26gt;\x3c\/span\x3e` \x3cspan class=\x22hljs-title\x22\x3eany\x26gt;\x3c\/span\x3e \x3c\/span\x3e= \x3cspan class=\x22hljs-type\x22\x3eT\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e (...args: any[]) =\x26gt; infer \x3cspan class=\x22hljs-type\x22\x3eR\x3c\/span\x3e ? \x3cspan class=\x22hljs-type\x22\x3eR\x3c\/span\x3e : any;\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e而\x3ccode\x3eNonnullable\x3c\/code\x3e，\x3ccode\x3eReturntype\x3c\/code\x3e和\x3ccode\x3eInstancetype\x3c\/code\x3e相对不言而喻，\x3ccode\x3eExclude\x3c\/code\x3e和\x3ccode\x3eExtract\x3c\/code\x3e则更有趣一些。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eExtract\x3c\/code\x3e 从第一个参数中选择用于给第二个参数分配的类型：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs typescript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ string[] | number[]\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e Foo = Extract\x26lt;\x3cspan class=\x22hljs-built_in\x22\x3eboolean\x3c\/span\x3e | \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e[] | \x3cspan class=\x22hljs-built_in\x22\x3enumber\x3c\/span\x3e[], \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e[]\x26gt;;\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e\x3ccode\x3eExclude\x3c\/code\x3e 则相反，它从第一个参数中删除不能分配给第二个参数的类型 :\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs typescript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ boolean\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e Bar = Exclude\x26lt;\x3cspan class=\x22hljs-built_in\x22\x3eboolean\x3c\/span\x3e | \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e[] | \x3cspan class=\x22hljs-built_in\x22\x3enumber\x3c\/span\x3e[], \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e[]\x26gt;;\n\x3c\/code\x3e\x3c\/pre\x3e\x3ch2\x3e只有声明才会发出\x3c\/h2\x3e\n\x3cp\x3e感谢来自\x3ca href=\x22https:\/\/github.com\/nojvek\x22\x3eManoj Patel\x3c\/a\x3e的\x3ca href=\x22https:\/\/github.com\/Microsoft\/TypeScript\/pull\/20735\x22\x3e一个pull请求\x3c\/a\x3e，TypeScript 现在提供了一个\x3ccode\x3e--emitDeclarationOnly\x3c\/code\x3e标志，当你有一个发送JavaScript文件的替代构建步骤时，可以使用这个标志，但需要单独发出声明文件。\n在这种模式下，不会生成JavaScript文件和源代码文件;只是可以用于资源使用者的\x3ccode\x3e.d.ts\x3c\/code\x3e文件。\x3c\/p\x3e\n\x3cp\x3e其中一个用例就是使用备用编译器来处理TypeScript，例如babel 7.对于利用此标志的存储库示例，check out \x3ca href=\x22https:\/\/github.com\/FormidableLabs\/urql\/tree\/ce9fb3cc02c8530e0b70cfb31d09690dab8b02dc\x22\x3eurql from Formidable Labs\x3c\/a\x3e，或查看\x3ca href=\x22https:\/\/github.com\/Microsoft\/TypeScript-Babel-Starter\x22\x3eour Babel starter repo\x3c\/a\x3e。\x3c\/p\x3e\n\x3ch2\x3e\x3ccode\x3e@jsx\x3c\/code\x3e 预处理指令（pragma comments）\x3c\/h2\x3e\n\x3cp\x3e通常，jsx的用户希望将其jsx标记重写为\x3ccode\x3eReact.createElement\x3c\/code\x3e。然而，如果你使用的库有类似React的工厂api，比如Preact, Stencil, Inferno, Cycle其他等，你可能想稍微调整一下。\x3c\/p\x3e\n\x3cp\x3e曾经，TypeScript 只允许用户使用\x3ccode\x3ejsxFactory\x3c\/code\x3e选项（以及不赞成使用的\x3ccode\x3ereactNamespace\x3c\/code\x3e选项）在全局级别控制jsx的发送。但如果你想在同一个应用程序中混合使用这些库，那 jsx 将无法使用。\x3c\/p\x3e\n\x3cp\x3e幸运的是，TypeScript 2.8现在允许你通过在文件顶部添加一个\x3ccode\x3e\/\/ @ jsx\x3c\/code\x3e注释来逐个文件地设置你的jsx工厂。如果你在babel中使用了相同的功能，这应该看起来有些熟悉。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/** @jsx dom *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { dom } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22.\/renderer\x22\x3c\/span\x3e\n\x26lt;h\x26gt;\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eh\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e上面的示例导入了一个名为\x3ccode\x3edom\x3c\/code\x3e的函数，并使用\x3ccode\x3ejsx\x3c\/code\x3e编译指示选择\x3ccode\x3edom\x3c\/code\x3e作为文件中所有jsx表达式的工厂。TypeScript 2.8 在编译为commonjs和es5时会将其重写为以下内容：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e renderer_1 = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22.\/renderer\x22\x3c\/span\x3e);\nrenderer_1.dom(\x3cspan class=\x22hljs-string\x22\x3e\x22h\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e);\n\x3c\/code\x3e\x3c\/pre\x3e\x3ch2\x3e\x3ccode\x3eJSX\x3c\/code\x3e 通过jsx工厂解决\x3c\/h2\x3e\n\x3cp\x3e目前，当typescript使用jsx时，它会查找全局\x3ccode\x3eJSX\x3c\/code\x3e命名空间来查找某些类型（例如“什么是jsx组件的类型？”）。在 TypeScript 2.8中，编译器将尝试根据jsx工厂的位置查找\x3ccode\x3eJSX\x3c\/code\x3e命名空间。例如，如果您的jsx工厂是\x3ccode\x3eReact.createElement\x3c\/code\x3e，那么 TypeScript 将尝试首先解析\x3ccode\x3eReact.JSX\x3c\/code\x3e，然后解析当前范围内的\x3ccode\x3eJSX\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e当混合和匹配不同库（例如: React 和 Preact）或特定库的不同版本（例如: React14和React16）时，这可能是有用的，因为将jsx名称空间放置在全局范围中可能导致问题。\x3c\/p\x3e\n\x3cp\x3e今后，我们建议新的面向jsx的库避免将\x3ccode\x3eJSX\x3c\/code\x3e放在全局范围内，而是将它从相应的工厂函数的相同位置导出。然而，为了能够向后兼容，TypeScript 将在必要时继续回落到全局范围。\x3c\/p\x3e\n\x3ch2\x3e精确地控制映射类型的修饰符\x3c\/h2\x3e\n\x3cp\x3eTypeScript 的映射对象类型是一个非常强大的构造。它有个便利的功能：是允许用户创建新的类型，其中包含为其所有属性设置的修饰符。例如，以下类型创建一个基于\x3ccode\x3eT\x3c\/code\x3e的新类型，并且\x3ccode\x3eT\x3c\/code\x3e中的每个属性都变为\x3ccode\x3e只读\x3c\/code\x3e和可选(\x3ccode\x3e?\x3c\/code\x3e)。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs elm\x22\x3e\/\/ 创建一个包含 \x3cspan class=\x22hljs-type\x22\x3eT\x3c\/span\x3e 中所有属性的类型，,\n\/\/ 但标记为只读和可选.\n\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eReadonlyAndPartial\x3c\/span\x3e`\x26lt;\x3cspan class=\x22hljs-type\x22\x3eT\x3c\/span\x3e\x26gt;` = {\n    readonly [\x3cspan class=\x22hljs-type\x22\x3eP\x3c\/span\x3e in keyof \x3cspan class=\x22hljs-type\x22\x3eT\x3c\/span\x3e]?: \x3cspan class=\x22hljs-type\x22\x3eT\x3c\/span\x3e[\x3cspan class=\x22hljs-type\x22\x3eP\x3c\/span\x3e]\n}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e所以映射的对象类型可以添加修饰符，但直到此时，无法从\x3ccode\x3eT\x3c\/code\x3e删除\x3cem\x3eremove\x3c\/em\x3e修饰符。\x3c\/p\x3e\n\x3cp\x3eTypeScript 2.8提供了用\x3ccode\x3e-\x3c\/code\x3e运算符去除映射类型中的修饰符的新语法，以及用\x3ccode\x3e\x2b\x3c\/code\x3e运算符添加修饰符的新的更加明确的语法。例如:\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs typescript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e Mutable\x3cspan class=\x22hljs-string\x22\x3e`\x26lt;T\x26gt;`\x3c\/span\x3e = {\n    -readonly [P \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e keyof T]: T[P]\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3einterface\x3c\/span\x3e Foo {\n    readonly abc: \x3cspan class=\x22hljs-built_in\x22\x3enumber\x3c\/span\x3e;\n    def?: \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e;\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x27abc\x27\x3c\/span\x3e\nis no longer read-only, but \x3cspan class=\x22hljs-string\x22\x3e\x27def\x27\x3c\/span\x3e\nis still optional.\n\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e TotallyMutableFoo = Mutable\x3cspan class=\x22hljs-string\x22\x3e`\x26lt;Foo\x26gt;`\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e在上面的例子中，\x3ccode\x3eMutable\x3c\/code\x3e从它映射的类型的每个属性中删除\x3ccode\x3ereadonly\x3c\/code\x3e。\n同样，TypeScript 现在在\x3ccode\x3elib.d.ts\x3c\/code\x3e中提供了一个新的\x3ccode\x3eRequired\x3c\/code\x3e类型，用于从每个属性中删除选项：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs elm\x22\x3e\/**\n * \x3cspan class=\x22hljs-type\x22\x3eMake\x3c\/span\x3e all properties \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eT\x3c\/span\x3e required\n *\/\n\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eRequired\x3c\/span\x3e`\x26lt;\x3cspan class=\x22hljs-type\x22\x3eT\x3c\/span\x3e\x26gt;` = {\n    [\x3cspan class=\x22hljs-type\x22\x3eP\x3c\/span\x3e in keyof \x3cspan class=\x22hljs-type\x22\x3eT\x3c\/span\x3e]-?: \x3cspan class=\x22hljs-type\x22\x3eT\x3c\/span\x3e[\x3cspan class=\x22hljs-type\x22\x3eP\x3c\/span\x3e];\n}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e当你想调出一个映射类型添加修饰符时，\x3ccode\x3e\x2b\x3c\/code\x3e操作符可以很方便的实现。例如，我们从上面的\x3ccode\x3eReadonlyAndPartial\x3c\/code\x3e可以定义如下：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs elm\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eReadonlyAndPartial\x3c\/span\x3e`\x26lt;\x3cspan class=\x22hljs-type\x22\x3eT\x3c\/span\x3e\x26gt;` = {\n    \x2breadonly [\x3cspan class=\x22hljs-type\x22\x3eP\x3c\/span\x3e in keyof \x3cspan class=\x22hljs-type\x22\x3eT\x3c\/span\x3e]\x2b?: \x3cspan class=\x22hljs-type\x22\x3eT\x3c\/span\x3e[\x3cspan class=\x22hljs-type\x22\x3eP\x3c\/span\x3e];\n}\n\x3c\/code\x3e\x3c\/pre\x3e\x3ch2\x3e组织导入（Organize imports）\x3c\/h2\x3e\n\x3cp\x3eTypeScript 的语言服务现在提供了组织导入的功能。此功能将删除所有未使用的导入，按文件路径对现有导入进行排序，并对命名导入进行排序。\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/p0.ssl.qhimg.com\/t01b5a3ee0d3f639578.gif\x22 alt=\x22\x22\x3e\x3c\/p\x3e\n\x3ch2\x3e修复未初始化的属性\x3c\/h2\x3e\n\x3cp\x3eTypeScript 2.7引入了对类中未初始化属性的额外检查，感谢来自\x3ca href=\x22https:\/\/github.com\/Kingwl\x22\x3eWenlu Wang\x3c\/a\x3e 的\x3ca href=\x22https:\/\/github.com\/Microsoft\/TypeScript\/pull\/21528\x22\x3ea pull request\x3c\/a\x3e。 TypeScript 2.8带来了一些有用的快速修复，使其更容易添加到您的代码库中。\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/p0.ssl.qhimg.com\/t018fdcb62c9f7b564e.gif\x22 alt=\x22\x22\x3e\x3c\/p\x3e\n\x3ch2\x3e突破性的改变\x3c\/h2\x3e\n\x3ch3\x3e在\x3ccode\x3e--noUnusedParameters\x3c\/code\x3e下检查未使用的类型参数\x3c\/h3\x3e\n\x3cp\x3e未使用的类型参数先前在\x3ccode\x3e--noUnusedLocals\x3c\/code\x3e下报告过，但是现在报告在\x3ccode\x3e--noUnusedParameters\x3c\/code\x3e下。\x3c\/p\x3e\n\x3ch3\x3e\x3ccode\x3eHTMLObjectElement\x3c\/code\x3e 不再具有 \x3ccode\x3ealt\x3c\/code\x3e 属性\x3c\/h3\x3e\n\x3cp\x3e这种行为不包含在 WHATWG 标准中。\x3c\/p\x3e\n\x3ch2\x3e下一步是什么？\x3c\/h2\x3e\n\x3cp\x3e我们希望 TypeScript 2.8能够进一步推动 envelope 提供一种真正代表 JavaScript 作为语言本质的类型系统。因此，我们相信我们可以在你编码的过程中，为你创造出一种更高效、更快乐的体验。 \x3c\/p\x3e\n\x3cp\x3e在接下来的几周内，我们将更清楚地了解 TypeScript 2.9的存储情况，但是和往常一样，你可以留意 \x3ca href=\x22https:\/\/github.com\/Microsoft\/TypeScript\/wiki\/Roadmap\x22\x3eTypeScript 路线图\x3c\/a\x3e ，看看我们正在为下一个版本做些什么。你也可以尝试我们的夜间发布，今天就能体验未来！例如，通用的jsx元素已经出现在 TypeScript 最近的夜间版本中！\x3c\/p\x3e\n\x3cp\x3e让我们知道你对这个版本的看法，请写在\x3ca href=\x22http:\/\/twitter.com\/typescriptlang\/\x22\x3eTwitter\x3c\/a\x3e 上或者在下面的评论中, 并随时向我们提交建议和 \x3ca href=\x22https:\/\/github.com\/Microsoft\/TypeScript\/issues\x22\x3ea GitHub issue\x3c\/a\x3e.\x3c\/p\x3e\n\x3cp\x3e可劲儿造吧！（Happy Hacking!）\x3c\/p\x3e\n\n          \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>Announcing TypeScript 2.8</p><h2 id="原文链接">原文链接</h2><p><a href="https://www.zcfy.cc/article/announcing-typescript-2-8">https://www.zcfy.cc/article/announcing-typescript-2-8</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/dvmh7vmzmkv/" target="_blank">https://alili.tech/archive/dvmh7vmzmkv/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>