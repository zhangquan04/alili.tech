<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="React 可视化开发工具 Shadow Widget 非正经入门（之三：双源属性与数据驱动）"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>React 可视化开发工具 Shadow Widget 非正经入门（之三：双源属性与数据驱动） | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/rrcax8ys5b/",
				"appid": "1613049289050283", 
				"title": "React 可视化开发工具 Shadow Widget 非正经入门（之三：双源属性与数据驱动） | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-12T02:30:25"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/hu3fihohisk/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/xaxzpmwlsbm/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2frrcax8ys5b%2f&text=React%20%e5%8f%af%e8%a7%86%e5%8c%96%e5%bc%80%e5%8f%91%e5%b7%a5%e5%85%b7%20Shadow%20Widget%20%e9%9d%9e%e6%ad%a3%e7%bb%8f%e5%85%a5%e9%97%a8%ef%bc%88%e4%b9%8b%e4%b8%89%ef%bc%9a%e5%8f%8c%e6%ba%90%e5%b1%9e%e6%80%a7%e4%b8%8e%e6%95%b0%e6%8d%ae%e9%a9%b1%e5%8a%a8%ef%bc%89"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2frrcax8ys5b%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2frrcax8ys5b%2f&text=React%20%e5%8f%af%e8%a7%86%e5%8c%96%e5%bc%80%e5%8f%91%e5%b7%a5%e5%85%b7%20Shadow%20Widget%20%e9%9d%9e%e6%ad%a3%e7%bb%8f%e5%85%a5%e9%97%a8%ef%bc%88%e4%b9%8b%e4%b8%89%ef%bc%9a%e5%8f%8c%e6%ba%90%e5%b1%9e%e6%80%a7%e4%b8%8e%e6%95%b0%e6%8d%ae%e9%a9%b1%e5%8a%a8%ef%bc%89"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2frrcax8ys5b%2f&title=React%20%e5%8f%af%e8%a7%86%e5%8c%96%e5%bc%80%e5%8f%91%e5%b7%a5%e5%85%b7%20Shadow%20Widget%20%e9%9d%9e%e6%ad%a3%e7%bb%8f%e5%85%a5%e9%97%a8%ef%bc%88%e4%b9%8b%e4%b8%89%ef%bc%9a%e5%8f%8c%e6%ba%90%e5%b1%9e%e6%80%a7%e4%b8%8e%e6%95%b0%e6%8d%ae%e9%a9%b1%e5%8a%a8%ef%bc%89"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2frrcax8ys5b%2f&is_video=false&description=React%20%e5%8f%af%e8%a7%86%e5%8c%96%e5%bc%80%e5%8f%91%e5%b7%a5%e5%85%b7%20Shadow%20Widget%20%e9%9d%9e%e6%ad%a3%e7%bb%8f%e5%85%a5%e9%97%a8%ef%bc%88%e4%b9%8b%e4%b8%89%ef%bc%9a%e5%8f%8c%e6%ba%90%e5%b1%9e%e6%80%a7%e4%b8%8e%e6%95%b0%e6%8d%ae%e9%a9%b1%e5%8a%a8%ef%bc%89"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=React%20%e5%8f%af%e8%a7%86%e5%8c%96%e5%bc%80%e5%8f%91%e5%b7%a5%e5%85%b7%20Shadow%20Widget%20%e9%9d%9e%e6%ad%a3%e7%bb%8f%e5%85%a5%e9%97%a8%ef%bc%88%e4%b9%8b%e4%b8%89%ef%bc%9a%e5%8f%8c%e6%ba%90%e5%b1%9e%e6%80%a7%e4%b8%8e%e6%95%b0%e6%8d%ae%e9%a9%b1%e5%8a%a8%ef%bc%89&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2frrcax8ys5b%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2frrcax8ys5b%2f&title=React%20%e5%8f%af%e8%a7%86%e5%8c%96%e5%bc%80%e5%8f%91%e5%b7%a5%e5%85%b7%20Shadow%20Widget%20%e9%9d%9e%e6%ad%a3%e7%bb%8f%e5%85%a5%e9%97%a8%ef%bc%88%e4%b9%8b%e4%b8%89%ef%bc%9a%e5%8f%8c%e6%ba%90%e5%b1%9e%e6%80%a7%e4%b8%8e%e6%95%b0%e6%8d%ae%e9%a9%b1%e5%8a%a8%ef%bc%89"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2frrcax8ys5b%2f&title=React%20%e5%8f%af%e8%a7%86%e5%8c%96%e5%bc%80%e5%8f%91%e5%b7%a5%e5%85%b7%20Shadow%20Widget%20%e9%9d%9e%e6%ad%a3%e7%bb%8f%e5%85%a5%e9%97%a8%ef%bc%88%e4%b9%8b%e4%b8%89%ef%bc%9a%e5%8f%8c%e6%ba%90%e5%b1%9e%e6%80%a7%e4%b8%8e%e6%95%b0%e6%8d%ae%e9%a9%b1%e5%8a%a8%ef%bc%89"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2frrcax8ys5b%2f&title=React%20%e5%8f%af%e8%a7%86%e5%8c%96%e5%bc%80%e5%8f%91%e5%b7%a5%e5%85%b7%20Shadow%20Widget%20%e9%9d%9e%e6%ad%a3%e7%bb%8f%e5%85%a5%e9%97%a8%ef%bc%88%e4%b9%8b%e4%b8%89%ef%bc%9a%e5%8f%8c%e6%ba%90%e5%b1%9e%e6%80%a7%e4%b8%8e%e6%95%b0%e6%8d%ae%e9%a9%b1%e5%8a%a8%ef%bc%89"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2frrcax8ys5b%2f&title=React%20%e5%8f%af%e8%a7%86%e5%8c%96%e5%bc%80%e5%8f%91%e5%b7%a5%e5%85%b7%20Shadow%20Widget%20%e9%9d%9e%e6%ad%a3%e7%bb%8f%e5%85%a5%e9%97%a8%ef%bc%88%e4%b9%8b%e4%b8%89%ef%bc%9a%e5%8f%8c%e6%ba%90%e5%b1%9e%e6%80%a7%e4%b8%8e%e6%95%b0%e6%8d%ae%e9%a9%b1%e5%8a%a8%ef%bc%89"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">React 可视化开发工具 Shadow Widget 非正经入门（之三：双源属性与数据驱动）</h1><div class="meta"><div class="postdate"><time datetime="2019-01-12" itemprop="datePublished">2019-01-12</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e本系列博文从 Shadow Widget 作者的视角，解释该框架的设计要点。本篇讲解双源属性、不可变数据、事件驱动等。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVOWCc?w=812\x26amp;h=590\x22 src=\x22https:\/\/static.alili.tech\/img\/bVOWCc?w=812\x26amp;h=590\x22 alt=\x22Love job\x22 title=\x22Love job\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e1. React 中的隐式双源\x3c\/h2\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var mainComp = null;\n\nfunction Welcome(props) {\n  return \x3ch1\x3eHello, {props.name}\x3c\/h1\x3e;\n}\n\nclass DivText extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {name:\x27Wayne\x27};\n    mainComp = this;\n  }\n  \n  render() {\n    return (\n      \x3cdiv key=\x27main\x27\x3e\n        \x3cWelcome key=\x27txt\x27 name={this.state.name} \/\x3e\n      \x3c\/div\x3e\n    );\n  }\n}\n\nReactDOM.render(\n  \x3cDivText \/\x3e,\n  document.getElementById(\x27root\x27)\n);\n\nsetTimeout( function() {\n  mainComp.setState({name:\x27George\x27});\n},5000);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e mainComp = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eWelcome\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eprops\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eh1\x3c\/span\x3e\x26gt;\x3c\/span\x3eHello, {props.name}\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eh1\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e;\n}\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eDivText\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(props) {\n    \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(props);\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = {\x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x27Wayne\x27\x3c\/span\x3e};\n    mainComp = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n  }\n  \n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ekey\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x27main\x27\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eWelcome\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ekey\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x27txt\x27\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{this.state.name}\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e\n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    );\n  }\n}\n\nReactDOM.render(\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eDivText\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e,\n  document.getElementById(\x27root\x27)\n);\n\nsetTimeout( function() {\n  mainComp.setState({name:\x27George\x27});\n},5000);\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这个例子创建的 component 树如下图，\x3ccode\x3emain\x3c\/code\x3e 节点的 \x3ccode\x3estate.name\x3c\/code\x3e 传递给 \x3ccode\x3etxt\x3c\/code\x3e 节点用作 \x3ccode\x3eprops.name\x3c\/code\x3e。\x3ccode\x3etxt\x3c\/code\x3e 节点初始显示 \x3ccode\x3e\x22Hello, Wayne\x22\x3c\/code\x3e，过 5 秒后切换为 \x3ccode\x3e\x22Hello, George\x22\x3c\/code\x3e。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 \x3croot node\x3e\n  \x2b-- main      \/\/ div\n  |   \x2b-- txt   \/\/ h1\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs dts\x22\x3e\x3ccode\x3e \x3cspan class=\x22hljs-params\x22\x3e\x26lt;root node\x26gt;\x3c\/span\x3e\n  \x2b-- main      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ div\x3c\/span\x3e\n  |   \x2b-- txt   \x3cspan class=\x22hljs-comment\x22\x3e\/\/ h1\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们研究一下 5 秒后切换都发生了什么，\x3ccode\x3emainComp.setState({name:\x27George\x27})\x3c\/code\x3e 一句更改 \x3ccode\x3emain\x3c\/code\x3e 节点的 \x3ccode\x3estate.name\x3c\/code\x3e，然后系统触发下级 \x3ccode\x3etxt\x3c\/code\x3e 节点的 \x3ccode\x3eprops.name\x3c\/code\x3e 变化，再驱动 \x3ccode\x3etxt\x3c\/code\x3e 节点内容刷新。\x3c\/p\x3e\n\x3cp\x3e本处 React 技术实现让初学者很费解，\x3ccode\x3emain\x3c\/code\x3e 节点的 \x3ccode\x3erender\x3c\/code\x3e 函数用 JSX 返回 Element，并非每次渲染都用 \x3ccode\x3e\x26lt;Welcome\x26gt;\x3c\/code\x3e 创建子节点。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  render() {\n    return (\n      \x3cdiv key=\x27main\x27\x3e\n        \x3cWelcome key=\x27txt\x27 name={this.state.name} \/\x3e\n      \x3c\/div\x3e\n    );\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ekey\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x27main\x27\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eWelcome\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ekey\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x27txt\x27\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{this.state.name}\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e\n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    );\n  }\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e而是首次渲染时创建一次，其后 \x3ccode\x3erender()\x3c\/code\x3e 调用只对已存在的节点做更新，由 \x3ccode\x3eprops.name\x3c\/code\x3e 变化驱动子节点内容刷新。所以，\x3cstrong\x3e上面 \x3ccode\x3etxt\x3c\/code\x3e 节点的 \x3ccode\x3eprops.name\x3c\/code\x3e 对节点自身来说，是不变量，但对父节点来说，是可变量\x3c\/strong\x3e。由 \x3ccode\x3estate.xxx\x3c\/code\x3e 驱动刷新与 \x3ccode\x3eprops.xxx\x3c\/code\x3e 驱动刷新本质是一回事，只不过 React 编程模型在表面弄了一点限制。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eprops.xxx\x3c\/code\x3e 驱动的刷新是一个源头，\x3ccode\x3estate.xxx\x3c\/code\x3e 驱动的刷新是另一个源头，合起来是 \x22双源驱动\x22。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e2. 改造双源驱动\x3c\/h2\x3e\n\x3cp\x3e由于 React 限定本节点 \x3ccode\x3eprops.xxx\x3c\/code\x3e 是只读的，我们通过改造，让一个节点既接受 \x3ccode\x3eprops.xxx\x3c\/code\x3e 驱动，也接受 \x3ccode\x3estate.xxx\x3c\/code\x3e 驱动。让 React 隐式的双源驱动，变成显式的双源驱动，如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var txtComp = null;\n\nclass Welcome extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {name:props.name};\n    this.oldName = props.name;\n    txtComp = this;\n  }\n\n  render() {\n    var name = this.state.name;\n    if (this.oldName !== this.props.name)\n      name = this.state.name = this.oldName = this.props.name;\n    return \x3ch1\x3eHello, {name}\x3c\/h1\x3e;\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e txtComp = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eWelcome\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(props) {\n    \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(props);\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = {\x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e:props.name};\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.oldName = props.name;\n    txtComp = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n  }\n\n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e name = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.name;\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.oldName !== \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.name)\n      name = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.name = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.oldName = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.name;\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eh1\x3c\/span\x3e\x26gt;\x3c\/span\x3eHello, {name}\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eh1\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e;\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样，在 \x3ccode\x3etxt\x3c\/code\x3e 节点，既可用 \x3ccode\x3etxtComp.setState({name:\x27George\x27})\x3c\/code\x3e 驱动刷新，也可由父节点传入的 \x3ccode\x3eprops.name\x3c\/code\x3e 变化来驱动刷新。我们额外要做的是，在 \x3ccode\x3etxt\x3c\/code\x3e 节点用 \x3ccode\x3ethis.oldName\x3c\/code\x3e 记录 \x3ccode\x3eprops.name\x3c\/code\x3e 旧值，由 \x3ccode\x3ethis.oldName !== this.props.name\x3c\/code\x3e 来识别传入 \x3ccode\x3eprops.name\x3c\/code\x3e 是否变化了。\x3c\/p\x3e\n\x3cp\x3e这么改造的意义在于：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e自身状态变迁与父级驱动变迁，是两种普遍存在的现象，我们引用正规的 \x22双源驱动\x22 概念，便于将两种源头归一，如后面叙述，用 \x3ccode\x3ethis.duals.xxx\x3c\/code\x3e 表达，归一后才能构造事件发布与订阅的机制。\x3c\/li\x3e\n\x3cli\x3eReact 让 props 属性只读的设计有点尴尬，有违普遍认知。   \x3cbr\x3e如前面介绍，它不是不可变，而是限定本级与下级不可修改，这个规则对保障单向数据传递有利。但大众对 DOM 节点的认知是这样的，以 \x3ccode\x3e\x26lt;input\x26gt;\x3c\/code\x3e 为例，\x3ccode\x3etype=\x27button\x27\x3c\/code\x3e 这个属性可以用 \x3ccode\x3eprops.type\x3c\/code\x3e 表达，因为生存周期里它不该有变化，而 \x3ccode\x3etitle=\x27for test\x27\x3c\/code\x3e 属性应让本节点参与管理，生存期内可变。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e让自身节点管理类似 \x3ccode\x3eprops.name, props.title\x3c\/code\x3e 的属性，大致有两种方法，其一，采取上面介绍的方法，让两个源头归一，再驱动本节点输出。其二，按严格的单向数据流要求，把代码写成下面样子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Welcome extends React.Component {\n  constructor(props) {\n    super(props);\n  }\n  \n  setName(newName) {\n    mainComp.setState({name:newName});\n  }\n  \n  render() {\n    return \x3ch1\x3eHello, {this.props.name}\x3c\/h1\x3e;\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eWelcome\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(props) {\n    \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(props);\n  }\n  \n  setName(newName) {\n    mainComp.setState({\x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e:newName});\n  }\n  \n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eh1\x3c\/span\x3e\x26gt;\x3c\/span\x3eHello, {this.props.name}\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eh1\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e;\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e也就是借助父节点的 \x3ccode\x3esetState()\x3c\/code\x3e 实现刷新，理论上，这也是单向数据流，理解有点别扭，自身节点的属性不能直接管理，非要到父节点跑一圈。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVO6wi?w=251\x26amp;h=144\x22 src=\x22https:\/\/static.alili.tech\/img\/bVO6wi?w=251\x26amp;h=144\x22 alt=\x22结点关系\x22 title=\x22结点关系\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3eShadow Widget 双源驱动的优点在于 \x3cstrong\x3e\x22让 DOM 节点功能回归本原\x22\x3c\/strong\x3e，让 \x3ccode\x3eprops.xxx\x3c\/code\x3e 服务于生存周期中不变量，让 \x3ccode\x3eduals.xxx\x3c\/code\x3e 服务于可变量，\x3ccode\x3estate.xxx\x3c\/code\x3e 也服务于可变量，但倾向于用来表达自身节点的私有状态。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/reflux\/refluxjs\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ereflux\x3c\/a\x3e 为实现 React flux 机制，仿 component 接口设计了 store，如果没有上述 \x3ccode\x3eprops.xxx\x3c\/code\x3e 限制，我相信把 component 与 store 合一远优于现有设计。回归原本的设计好处是潜在的，因为倾斜的地基会导致上层建筑更加倾斜。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e3. 数据侦听机制\x3c\/h2\x3e\n\x3cp\x3eShadow Widget 将双源驱动归一后，用 \x3ccode\x3eduals.attr\x3c\/code\x3e 存取属性，而且系统内部对读写 \x3ccode\x3eduals.attr\x3c\/code\x3e 做了封装，\x22读属性\x22 自动转从 \x3ccode\x3estate.attr\x3c\/code\x3e 读值，\x22写属性\x22 则封装成事件驱动机制，等效于调用 \x3ccode\x3ecomp.setState({attr:value})\x3c\/code\x3e，但它所做的事远不止这个，还包括：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e用户可以调用 \x3ccode\x3ecomp.defineDual(attr,setterFunc)\x3c\/code\x3e 注册自定义的 setter 函数，甚至对同一 \x3ccode\x3eduals.attr\x3c\/code\x3e 多次注册不同 settrer 函数，比如基类定义一个 setter 函数，继承类中再定义另一个 setter，两个 setter 会依顺被调用。即 \x3ccode\x3eduals.attr\x3c\/code\x3e 的 setter 也具有一种可继承的机制。\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3eduals.attr\x3c\/code\x3e 可被侦听，被侦听后源头 \x3ccode\x3eduals.attr\x3c\/code\x3e 若发生变化，相应的侦听函数将自动被调起。\x3c\/li\x3e\n\x3cli\x3e多个 component 节点的双源属性可以串接，源头更改其它地方会自动更新。\x3c\/li\x3e\n\x3cli\x3e对某节点的 \x3ccode\x3eduals.attr\x3c\/code\x3e 赋值，会导致多种联动响应，如果导致本节点其它双源属性更新，更新将在同一周期立即进行，如果导致其它节点的双源属性更新，将在下一周期在其它节点 \x3ccode\x3erender()\x3c\/code\x3e 时进行，如果触发侦听事件，也在下一周期调用侦听函数。Shadow Widget 对 \x3ccode\x3eduals.attr\x3c\/code\x3e 赋值的设计，已兼顾考虑了本节点内双源属性递归回调的效率，也保证了数据流传递的单向性。\x3c\/li\x3e\n\x3cli\x3e在各节点注册 \x3ccode\x3eduals.attr\x3c\/code\x3e 的 setter 函数、侦听函数，能自动适应它的生存周期。比如 B 节点侦听 A 节点的 \x3ccode\x3eduals.attr\x3c\/code\x3e，无论 A 节点，还是 B 节点先被卸载，侦听链都会自动断开。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e侦听源节点的双源属性，常见代码有这么两种写法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  sourceComp.listen(\x27attr\x27,targetComp,\x27attrMethod\x27);\n  sourceComp.listen(\x27attr\x27,function(value,oldValue){});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e  sourceComp.listen(\x3cspan class=\x22hljs-string\x22\x3e\x27attr\x27\x3c\/span\x3e,targetComp,\x3cspan class=\x22hljs-string\x22\x3e\x27attrMethod\x27\x3c\/span\x3e);\n  sourceComp.listen(\x3cspan class=\x22hljs-string\x22\x3e\x27attr\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3evalue,oldValue\x3c\/span\x3e)\x3c\/span\x3e{});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e第 1 行写法的效果是：sourceComp.duals.attr 发生变化后，自动触发 targetComp[\x27attrMethod\x27] 的函数调用。第 2 行则触发由参数指定的回调函数。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e4. 数据更新的判断依据\x3c\/h2\x3e\n\x3cp\x3eShadow Widget 采用 \x22恒等比较\x22 的方式判断两个数值是否更改为，在 \x3ccode\x3ecomp.duals.attr = value\x3c\/code\x3e 与 \x3ccode\x3ecomp.setState({attr:value})\x3c\/code\x3e 语句中，当所赋新值（\x3ccode\x3evalue\x3c\/code\x3e）与旧值恒等（即 \x3ccode\x3e===\x3c\/code\x3e），则视作数据未更新，也就不会触发相应的 setter 调用或 listen 调用。\x3c\/p\x3e\n\x3cp\x3eShadow Widget 已为各构件配置 \x3ccode\x3eshouldComponentUpdate()\x3c\/code\x3e 与 \x3ccode\x3ecomponentWillReceiveProps()\x3c\/code\x3e 缺省处理，除非有特别理由，您不应改变缺省 \x22以各属性新旧值是否恒等\x22 的判断方式。\x3c\/p\x3e\n\x3cp\x3e至于如何对 Array 或 Object 快速构造新数据，以便被系统判断为 \x22非恒等\x22，我们建议用 React addon 提供的 \x3ccode\x3eupdate\x3c\/code\x3e 接口，Shadow Widget 已缺省内置该函数，即 \x3ccode\x3eex.update()\x3c\/code\x3e，请参考 Shadow Widget 的 API 手册。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e5. 自动定义的双源属性\x3c\/h2\x3e\n\x3cp\x3e双源属性一般要调用 \x3ccode\x3ecomp.defineDual()\x3c\/code\x3e 注册后才使用，但对于 DOM 节点内置属性是例外，如 \x3ccode\x3etitle, id, name\x3c\/code\x3e 等，这些属性只要节点在创建时，传入的 \x3ccode\x3eprops\x3c\/code\x3e 用到了，就会被系统自动注册为双源属性。\x3c\/p\x3e\n\x3cp\x3e另外，命名为 \x3ccode\x3edata-*, aria-*, dual-*\x3c\/code\x3e 的属性，也自动注册为双源属性。\x3c\/p\x3e\n\x3cp\x3e自动注册双源属性的设计目的是为了简化编程，如果遇到不想变成双源属性却自动注册了的情况，不使用 \x3ccode\x3eduals.xxx\x3c\/code\x3e 即可。\x3c\/p\x3e\n\x3cp\x3e（本文完）\x3c\/p\x3e\n\x3cp\x3e本专栏历史文章：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000009688749\x22\x3e介绍一项让 React 可以与 Vue 抗衡的技术\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000009719938\x22 target=\x22_blank\x22\x3eReact 可视化开发工具 Shadow Widget 非正经入门（之一：React 三宗罪）\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000009742514\x22\x3eReact 可视化开发工具 Shadow Widget 非正经入门（之二：分离界面设计）\x3c\/a\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>React 可视化开发工具 Shadow Widget 非正经入门（之三：双源属性与数据驱动）</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000009756694">https://segmentfault.com/a/1190000009756694</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/rrcax8ys5b/" target="_blank">https://alili.tech/archive/rrcax8ys5b/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>