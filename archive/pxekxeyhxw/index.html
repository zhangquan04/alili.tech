<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="编写 Node.js Rest API 的 10 个最佳实践"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>编写 Node.js Rest API 的 10 个最佳实践 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/pxekxeyhxw/",
				"appid": "1613049289050283", 
				"title": "编写 Node.js Rest API 的 10 个最佳实践 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-25T02:30:23"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/h3w3n3g139v/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/z3urntmbxe/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fpxekxeyhxw%2f&text=%e7%bc%96%e5%86%99%20Node.js%20Rest%20API%20%e7%9a%84%2010%20%e4%b8%aa%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fpxekxeyhxw%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fpxekxeyhxw%2f&text=%e7%bc%96%e5%86%99%20Node.js%20Rest%20API%20%e7%9a%84%2010%20%e4%b8%aa%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fpxekxeyhxw%2f&title=%e7%bc%96%e5%86%99%20Node.js%20Rest%20API%20%e7%9a%84%2010%20%e4%b8%aa%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fpxekxeyhxw%2f&is_video=false&description=%e7%bc%96%e5%86%99%20Node.js%20Rest%20API%20%e7%9a%84%2010%20%e4%b8%aa%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e7%bc%96%e5%86%99%20Node.js%20Rest%20API%20%e7%9a%84%2010%20%e4%b8%aa%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fpxekxeyhxw%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fpxekxeyhxw%2f&title=%e7%bc%96%e5%86%99%20Node.js%20Rest%20API%20%e7%9a%84%2010%20%e4%b8%aa%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fpxekxeyhxw%2f&title=%e7%bc%96%e5%86%99%20Node.js%20Rest%20API%20%e7%9a%84%2010%20%e4%b8%aa%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fpxekxeyhxw%2f&title=%e7%bc%96%e5%86%99%20Node.js%20Rest%20API%20%e7%9a%84%2010%20%e4%b8%aa%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fpxekxeyhxw%2f&title=%e7%bc%96%e5%86%99%20Node.js%20Rest%20API%20%e7%9a%84%2010%20%e4%b8%aa%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">编写 Node.js Rest API 的 10 个最佳实践</h1><div class="meta"><div class="postdate"><time datetime="2019-01-25" itemprop="datePublished">2019-01-25</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e\x3cp\x3e本文首发于之乎专栏\x3ca href=\x22https:\/\/zhuanlan.zhihu.com\/p\/25506654\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e前端周刊\x3c\/a\x3e，全文共 6953 字，读完需 8 分钟，速度需 2 分钟。翻译自：\x3ccode\x3eRingStack\x3c\/code\x3e 的文章 \x3ca href=\x22https:\/\/blog.risingstack.com\/10-best-practices-for-writing-node-js-rest-apis\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/blog.risingstack.com\/10-best-practices-for-writing-node-js-rest-apis\/\x3c\/a\x3e，英文好的同学可以直接阅读原文，译文较原文有删节。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e\x3ccode\x3eNode.js\x3c\/code\x3e 除了用来编写 \x3ccode\x3eWEB\x3c\/code\x3e 应用之外，还可以用来编写 \x3ccode\x3eAPI\x3c\/code\x3e 服务，我们在本文中会介绍编写 \x3ccode\x3eNode.js Rest API\x3c\/code\x3e 的最佳实践，包括如何命名路由、进行认证和测试等话题，内容摘要如下：\x3c\/p\x3e\n\x3cblockquote\x3e\x3col\x3e\n\x3cli\x3e\x3cp\x3e正确使用 \x3ccode\x3eHTTP Method\x3c\/code\x3e 和路由\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e正确的使用 \x3ccode\x3eHTTP\x3c\/code\x3e 状态码\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e使用 \x3ccode\x3eHTTP Header\x3c\/code\x3e 来发送元数据\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e为 \x3ccode\x3eREST API\x3c\/code\x3e 挑选合适的框架\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e要对 \x3ccode\x3eAPI\x3c\/code\x3e 进行黑盒测试\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e使用基于 \x3ccode\x3eJWT\x3c\/code\x3e 的无状态的认证机制\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e学会使用条件请求机制\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e拥抱接口调用频率限制（Rate-Limiting）\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e编写良好的 \x3ccode\x3eAPI\x3c\/code\x3e 文档\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e对 \x3ccode\x3eAPI\x3c\/code\x3e 技术演化保持关注\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e1. 正确使用 HTTP Method 和路由\x3c\/h2\x3e\n\x3cp\x3e试想你正要构建一个 \x3ccode\x3eAPI\x3c\/code\x3e 用来创建、更新、获取、删除用户，对于这些操作，\x3ccode\x3eHTTP\x3c\/code\x3e 规范里面已经有了现成的操作：\x3ccode\x3ePOST\x3c\/code\x3e、\x3ccode\x3ePUT\x3c\/code\x3e、\x3ccode\x3eGET\x3c\/code\x3e、\x3ccode\x3eDELETE\x3c\/code\x3e，建议直接使用他们来描述接口的行为。\x3c\/p\x3e\n\x3cp\x3e至于路由的命名，应该使用名词或名词性短语来作为资源标识符，比如上文提到的用户管理的例子，路由就应该长这样：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3ePOST \/users\x3c\/code\x3e 或者 \x3ccode\x3ePUT \/users\/:id\x3c\/code\x3e 用来创建新用户；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eGET \/users\x3c\/code\x3e 用来获取用户列表；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eGET \/users\/:id\x3c\/code\x3e 用来获取单个用户；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3ePATCH \/users\/:id\x3c\/code\x3e 用来更新用户信息；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eDELETE \/users\/:id\x3c\/code\x3e 用来删除用户；\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e2. 正确的使用 \x3ccode\x3eHTTP\x3c\/code\x3e 状态码\x3c\/h2\x3e\n\x3cp\x3e如果服务器端在请求处理的过程中出错了，你必须设置正确的响应状态码，具体如下：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3e2xx\x3c\/code\x3e，表示一切正常；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3e3xx\x3c\/code\x3e，表示资源位置已经更改；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3e4xx\x3c\/code\x3e，表示因为客户端错误而导致请求无法被处理，比如参数校验没通过；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3e5xx\x3c\/code\x3e，表示因为服务器错误导致请求无法被处理，比如服务端抛了异常；\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e如果你使用 \x3ccode\x3eexpress\x3c\/code\x3e，设置状态码非常简单：\x3ccode\x3eres.status(500).send({ error: \x27Internal server error happend\x27 })\x3c\/code\x3e，如果使用了 \x3ccode\x3erestify\x3c\/code\x3e，也是类似的：\x3ccode\x3eres.status(201)\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e如果想看完整的 \x3ccode\x3eHTTP\x3c\/code\x3e 状态码，\x3ca href=\x22https:\/\/en.wikipedia.org\/wiki\/List_of_HTTP_status_codes\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e点击这里\x3c\/a\x3e。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e3. 使用 \x3ccode\x3eHTTP Header\x3c\/code\x3e 来发送元数据\x3c\/h2\x3e\n\x3cp\x3e如果想要发送关于响应体数据的元数据，可以使用 \x3ccode\x3eHeader\x3c\/code\x3e ，\x3ccode\x3eHeader\x3c\/code\x3e 可以包含的常见元数据包括如下几类：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e分页信息；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e频率限制信息；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e认证信息；\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e如果你需要在 \x3ccode\x3eHeader\x3c\/code\x3e 中发送自定义的元数据，最好的做法是在 \x3ccode\x3eHeader\x3c\/code\x3e 名称前面加 \x3ccode\x3eX\x3c\/code\x3e，例如，需要发送 \x3ccode\x3eCSRF Token\x3c\/code\x3e 的时候，实际的 \x3ccode\x3eHeader\x3c\/code\x3e 应该命名为：\x3ccode\x3eX-CSRF-Token\x3c\/code\x3e，然而，这种 \x3ccode\x3eHeader\x3c\/code\x3e 在 \x3ca href=\x22https:\/\/tools.ietf.org\/html\/rfc6648\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eRFC 6648\x3c\/a\x3e 中已经被废弃了。API 在设置自定义 \x3ccode\x3eHeader\x3c\/code\x3e 的时候还要尽可能避免命名冲突，比如为了达到这个目的\x3ccode\x3eOpenStack\x3c\/code\x3e 为所有 API  的自定义 \x3ccode\x3eHeader\x3c\/code\x3e 都加上了 \x3ccode\x3eOpenStack\x3c\/code\x3e 的前缀：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22OpenStack-Identity-Account-ID  \nOpenStack-Networking-Host-Name  \nOpenStack-Object-Storage-Policy  \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs delphi\x22\x3e\x3ccode\x3eOpenStack-Identity-Account-ID  \nOpenStack-Networking-Host-\x3cspan class=\x22hljs-keyword\x22\x3eName\x3c\/span\x3e  \nOpenStack-\x3cspan class=\x22hljs-keyword\x22\x3eObject\x3c\/span\x3e-Storage-Policy  \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e需要注意的是，虽然 HTTP 规范中没有规定 \x3ccode\x3eHeader\x3c\/code\x3e 的大小，但是 Node.js 中 \x3ccode\x3eHeader\x3c\/code\x3e 的大小被限制在了 \x3ccode\x3e80KB\x3c\/code\x3e。官方原文如下：\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e不要让 HTTP \x3ccode\x3eHeader\x3c\/code\x3e ，包括其中状态码那行的整体大小超过 HTTP_MAX_Header_SIZE，这样做的目的是为了防御基于 \x3ccode\x3eHeader\x3c\/code\x3e 的 \x3ccode\x3eDDOS\x3c\/code\x3e 攻击。\x3ca href=\x22https:\/\/github.com\/nodejs\/node\/blob\/db1087c9757c31a82c50a1eba368d8cba95b57d0\/deps\/http_parser\/http_parser.c#L143\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e点击这里\x3c\/a\x3e\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e4. 为 REST API 挑选合适的框架\x3c\/h2\x3e\n\x3cp\x3e根据你的实际场景挑选合适的框架是非常重要的，\x3ccode\x3eNode.js\x3c\/code\x3e 中的框架大致介绍如下：\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3eExpress、Koa、HAPI\x3c\/h3\x3e\n\x3cp\x3e\x3ca href=\x22http:\/\/expressjs.com\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eExpress\x3c\/a\x3e、\x3ca href=\x22http:\/\/koajs.com\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eKoa\x3c\/a\x3e、\x3ca href=\x22http:\/\/hapijs.com\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eHAPI\x3c\/a\x3e 主要是用来构建浏览器 \x3ccode\x3eWEB\x3c\/code\x3e 应用，因为他们都支持服务端模板渲染，虽然这只是他们众多功能中的一个。如果你的应用需要提供用户界面，那么这三个就是不错的选择。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3eRestify\x3c\/h3\x3e\n\x3cp\x3e而 \x3ca href=\x22http:\/\/restify.com\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eRestify\x3c\/a\x3e 是专门用来创建符合 \x3ccode\x3eREST\x3c\/code\x3e 规范的服务的，他诞生的目的就是帮你构建严格意义上的、可维护的 \x3ccode\x3eAPI\x3c\/code\x3e 服务。\x3ccode\x3eRestify\x3c\/code\x3e 内置了所有请求处理函数的 \x3ca href=\x22http:\/\/dtrace.org\/blogs\/about\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eDTrace\x3c\/a\x3e 支持。并且已经被 \x3ca href=\x22https:\/\/npmjs.com\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3enpm\x3c\/a\x3e 和 \x3ca href=\x22https:\/\/netflix.com\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3enetflix\x3c\/a\x3e 用来在生产环境提供重要的服务。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3e5. 要对 API 进行黑盒测试\x3c\/h2\x3e\n\x3cp\x3e测试 \x3ccode\x3eAPI\x3c\/code\x3e 的最好办法是对他们进行黑盒测试，黑盒测试是一种不关心应用内部结构和工作原理的测试方法，测试时系统任何部分都不应该被 \x3ccode\x3emock\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/www.npmjs.com\/package\/supertest\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3esupertest\x3c\/a\x3e 是可以用来对接口进行黑盒测试的模块之一，下面是基于测试框架 \x3ca href=\x22https:\/\/mochajs.org\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3emocha\x3c\/a\x3e 编写的一个测试用例，该用例的目的是检查接口是否能返回单条的用户数据：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const request = require(\x27supertest\x27)\n\ndescribe(\x27GET \/user\/:id\x27, function() {\n  it(\x27returns a user\x27, function() {\n    \/\/ newer mocha versions accepts promises as well\n    return request(app)\n      .get(\x27\/user\x27)\n      .set(\x27Accept\x27, \x27application\/json\x27)\n      .expect(200, {\n        id: \x271\x27,\n        name: \x27John Math\x27\n      }, done);\n  });\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs qml\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e request = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27supertest\x27\x3c\/span\x3e)\n\ndescribe(\x3cspan class=\x22hljs-string\x22\x3e\x27GET \/user\/:id\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  it(\x3cspan class=\x22hljs-string\x22\x3e\x27returns a user\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ newer mocha versions accepts promises as well\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e request(app)\n      .get(\x3cspan class=\x22hljs-string\x22\x3e\x27\/user\x27\x3c\/span\x3e)\n      .set(\x3cspan class=\x22hljs-string\x22\x3e\x27Accept\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27application\/json\x27\x3c\/span\x3e)\n      .expect(\x3cspan class=\x22hljs-number\x22\x3e200\x3c\/span\x3e, {\n        \x3cspan class=\x22hljs-attribute\x22\x3eid:\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e \x271\x27,\n        name\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27John Math\x27\x3c\/span\x3e\n      }, done);\n  });\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可能有人会问：\x3ccode\x3eAPI\x3c\/code\x3e 服务所连接的数据库里面的数据是如何写进去的呢？\x3c\/p\x3e\n\x3cp\x3e通常来说，你写测试的时候，要尽可能不对系统状态做假设，然而在某些场景下，你需要准确的知道系统当前所处的状态以增加更多的断言来提高测试覆盖率。如果你有这种需求，你可以试用如下的方法对数据库进行预填充：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e选择生产环境数据的子集来运行黑盒测试；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e运行黑盒测试之前把手工构造的数据填充到数据库中。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e此外，有了黑盒测试并不意味着不需要单元测试，针对 \x3ccode\x3eAPI\x3c\/code\x3e 的\x3ca href=\x22https:\/\/blog.risingstack.com\/node-hero-node-js-unit-testing-tutorial\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e单元测试\x3c\/a\x3e还是需要编写的。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3e6. 使用基于 JWT 的无状态的认证机制\x3c\/h2\x3e\n\x3cp\x3e因为 \x3ccode\x3eRest API\x3c\/code\x3e 必须是无状态的，因此认证机制也需要是无状态的，而基于 \x3ccode\x3eJWT（JSON Web Token）\x3c\/code\x3e 的认证机制是无状态认证机制中的最佳解决方案。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eJWT\x3c\/code\x3e 的认证机制包含三部分：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eHeader\x3c\/code\x3e：包含 \x3ccode\x3etoken\x3c\/code\x3e 的类型和哈希算法；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3epayload\x3c\/code\x3e：包含声明信息；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3esignature\x3c\/code\x3e：\x3ccode\x3eJWT\x3c\/code\x3e 实际上并不是对 \x3ccode\x3epayload\x3c\/code\x3e 进行加密，只是对其做了签名；\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e为 \x3ccode\x3eAPI\x3c\/code\x3e 添加基于 \x3ccode\x3eJWT\x3c\/code\x3e 的认证机制也非常的简单，比如下面的代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const koa = require(\x27koa\x27);\nconst jwt = require(\x27koa-jwt\x27);\n\nconst app = koa();\n\napp.use(jwt(\n  secret: \x27very-secret\x27\n}));\n\n\/\/ Protected middleware\napp.use(function*() \n  \/\/ content of the token will be available on this.state.user\n  this.body = { secret: \x2742\x27 }\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs php\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e koa = \x3cspan class=\x22hljs-keyword\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27koa\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e jwt = \x3cspan class=\x22hljs-keyword\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27koa-jwt\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e app = koa();\n\napp.\x3cspan class=\x22hljs-keyword\x22\x3euse\x3c\/span\x3e(jwt(\n  secret: \x3cspan class=\x22hljs-string\x22\x3e\x27very-secret\x27\x3c\/span\x3e\n}));\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Protected middleware\x3c\/span\x3e\napp.\x3cspan class=\x22hljs-keyword\x22\x3euse\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e*\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \n  \/\/ \x3cspan class=\x22hljs-title\x22\x3econtent\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eof\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ethe\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3etoken\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ewill\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ebe\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eavailable\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eon\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ethis\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3estate\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3euser\x3c\/span\x3e\n  \x3cspan class=\x22hljs-title\x22\x3ethis\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3ebody\x3c\/span\x3e = \x3c\/span\x3e{ secret: \x3cspan class=\x22hljs-string\x22\x3e\x2742\x27\x3c\/span\x3e }\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e有了如上的代码，你的 \x3ccode\x3eAPI\x3c\/code\x3e 就有了 \x3ccode\x3eJWT\x3c\/code\x3e 的保护。如果要访问这种被保护的接口，需要使用 \x3ccode\x3eAuthorization Header\x3c\/code\x3e 来提供 \x3ccode\x3etoken\x3c\/code\x3e，比如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22curl --Header \x26quot;Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ\x26quot; my-website.com  \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs css\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3ecurl\x3c\/span\x3e \x3cspan class=\x22hljs-selector-tag\x22\x3e--Header\x3c\/span\x3e \x22\x3cspan class=\x22hljs-selector-tag\x22\x3eAuthorization\x3c\/span\x3e: \x3cspan class=\x22hljs-selector-tag\x22\x3eBearer\x3c\/span\x3e \x3cspan class=\x22hljs-selector-tag\x22\x3eeyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ\x3c\/span\x3e\x22 \x3cspan class=\x22hljs-selector-tag\x22\x3emy-website\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.com\x3c\/span\x3e  \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e你可能注意到了，\x3ccode\x3eJWT\x3c\/code\x3e 模块并不依赖任何数据存储层，这是因为 \x3ccode\x3etoken\x3c\/code\x3e 本身是可以单独被校验的，\x3ccode\x3etoken\x3c\/code\x3e 里面的 \x3ccode\x3epayload\x3c\/code\x3e 甚至可以包含 \x3ccode\x3etoken\x3c\/code\x3e 的签名时间、有效期限。\x3c\/p\x3e\n\x3cp\x3e此外，你还需要确保，所有的 \x3ccode\x3eAPI\x3c\/code\x3e 接口只能通过更安全的 \x3ccode\x3eHTTPS\x3c\/code\x3e 链接来访问。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3e7. 学会使用条件请求机制\x3c\/h2\x3e\n\x3cp\x3e条件请求机制是基于不同的 \x3ccode\x3eHeader\x3c\/code\x3e 表现出不同的行为的机制，可以认为这些 \x3ccode\x3eHeader\x3c\/code\x3e 就是请求处理方式的先决条件，如果条件满足，请求处理方式就会有所不同。\x3c\/p\x3e\n\x3cp\x3e可以利用这些 \x3ccode\x3eHeader\x3c\/code\x3e 检测服务器上的资源版本是否匹配特定的资源版本，这些 \x3ccode\x3eHeader\x3c\/code\x3e 的取值可以是如下的内容：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e资源的最后修改时间；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e资源的标签（随资源变化而变化）；\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e具体来说：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eLast-Modified\x3c\/code\x3e：标识资源的最新修改时间；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eEtag\x3c\/code\x3e：标识资源的标签；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eIf-Modified-Since\x3c\/code\x3e：结合 \x3ccode\x3eLast-Modified Header\x3c\/code\x3e 使用；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eIf-Non-Match\x3c\/code\x3e：结合 \x3ccode\x3eEtag\x3c\/code\x3e 使用；\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e下面来看一个实际的例子：\x3c\/p\x3e\n\x3cp\x3e客户端不知道 \x3ccode\x3edoc\x3c\/code\x3e 资源的任何版本，所以请求时即不能提供 \x3ccode\x3eIf-Modified-Since\x3c\/code\x3e，也不能提供 \x3ccode\x3eIf-Non-Match\x3c\/code\x3e 两个 Header，然后服务端在响应中会增加 \x3ccode\x3eEtag\x3c\/code\x3e 和 \x3ccode\x3eLast-Modified\x3c\/code\x3e 两个 \x3ccode\x3eHeader\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000008537715\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000008537715\x22 alt=\x22nodejs-resftul-api-with-conditional-request-without-previous-versions.png\x22 title=\x22nodejs-resftul-api-with-conditional-request-without-previous-versions.png\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e接下来，客户端再次请求相同的资源的时候，就可以带上 \x3ccode\x3eIf-Modified-Since\x3c\/code\x3e 和 \x3ccode\x3eIf-Non-Match\x3c\/code\x3e 这两个 \x3ccode\x3eHeader\x3c\/code\x3e 了，然后如果服务器端会检查资源是否修改，如果没有修改，直接返回 \x3ccode\x3e304 - Not Modified\x3c\/code\x3e 状态码，而不重复发送资源的内容。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000008537716\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000008537716\x22 alt=\x22nodejs-resftul-api-with-conditional-request-with-previous-versions.png\x22 title=\x22nodejs-resftul-api-with-conditional-request-with-previous-versions.png\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader9\x22\x3e8. 拥抱接口调用频率限制（Rate-Limiting）\x3c\/h2\x3e\n\x3cp\x3e频率限制是用来控制调用方有对接口发起请求的次数，为了让你的 \x3ccode\x3eAPI\x3c\/code\x3e 用户知道他们还剩下多少余额，可以设置下面的 \x3ccode\x3eHeader\x3c\/code\x3e：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eX-Rate-Limit-Limit：特定时间段内允许的最多请求次数；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eX-Rate-Limit-Remaining：特定时间段内剩余的请求次数；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eX-Rate-Limit-Reset：什么时候请求频率限制次数会重置；\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e大多数的 \x3ccode\x3eWEB\x3c\/code\x3e 框架都支持上面这些 \x3ccode\x3eHeader\x3c\/code\x3e，如果内置不支持，也可以找到插件来支持，比如，如果你使用了 \x3ccode\x3ekoa\x3c\/code\x3e，可以使用 \x3ca href=\x22https:\/\/github.com\/koajs\/ratelimit\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ekoa-rate-limit\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3e需要注意的是，不同的 \x3ccode\x3eAPI\x3c\/code\x3e 服务提供商频率限制的时间窗差异会很大，比如 \x3ccode\x3eGitHub\x3c\/code\x3e 是 60 分钟，而 \x3ccode\x3eTwitter\x3c\/code\x3e 是 15 分钟。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader10\x22\x3e9. 编写良好的 API 文档\x3c\/h2\x3e\n\x3cp\x3e编写 \x3ccode\x3eAPI\x3c\/code\x3e 的目的当然是让别人使用并受益，提供良好的接口文档至关重要。下面这两个开源项目可以帮你创建 \x3ccode\x3eAPI\x3c\/code\x3e 文档：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/apiblueprint.org\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eAPI Blueprint\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/swagger.io\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eSwagger\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e如果你愿意使用第三方文档服务商，可以考虑 \x3ca href=\x22https:\/\/apiary.io\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eApiary\x3c\/a\x3e。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader11\x22\x3e10. 对 API 技术演化保持关注\x3c\/h2\x3e\n\x3cp\x3e过去几年中，\x3ccode\x3eAPI\x3c\/code\x3e 技术方案领域出现了两种新的查询语言，分别是 \x3ccode\x3eFacebook\x3c\/code\x3e 的 \x3ccode\x3eGraphQL\x3c\/code\x3e 和 \x3ccode\x3eNetflix\x3c\/code\x3e 的 \x3ccode\x3eFalcor\x3c\/code\x3e，为什么需要他们呢？\x3c\/p\x3e\n\x3cp\x3e试想这种 API 接口请求：\x3ccode\x3e\/org\/1\/space\/2\/docs\/1\/collaborators?include=email\x26amp;page=1\x26amp;limit=10\x3c\/code\x3e，类似的情况会让 API 很快失控，如果你希望所有接口能返回类似的响应格式，那么 \x3ccode\x3eGraphQL\x3c\/code\x3e 和 \x3ccode\x3eFalcor\x3c\/code\x3e 就能帮你解决这个问题。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e关于 GraphQL\x3c\/strong\x3e：\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3eGraphQL 是一种用于 API 的查询语言，也是一种基于现有数据处理数据查询的运行时。GraphQL 为您的 API 中的数据提供了一个完整和可理解的描述，使用户能够准确地询问他们需要什么，使得随着时间推移的 API 演化更容易，GraphQL 还有强大的开发工具支持。 到\x3ca href=\x22http:\/\/graphql.org\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e这里\x3c\/a\x3e阅读更多。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e\x3cstrong\x3e关于 Falcor\x3c\/strong\x3e：\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3eFalcor 是支撑着 Netflix UI 的创新数据平台。Falcor 允许你将所有后端数据建模为 Node.js 服务商的单个虚拟 JSON 对象。在客户端可以使用熟悉的 JavaScript 操作、处理远程JSON对象。如果你知道你的数据，你就知道你的 API 长啥样。 到\x3ca href=\x22https:\/\/netflix.github.io\/falcor\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e这里\x3c\/a\x3e阅读更多。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader12\x22\x3e能带来灵感的优秀 API 设计\x3c\/h2\x3e\n\x3cp\x3e如果你正在开发 \x3ccode\x3eRest API\x3c\/code\x3e 或者准备改进老版本的 \x3ccode\x3eAPI\x3c\/code\x3e，这里收集了几个在线上提供服务、设计优秀并且非常直接借鉴的 \x3ccode\x3eAPI\x3c\/code\x3e：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/developer.github.com\/v3\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eGitHub API\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/www.twilio.com\/docs\/api\/rest\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eTwilio API\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/stripe.com\/docs\/api\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eStripe API\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/developers.digitalocean.com\/documentation\/v2\/#introduction\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eDigital Ocean API\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e希望读到这里的同学对如何用 \x3ccode\x3eNode.js\x3c\/code\x3e 编写良好的 \x3ccode\x3eAPI\x3c\/code\x3e 有更好的理解，如果有建议，欢迎评论中提出。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader13\x22\x3eOne More Thing\x3c\/h3\x3e\n\x3cp\x3e想直接在微信中订阅前端周刊？扫下方二维码关注前端周刊订阅号。\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000008537717\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000008537717\x22 alt=\x22feweekly\x22 title=\x22feweekly\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e想和我面对面交流？扫下方二维码添加我为好友。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000008537718\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000008537718\x22 alt=\x22wangshijun\x22 title=\x22wangshijun\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3eHappy Hacking\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>编写 Node.js Rest API 的 10 个最佳实践</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000008537712">https://segmentfault.com/a/1190000008537712</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/pxekxeyhxw/" target="_blank">https://alili.tech/archive/pxekxeyhxw/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>