<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="Vue2 源码分析"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>Vue2 源码分析 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/cdzt7kpd40l/",
				"appid": "1613049289050283", 
				"title": "Vue2 源码分析 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-26T02:30:18"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/us8olg5mpy/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/coi5anwwocw/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fcdzt7kpd40l%2f&text=Vue2%20%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fcdzt7kpd40l%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fcdzt7kpd40l%2f&text=Vue2%20%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fcdzt7kpd40l%2f&title=Vue2%20%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fcdzt7kpd40l%2f&is_video=false&description=Vue2%20%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=Vue2%20%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fcdzt7kpd40l%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fcdzt7kpd40l%2f&title=Vue2%20%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fcdzt7kpd40l%2f&title=Vue2%20%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fcdzt7kpd40l%2f&title=Vue2%20%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fcdzt7kpd40l%2f&title=Vue2%20%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">Vue2 源码分析</h1><div class="meta"><div class="postdate"><time datetime="2019-01-26" itemprop="datePublished">2019-01-26</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e源码版本：\x3ca href=\x22https:\/\/github.com\/vuejs\/vue\/tree\/v2.1.10\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ev2.1.10\x3c\/a\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e分析目标\x3c\/h2\x3e\n\x3cp\x3e通过阅读源码，对 Vue2 的基础运行机制有所了解，主要是：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eVue2 中数据绑定的实现方式\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eVue2 中对 Virtual DOM 机制的使用方式\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e源码初见\x3c\/h2\x3e\n\x3cp\x3e项目构建配置文件为 \x3ccode\x3ebuild\/config.js\x3c\/code\x3e，定位 vue.js 对应的入口文件为 \x3ccode\x3esrc\/entries\/web-runtime-with-compiler.js\x3c\/code\x3e，基于 \x3ca href=\x22http:\/\/rollupjs.org\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3erollup\x3c\/a\x3e 进行模块打包。\x3c\/p\x3e\n\x3cp\x3e代码中使用 \x3ca href=\x22https:\/\/flowtype.org\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eflow\x3c\/a\x3e 进行接口类型标记和检查，在打包过程中移除这些标记。为了阅读代码方便，在  VS Code 中安装了插件 \x3ca href=\x22https:\/\/marketplace.visualstudio.com\/items?itemName=flowtype.flow-for-vscode\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eFlow Language Support\x3c\/a\x3e，然后关闭工作区 JS 代码检查，这样界面就清爽很多了。\x3c\/p\x3e\n\x3cp\x3eVue 应用启动一般是通过 \x3ccode\x3enew Vue({...})\x3c\/code\x3e，所以，先从该构造函数着手。\x3c\/p\x3e\n\x3cp\x3e注：本文只关注 Vue 在浏览器端的应用，不涉及服务器端代码。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3eVue 构造函数\x3c\/h2\x3e\n\x3cp\x3e文件：\x3ccode\x3esrc\/core\/instance\/index.js\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e该文件只是构造函数，Vue 原型对象的声明分散在当前目录的多个文件中：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3einit.js：\x3ccode\x3e._init()\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3estate.js：\x3ccode\x3e.$data\x3c\/code\x3e \x3ccode\x3e.$set()\x3c\/code\x3e \x3ccode\x3e.$delete()\x3c\/code\x3e \x3ccode\x3e.$watch()\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3erender.js：\x3ccode\x3e._render()\x3c\/code\x3e ...\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eevents.js：\x3ccode\x3e.$on()\x3c\/code\x3e \x3ccode\x3e.$once()\x3c\/code\x3e \x3ccode\x3e.$off()\x3c\/code\x3e \x3ccode\x3e.$emit()\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3elifecycle.js：\x3ccode\x3e._mount()\x3c\/code\x3e \x3ccode\x3e._update()\x3c\/code\x3e \x3ccode\x3e.$forceUpdate()\x3c\/code\x3e \x3ccode\x3e.$destroy()\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e构造函数接收参数 \x3ccode\x3eoptions\x3c\/code\x3e ，然后调用 \x3ccode\x3ethis._init(options)\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3e._init()\x3c\/code\x3e 中进行初始化，其中会依次调用 lifecycle、events、render、state 模块中的初始化函数。\x3c\/p\x3e\n\x3cp\x3eVue2 中应该是为了代码更易管理，Vue 类的定义分散到了上面的多个文件中。\x3c\/p\x3e\n\x3cp\x3e其中，对于 \x3ccode\x3eVue.prototype\x3c\/code\x3e 对象的定义，通过 mixin 的方式在入口文件 \x3ccode\x3ecore\/index.js\x3c\/code\x3e 中依次调用。对于实例对象（代码中通常称为 \x3ccode\x3evm\x3c\/code\x3e）则通过 init 函数在 \x3ccode\x3evm._init()\x3c\/code\x3e 中依次调用。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3eVue 公共接口\x3c\/h2\x3e\n\x3cp\x3e文件：\x3ccode\x3esrc\/core\/index.js\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e这里调用了 \x3ccode\x3einitGlobalAPI()\x3c\/code\x3e 来初始化 Vue 的公共接口，包括：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eVue.util\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eVue.set\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eVue.delete\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eVue.nextTick\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eVue.options\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eVue.use\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eVue.mixin\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eVue.extend\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3easset相关接口：配置在 \x3ccode\x3esrc\/core\/config.js\x3c\/code\x3e 中\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3eVue 启动过程\x3c\/h2\x3e\n\x3cp\x3e调用 \x3ccode\x3enew Vue({...})\x3c\/code\x3e 后，在内部的 \x3ccode\x3e._init()\x3c\/code\x3e 的最后，是调用 \x3ccode\x3e.$mount()\x3c\/code\x3e 方法来“启动”。\x3c\/p\x3e\n\x3cp\x3e在 \x3ccode\x3eweb-runtime-with-compiler.js\x3c\/code\x3e 和 \x3ccode\x3eweb-runtime.js\x3c\/code\x3e 中，定义了 \x3ccode\x3eVue.prototype.$mount()\x3c\/code\x3e。不过两个文件中的 \x3ccode\x3e$mount()\x3c\/code\x3e 最终调用的是 \x3ccode\x3e._mount()\x3c\/code\x3e 内部方法，定义在文件 \x3ccode\x3esrc\/core\/instance\/lifecycle.js\x3c\/code\x3e 中。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3eVue.prototype._mount(el, hydrating)\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e简化逻辑后的伪代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22vm = this\nvm._watcher = new Watcher(vm, updateComponent)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3evm = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e\nvm._watcher = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Watcher(vm, updateComponent)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e接下来看 \x3ccode\x3eWatcher\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3eWatcher\x3c\/h2\x3e\n\x3cp\x3e文件：\x3ccode\x3esrc\/core\/observer\/watcher.js\x3c\/code\x3e \x3c\/p\x3e\n\x3cp\x3e先看构造函数的简化逻辑：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 参数：vm, expOrFn, cb, options\nthis.vm = vm\nvm._watchers.push(this)\n\/\/ 解析 options，略....\n\/\/ 属性初始化，略....\nthis.getter = expOrFn \/\/ if `function`\nthis.value = this.lazy ? undefined : this.get()\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 参数：vm, expOrFn, cb, options\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.vm = vm\nvm._watchers.push(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 解析 options，略....\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 属性初始化，略....\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getter = expOrFn \x3cspan class=\x22hljs-comment\x22\x3e\/\/ if `function`\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.value = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.lazy ? \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e : \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.get()\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e由于缺省的 \x3ccode\x3elazy\x3c\/code\x3e 属性值为 \x3ccode\x3efalse\x3c\/code\x3e，接着看 \x3ccode\x3e.get()\x3c\/code\x3e 的逻辑：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22pushTarget(this) \/\/ !\nvalue = this.getter.call(this.vm, this.vm)\npopTarget()\nthis.cleanupDeps()\nreturn value\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3epushTarget(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ !\x3c\/span\x3e\nvalue = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getter.call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.vm, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.vm)\npopTarget()\n\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.cleanupDeps()\n\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e value\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e先看这里对 \x3ccode\x3egetter\x3c\/code\x3e 的调用，返回到 \x3ccode\x3e._mount()\x3c\/code\x3e 中，可以看到，是调用了 \x3ccode\x3evm._update(vm._render(), hydrating)\x3c\/code\x3e，涉及两个方法：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3evm._render()：返回虚拟节点（VNode）\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3evm._update()\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e来看 \x3ccode\x3e_update()\x3c\/code\x3e 的逻辑，这里应该是进行 Virtual DOM 的更新：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 参数：vnode, hydrating\nvm = this\nprevEl = vm.$el\nprevVnode = vm._vnode\nprevActiveInstance = activeInstance\nactiveInstance = vm\nvm._vnode = vnode\nif (!prevVnode) {\n  \/\/ 初次加载\n  vm.$el = vm.__patch__(vm.$el, vnode, ...)\n} else {\n  \/\/ 更新\n  vm.$el = vm.__patch__(prevVnode, vnode)\n}\nactiveInstance = prevActiveInstance\n\/\/ 后续属性配置，略....\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 参数：vnode, hydrating\x3c\/span\x3e\nvm = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e\nprevEl = vm.$el\nprevVnode = vm._vnode\nprevActiveInstance = activeInstance\nactiveInstance = vm\nvm._vnode = vnode\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!prevVnode) {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 初次加载\x3c\/span\x3e\n  vm.$el = vm.__patch__(vm.$el, vnode, ...)\n} \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 更新\x3c\/span\x3e\n  vm.$el = vm.__patch__(prevVnode, vnode)\n}\nactiveInstance = prevActiveInstance\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 后续属性配置，略....\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e参考 Virtual DOM 的一般逻辑，这里是差不多的处理过程，不再赘述。\x3c\/p\x3e\n\x3cp\x3e综上，这里的 watcher 主要作用应该是在数据发生变更时，触发重新渲染和更新视图的处理：\x3ccode\x3evm._update(vm._render())\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e接下来，我们看下 watcher 是如何发挥作用的，参考 Vue 1.0 的经验，下面应该是关于依赖收集、数据绑定方面的细节了，而这一部分，和 Vue 1.0 差别不大。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3e数据绑定\x3c\/h2\x3e\n\x3cp\x3e\x3ccode\x3ewatcher.get()\x3c\/code\x3e 中调用的 \x3ccode\x3epushTarget()\x3c\/code\x3e 和 \x3ccode\x3epopTarget()\x3c\/code\x3e 来自文件：\x3ccode\x3esrc\/core\/observer\/dep.js\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3epushTarget()\x3c\/code\x3e 和 \x3ccode\x3epopTarget()\x3c\/code\x3e 两个方法，用于处理 \x3ccode\x3eDep.target\x3c\/code\x3e，显然 \x3ccode\x3eDep.target\x3c\/code\x3e 在 \x3ccode\x3ewather.getter\x3c\/code\x3e 的调用过程中会用到，调用时会涉及到依赖收集，从而建立起数据绑定的关系。\x3c\/p\x3e\n\x3cp\x3e在 \x3ccode\x3eDep\x3c\/code\x3e 类的 \x3ccode\x3e.dep()\x3c\/code\x3e 方法中用到了 \x3ccode\x3eDep.target\x3c\/code\x3e，调用方式为：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Dep.target.addDep(this)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3eDep.target.addDep(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可以想见，在使用数据进行渲染的过程中，会对数据属性进行“读”操作，从而触发 \x3ccode\x3edep.depend()\x3c\/code\x3e，进而收集到这个依赖关系。下面来找一下这样的调用的位置。\x3c\/p\x3e\n\x3cp\x3e在 \x3ccode\x3estate.js\x3c\/code\x3e 中找到一处，\x3ccode\x3emakeComputedGetter()\x3c\/code\x3e 函数中通过 \x3ccode\x3ewatcher.depend()\x3c\/code\x3e 间接调用了 \x3ccode\x3edep.depend()\x3c\/code\x3e。不过 computedGetter 应该不是最主要的地方，根据 Vue 1.0 的经验，还是要找对数据进行“数据劫持”的地方，应该是\x3ccode\x3edefineReactive()\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3edefineReactive()\x3c\/code\x3e 定义在文件 \x3ccode\x3esrc\/core\/observer\/index.js\x3c\/code\x3e。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 参数：obj, key, val, customSetter?\ndep = new Dep()\nchildOb = observe(val)\nObject.defineProperty(obj, key, {\n  enumerable: true,\n  configurable: true,\n  get: function () {\n    \/\/ 略，调用了 dep.depend()\n  },\n  set: function () {\n    \/\/ 略，调用 dep.notify()\n  }\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 参数：obj, key, val, customSetter?\x3c\/span\x3e\ndep = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Dep()\nchildOb = observe(val)\n\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperty(obj, key, {\n  \x3cspan class=\x22hljs-attr\x22\x3eenumerable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3econfigurable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3eget\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 略，调用了 dep.depend()\x3c\/span\x3e\n  },\n  \x3cspan class=\x22hljs-attr\x22\x3eset\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 略，调用 dep.notify()\x3c\/span\x3e\n  }\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e结合 Vue 1.0 经验，这里应该就是数据劫持的关键了。数据原有的属性被重新定义，属性的 \x3ccode\x3eget()\x3c\/code\x3e 被调用时，会通过 \x3ccode\x3edep.depend()\x3c\/code\x3e 收集依赖关系，记录到 vm 中；而在 \x3ccode\x3eset()\x3c\/code\x3e 被调用时，则会判断属性值是否发生变更，如果发生变更，则通过 \x3ccode\x3edep.notify()\x3c\/code\x3e 来通知 vm，从而触发 vm 的更新操作，实现 UI 与数据的同步，这也就是数据绑定后的效果了。\x3c\/p\x3e\n\x3cp\x3e回过头来看 \x3ccode\x3estate.js\x3c\/code\x3e，是在 \x3ccode\x3einitProps()\x3c\/code\x3e 中调用了 \x3ccode\x3edefineReactive()\x3c\/code\x3e。而 \x3ccode\x3einitProps()\x3c\/code\x3e 在 \x3ccode\x3einitState()\x3c\/code\x3e 中调用，后者则是在 \x3ccode\x3eVue.prototype._init()\x3c\/code\x3e 中被调用。\x3c\/p\x3e\n\x3cp\x3e不过最常用的其实是在 \x3ccode\x3einitData()\x3c\/code\x3e 中，对初始传入的 \x3ccode\x3edata\x3c\/code\x3e 进行劫持，不过里面的过程稍微绕一些，是将这里的 data 赋值到 \x3ccode\x3evm._data\x3c\/code\x3e 并且代理到了 \x3ccode\x3evm\x3c\/code\x3e 上，进一步的处理还涉及 \x3ccode\x3eobserve()\x3c\/code\x3e 和 \x3ccode\x3eObserver\x3c\/code\x3e 类。这里不展开了。\x3c\/p\x3e\n\x3cp\x3e综上，数据绑定的实现过程为：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e初始化：new Vue() -\x26gt; vm._init()\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e数据劫持：initState(vm) -\x26gt; initProps(), initData() -\x26gt; dep.depend()\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e依赖收集：vm.$mount() -\x26gt; vm._mount() -\x26gt; new Watcher() -\x26gt; vm._render()\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3e渲染\x3c\/h2\x3e\n\x3cp\x3e首先来看 \x3ccode\x3einitRender()\x3c\/code\x3e，这里在 vm 上初始化了两个与创建虚拟元素相关的方法：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3evm._c()\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3evm.$createElement()\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e其内部实现都是调用 \x3ccode\x3ecreateElement()\x3c\/code\x3e，来自文件：\x3ccode\x3esrc\/core\/vdom\/create-element.js\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e而在 \x3ccode\x3erenderMixin()\x3c\/code\x3e 中初始化了 \x3ccode\x3eVue.prototype._render()\x3c\/code\x3e 方法，其中创建 vnode 的逻辑为：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22render = vm.$options.render\ntry {\n  vnode = render.call(vm._renderProxy, vm.$createElement)\n} catch (e) {\n  \/\/ ...\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3erender = vm.$options.render\n\x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n  vnode = render.call(vm._renderProxy, vm.$createElement)\n} \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e (e) {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里传入 \x3ccode\x3erender()\x3c\/code\x3e 是一个会返回 vnode 的函数。\x3c\/p\x3e\n\x3cp\x3e接下来看 \x3ccode\x3evm._update()\x3c\/code\x3e 的逻辑，这部分在前面有介绍，初次渲染时是通过调用 \x3ccode\x3evm.__patch__()\x3c\/code\x3e 来实现。那么 \x3ccode\x3evm.__patch__()\x3c\/code\x3e 是在哪里实现的呢？在 \x3ccode\x3e_update()\x3c\/code\x3e 代码中有句注释，提到：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    \/\/ Vue.prototype.__patch__ is injected in entry points\n    \/\/ based on the rendering backend used.\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Vue.prototype.__patch__ is injected in entry points\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ based on the rendering backend used.\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在文件 \x3ccode\x3eweb-runtime.js\x3c\/code\x3e 中，找到了：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Vue.prototype.__patch__ = inBrowser ? patch : noop\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3eVue.prototype.__patch__ = inBrowser ? patch : noop\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e显然示在浏览器环境下使用 \x3ccode\x3epatch()\x3c\/code\x3e，来自：\x3ccode\x3esrc\/platforms\/web\/runtime\/patch.js\x3c\/code\x3e，其实现是通过 \x3ccode\x3ecreatePatchFunction()\x3c\/code\x3e，来自文件 \x3ccode\x3esrc\/core\/vdom\/patch\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3eOK，以上线索都指向了 vdom 相关的模块，也就是说，显然是 vdom 也就是 Virtual DOM 参与了渲染和更新。\x3c\/p\x3e\n\x3cp\x3e不过还有个问题没有解决，那就是原始的字符串模块，是如何转成用于 Virtual DOM 创建的函数调用的呢？这里会有一个解析的过程。\x3c\/p\x3e\n\x3cp\x3e回到入口文件 \x3ccode\x3eweb-runtime-with-compiler.js\x3c\/code\x3e，在 \x3ccode\x3eVue.prototype.$mount()\x3c\/code\x3e 中，有一个关键的调用：\x3ccode\x3ecompileToFunctions(template, ...)\x3c\/code\x3e，\x3ccode\x3etemplate\x3c\/code\x3e 变量值为传入的参数解析得到的模板内容。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3e模板解析\x3c\/h2\x3e\n\x3cp\x3e文件：\x3ccode\x3esrc\/platforms\/web\/compiler\/index.js\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e函数 \x3ccode\x3ecompileToFunctions()\x3c\/code\x3e 的基本逻辑：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 参数：template, options?, vm?\nres = {}\ncompiled = compile(template, options)\nres.render = makeFunction(compiled.render)\n\/\/ 拷贝数组元素：\n\/\/ res.staticRenderFns \x3c= compiled.staticRenderFns\nreturn res\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 参数：template, options?, vm?\x3c\/span\x3e\nres = {}\ncompiled = compile(template, options)\nres.render = makeFunction(compiled.render)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 拷贝数组元素：\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ res.staticRenderFns \x26lt;= compiled.staticRenderFns\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e res\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里对模板进行了编译（\x3ccode\x3ecompile()\x3c\/code\x3e），最终返回了根据编译结果得到的 \x3ccode\x3erender()、staticRenderFns\x3c\/code\x3e。再看 \x3ccode\x3eweb-runtime-with-compiler.js\x3c\/code\x3e 中 \x3ccode\x3eVue.prototype.$mount()\x3c\/code\x3e 的逻辑，则是将这里得到的结果写入了 \x3ccode\x3evm.$options\x3c\/code\x3e 中，也就是说，后面 \x3ccode\x3evm._render()\x3c\/code\x3e 中会使用这里的 \x3ccode\x3erender()\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e再来看 \x3ccode\x3ecompile()\x3c\/code\x3e 函数，这里是实现模板解析的核心，来做文件 \x3ccode\x3esrc\/compiler\/index.js\x3c\/code\x3e，基本逻辑为：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 参数：template, options\nast = parse(template.trim(), options)\noptimize(ast, options)\ncode = generate(ast, options)\nreturn {\n  ast,\n  render: code.render,\n  staticRenderFns: code.staticRenderFns\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 参数：template, options\x3c\/span\x3e\nast = parse(template.trim(), options)\noptimize(ast, options)\ncode = generate(ast, options)\n\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n  ast,\n  \x3cspan class=\x22hljs-attr\x22\x3erender\x3c\/span\x3e: code.render,\n  \x3cspan class=\x22hljs-attr\x22\x3estaticRenderFns\x3c\/span\x3e: code.staticRenderFns\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e逻辑很清晰，首先从模板进行解析得到抽象语法树（ast），进行优化，最后生成结果代码。整个过程中肯定会涉及到 Vue 的语法，包括指令、组件嵌套等等，不仅仅是得到构建 Virtual DOM 的代码。\x3c\/p\x3e\n\x3cp\x3e需要注意的是，编译得到 render 其实是代码文本，通过 \x3ccode\x3enew Function(code)\x3c\/code\x3e 的方式转为函数。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader9\x22\x3e总结\x3c\/h2\x3e\n\x3cp\x3eVue2 相比 Vue1 一个主要的区别在于引入了 Virtual DOM，但其 MVVM 的特性还在，也就是说仍有一套数据绑定的机制。\x3c\/p\x3e\n\x3cp\x3e此外，Virtual DOM 的存在，使得原有的视图模板需要转变为函数调用的模式，从而在每次有更新时可以重新调用得到新的 vnode，从而应用 Virtual DOM 的更新机制。为此，Vue2 实现了编译器（compiler），这也意味着 Vue2 的模板可以是纯文本，而不必是 DOM 元素。\x3c\/p\x3e\n\x3cp\x3eVue2 基本运行机制总结为：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e文本模板，编译得到生成 vnode 的函数（render），该过程中会识别并记录 Vue 的指令和其他语法\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3enew Vue() 得到 vm 对象，其中传入的数据会进行数据劫持处理，从而可以收集依赖，实现数据绑定\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e渲染过程是将所有数据交由渲染函数（render）进行调用得到 vnode，应该 Virtual DOM 的机制实现初始渲染和更新\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader10\x22\x3e写在最后\x3c\/h2\x3e\n\x3cp\x3e对 Vue2 的源码分析，是基于我之前对 Vue1 的分析和对 Virtual DOM 的了解，见【链接】中之前的文章。\x3c\/p\x3e\n\x3cp\x3e水平有限，错漏难免，欢迎指正。\x3c\/p\x3e\n\x3cp\x3e感谢阅读！\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader11\x22\x3e链接\x3c\/h2\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/www.jianshu.com\/p\/d3a15a1f94a0\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eVue 双向数据绑定原理分析 - luobotang\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/www.jianshu.com\/p\/bef1c1ee5a0e\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e一起理解 Virtual DOM - luobotang\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>Vue2 源码分析</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000008488543">https://segmentfault.com/a/1190000008488543</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/cdzt7kpd40l/" target="_blank">https://alili.tech/archive/cdzt7kpd40l/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>