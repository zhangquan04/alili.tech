<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="理解ES6中的暂时死区(TDZ)"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>理解ES6中的暂时死区(TDZ) | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/b5ayrtvdtpe/",
				"appid": "1613049289050283", 
				"title": "理解ES6中的暂时死区(TDZ) | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-27T02:30:59"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/2ufst8il1y2/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/dq68sjinqlc/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fb5ayrtvdtpe%2f&text=%e7%90%86%e8%a7%a3ES6%e4%b8%ad%e7%9a%84%e6%9a%82%e6%97%b6%e6%ad%bb%e5%8c%ba%28TDZ%29"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fb5ayrtvdtpe%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fb5ayrtvdtpe%2f&text=%e7%90%86%e8%a7%a3ES6%e4%b8%ad%e7%9a%84%e6%9a%82%e6%97%b6%e6%ad%bb%e5%8c%ba%28TDZ%29"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fb5ayrtvdtpe%2f&title=%e7%90%86%e8%a7%a3ES6%e4%b8%ad%e7%9a%84%e6%9a%82%e6%97%b6%e6%ad%bb%e5%8c%ba%28TDZ%29"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fb5ayrtvdtpe%2f&is_video=false&description=%e7%90%86%e8%a7%a3ES6%e4%b8%ad%e7%9a%84%e6%9a%82%e6%97%b6%e6%ad%bb%e5%8c%ba%28TDZ%29"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e7%90%86%e8%a7%a3ES6%e4%b8%ad%e7%9a%84%e6%9a%82%e6%97%b6%e6%ad%bb%e5%8c%ba%28TDZ%29&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fb5ayrtvdtpe%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fb5ayrtvdtpe%2f&title=%e7%90%86%e8%a7%a3ES6%e4%b8%ad%e7%9a%84%e6%9a%82%e6%97%b6%e6%ad%bb%e5%8c%ba%28TDZ%29"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fb5ayrtvdtpe%2f&title=%e7%90%86%e8%a7%a3ES6%e4%b8%ad%e7%9a%84%e6%9a%82%e6%97%b6%e6%ad%bb%e5%8c%ba%28TDZ%29"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fb5ayrtvdtpe%2f&title=%e7%90%86%e8%a7%a3ES6%e4%b8%ad%e7%9a%84%e6%9a%82%e6%97%b6%e6%ad%bb%e5%8c%ba%28TDZ%29"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fb5ayrtvdtpe%2f&title=%e7%90%86%e8%a7%a3ES6%e4%b8%ad%e7%9a%84%e6%9a%82%e6%97%b6%e6%ad%bb%e5%8c%ba%28TDZ%29"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">理解ES6中的暂时死区(TDZ)</h1><div class="meta"><div class="postdate"><time datetime="2019-01-27" itemprop="datePublished">2019-01-27</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3eTemporal Dead Zone(TDZ)是ES6(ES2015)中对作用域新的专用语义。TDZ名词并没有明确地写在ES6的标准文件中，一开始是出现在\x3ca href=\x22https:\/\/esdiscuss.org\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eES Discussion\x3c\/a\x3e讨论区中，是对于某些遇到在区块作用域绑定早于声明语句时的状况时，所使用的专用术语。\x3c\/p\x3e\n\x3cp\x3e以英文名词来说明，Temporal是\x22时间的、暂时的\x22意义，Dead Zone则是\x22死区\x22，意指\x22电波达不到的区域\x22。所以TDZ可以翻为\x22时间上暂时的无法达到的区域\x22，简称为\x22时间死区\x22或\x22暂时死区\x22。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3elet\/const与var\x3c\/h2\x3e\n\x3cp\x3e在ES6的新特性中，最容易看到TDZ作用就是在let\/const的使用上，let\/const与var的主要不同有两个地方:\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3elet\/const是使用区块作用域；var是使用函数作用域\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e在let\/const声明之前就访问对应的变量与常量，会抛出\x3ccode\x3eReferenceError\x3c\/code\x3e错误；但在var声明之前就访问对应的变量，则会得到\x3ccode\x3eundefined\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22console.log(aVar) \/\/ undefined\nconsole.log(aLet) \/\/ causes ReferenceError: aLet is not defined\nvar aVar = 1\nlet aLet = 2\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(aVar) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ undefined\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(aLet) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ causes ReferenceError: aLet is not defined\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e aVar = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e aLet = \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e根据ES6标准中对于let\/const声明的章节\x3ca href=\x22http:\/\/www.ecma-international.org\/ecma-262\/6.0\/#sec-let-and-const-declarations\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e13.3.1\x3c\/a\x3e，有以下的文字说明:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22The variables are created when their containing Lexical Environment is instantiated but may not be accessed in any way until the variable’s LexicalBinding is evaluated.\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs vhdl\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3eThe variables are created \x3cspan class=\x22hljs-keyword\x22\x3ewhen\x3c\/span\x3e their containing Lexical Environment \x3cspan class=\x22hljs-keyword\x22\x3eis\x3c\/span\x3e instantiated but may \x3cspan class=\x22hljs-keyword\x22\x3enot\x3c\/span\x3e be accessed \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e any way \x3cspan class=\x22hljs-keyword\x22\x3euntil\x3c\/span\x3e the \x3cspan class=\x22hljs-keyword\x22\x3evariable\x3c\/span\x3e’s LexicalBinding \x3cspan class=\x22hljs-keyword\x22\x3eis\x3c\/span\x3e evaluated.\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e意思是说由let\/const声明的变量，当它们包含的词法环境(Lexical Environment)被实例化时会被创建，但只有在变量的词法绑定(LexicalBinding)已经被求值运算后，才能够被访问。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e注: 这里指的\x22变量\x22是let\/const两者，const在ES6定义中是constant variable(固定的变量)的意思。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e说得更明白些，当程序的控制流程在新的作用域(module, function或block作用域)进行实例化时，在此作用域中的用let\/const声明的变量会先在作用域中被创建出来，但因此时还未进行词法绑定，也就是对声明语句进行求值运算，所以是不能被访问的，访问就会抛出错误。所以在这运行流程一进入作用域创建变量，到变量开始可被访问之间的一段时间，就称之为TDZ(暂时死区)。\x3c\/p\x3e\n\x3cp\x3e以上面解说来看，以let\/const声明的变量，的确也是有提升(hoist)的作用。这个是很容易被误解的地方，实际上以let\/const声明的变量也是会有提升(hoist)的作用。提升是JS语言中对于变量声明的基本特性，只是因为TDZ的作用，并不会像使用var来声明变量，只是会得到\x3ccode\x3eundefined\x3c\/code\x3e而已，现在则是会直接抛出\x3ccode\x3eReferenceError\x3c\/code\x3e错误，而且很明显的这是一个在运行期间才会出现的错误。\x3c\/p\x3e\n\x3cp\x3e用一个简单的例子来说明let声明的变量会在作用域中被提升，就像下面这样:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let x = \x27outer value\x27\n\n(function() {\n  \/\/ 这里会产生 TDZ for x\n  console.log(x) \/\/ TDZ期间访问，产生ReferenceError错误\n  let x = \x27inner value\x27 \/\/ 对x的声明语句，这里结束 TDZ for x\n}())\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e x = \x3cspan class=\x22hljs-string\x22\x3e\x27outer value\x27\x3c\/span\x3e\n\n(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里会产生 TDZ for x\x3c\/span\x3e\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(x) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ TDZ期间访问，产生ReferenceError错误\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e x = \x3cspan class=\x22hljs-string\x22\x3e\x27inner value\x27\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 对x的声明语句，这里结束 TDZ for x\x3c\/span\x3e\n}())\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在例子中的IIFE里的函数作用域，变量x在作用域中会先被提升到函数区域中的最上面，但这时会产生TDZ，如果在程序流程还未运行到x的声明语句时，算是在TDZ作用的期间，这时候访问x的值，就会抛出\x3ccode\x3eReferenceError\x3c\/code\x3e错误。\x3c\/p\x3e\n\x3cp\x3e在let与const声明的章节\x3ca href=\x22http:\/\/www.ecma-international.org\/ecma-262\/6.0\/#sec-let-and-const-declarations\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e13.3.1\x3c\/a\x3e接着的几句，说明有关变量是如何进行初始化的:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22A variable defined by a LexicalBinding with an Initializer is assigned the value of its Initializer’s AssignmentExpression when the LexicalBinding is evaluated, not when the variable is created. If a LexicalBinding in a let declaration does not have an Initializer the variable is assigned the value undefined when the LexicalBinding is evaluated.\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs livecodeserver\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3eA \x3cspan class=\x22hljs-built_in\x22\x3evariable\x3c\/span\x3e defined \x3cspan class=\x22hljs-keyword\x22\x3eby\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ea\x3c\/span\x3e LexicalBinding \x3cspan class=\x22hljs-keyword\x22\x3ewith\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ean\x3c\/span\x3e Initializer is assigned \x3cspan class=\x22hljs-keyword\x22\x3ethe\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3evalue\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eof\x3c\/span\x3e its Initializer’s AssignmentExpression when \x3cspan class=\x22hljs-keyword\x22\x3ethe\x3c\/span\x3e LexicalBinding is evaluated, \x3cspan class=\x22hljs-keyword\x22\x3enot\x3c\/span\x3e when \x3cspan class=\x22hljs-keyword\x22\x3ethe\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3evariable\x3c\/span\x3e is created. If \x3cspan class=\x22hljs-keyword\x22\x3ea\x3c\/span\x3e LexicalBinding \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ea\x3c\/span\x3e let declaration does \x3cspan class=\x22hljs-keyword\x22\x3enot\x3c\/span\x3e have \x3cspan class=\x22hljs-keyword\x22\x3ean\x3c\/span\x3e Initializer \x3cspan class=\x22hljs-keyword\x22\x3ethe\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3evariable\x3c\/span\x3e is assigned \x3cspan class=\x22hljs-keyword\x22\x3ethe\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3evalue\x3c\/span\x3e undefined when \x3cspan class=\x22hljs-keyword\x22\x3ethe\x3c\/span\x3e LexicalBinding is evaluated.\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这几句比较重点的部份是关于初始化的过程。以let\/const声明的变量或常量，必需是经过对声明的赋值语句的求值后，才算初始化完成，创建时并不算初始化。如果以let声明的变量没有赋给初始值，那么就赋值给它\x3ccode\x3eundefined\x3c\/code\x3e值。也就是经过初始化的完成，才代表着TDZ期间的真正结束，这些在作用域中的被声明的变量才能够正常地被访问。\x3c\/p\x3e\n\x3cp\x3e下面这个例子是一个未初始化完成的结果，它一样是在TDZ中，也是会抛出\x3ccode\x3eReferenceError\x3c\/code\x3e错误:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let x = x\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e x = x\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e因为右值(要被赋的值)，它在此时是一个还未被初始化完成的变量，实际上我们就在这一个同一表达式中要初始化它。\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3e注: TDZ最一开始是为了const所设计的，但后来的对let的设计也是一致的，例子中都用let来说明会比较容易。\x3c\/p\x3e\n\x3cp\x3e注: 在ES6标准中，对于const所声明的识别子仍然也经常为variable(变量)，称为constant variable(固定的变量)。以const声明所创建出来的常量，在JS中只是不能再被赋(can\x27t re-assignment)，并不是不可被改变(immutable)的，这两种概念仍然有很大的差异。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e函数的传参预设值\x3c\/h2\x3e\n\x3cp\x3eTDZ作用在ES6中，很明确的就是与区块作用域(block scope)，以及变量\/常量的要如何被初始化有关。实际上在许多ES6新特性中都有出现TDZ作用，而另一个常会被提及的是函数的传参预设值中的TDZ作用。\x3c\/p\x3e\n\x3cp\x3e下面的例子可以看到在传参预设值的识别名称，在未经初始化(有赋到值)时，它会进入TDZ而产生错误，而这个错误是只有在函数调用时，要使用到传参预设值时才会出现:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function foo(x = y, y = 1) {\n  console.log(y)\n}\n\nfoo(1) \/\/ 这不会有错误\nfoo(undefined, 1) \/\/ 错误 ReferenceError: y is not defined\nfoo() \/\/ 错误 ReferenceError: y is not defined\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ex = y, y = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(y)\n}\n\nfoo(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这不会有错误\x3c\/span\x3e\nfoo(\x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 错误 ReferenceError: y is not defined\x3c\/span\x3e\nfoo() \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 错误 ReferenceError: y is not defined\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e从这个例子可以知道TDZ的作用，实际上在ES6中到处都有类似的作用。\x3c\/p\x3e\n\x3cp\x3e传参预设值有另一个作用域的议题会被讨论，就是对于传参预设值的作用域，到底是属于\x22全局作用域\x22还是\x22函数中的作用域\x22的议题，目前看到比较常见的说法是，它是处于\x22中介的作用域\x22，夹在这两者之间，但仍然会互相影响。中介的作用域的一个例子，是使用其他函数作为传参的预设值，这通常会是一个callback(回调、回呼)函数，一般的情况没什么特别，但涉及作用域时互相影响的情况下会不易理解。下面这个例子\x3ca href=\x22http:\/\/dmitrysoshnikov.com\/ecmascript\/es6-notes-default-values-of-parameters\/#conditional-intermediate-scope-for-parameters\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e来自这里\x3c\/a\x3e:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let x = 1\n\nfunction foo(a = 1, b = function(){ x = 2 }){\n  let x = 3\n  b()\n  console.log(x)\n}\n\nfoo()\n\nconsole.log(x)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e x = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ea = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, b = function(\x3c\/span\x3e)\x3c\/span\x3e{ x = \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e }){\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e x = \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e\n  b()\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(x)\n}\n\nfoo()\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(x)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这个例子中的最后结果，在函数foo中输出的x值到底是1、2还是3？另外，在最外围作用域的x最后会被改变吗？\x3c\/p\x3e\n\x3cp\x3e函数中的x输出结果不可能是1，这是很明确的，因为函数区块中有另一个x的声明与赋值\x3ccode\x3elet x = 3\x3c\/code\x3e语句，这两个都有可能被运行产生作用。剩下的是传参预设值中的那个函数，是不是会变量到函数区块中的x值的问题。另一个是，在全局中的那个x变量，会不会被改变，这也是一个问题。\x3c\/p\x3e\n\x3cp\x3e按照这个例子的出处文档的说明，作者认为答案是3与1。但是根据我的实验，下面的几个浏览器与编译器并不是这样认为:\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3ebabel编译器: 2与1\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eClosure Compiler: 3与2\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eGoogle Chrome(v55): 3与2\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eFirefox(v50): 2与1\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eEdge(v38): 3与2\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e实际测试的结果，怎么都不会有3与1的答案，要不就3与2，要不就2与1。\x3c\/p\x3e\n\x3cp\x3e3与2的答案是让b传参的\x3ccode\x3ex = 2\x3c\/code\x3e运行出来，但因为受到中介作用域的影响，因此干扰不到函数中的原本区块中的作用域，但会影响到全局中的x变量。也就是基本上认定函数预设值中的那个callback中的作用域与全局(或外层)有关系。\x3c\/p\x3e\n\x3cp\x3e2与1的答案则是倒过来，只会影响到函数中的区块，对全局(或外层)没有影响。\x3c\/p\x3e\n\x3cp\x3e所以除非中介作用域，有自己独立的作用域，完全与函数区块中的作用域与全局都不相干，才有可能产生3与1的结果，这是这篇文档的作者所认为的。\x3c\/p\x3e\n\x3cp\x3e这个函数预设值的作用域因为实作不同，造成两种不同的结果，但如果以Chrome(v55)与Firefox(v50)来实验，在TDZ期间的抛出错误的行为基本上会一致，但Firefox有两种不同的错误消息，例如下面的几个例子:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ Chrome: ReferenceError: x is not defined\n\/\/ Firefox: ReferenceError: x is not defined\nfunction foo(a = 1, b = function(){ let x = 2 }){\n  b()\n  console.log(x)\n}\nfoo()\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Chrome: ReferenceError: x is not defined\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Firefox: ReferenceError: x is not defined\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ea = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, b = function(\x3c\/span\x3e)\x3c\/span\x3e{ \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e x = \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e }){\n  b()\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(x)\n}\nfoo()\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ Chrome: ReferenceError: x is not defined\n\/\/ Firefox: ReferenceError: can\x27t access lexical declaration `x\x27 before initialization\nfunction foo(a = 1, b = function(){ x = 2 }){\n  b()\n  console.log(x)\n}\nfoo()\nlet x = 1\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Chrome: ReferenceError: x is not defined\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Firefox: ReferenceError: can\x27t access lexical declaration `x\x27 before initialization\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ea = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, b = function(\x3c\/span\x3e)\x3c\/span\x3e{ x = \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e }){\n  b()\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(x)\n}\nfoo()\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e x = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ Chrome: ReferenceError: x is not defined\n\/\/ Firefox: ReferenceError: can\x27t access lexical declaration `x\x27 before initialization\nfunction foo(a = 1, b = function(){ x = 2 }){\n  b()\n  console.log(x)\n  let x = 3\n}\nfoo()\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Chrome: ReferenceError: x is not defined\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Firefox: ReferenceError: can\x27t access lexical declaration `x\x27 before initialization\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ea = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, b = function(\x3c\/span\x3e)\x3c\/span\x3e{ x = \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e }){\n  b()\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(x)\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e x = \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e\n}\nfoo()\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e不管如何，这个作用域的影响仍然是有争议的，目前并没有统一的答案。这代表ES6虽然标准定好了，但里面的一些新特性仍然有实作细节的差异，未来有可能这些差异才会慢慢一致。但对一般的开发者来说，因为知道了有这些情况，所以要尽量避免，以免产生不兼容的情况。\x3c\/p\x3e\n\x3cp\x3e要如何避免这种情况？最重要的就是，\x22不要在传参预设值中作有副作用的运算\x22，上面的\x3ccode\x3efunction(){ x = 2 }\x3c\/code\x3e是有副作用的，它有可能会改变函数区块中，或是全局中的同名称变量，而在整个代码中，可能会互相影响的作用域彼此间，避免使用同样识别名称的变量，这也是一个很基本的撰写规则。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e注: 本节的内容可以参考这几篇文档\x3ca href=\x22http:\/\/jsrocks.org\/2015\/01\/temporal-dead-zone-tdz-demystified\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eTEMPORAL DEAD ZONE (TDZ) DEMYSTIFIED\x3c\/a\x3e、\x3ca href=\x22http:\/\/dmitrysoshnikov.com\/ecmascript\/es6-notes-default-values-of-parameters\/#tdz-temporal-dead-zone-for-parameters\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eES6 Notes: Default values of parameters\x3c\/a\x3e与这个\x3ca href=\x22https:\/\/github.com\/google\/traceur-compiler\/issues\/1376\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eDefault parameters intermediate scope\x3c\/a\x3e讨论文。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3eTDZ的其它议题(陷阱)\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3etypeof语句\x3c\/h3\x3e\n\x3cp\x3e对TDZ期间中的变量\/常量作任何的访问动作，一律会抛出错误，使用\x3ccode\x3etypeof\x3c\/code\x3e的语句也一样。如下面的例子:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22typeof x \/\/ \x26quot;undefined\x26quot;\n\n{\n  \/\/ TDZ\n  typeof x \/\/ ReferenceError\n  let x = 42\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e x \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22undefined\x22\x3c\/span\x3e\n\n{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ TDZ\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e x \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ReferenceError\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e x = \x3cspan class=\x22hljs-number\x22\x3e42\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e但有些开发者会认为像\x3ccode\x3etypeof\x3c\/code\x3e这样的语句，需要被用来判断变量是否存在，不应该是导致抛出错误，所以有部份反对的声音，认为它让\x3ccode\x3etypeof\x3c\/code\x3e语句变得不安全，会造成使用上的陷阱。实际上这原本就是TDZ的设计，变量本来就不该在没声明完成前访问，这是为了让JS运行更为合理的改善设计，只是之前JS在这一部份是有缺陷的作法，实际上会用\x3ccode\x3etypeof\x3c\/code\x3e与undefined来判别变量\/常量存在与否的方式，通常是对于全局变量的才会作的事情。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3eTDZ期间抛出的错误是运行阶段的错误\x3c\/h3\x3e\n\x3cp\x3eTDZ期间所抛出的错误，是一种运行阶段的错误，因为TDZ除了作用域的绑定过程外，还需要有变量\/常量初始化的过程，才会创建出TDZ的期间。下面两个例子就可以看到TDZ的错误需要真正运行到才会出现:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 这个例子会有因TDZ抛出的错误\nfunction f() { return x }\nf() \/\/ ReferenceError\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这个例子会有因TDZ抛出的错误\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ef\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e x }\nf() \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ReferenceError\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 这个例子不会有错误\nfunction f() { return x }\nlet x = 1\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这个例子不会有错误\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ef\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e x }\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e x = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e那这会有什么问题出现？因为要能侦测出代码中的因TDZ造成的错误，唯有透过静态的代码分析工具，或是要真正调用到函数运行里面的代码，才会产生错误，这将会让TDZ在编译工具中实作变得困难。\x3c\/p\x3e\n\x3cp\x3e不过只要你理解TDZ的设计，就知道只能这样设计，初始化过程原本就只会在调用运行阶段作这事，这部份还是只能靠其它工具来补强。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e支持ES6的浏览器上的运行效能\x3c\/h3\x3e\n\x3cp\x3e在\x3ca href=\x22https:\/\/esdiscuss.org\/topic\/performance-concern-with-let-const\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eES Discussion\x3c\/a\x3e上对于let\/const的效能很早以前就已经有些批评的，认为在浏览器上实作的结果，由于TDZ的设计，会让let相较于var的效能至少要慢5%。\x3c\/p\x3e\n\x3cp\x3e上面这篇贴文是在4年前所发表，就算是当时的实验性质的实作在JS引擎上，没有经过优化，实际上真的效能有差这么大也不得而知。加上let本身在for回圈上有另外的花费，与var的设计不同，这两个比较当然会有所不同，是不是都是TDZ影响的也不知道。\x3c\/p\x3e\n\x3cp\x3e以最近在讨论区中的\x3ca href=\x22http:\/\/stackoverflow.com\/questions\/21467642\/is-there-a-performance-difference-between-let-and-var\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3elet与var的效能\x3c\/a\x3e比较议题来看，let的运行效率只有在某些情况下(for回圈中)会慢var很多，在基本的内部作用域测试反而是快过var的，当然这也是要视不同的浏览器与版本而定。\x3c\/p\x3e\n\x3cp\x3e题外话是，在其它的回答中就有明确的指出，会促使加入TDZ的主因是针对const，而不是let。但最后TC39的决议是让let与const都有一致的TDZ设计。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3eES6到ES5的编译\x3c\/h3\x3e\n\x3cp\x3eES6中的许多新式的设计仍然是很新的JS语言特性，目前ES6仍然需要依赖如babel之类的编译器，将ES6语法编译到ES5，来进行在浏览器上运行前的最后编译。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e这些编译器对于TDZ是会如何编译？答案是目前\x22并不会直接编译\x22。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e以babel来说，它预设不会编译出具有TDZ的代码，它需要额外使用\x3ca href=\x22https:\/\/babeljs.io\/docs\/plugins\/transform-es2015-block-scoping\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ebabel-plugin-transform-es2015-block-scoping\x3c\/a\x3e或编译时的选项\x3ccode\x3ees6.blockScopingTDZ\x3c\/code\x3e，才会将TDZ与区域作用域的功能编译出来。基本上这应该属于实验性质的，而且现在在使用上还有满多问题的。ES5标准中原本就没这种设计，所以说实在硬要使用也是麻烦，TDZ会造成的错误是运行期间的错误，对于编译器来说，在实作上也有一定的难度。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>理解ES6中的暂时死区(TDZ)</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000008213835">https://segmentfault.com/a/1190000008213835</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/b5ayrtvdtpe/" target="_blank">https://alili.tech/archive/b5ayrtvdtpe/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>