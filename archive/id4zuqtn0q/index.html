<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="正则表达式前端使用手册"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>正则表达式前端使用手册 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/id4zuqtn0q/",
				"appid": "1613049289050283", 
				"title": "正则表达式前端使用手册 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-26T02:30:18"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/yshfcc35dgp/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/49vn7vh48ev/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fid4zuqtn0q%2f&text=%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f%e5%89%8d%e7%ab%af%e4%bd%bf%e7%94%a8%e6%89%8b%e5%86%8c"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fid4zuqtn0q%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fid4zuqtn0q%2f&text=%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f%e5%89%8d%e7%ab%af%e4%bd%bf%e7%94%a8%e6%89%8b%e5%86%8c"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fid4zuqtn0q%2f&title=%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f%e5%89%8d%e7%ab%af%e4%bd%bf%e7%94%a8%e6%89%8b%e5%86%8c"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fid4zuqtn0q%2f&is_video=false&description=%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f%e5%89%8d%e7%ab%af%e4%bd%bf%e7%94%a8%e6%89%8b%e5%86%8c"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f%e5%89%8d%e7%ab%af%e4%bd%bf%e7%94%a8%e6%89%8b%e5%86%8c&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fid4zuqtn0q%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fid4zuqtn0q%2f&title=%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f%e5%89%8d%e7%ab%af%e4%bd%bf%e7%94%a8%e6%89%8b%e5%86%8c"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fid4zuqtn0q%2f&title=%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f%e5%89%8d%e7%ab%af%e4%bd%bf%e7%94%a8%e6%89%8b%e5%86%8c"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fid4zuqtn0q%2f&title=%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f%e5%89%8d%e7%ab%af%e4%bd%bf%e7%94%a8%e6%89%8b%e5%86%8c"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fid4zuqtn0q%2f&title=%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f%e5%89%8d%e7%ab%af%e4%bd%bf%e7%94%a8%e6%89%8b%e5%86%8c"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">正则表达式前端使用手册</h1><div class="meta"><div class="postdate"><time datetime="2019-01-26" itemprop="datePublished">2019-01-26</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch3 id=\x22articleHeader0\x22\x3e导读\x3c\/h3\x3e\n\x3cp\x3e你有没有在搜索文本的时候绞尽脑汁, 试了一个又一个表达式, 还是不行.\x3c\/p\x3e\n\x3cp\x3e你有没有在表单验证的时候, 只是做做样子(只要不为空就好), 然后烧香拜佛, 虔诚祈祷, 千万不要出错.\x3c\/p\x3e\n\x3cp\x3e你有没有在使用sed 和 grep 命令的时候, 感觉莫名其妙, 明明应该支持的元字符, 却就是匹配不到.\x3c\/p\x3e\n\x3cp\x3e甚至, 你压根没遇到过上述情况, 你只是一遍又一遍的调用 replace 而已 (把非搜索文本全部替换为空, 然后就只剩搜索文本了), 面对别人家的简洁高效的语句, 你只能在心中呐喊, replace 大法好.\x3c\/p\x3e\n\x3cp\x3e为什么要学正则表达式. 有位网友这么说: 江湖传说里, 程序员的正则表达式和医生的处方, 道士的鬼符齐名, 曰: 普通人看不懂的三件神器. 这个传说至少向我们透露了两点信息: 一是正则表达式很牛, 能和医生的处方, 道士的鬼符齐名, 并被大家提起, 可见其江湖地位. 二是正则表达式很难, 这也从侧面说明了, 如果你可以熟练的掌握并应用它, 在装逼的路上, 你将如日中天 (别问我中天是谁……) !\x3c\/p\x3e\n\x3cp\x3e显然, 有关正则表达的介绍, 无须我多言. 这里就借助 Jeffrey Friedl 的《精通正则表达式》一书的序言正式抛个砖.\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3e​    \x22如果罗列计算机软件领域的伟大发明, 我相信绝对不会超过二十项, 在这个名单当中, 当然应该包括分组交换网络, Web, Lisp, 哈希算法, UNIX, 编译技术, 关系模型, 面向对象, XML这些大名鼎鼎的家伙, 而正则表达式也绝对不应该被漏掉. \x3c\/p\x3e\n\x3cp\x3e​     对很多实际工作而言, 正则表达式简直是灵丹妙药, 能够成百倍的提高开发效率和程序质量, 正则表达式在生物信息学和人类基因图谱的研究中所发挥的关键作用, 更是被传为佳话. CSDN的创始人蒋涛先生在早年开发专业软件产品时, 就曾经体验过这一工具的巨大威力, 并且一直印象深刻.\x22\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e因此, 我们没有理由不去了解正则表达式, 甚至是熟练掌握并运用它.\x3c\/p\x3e\n\x3cp\x3e本文以正则基础语法开篇, 结合具体实例, 逐步讲解正则表达式匹配原理. 代码实例使用语言包括 js, php, python, java(因有些匹配模式, js并未支持, 需要借助其他语言讲解). 内容包括初阶技能和高阶技能, 适合新手学习和进阶. 本文力求简单通俗易懂, 同时为求全面, 涉及知识较多, 共计12k字, 篇幅较长, 请耐心阅读, 如有阅读障碍请及时\x3ca href=\x22https:\/\/github.com\/Louiszhai\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e联系我\x3c\/a\x3e.\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3e回顾历史\x3c\/h3\x3e\n\x3cp\x3e要论正则表达式的渊源, 最早可以追溯至对人类神经系统如何工作的早期研究. Warren McCulloch 和 Walter Pitts 这两位神经大咖 (神经生理学家) 研究出一种数学方式来描述这些神经网络.\x3c\/p\x3e\n\x3cp\x3e1956 年, 一位叫 Stephen Kleene 的数学家在 McCulloch 和 Pitts 早期工作的基础上, 发表了一篇标题为\x22神经网事件的表示法\x22的论文, 引入了正则表达式的概念.\x3c\/p\x3e\n\x3cp\x3e随后, 发现可以将这一工作应用于使用 Ken Thompson 的计算搜索算法的一些早期研究中. 而 Ken Thompson 又是 Unix 的主要发明人. 因此半个世纪以前的Unix 中的 qed 编辑器(1966 qed编辑器问世) 成了第一个使用正则表达式的应用程序.\x3c\/p\x3e\n\x3cp\x3e至此之后, 正则表达式成为家喻户晓的文本处理工具, 几乎各大编程语言都以支持正则表达式作为卖点, 当然 JavaScript 也不例外.\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e正则表达式的定义\x3c\/h3\x3e\n\x3cp\x3e正则表达式是由普通字符和特殊字符(也叫元字符或限定符)组成的文字模板. 如下便是简单的匹配连续数字的正则表达式:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/[0-9]\x2b\/\n\/\\d\x2b\/\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs awk\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-regexp\x22\x3e\/[0-9]\x2b\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-regexp\x22\x3e\/\\d\x2b\/\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x22d\x22 就是元字符, 而 \x22\x2b\x22 则是限定符.\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e元字符\x3c\/h3\x3e\n\x3ctable\x3e\n\x3cthead\x3e\x3ctr\x3e\n\x3cth align=\x22center\x22\x3e元字符\x3c\/th\x3e\n\x3cth align=\x22center\x22\x3e描述\x3c\/th\x3e\n\x3c\/tr\x3e\x3c\/thead\x3e\n\x3ctbody\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e.\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e匹配除换行符以外的任意字符\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e\\d\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e匹配数字, 等价于字符组[0-9]\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e\\w\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e匹配字母, 数字, 下划线或汉字\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e\\s\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e匹配任意的空白符(包括制表符,空格,换行等)\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e\\b\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e匹配单词开始或结束的位置\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e^\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e匹配行首\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e$\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e匹配行尾\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3c\/tbody\x3e\n\x3c\/table\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e反义元字符\x3c\/h3\x3e\n\x3ctable\x3e\n\x3cthead\x3e\x3ctr\x3e\n\x3cth align=\x22center\x22\x3e元字符\x3c\/th\x3e\n\x3cth align=\x22center\x22\x3e描述\x3c\/th\x3e\n\x3c\/tr\x3e\x3c\/thead\x3e\n\x3ctbody\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e\\D\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e匹配非数字的任意字符, 等价于[^0-9]\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e\\W\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e匹配除字母,数字,下划线或汉字之外的任意字符\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e\\S\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e匹配非空白的任意字符\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e\\B\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e匹配非单词开始或结束的位置\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e[^x]\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e匹配除x以外的任意字符\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3c\/tbody\x3e\n\x3c\/table\x3e\n\x3cp\x3e可以看出正则表达式严格区分大小写.\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e重复限定符\x3c\/h3\x3e\n\x3cp\x3e限定符共有6个, 假设重复次数为x次, 那么将有如下规则:\x3c\/p\x3e\n\x3ctable\x3e\n\x3cthead\x3e\x3ctr\x3e\n\x3cth align=\x22center\x22\x3e限定符\x3c\/th\x3e\n\x3cth align=\x22center\x22\x3e描述\x3c\/th\x3e\n\x3c\/tr\x3e\x3c\/thead\x3e\n\x3ctbody\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e*\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3ex\x26gt;=0\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e\x2b\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3ex\x26gt;=1\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e?\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3ex=0 or x=1\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e{n}\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3ex=n\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e{n,}\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3ex\x26gt;=n\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e{n,m}\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3en\x26lt;=x\x26lt;=m\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3c\/tbody\x3e\n\x3c\/table\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e字符组\x3c\/h3\x3e\n\x3cp\x3e[...] 匹配中括号内字符之一. 如: [xyz]  匹配字符 x, y 或 z. 如果中括号中包含元字符, 则元字符降级为普通字符, 不再具有元字符的功能, 如 [\x2b.?] 匹配 加号, 点号或问号.\x3c\/p\x3e\n\x3ch4\x3e排除性字符组\x3c\/h4\x3e\n\x3cp\x3e[^…] 匹配任何未列出的字符,. 如:  [^x]  匹配除x以外的任意字符.\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e多选结构\x3c\/h3\x3e\n\x3cp\x3e| 就是或的意思, 表示两者中的一个. 如: a|b 匹配a或者b字符.\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e括号\x3c\/h3\x3e\n\x3cp\x3e括号 常用来界定重复限定符的范围, 以及将字符\x3cstrong\x3e分组\x3c\/strong\x3e. 如: (ab)\x2b 可以匹配abab..等, 其中 ab 便是一个分组.\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3e转义字符\x3c\/h3\x3e\n\x3cp\x3e即转义字符, 通常 \x3cstrong\x3e * \x2b ? | { [ ( ) ] }^ $ . # 和 空白\x3c\/strong\x3e 这些字符都需要转义.\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3e操作符的运算优先级\x3c\/h3\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e转义符\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e(), (?:), (?=), [] 圆括号或方括号\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e*, \x2b, ?, {n}, {n,}, {n,m} 限定符\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e^, $ 位置\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e| \x22或\x22 操作\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch3 id=\x22articleHeader11\x22\x3e测试\x3c\/h3\x3e\n\x3cp\x3e我们来测试下上面的知识点, 写一个匹配手机号码的正则表达式, 如下:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22(\\\x2b86)?1\\d{10}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e(\\\x2b\x3cspan class=\x22hljs-number\x22\x3e86\x3c\/span\x3e)?\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\\d{\x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e① \x22\\\x2b86\x22 匹配文本 \x22\x2b86\x22, 后面接元字符问号, 表示可匹配1次或0次, 合起来表示 \x22(\\\x2b86)?\x22 匹配 \x22\x2b86\x22 或者 \x22\x22.\x3c\/p\x3e\n\x3cp\x3e② 普通字符\x221\x22 匹配文本 \x221\x22.\x3c\/p\x3e\n\x3cp\x3e③ 元字符 \x22\\d\x22 匹配数字0到9, 区间量词 \x22{10}\x22 表示匹配 10 次, 合起来表示 \x22\\d{10}\x22 匹配连续的10个数字.\x3c\/p\x3e\n\x3cp\x3e以上, 匹配结果如下:\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000008367188?w=200\x26amp;h=60\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000008367188?w=200\x26amp;h=60\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader12\x22\x3e修饰符\x3c\/h3\x3e\n\x3cp\x3ejavaScript中正则表达式默认有如下五种修饰符:\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eg (全文查找), 如上述截图, 实际上就开启了全文查找模式.\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ei (忽略大小写查找)\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3em (多行查找)\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ey (ES6新增的粘连修饰符)\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eu (ES6新增)\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader13\x22\x3e常用的正则表达式\x3c\/h3\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e汉字: ^[u4e00-u9fa5]{0,}$\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eEmail: ^w\x2b([-\x2b.]w\x2b)*@w\x2b([-.]w\x2b)*\\.w\x2b([-.]w\x2b)*$\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eURL: ^https?:\/\/([w-]\x2b.)\x2b[w-]\x2b(\/[w-.\/?%\x26amp;=]*)?$\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e手机号码: ^1d{10}$\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e身份证号: ^(d{15}|d{17}(d|X))$\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e中国邮政编码: [1-9]d{5}(?!d) (邮政编码为6位数字)\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch3 id=\x22articleHeader14\x22\x3e密码验证\x3c\/h3\x3e\n\x3cp\x3e密码验证是常见的需求, 一般来说, 常规密码大致会满足规律: 6-16位, 数字, 字母, 字符至少包含两种, 同时不能包含中文和空格. 如下便是常规密码验证的正则描述:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var reg = \/(?!^[0-9]\x2b$)(?!^[A-z]\x2b$)(?!^[^A-z0-9]\x2b$)^[^\\s\\u4e00-\\u9fa5]{6,16}$\/;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e reg = \x3cspan class=\x22hljs-regexp\x22\x3e\/(?!^[0-9]\x2b$)(?!^[A-z]\x2b$)(?!^[^A-z0-9]\x2b$)^[^\\s\\u4e00-\\u9fa5]{6,16}$\/\x3c\/span\x3e;\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader15\x22\x3e正则的几大家族\x3c\/h3\x3e\n\x3ch3 id=\x22articleHeader16\x22\x3e正则表达式分类\x3c\/h3\x3e\n\x3cp\x3e在 linux 和 osx 下, 常见的正则表达式, 至少有以下三种:\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e基本的正则表达式( Basic Regular Expression 又叫 Basic RegEx  简称 \x3cstrong\x3eBREs\x3c\/strong\x3e )\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e扩展的正则表达式( Extended Regular Expression 又叫 Extended RegEx 简称 \x3cstrong\x3eEREs\x3c\/strong\x3e )\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ePerl 的正则表达式( Perl Regular Expression 又叫 Perl RegEx 简称 \x3cstrong\x3ePREs\x3c\/strong\x3e )\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader17\x22\x3e正则表达式比较\x3c\/h3\x3e\n\x3ctable\x3e\n\x3cthead\x3e\x3ctr\x3e\n\x3cth\x3e字符\x3c\/th\x3e\n\x3cth\x3e说明\x3c\/th\x3e\n\x3cth\x3eBasic RegEx\x3c\/th\x3e\n\x3cth\x3eExtended RegEx\x3c\/th\x3e\n\x3cth\x3epython RegEx\x3c\/th\x3e\n\x3cth\x3ePerl regEx\x3c\/th\x3e\n\x3c\/tr\x3e\x3c\/thead\x3e\n\x3ctbody\x3e\n\x3ctr\x3e\n\x3ctd\x3e转义\x3c\/td\x3e\n\x3ctd\x3e \x3c\/td\x3e\n\x3ctd\x3e \x3c\/td\x3e\n\x3ctd\x3e \x3c\/td\x3e\n\x3ctd\x3e \x3c\/td\x3e\n\x3ctd\x3e \x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e^\x3c\/td\x3e\n\x3ctd\x3e匹配行首，例如\x27^dog\x27匹配以字符串dog开头的行（注意：awk 指令中，\x27^\x27则是匹配字符串的开始）\x3c\/td\x3e\n\x3ctd\x3e^\x3c\/td\x3e\n\x3ctd\x3e^\x3c\/td\x3e\n\x3ctd\x3e^\x3c\/td\x3e\n\x3ctd\x3e^\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e$\x3c\/td\x3e\n\x3ctd\x3e匹配行尾，例如：\x27^、dog\x26amp;dollar;\x27 匹配以字符串 dog 为结尾的行（注意：awk 指令中，\x27$\x27则是匹配字符串的结尾）\x3c\/td\x3e\n\x3ctd\x3e$\x3c\/td\x3e\n\x3ctd\x3e$\x3c\/td\x3e\n\x3ctd\x3e$\x3c\/td\x3e\n\x3ctd\x3e$\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e^$\x3c\/td\x3e\n\x3ctd\x3e匹配空行\x3c\/td\x3e\n\x3ctd\x3e^$\x3c\/td\x3e\n\x3ctd\x3e^$\x3c\/td\x3e\n\x3ctd\x3e^$\x3c\/td\x3e\n\x3ctd\x3e^$\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e^string$\x3c\/td\x3e\n\x3ctd\x3e匹配行，例如：\x27^dog$\x27匹配只含一个字符串 dog 的行\x3c\/td\x3e\n\x3ctd\x3e^string$\x3c\/td\x3e\n\x3ctd\x3e^string$\x3c\/td\x3e\n\x3ctd\x3e^string$\x3c\/td\x3e\n\x3ctd\x3e^string$\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x26lt;\x3c\/td\x3e\n\x3ctd\x3e匹配单词，例如：\x27\x26lt;frog\x27 （等价于\x27bfrog\x27），匹配以 frog 开头的单词\x3c\/td\x3e\n\x3ctd\x3e\x26lt;\x3c\/td\x3e\n\x3ctd\x3e\x26lt;\x3c\/td\x3e\n\x3ctd\x3e\x3cstrong\x3e不支持\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd\x3e\n\x3cstrong\x3e不支持\x3c\/strong\x3e（但可以使用b来匹配单词，例如：\x27bfrog\x27）\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x26gt;\x3c\/td\x3e\n\x3ctd\x3e匹配单词，例如：\x27frog\x26gt;\x27（等价于\x27frogb \x27），匹配以 frog 结尾的单词\x3c\/td\x3e\n\x3ctd\x3e\x26gt;\x3c\/td\x3e\n\x3ctd\x3e\x26gt;\x3c\/td\x3e\n\x3ctd\x3e\x3cstrong\x3e不支持\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd\x3e\n\x3cstrong\x3e不支持\x3c\/strong\x3e（但可以使用b来匹配单词，例如：\x27frogb\x27）\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x26lt;x\x26gt;\x3c\/td\x3e\n\x3ctd\x3e匹配一个单词或者一个特定字符，例如：\x27\x26lt;frog\x26gt;\x27（等价于\x27bfrogb\x27）、\x27\x26lt;G\x26gt;\x27\x3c\/td\x3e\n\x3ctd\x3e\x26lt;x\x26gt;\x3c\/td\x3e\n\x3ctd\x3e\x26lt;x\x26gt;\x3c\/td\x3e\n\x3ctd\x3e\x3cstrong\x3e不支持\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd\x3e\n\x3cstrong\x3e不支持\x3c\/strong\x3e（但可以使用b来匹配单词，例如：\x27bfrogb\x27\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e()\x3c\/td\x3e\n\x3ctd\x3e匹配表达式，例如：不支持\x27（frog）\x27\x3c\/td\x3e\n\x3ctd\x3e\n\x3cstrong\x3e不支持\x3c\/strong\x3e（但可以使用，如：dog\x3c\/td\x3e\n\x3ctd\x3e()\x3c\/td\x3e\n\x3ctd\x3e()\x3c\/td\x3e\n\x3ctd\x3e()\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e \x3c\/td\x3e\n\x3ctd\x3e匹配表达式，例如：不支持\x27（frog）\x27\x3c\/td\x3e\n\x3ctd\x3e \x3c\/td\x3e\n\x3ctd\x3e\n\x3cstrong\x3e不支持\x3c\/strong\x3e（同())\x3c\/td\x3e\n\x3ctd\x3e\n\x3cstrong\x3e不支持\x3c\/strong\x3e（同())\x3c\/td\x3e\n\x3ctd\x3e\n\x3cstrong\x3e不支持\x3c\/strong\x3e（同())\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e？\x3c\/td\x3e\n\x3ctd\x3e匹配前面的子表达式 0 次或 1 次（等价于{0,1}），例如：where(is)?能匹配\x22where\x22 以及\x22whereis\x22\x3c\/td\x3e\n\x3ctd\x3e\n\x3cstrong\x3e不支持\x3c\/strong\x3e（同?)\x3c\/td\x3e\n\x3ctd\x3e？\x3c\/td\x3e\n\x3ctd\x3e？\x3c\/td\x3e\n\x3ctd\x3e？\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e?\x3c\/td\x3e\n\x3ctd\x3e匹配前面的子表达式 0 次或 1 次（等价于\x27{0,1}\x27），例如：\x27whereis? \x27能匹配 \x22where\x22以及\x22whereis\x22\x3c\/td\x3e\n\x3ctd\x3e?\x3c\/td\x3e\n\x3ctd\x3e\n\x3cstrong\x3e不支持\x3c\/strong\x3e（同?)\x3c\/td\x3e\n\x3ctd\x3e\n\x3cstrong\x3e不支持\x3c\/strong\x3e（同?)\x3c\/td\x3e\n\x3ctd\x3e\n\x3cstrong\x3e不支持\x3c\/strong\x3e（同?)\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e?\x3c\/td\x3e\n\x3ctd\x3e当该字符紧跟在任何一个其他限制符（*, \x2b, ?, {n},{n,}, {n,m}） 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 \x22oooo\x22，\x27o\x2b?\x27 将匹配单个\x22o\x22，而 \x27o\x2b\x27 将匹配所有 \x27o\x27\x3c\/td\x3e\n\x3ctd\x3e\x3cstrong\x3e不支持\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cstrong\x3e不支持\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cstrong\x3e不支持\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cstrong\x3e不支持\x3c\/strong\x3e\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e.\x3c\/td\x3e\n\x3ctd\x3e匹配除换行符（\x27n\x27）之外的任意单个字符（注意：awk 指令中的句点能匹配换行符）\x3c\/td\x3e\n\x3ctd\x3e.\x3c\/td\x3e\n\x3ctd\x3e.（如果要匹配包括“n”在内的任何一个字符，请使用: [sS]\x3c\/td\x3e\n\x3ctd\x3e.\x3c\/td\x3e\n\x3ctd\x3e.（如果要匹配包括“n”在内的任何一个字符，请使用：\x27 [.n] \x27\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e*\x3c\/td\x3e\n\x3ctd\x3e匹配前面的子表达式 0 次或多次（等价于{0, }），例如：zo* 能匹配 \x22z\x22以及 \x22zoo\x22\x3c\/td\x3e\n\x3ctd\x3e*\x3c\/td\x3e\n\x3ctd\x3e*\x3c\/td\x3e\n\x3ctd\x3e*\x3c\/td\x3e\n\x3ctd\x3e*\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x2b\x3c\/td\x3e\n\x3ctd\x3e匹配前面的子表达式 1 次或多次（等价于\x27{1, }\x27），例如：\x27whereis\x2b \x27能匹配 \x22whereis\x22以及\x22whereisis\x22\x3c\/td\x3e\n\x3ctd\x3e\x2b\x3c\/td\x3e\n\x3ctd\x3e\n\x3cstrong\x3e不支持\x3c\/strong\x3e（同\x2b)\x3c\/td\x3e\n\x3ctd\x3e\n\x3cstrong\x3e不支持\x3c\/strong\x3e（同\x2b)\x3c\/td\x3e\n\x3ctd\x3e\n\x3cstrong\x3e不支持\x3c\/strong\x3e（同\x2b)\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x2b\x3c\/td\x3e\n\x3ctd\x3e匹配前面的子表达式 1 次或多次（等价于{1, }），例如：zo\x2b能匹配 \x22zo\x22以及 \x22zoo\x22，但不能匹配 \x22z\x22\x3c\/td\x3e\n\x3ctd\x3e\n\x3cstrong\x3e不支持\x3c\/strong\x3e（同\\\x2b)\x3c\/td\x3e\n\x3ctd\x3e\x2b\x3c\/td\x3e\n\x3ctd\x3e\x2b\x3c\/td\x3e\n\x3ctd\x3e\x2b\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e{n}\x3c\/td\x3e\n\x3ctd\x3en 必须是一个 0 或者正整数，匹配子表达式 n 次，例如：zo{2}能匹配\x3c\/td\x3e\n\x3ctd\x3e\n\x3cstrong\x3e不支持\x3c\/strong\x3e（同\\{n\\})\x3c\/td\x3e\n\x3ctd\x3e{n}\x3c\/td\x3e\n\x3ctd\x3e{n}\x3c\/td\x3e\n\x3ctd\x3e{n}\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e{n,}\x3c\/td\x3e\n\x3ctd\x3e\x22zooz\x22，但不能匹配 \x22Bob\x22n 必须是一个 0 或者正整数，匹配子表达式大于等于 n次，例如：go{2,}\x3c\/td\x3e\n\x3ctd\x3e\n\x3cstrong\x3e不支持\x3c\/strong\x3e（同\\{n,\\})\x3c\/td\x3e\n\x3ctd\x3e{n,}\x3c\/td\x3e\n\x3ctd\x3e{n,}\x3c\/td\x3e\n\x3ctd\x3e{n,}\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e{n,m}\x3c\/td\x3e\n\x3ctd\x3e能匹配 \x22good\x22，但不能匹配 godm 和 n 均为非负整数，其中 n \x26lt;= m，最少匹配 n 次且最多匹配 m 次 ，例如：o{1,3}将配\x22fooooood\x22 中的前三个 o（请注意在逗号和两个数之间不能有空格）\x3c\/td\x3e\n\x3ctd\x3e\n\x3cstrong\x3e不支持\x3c\/strong\x3e（同\\{n,m\\})\x3c\/td\x3e\n\x3ctd\x3e{n,m}\x3c\/td\x3e\n\x3ctd\x3e{n,m}\x3c\/td\x3e\n\x3ctd\x3e{n,m}\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3ex l y\x3c\/td\x3e\n\x3ctd\x3e匹配 x 或 y\x3c\/td\x3e\n\x3ctd\x3e\n\x3cstrong\x3e不支持\x3c\/strong\x3e（同x l y\x3c\/td\x3e\n\x3ctd\x3ex l y\x3c\/td\x3e\n\x3ctd\x3ex l y\x3c\/td\x3e\n\x3ctd\x3ex l y\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e[0-9]\x3c\/td\x3e\n\x3ctd\x3e匹配从 0 到 9 中的任意一个数字字符（注意：要写成递增）\x3c\/td\x3e\n\x3ctd\x3e[0-9]\x3c\/td\x3e\n\x3ctd\x3e[0-9]\x3c\/td\x3e\n\x3ctd\x3e[0-9]\x3c\/td\x3e\n\x3ctd\x3e[0-9]\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e[xyz]\x3c\/td\x3e\n\x3ctd\x3e字符集合，匹配所包含的任意一个字符，例如：\x27[abc]\x27可以匹配\x22lay\x22 中的 \x27a\x27（注意：如果元字符，例如：. *等，它们被放在[ ]中，那么它们将变成一个普通字符）\x3c\/td\x3e\n\x3ctd\x3e[xyz]\x3c\/td\x3e\n\x3ctd\x3e[xyz]\x3c\/td\x3e\n\x3ctd\x3e[xyz]\x3c\/td\x3e\n\x3ctd\x3e[xyz]\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e[^xyz]\x3c\/td\x3e\n\x3ctd\x3e负值字符集合，匹配未包含的任意一个字符（注意：不包括换行符），例如：\x27[^abc]\x27 可以匹配 \x22Lay\x22 中的\x27L\x27（注意：[^xyz]在awk 指令中则是匹配未包含的任意一个字符\x2b换行符）\x3c\/td\x3e\n\x3ctd\x3e[^xyz]\x3c\/td\x3e\n\x3ctd\x3e[^xyz]\x3c\/td\x3e\n\x3ctd\x3e[^xyz]\x3c\/td\x3e\n\x3ctd\x3e[^xyz]\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e[A-Za-z]\x3c\/td\x3e\n\x3ctd\x3e匹配大写字母或者小写字母中的任意一个字符（注意：要写成递增）\x3c\/td\x3e\n\x3ctd\x3e[A-Za-z]\x3c\/td\x3e\n\x3ctd\x3e[A-Za-z]\x3c\/td\x3e\n\x3ctd\x3e[A-Za-z]\x3c\/td\x3e\n\x3ctd\x3e[A-Za-z]\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e[^A-Za-z]\x3c\/td\x3e\n\x3ctd\x3e匹配除了大写与小写字母之外的任意一个字符（注意：写成递增）\x3c\/td\x3e\n\x3ctd\x3e[^A-Za-z]\x3c\/td\x3e\n\x3ctd\x3e[^A-Za-z]\x3c\/td\x3e\n\x3ctd\x3e[^A-Za-z]\x3c\/td\x3e\n\x3ctd\x3e[^A-Za-z]\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\\d\x3c\/td\x3e\n\x3ctd\x3e匹配从 0 到 9 中的任意一个数字字符（等价于 [0-9]）\x3c\/td\x3e\n\x3ctd\x3e\x3cstrong\x3e不支持\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cstrong\x3e不支持\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd\x3e\\d\x3c\/td\x3e\n\x3ctd\x3e\\d\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\\D\x3c\/td\x3e\n\x3ctd\x3e匹配非数字字符（等价于 \x3csup\x3e\x3ca class=\x22footnote-ref\x22\x3e1\x3c\/a\x3e\x3c\/sup\x3e）\x3c\/td\x3e\n\x3ctd\x3e\x3cstrong\x3e不支持\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cstrong\x3e不支持\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd\x3e\\D\x3c\/td\x3e\n\x3ctd\x3e\\D\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\\S\x3c\/td\x3e\n\x3ctd\x3e匹配任何非空白字符（等价于\x3csup\x3e\x3ca class=\x22footnote-ref\x22\x3e2\x3c\/a\x3e\x3c\/sup\x3e）\x3c\/td\x3e\n\x3ctd\x3e\x3cstrong\x3e不支持\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cstrong\x3e不支持\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd\x3e\\S\x3c\/td\x3e\n\x3ctd\x3e\\S\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\\s\x3c\/td\x3e\n\x3ctd\x3e匹配任何空白字符，包括空格、制表符、换页符等等（等价于[ fnrtv]）\x3c\/td\x3e\n\x3ctd\x3e\x3cstrong\x3e不支持\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cstrong\x3e不支持\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd\x3e\\s\x3c\/td\x3e\n\x3ctd\x3e\\s\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\\W\x3c\/td\x3e\n\x3ctd\x3e匹配任何非单词字符 (等价于\x3csup\x3e\x3ca class=\x22footnote-ref\x22\x3e3\x3c\/a\x3e\x3c\/sup\x3e)\x3c\/td\x3e\n\x3ctd\x3e\\W\x3c\/td\x3e\n\x3ctd\x3e\\W\x3c\/td\x3e\n\x3ctd\x3e\\W\x3c\/td\x3e\n\x3ctd\x3e\\W\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\\w\x3c\/td\x3e\n\x3ctd\x3e匹配包括下划线的任何单词字符（等价于[A-Za-z0-9_]）\x3c\/td\x3e\n\x3ctd\x3e\\w\x3c\/td\x3e\n\x3ctd\x3e\\w\x3c\/td\x3e\n\x3ctd\x3e\\w\x3c\/td\x3e\n\x3ctd\x3e\\w\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\\B\x3c\/td\x3e\n\x3ctd\x3e匹配非单词边界，例如：\x27erB\x27 能匹配 \x22verb\x22 中的\x27er\x27，但不能匹配\x22never\x22 中的\x27er\x27\x3c\/td\x3e\n\x3ctd\x3e\\B\x3c\/td\x3e\n\x3ctd\x3e\\B\x3c\/td\x3e\n\x3ctd\x3e\\B\x3c\/td\x3e\n\x3ctd\x3e\\B\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\\b\x3c\/td\x3e\n\x3ctd\x3e匹配一个单词边界，也就是指单词和空格间的位置，例如： \x27erb\x27 可以匹配\x22never\x22 中的 \x27er\x27，但不能匹配 \x22verb\x22 中的\x27er\x27\x3c\/td\x3e\n\x3ctd\x3e\\b\x3c\/td\x3e\n\x3ctd\x3e\\b\x3c\/td\x3e\n\x3ctd\x3e\\b\x3c\/td\x3e\n\x3ctd\x3e\\b\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\\t\x3c\/td\x3e\n\x3ctd\x3e匹配一个横向制表符（等价于 x09和 cI）\x3c\/td\x3e\n\x3ctd\x3e\x3cstrong\x3e不支持\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cstrong\x3e不支持\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd\x3e\\t\x3c\/td\x3e\n\x3ctd\x3e\\t\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\\v\x3c\/td\x3e\n\x3ctd\x3e匹配一个垂直制表符（等价于 x0b和 cK）\x3c\/td\x3e\n\x3ctd\x3e\x3cstrong\x3e不支持\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cstrong\x3e不支持\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd\x3e\\v\x3c\/td\x3e\n\x3ctd\x3e\\v\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\\n\x3c\/td\x3e\n\x3ctd\x3e匹配一个换行符（等价于 x0a 和cJ）\x3c\/td\x3e\n\x3ctd\x3e\x3cstrong\x3e不支持\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cstrong\x3e不支持\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd\x3e\\n\x3c\/td\x3e\n\x3ctd\x3e\\n\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\\f\x3c\/td\x3e\n\x3ctd\x3e匹配一个换页符（等价于x0c 和cL）\x3c\/td\x3e\n\x3ctd\x3e\x3cstrong\x3e不支持\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cstrong\x3e不支持\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd\x3e\\f\x3c\/td\x3e\n\x3ctd\x3e\\f\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\\r\x3c\/td\x3e\n\x3ctd\x3e匹配一个回车符（等价于 x0d 和cM）\x3c\/td\x3e\n\x3ctd\x3e\x3cstrong\x3e不支持\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cstrong\x3e不支持\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd\x3e\\r\x3c\/td\x3e\n\x3ctd\x3e\\r\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\\\x3c\/td\x3e\n\x3ctd\x3e匹配转义字符本身\x22\x22\x3c\/td\x3e\n\x3ctd\x3e\\\x3c\/td\x3e\n\x3ctd\x3e\\\x3c\/td\x3e\n\x3ctd\x3e\\\x3c\/td\x3e\n\x3ctd\x3e\\\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3ecx\x3c\/td\x3e\n\x3ctd\x3e匹配由 x 指明的控制字符，例如：cM匹配一个Control-M 或回车符，x 的值必须为A-Z 或 a-z 之一，否则，将 c 视为一个原义的 \x27c\x27 字符\x3c\/td\x3e\n\x3ctd\x3e\x3cstrong\x3e不支持\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cstrong\x3e不支持\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd\x3e \x3c\/td\x3e\n\x3ctd\x3ecx\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3exn\x3c\/td\x3e\n\x3ctd\x3e匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长，例如：\x27x41\x27 匹配 \x22A\x22。\x27x041\x27 则等价于\x27x04\x27 \x26amp; \x221\x22。正则表达式中可以使用 ASCII 编码\x3c\/td\x3e\n\x3ctd\x3e\x3cstrong\x3e不支持\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd\x3e\x3cstrong\x3e不支持\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd\x3e \x3c\/td\x3e\n\x3ctd\x3exn\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3enum\x3c\/td\x3e\n\x3ctd\x3e匹配 num，其中 num是一个正整数。表示对所获取的匹配的引用\x3c\/td\x3e\n\x3ctd\x3e\x3cstrong\x3e不支持\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd\x3enum\x3c\/td\x3e\n\x3ctd\x3enum\x3c\/td\x3e\n\x3ctd\x3e \x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e[:alnum:]\x3c\/td\x3e\n\x3ctd\x3e匹配任何一个字母或数字（[A-Za-z0-9]），例如：\x27[[:alnum:]] \x27\x3c\/td\x3e\n\x3ctd\x3e[:alnum:]\x3c\/td\x3e\n\x3ctd\x3e[:alnum:]\x3c\/td\x3e\n\x3ctd\x3e[:alnum:]\x3c\/td\x3e\n\x3ctd\x3e[:alnum:]\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e[:alpha:]\x3c\/td\x3e\n\x3ctd\x3e匹配任何一个字母（[A－Za－z]）， 例如：\x27 [[:alpha:]] \x27\x3c\/td\x3e\n\x3ctd\x3e[:alpha:]\x3c\/td\x3e\n\x3ctd\x3e[:alpha:]\x3c\/td\x3e\n\x3ctd\x3e[:alpha:]\x3c\/td\x3e\n\x3ctd\x3e[:alpha:]\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e[:digit:]\x3c\/td\x3e\n\x3ctd\x3e匹配任何一个数字（[0-9]），例如：\x27[[:digit:]] \x27\x3c\/td\x3e\n\x3ctd\x3e[:digit:]\x3c\/td\x3e\n\x3ctd\x3e[:digit:]\x3c\/td\x3e\n\x3ctd\x3e[:digit:]\x3c\/td\x3e\n\x3ctd\x3e[:digit:]\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e[:lower:]\x3c\/td\x3e\n\x3ctd\x3e匹配任何一个小写字母（[a-z]）， 例如：\x27 [[:lower:]] \x27\x3c\/td\x3e\n\x3ctd\x3e[:lower:]\x3c\/td\x3e\n\x3ctd\x3e[:lower:]\x3c\/td\x3e\n\x3ctd\x3e[:lower:]\x3c\/td\x3e\n\x3ctd\x3e[:lower:]\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e[:upper:]\x3c\/td\x3e\n\x3ctd\x3e匹配任何一个大写字母（[A-Z]）\x3c\/td\x3e\n\x3ctd\x3e[:upper:]\x3c\/td\x3e\n\x3ctd\x3e[:upper:]\x3c\/td\x3e\n\x3ctd\x3e[:upper:]\x3c\/td\x3e\n\x3ctd\x3e[:upper:]\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e[:space:]\x3c\/td\x3e\n\x3ctd\x3e任何一个空白字符： 支持制表符、空格，例如：\x27 [[:space:]] \x27\x3c\/td\x3e\n\x3ctd\x3e[:space:]\x3c\/td\x3e\n\x3ctd\x3e[:space:]\x3c\/td\x3e\n\x3ctd\x3e[:space:]\x3c\/td\x3e\n\x3ctd\x3e[:space:]\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e[:blank:]\x3c\/td\x3e\n\x3ctd\x3e空格和制表符（横向和纵向），例如：\x27[[:blank:]]\x27ó\x27[stv]\x27\x3c\/td\x3e\n\x3ctd\x3e[:blank:]\x3c\/td\x3e\n\x3ctd\x3e[:blank:]\x3c\/td\x3e\n\x3ctd\x3e[:blank:]\x3c\/td\x3e\n\x3ctd\x3e[:blank:]\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e[:graph:]\x3c\/td\x3e\n\x3ctd\x3e任何一个可以看得见的且可以打印的字符（注意：不包括空格和换行符等），例如：\x27[[:graph:]] \x27\x3c\/td\x3e\n\x3ctd\x3e[:graph:]\x3c\/td\x3e\n\x3ctd\x3e[:graph:]\x3c\/td\x3e\n\x3ctd\x3e[:graph:]\x3c\/td\x3e\n\x3ctd\x3e[:graph:]\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e[:print:]\x3c\/td\x3e\n\x3ctd\x3e任何一个可以打印的字符（注意：不包括：[:cntrl:]、字符串结束符\x270\x27、EOF 文件结束符（-1）， 但包括空格符号），例如：\x27[[:print:]] \x27\x3c\/td\x3e\n\x3ctd\x3e[:print:]\x3c\/td\x3e\n\x3ctd\x3e[:print:]\x3c\/td\x3e\n\x3ctd\x3e[:print:]\x3c\/td\x3e\n\x3ctd\x3e[:print:]\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e[:cntrl:]\x3c\/td\x3e\n\x3ctd\x3e任何一个控制字符（ASCII 字符集中的前 32 个字符，即：用十进制表示为从 0 到31，例如：换行符、制表符等等），例如：\x27 [[:cntrl:]]\x27\x3c\/td\x3e\n\x3ctd\x3e[:cntrl:]\x3c\/td\x3e\n\x3ctd\x3e[:cntrl:]\x3c\/td\x3e\n\x3ctd\x3e[:cntrl:]\x3c\/td\x3e\n\x3ctd\x3e[:cntrl:]\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e[:punct:]\x3c\/td\x3e\n\x3ctd\x3e任何一个标点符号（不包括：[:alnum:]、[:cntrl:]、[:space:]这些字符集）\x3c\/td\x3e\n\x3ctd\x3e[:punct:]\x3c\/td\x3e\n\x3ctd\x3e[:punct:]\x3c\/td\x3e\n\x3ctd\x3e[:punct:]\x3c\/td\x3e\n\x3ctd\x3e[:punct:]\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e[:xdigit:]\x3c\/td\x3e\n\x3ctd\x3e任何一个十六进制数（即：0-9，a-f，A-F）\x3c\/td\x3e\n\x3ctd\x3e[:xdigit:]\x3c\/td\x3e\n\x3ctd\x3e[:xdigit:]\x3c\/td\x3e\n\x3ctd\x3e[:xdigit:]\x3c\/td\x3e\n\x3ctd\x3e[:xdigit:]\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3c\/tbody\x3e\n\x3c\/table\x3e\n\x3cp\x3e\x3cstrong\x3e注意\x3c\/strong\x3e\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3ejs中支持的是EREs.\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e当使用 BREs ( 基本正则表达式 ) 时，必须在下列这些符号(?,\x2b,|,{,},(,))前加上转义字符  .\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e上述[[:xxxx:]] 形式的正则表达式, 是php中内置的通用字符簇, js中并不支持.\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader18\x22\x3elinux\/osx下常用命令与正则表达式的关系\x3c\/h3\x3e\n\x3cp\x3e我曾经尝试在 grep 和 sed 命令中书写正则表达式, 经常发现不能使用元字符, 而且有时候需要转义, 有时候不需要转义, 始终不能摸清它的规律. 如果恰好你也有同样的困惑, 那么请往下看, 相信应该能有所收获.\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader19\x22\x3egrep , egrep , sed , awk  正则表达式特点\x3c\/h3\x3e\n\x3cp\x3egrep 支持：BREs、EREs、PREs 正则表达式\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3egrep 指令后不跟任何参数, 则表示要使用 \x22BREs\x22\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3egrep 指令后跟 ”-E\x22 参数, 则表示要使用 \x22EREs\x22\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3egrep 指令后跟 “-P\x22 参数, 则表示要使用 \x22PREs\x22\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3eegrep 支持：EREs、PREs 正则表达式\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eegrep 指令后不跟任何参数, 则表示要使用 \x22EREs\x22\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eegrep 指令后跟 “-P\x22 参数, 则表示要使用 \x22PREs\x22\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3esed 支持: BREs、EREs\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3esed 指令默认是使用 \x22BREs\x22\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3esed 指令后跟 \x22-r\x22 参数 , 则表示要使用“EREs\x22\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3eawk 支持 EREs, 并且默认使用 \x22EREs\x22\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader20\x22\x3e正则表达式初阶技能\x3c\/h3\x3e\n\x3ch3 id=\x22articleHeader21\x22\x3e贪婪模式与非贪婪模式\x3c\/h3\x3e\n\x3cp\x3e默认情况下, 所有的限定词都是贪婪模式, 表示尽可能多的去捕获字符; 而在限定词后增加?, 则是非贪婪模式, 表示尽可能少的去捕获字符. 如下:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var str = \x26quot;aaab\x26quot;,\n    reg1 = \/a\x2b\/, \/\/贪婪模式\n    reg2 = \/a\x2b?\/;\/\/非贪婪模式\nconsole.log(str.match(reg1)); \/\/[\x26quot;aaa\x26quot;], 由于是贪婪模式, 捕获了所有的a\nconsole.log(str.match(reg2)); \/\/[\x26quot;a\x26quot;], 由于是非贪婪模式, 只捕获到第一个a\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e str = \x3cspan class=\x22hljs-string\x22\x3e\x22aaab\x22\x3c\/span\x3e,\n    reg1 = \x3cspan class=\x22hljs-regexp\x22\x3e\/a\x2b\/\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/贪婪模式\x3c\/span\x3e\n    reg2 = \x3cspan class=\x22hljs-regexp\x22\x3e\/a\x2b?\/\x3c\/span\x3e;\x3cspan class=\x22hljs-comment\x22\x3e\/\/非贪婪模式\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(str.match(reg1)); \x3cspan class=\x22hljs-comment\x22\x3e\/\/[\x22aaa\x22], 由于是贪婪模式, 捕获了所有的a\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(str.match(reg2)); \x3cspan class=\x22hljs-comment\x22\x3e\/\/[\x22a\x22], 由于是非贪婪模式, 只捕获到第一个a\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e实际上, 非贪婪模式非常有效, 特别是当匹配html标签时. 比如匹配一个配对出现的div, 方案一可能会匹配到很多的div标签对, 而方案二则只会匹配一个div标签对.\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var str = \x26quot;\x3cdiv class=\x27v1\x27\x3e\x3cdiv class=\x27v2\x27\x3etest\x3c\/div\x3e\x3cinput type=\x27text\x27\/\x3e\x3c\/div\x3e\x26quot;;\nvar reg1 = \/\x3cdiv.*\x3c\\\/div\x3e\/; \/\/方案一,贪婪匹配\nvar reg2 = \/\x3cdiv.*?\x3c\\\/div\x3e\/;\/\/方案二,非贪婪匹配\nconsole.log(str.match(reg1));\/\/\x26quot;\x3cdiv class=\x27v1\x27\x3e\x3cdiv class=\x27v2\x27\x3etest\x3c\/div\x3e\x3cinput type=\x27text\x27\/\x3e\x3c\/div\x3e\x26quot;\nconsole.log(str.match(reg2));\/\/\x26quot;\x3cdiv class=\x27v1\x27\x3e\x3cdiv class=\x27v2\x27\x3etest\x3c\/div\x3e\x26quot;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e str = \x3cspan class=\x22hljs-string\x22\x3e\x22\x26lt;div class=\x27v1\x27\x26gt;\x26lt;div class=\x27v2\x27\x26gt;test\x26lt;\/div\x26gt;\x26lt;input type=\x27text\x27\/\x26gt;\x26lt;\/div\x26gt;\x22\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e reg1 = \x3cspan class=\x22hljs-regexp\x22\x3e\/\x26lt;div.*\x26lt;\\\/div\x26gt;\/\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/方案一,贪婪匹配\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e reg2 = \x3cspan class=\x22hljs-regexp\x22\x3e\/\x26lt;div.*?\x26lt;\\\/div\x26gt;\/\x3c\/span\x3e;\x3cspan class=\x22hljs-comment\x22\x3e\/\/方案二,非贪婪匹配\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(str.match(reg1));\x3cspan class=\x22hljs-comment\x22\x3e\/\/\x22\x26lt;div class=\x27v1\x27\x26gt;\x26lt;div class=\x27v2\x27\x26gt;test\x26lt;\/div\x26gt;\x26lt;input type=\x27text\x27\/\x26gt;\x26lt;\/div\x26gt;\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(str.match(reg2));\x3cspan class=\x22hljs-comment\x22\x3e\/\/\x22\x26lt;div class=\x27v1\x27\x26gt;\x26lt;div class=\x27v2\x27\x26gt;test\x26lt;\/div\x26gt;\x22\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch5\x3e区间量词的非贪婪模式\x3c\/h5\x3e\n\x3cp\x3e一般情况下, 非贪婪模式, 我们使用的是\x22*?\x22, 或 \x22\x2b?\x22 这种形式, 还有一种是 \x22{n,m}?\x22.\x3c\/p\x3e\n\x3cp\x3e区间量词\x22{n,m}\x22 也是匹配优先, 虽有匹配次数上限, 但是在到达上限之前, 它依然是尽可能多的匹配, 而\x22{n,m}?\x22 则表示在区间范围内, 尽可能少的匹配.\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e需要注意的是\x3c\/strong\x3e:\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e能达到同样匹配结果的贪婪与非贪婪模式, 通常是贪婪模式的匹配效率较高.\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e所有的非贪婪模式, 都可以通过修改量词修饰的子表达式, 转换为贪婪模式.\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e贪婪模式可以与\x3ccode\x3e固化分组\x3c\/code\x3e(后面会讲到)结合，提升匹配效率，而非贪婪模式却不可以.\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch4\x3e分组\x3c\/h4\x3e\n\x3cp\x3e正则的分组主要通过小括号来实现, 括号包裹的子表达式作为一个分组, 括号后可以紧跟限定词表示重复次数. 如下, 小括号内包裹的abc便是一个分组:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/(abc)\x2b\/.test(\x26quot;abc123\x26quot;) == true\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\/(abc)\x2b\x3cspan class=\x22hljs-regexp\x22\x3e\/.test(\x22abc123\x22) == true\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e那么分组有什么用呢? 一般来说, 分组是为了方便的表示重复次数, 除此之外, 还有一个作用就是用于捕获, 请往下看.\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader22\x22\x3e捕获性分组\x3c\/h3\x3e\n\x3cp\x3e捕获性分组, 通常由一对小括号加上子表达式组成. 捕获性分组会创建反向引用, 每个反向引用都由一个编号或名称来标识, js中主要是通过 \x3ccode\x3e$\x2b编号\x3c\/code\x3e 或者 \x3ccode\x3e\\\x2b编号\x3c\/code\x3e 表示法进行引用. 如下便是一个捕获性分组的例子.\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var color = \x26quot;#808080\x26quot;;\nvar output = color.replace(\/#(\\d\x2b)\/,\x26quot;$1\x26quot;\x2b\x26quot;~~\x26quot;);\/\/自然也可以写成 \x26quot;$1~~\x26quot;\nconsole.log(RegExp.$1);\/\/808080\nconsole.log(output);\/\/808080~~\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e color = \x3cspan class=\x22hljs-string\x22\x3e\x22#808080\x22\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e output = color.replace(\x3cspan class=\x22hljs-regexp\x22\x3e\/#(\\d\x2b)\/\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x22$1\x22\x3c\/span\x3e\x2b\x3cspan class=\x22hljs-string\x22\x3e\x22~~\x22\x3c\/span\x3e);\x3cspan class=\x22hljs-comment\x22\x3e\/\/自然也可以写成 \x22$1~~\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-built_in\x22\x3eRegExp\x3c\/span\x3e.$\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\x3cspan class=\x22hljs-comment\x22\x3e\/\/808080\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(output);\x3cspan class=\x22hljs-comment\x22\x3e\/\/808080~~\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上, (d\x2b) 表示一个捕获性分组, \x22RegExp.\x26amp;dollar;1\x22 指向该分组捕获的内容. \x3ccode\x3e$\x2b编号\x3c\/code\x3e 这种引用通常在正则表达式之外使用. \x3ccode\x3e\\\x2b编号\x3c\/code\x3e 这种引用却可以在正则表达式中使用, 可用于匹配不同位置相同部分的子串.\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var url = \x26quot;www.google.google.com\x26quot;;\nvar re = \/([a-z]\x2b)\\.\\1\/;\nconsole.log(url.replace(re,\x26quot;$1\x26quot;));\/\/\x26quot;www.google.com\x26quot;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e url = \x3cspan class=\x22hljs-string\x22\x3e\x22www.google.google.com\x22\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e re = \x3cspan class=\x22hljs-regexp\x22\x3e\/([a-z]\x2b)\\.\\1\/\x3c\/span\x3e;\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(url.replace(re,\x3cspan class=\x22hljs-string\x22\x3e\x22$1\x22\x3c\/span\x3e));\x3cspan class=\x22hljs-comment\x22\x3e\/\/\x22www.google.com\x22\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上, 相同部分的\x22google\x22字符串只被替换一次.\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader23\x22\x3e非捕获性分组\x3c\/h3\x3e\n\x3cp\x3e非捕获性分组, 通常由一对括号加上\x22?:\x22加上子表达式组成, 非捕获性分组不会创建反向引用, 就好像没有括号一样. 如下:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var color = \x26quot;#808080\x26quot;;\nvar output = color.replace(\/#(?:\\d\x2b)\/,\x26quot;$1\x26quot;\x2b\x26quot;~~\x26quot;);\nconsole.log(RegExp.$1);\/\/\x26quot;\x26quot;\nconsole.log(output);\/\/$1~~\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e color = \x3cspan class=\x22hljs-string\x22\x3e\x22#808080\x22\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e output = color.replace(\x3cspan class=\x22hljs-regexp\x22\x3e\/#(?:\\d\x2b)\/\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x22$1\x22\x3c\/span\x3e\x2b\x3cspan class=\x22hljs-string\x22\x3e\x22~~\x22\x3c\/span\x3e);\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-built_in\x22\x3eRegExp\x3c\/span\x3e.$\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\x3cspan class=\x22hljs-comment\x22\x3e\/\/\x22\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(output);\x3cspan class=\x22hljs-comment\x22\x3e\/\/$1~~\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上, (?:d\x2b) 表示一个非捕获性分组, 由于分组不捕获任何内容, 所以, RegExp.$1 就指向了空字符串.\x3cbr\x3e同时, 由于$1 的反向引用不存在, 因此最终它被当成了普通字符串进行替换.\x3cbr\x3e实际上, 捕获性分组和无捕获性分组在搜索效率方面也没什么不同, 没有哪一个比另一个更快.\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader24\x22\x3e命名分组\x3c\/h3\x3e\n\x3cp\x3e语法: (?\x26lt;name\x26gt;...)\x3c\/p\x3e\n\x3cp\x3e命名分组也是捕获性分组,  它将匹配的字符串捕获到一个组名称或编号名称中, 在获得匹配结果后, 可通过分组名进行获取. 如下是一个python的命名分组的例子.\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import re\ndata = \x26quot;#808080\x26quot;\nregExp = r\x26quot;#(?P\x3cone\x3e\\d\x2b)\x26quot;\nreplaceString = \x26quot;\\g\x3cone\x3e\x26quot; \x2b \x26quot;~~\x26quot;\nprint re.sub(regExp,replaceString,data) # 808080~~\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22python hljs\x22\x3e\x3ccode class=\x22python\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e re\ndata = \x3cspan class=\x22hljs-string\x22\x3e\x22#808080\x22\x3c\/span\x3e\nregExp = \x3cspan class=\x22hljs-string\x22\x3er\x22#(?P\x26lt;one\x26gt;\\d\x2b)\x22\x3c\/span\x3e\nreplaceString = \x3cspan class=\x22hljs-string\x22\x3e\x22\\g\x26lt;one\x26gt;\x22\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22~~\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eprint\x3c\/span\x3e re.sub(regExp,replaceString,data) \x3cspan class=\x22hljs-comment\x22\x3e# 808080~~\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3epython的命名分组表达式与标准格式相比, 在 ? 后多了一大写的 P 字符, 并且python通过“g\x26lt;命名\x26gt;\x22表示法进行引用. (如果是捕获性分组, python通过\x22g\x26lt;编号\x26gt;\x22表示法进行引用)\x3c\/p\x3e\n\x3cp\x3e与python不同的是, javaScript 中并不支持命名分组.\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader25\x22\x3e固化分组\x3c\/h3\x3e\n\x3cp\x3e固化分组, 又叫原子组.\x3c\/p\x3e\n\x3cp\x3e语法: (?\x26gt;...)\x3c\/p\x3e\n\x3cp\x3e如上所述, 我们在使用非贪婪模式时, 匹配过程中可能会进行多次的回溯, 回溯越多, 正则表达式的运行效率就越低. 而固化分组就是用来减少回溯次数的.\x3c\/p\x3e\n\x3cp\x3e实际上, 固化分组(?\x26gt;…)的匹配与正常的匹配并无分别, 它并不会改变匹配结果. 唯一的不同就是: 固化分组匹配结束时, 它匹配到的文本已经固化为一个单元, 只能作为整体而保留或放弃, 括号内的子表达式中未尝试过的备用状态都会被放弃, 所以回溯永远也不能选择其中的状态(因此不能参与回溯). 下面我们来通过一个例子更好地理解固化分组.\x3c\/p\x3e\n\x3cp\x3e假如要处理一批数据, 原格式为 123.456, 因为浮点数显示问题, 部分数据格式会变为123.456000000789这种, 现要求只保留小数点后2~3位, 但是最后一位不能为0, 那么这个正则怎么写呢?\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var str = \x26quot;123.456000000789\x26quot;;\nstr = str.replace(\/(\\.\\d\\d[1-9]?)\\d*\/,\x26quot;$1\x26quot;); \/\/123.456\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e str = \x3cspan class=\x22hljs-string\x22\x3e\x22123.456000000789\x22\x3c\/span\x3e;\nstr = str.replace(\x3cspan class=\x22hljs-regexp\x22\x3e\/(\\.\\d\\d[1-9]?)\\d*\/\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x22$1\x22\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/123.456\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上的正则, 对于\x22123.456\x22 这种格式的数据, 将白白处理一遍. 为了提高效率, 我们将正则最后的一个\x22*\x22改为\x22\x2b\x22. 如下:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var str = \x26quot;123.456\x26quot;;\nstr = str.replace(\/(\\.\\d\\d[1-9]?)\\d\x2b\/,\x26quot;$1\x26quot;); \/\/123.45\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e str = \x3cspan class=\x22hljs-string\x22\x3e\x22123.456\x22\x3c\/span\x3e;\nstr = str.replace(\x3cspan class=\x22hljs-regexp\x22\x3e\/(\\.\\d\\d[1-9]?)\\d\x2b\/\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x22$1\x22\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/123.45\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e此时, \x22dd[1-9]?\x22 子表达式, 匹配是 \x2245\x22, 而不是 \x22456\x22, 这是因为正则末尾使用了\x22\x2b\x22, 表示末尾至少要匹配一个数字, 因此末尾的子表达式\x22d\x2b\x22 匹配到了 \x226\x22. 显然 \x22123.45\x22 不是我们期望的匹配结果, 那我们应该怎么做呢? 能否让 \x22[1-9]?\x22 一旦匹配成功, 便不再进行回溯, 这里就要用到我们上面说的固化分组.\x3c\/p\x3e\n\x3cp\x3e\x22(\\.dd(?\x26gt;[1-9]?))d\x2b\x22 便是上述正则的固化分组形式. 由于字符串 \x22123.456\x22 不满足该固化分组的正则, 所以, 匹配会失败, 符合我们期望.\x3c\/p\x3e\n\x3cp\x3e下面我们来分析下固化分组的正则 (\\.dd(?\x26gt;[1-9]?))d\x2b 为什么匹配不到字符串\x22123.456\x22.\x3c\/p\x3e\n\x3cp\x3e很明显, 对于上述固化分组, 只存在两种匹配结果.\x3c\/p\x3e\n\x3cp\x3e情况①: 若 [1-9] 匹配失败, 正则会返回 ? 留下的备用状态. 然后匹配脱离固化分组, 继续前进到[d\x2b]. 当控制权离开固化分组时, 没有备用状态需要放弃(因固化分组中根本没有创建任何备用状态).\x3c\/p\x3e\n\x3cp\x3e情况②: 若 [1-9] 匹配成功, 匹配脱离固化分组之后,  ? 保存的备用状态仍然存在, 但是, 由于它属于已经结束的固化分组, 所以会被抛弃.\x3c\/p\x3e\n\x3cp\x3e对于字符串 \x22123.456\x22, 由于 [1-9] 能够匹配成功, 所以它符合情况②. 下面我们来还原情况②的执行现场.\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e匹配所处的状态:  匹配已经走到了 \x226\x22 的位置, 匹配将继续前进;==\x26gt;\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e子表达式 d\x2b 发现无法匹配, 正则引擎便尝试回溯;==\x26gt;\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e查看是否存在备用状态以供回溯?==\x26gt;\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x22?\x22 保存的备用状态属于已经结束的固化分组, 所以该备用状态会被放弃;==\x26gt;\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e此时固化分组匹配到的 \x226\x22, 便不能用于正则引擎的回溯;==\x26gt;\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e尝试回溯失败;==\x26gt;\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e正则匹配失败.==\x26gt;\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e文本 \x22123.456\x22 没有被正则表达式匹配上, 符合预期.\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e相应的流程图如下:\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000008367189?w=1078\x26amp;h=1360\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000008367189?w=1078\x26amp;h=1360\x22 alt=\x22正则表达式流程图\x22 title=\x22正则表达式流程图\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e遗憾的是, javaScript, java 和 python中并不支持固化分组的语法, 不过, 它在php和.NET中表现良好. 下面提供了一个php版的固化分组形式的正则表达式, 以供尝试.\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22$str = \x26quot;123.456\x26quot;;\necho preg_replace(\x26quot;\/(\\.\\d\\d(?\x3e[1-9]?))\\d\x2b\/\x26quot;,\x26quot;\\\\1\x26quot;,$str); \/\/固化分组\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22php hljs\x22\x3e\x3ccode class=\x22php\x22\x3e$str = \x3cspan class=\x22hljs-string\x22\x3e\x22123.456\x22\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eecho\x3c\/span\x3e preg_replace(\x3cspan class=\x22hljs-string\x22\x3e\x22\/(\\.\\d\\d(?\x26gt;[1-9]?))\\d\x2b\/\x22\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x22\\\\1\x22\x3c\/span\x3e,$str); \x3cspan class=\x22hljs-comment\x22\x3e\/\/固化分组\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e不仅如此, php还提供了占有量词优先的语法. 如下:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22$str = \x26quot;123.456\x26quot;;\necho preg_replace(\x26quot;\/(\\.\\d\\d[1-9]?\x2b)\\d\x2b\/\x26quot;,\x26quot;\\\\1\x26quot;,$str); \/\/占有量词优先\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22php hljs\x22\x3e\x3ccode class=\x22php\x22\x3e$str = \x3cspan class=\x22hljs-string\x22\x3e\x22123.456\x22\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eecho\x3c\/span\x3e preg_replace(\x3cspan class=\x22hljs-string\x22\x3e\x22\/(\\.\\d\\d[1-9]?\x2b)\\d\x2b\/\x22\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x22\\\\1\x22\x3c\/span\x3e,$str); \x3cspan class=\x22hljs-comment\x22\x3e\/\/占有量词优先\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e虽然java不支持固化分组的语法, 但java也提供了占有量词优先的语法, 同样能够避免正则回溯. 如下:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22String str = \x26quot;123.456\x26quot;;\nSystem.out.println(str.replaceAll(\x26quot;(\\\\.\\\\d\\\\d[1-9]?\x2b)\\\\d\x2b\x26quot;, \x26quot;$1\x26quot;));\/\/ 123.456\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22java hljs\x22\x3e\x3ccode class=\x22java\x22\x3eString str = \x3cspan class=\x22hljs-string\x22\x3e\x22123.456\x22\x3c\/span\x3e;\nSystem.out.println(str.replaceAll(\x3cspan class=\x22hljs-string\x22\x3e\x22(\\\\.\\\\d\\\\d[1-9]?\x2b)\\\\d\x2b\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22$1\x22\x3c\/span\x3e));\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 123.456\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e值得注意的是: java中 replaceAll 方法需要转义反斜杠.\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader26\x22\x3e正则表达式高阶技能-零宽断言\x3c\/h3\x3e\n\x3cp\x3e如果说正则分组是写轮眼, 那么零宽断言就是万花筒写轮眼终极奥义-须佐能乎(这里借火影忍术打个比方). 合理地使用零宽断言, 能够能分组之不能, 极大地增强正则匹配能力, 它甚至可以帮助你在匹配条件非常模糊的情况下快速地定位文本.\x3c\/p\x3e\n\x3cp\x3e零宽断言, 又叫环视. 环视只进行子表达式的匹配, 匹配到的内容不保存到最终的匹配结果, 由于匹配是零宽度的, 故最终匹配到的只是一个位置. \x3c\/p\x3e\n\x3cp\x3e环视按照方向划分, 有顺序和逆序两种(也叫前瞻和后瞻), 按照是否匹配有肯定和否定两种, 组合之, 便有4种环视. 4种环视并不复杂, 如下便是它们的描述.\x3c\/p\x3e\n\x3ctable\x3e\n\x3cthead\x3e\x3ctr\x3e\n\x3cth align=\x22center\x22\x3e\x3cstrong\x3e字符\x3c\/strong\x3e\x3c\/th\x3e\n\x3cth\x3e\x3cstrong\x3e描述\x3c\/strong\x3e\x3c\/th\x3e\n\x3cth\x3e\x3cstrong\x3e示例\x3c\/strong\x3e\x3c\/th\x3e\n\x3c\/tr\x3e\x3c\/thead\x3e\n\x3ctbody\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e(?:\x3cem\x3epattern\x3c\/em\x3e)\x3c\/td\x3e\n\x3ctd\x3e非捕获性分组, 匹配pattern的位置, 但不捕获匹配结果.也就是说不创建反向引用, 就好像没有括号一样.\x3c\/td\x3e\n\x3ctd\x3e\x27abcd(?:e)匹配\x27abcde\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e(?=\x3cem\x3epattern\x3c\/em\x3e)\x3c\/td\x3e\n\x3ctd\x3e\n\x3cstrong\x3e顺序肯定环视\x3c\/strong\x3e, 匹配后面是pattern 的位置, 不捕获匹配结果.\x3c\/td\x3e\n\x3ctd\x3e\x27Windows (?=2000)\x27匹配 \x22Windows2000\x22 中的 \x22Windows\x22; 不匹配 \x22Windows3.1\x22 中的 \x22Windows\x22\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e(?!\x3cem\x3epattern\x3c\/em\x3e)\x3c\/td\x3e\n\x3ctd\x3e\n\x3cstrong\x3e顺序否定环视\x3c\/strong\x3e, 匹配后面不是 pattern 的位置, 不捕获匹配结果.\x3c\/td\x3e\n\x3ctd\x3e\x27Windows (?!2000)\x27匹配 \x22Windows3.1\x22 中的 \x22Windows\x22; 不匹配 \x22Windows2000\x22 中的 \x22Windows\x22\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e(?\x26lt;=\x3cem\x3epattern\x3c\/em\x3e)\x3c\/td\x3e\n\x3ctd\x3e\n\x3cstrong\x3e逆序肯定环视\x3c\/strong\x3e, 匹配前面是 pattern 的位置, 不捕获匹配结果.\x3c\/td\x3e\n\x3ctd\x3e\x27(?\x26lt;=Office)2000\x27匹配 \x22 Office2000\x22 中的 \x222000\x22; 不匹配 \x22Windows2000\x22 中的 \x222000\x22\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e(?\x26lt;!\x3cem\x3epattern\x3c\/em\x3e)\x3c\/td\x3e\n\x3ctd\x3e\n\x3cstrong\x3e逆序否定环视\x3c\/strong\x3e, 匹配前面不是 pattern 的位置, 不捕获匹配结果.\x3c\/td\x3e\n\x3ctd\x3e\x27(?\x26lt;!Office)2000\x27匹配 \x22 Windows2000\x22 中的 \x222000\x22; 不匹配 \x22 Office2000\x22 中的 \x222000\x22\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3c\/tbody\x3e\n\x3c\/table\x3e\n\x3cp\x3e非捕获性分组由于结构与环视相似, 故列在表中, 以做对比. 以上4种环视中, 目前 javaScript 中只支持前两种, 也就是只支持 \x3cstrong\x3e顺序肯定环视\x3c\/strong\x3e 和 \x3cstrong\x3e顺序否定环视\x3c\/strong\x3e. 下面我们通过实例来帮助理解下:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var str = \x26quot;123abc789\x26quot;,s;\n\/\/没有使用环视,abc直接被替换\ns = str.replace(\/abc\/,456);\nconsole.log(s); \/\/123456789\n\n\/\/使用了顺序肯定环视,捕获到了a前面的位置,所以abc没有被替换,只是将3替换成了3456\ns = str.replace(\/3(?=abc)\/,3456);\nconsole.log(s); \/\/123456abc789\n\n\/\/使用了顺序否定环视,由于3后面跟着abc,不满意条件,故捕获失败,所以原字符串没有被替换\ns = str.replace(\/3(?!abc)\/,3456);\nconsole.log(s); \/\/123abc789\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e str = \x3cspan class=\x22hljs-string\x22\x3e\x22123abc789\x22\x3c\/span\x3e,s;\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/没有使用环视,abc直接被替换\x3c\/span\x3e\ns = str.replace(\x3cspan class=\x22hljs-regexp\x22\x3e\/abc\/\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e456\x3c\/span\x3e);\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(s); \x3cspan class=\x22hljs-comment\x22\x3e\/\/123456789\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/使用了顺序肯定环视,捕获到了a前面的位置,所以abc没有被替换,只是将3替换成了3456\x3c\/span\x3e\ns = str.replace(\x3cspan class=\x22hljs-regexp\x22\x3e\/3(?=abc)\/\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e3456\x3c\/span\x3e);\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(s); \x3cspan class=\x22hljs-comment\x22\x3e\/\/123456abc789\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/使用了顺序否定环视,由于3后面跟着abc,不满意条件,故捕获失败,所以原字符串没有被替换\x3c\/span\x3e\ns = str.replace(\x3cspan class=\x22hljs-regexp\x22\x3e\/3(?!abc)\/\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e3456\x3c\/span\x3e);\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(s); \x3cspan class=\x22hljs-comment\x22\x3e\/\/123abc789\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e下面通过python来演示下 \x3cstrong\x3e逆序肯定环视\x3c\/strong\x3e 和 \x3cstrong\x3e逆序否定环视\x3c\/strong\x3e 的用法.\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import re\ndata = \x26quot;123abc789\x26quot;\n# 使用了逆序肯定环视,替换左边为123的连续的小写英文字母,匹配成功,故abc被替换为456\nregExp = r\x26quot;(?\x3c=123)[a-z]\x2b\x26quot;\nreplaceString = \x26quot;456\x26quot;\nprint re.sub(regExp,replaceString,data) # 123456789\n\n# 使用了逆序否定环视,由于英文字母左侧不能为123,故子表达式[a-z]\x2b捕获到bc,最终bc被替换为456\nregExp = r\x26quot;(?\x3c!123)[a-z]\x2b\x26quot;\nreplaceString = \x26quot;456\x26quot;\nprint re.sub(regExp,replaceString,data) # 123a456789\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22python hljs\x22\x3e\x3ccode class=\x22python\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e re\ndata = \x3cspan class=\x22hljs-string\x22\x3e\x22123abc789\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e# 使用了逆序肯定环视,替换左边为123的连续的小写英文字母,匹配成功,故abc被替换为456\x3c\/span\x3e\nregExp = \x3cspan class=\x22hljs-string\x22\x3er\x22(?\x26lt;=123)[a-z]\x2b\x22\x3c\/span\x3e\nreplaceString = \x3cspan class=\x22hljs-string\x22\x3e\x22456\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eprint\x3c\/span\x3e re.sub(regExp,replaceString,data) \x3cspan class=\x22hljs-comment\x22\x3e# 123456789\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e# 使用了逆序否定环视,由于英文字母左侧不能为123,故子表达式[a-z]\x2b捕获到bc,最终bc被替换为456\x3c\/span\x3e\nregExp = \x3cspan class=\x22hljs-string\x22\x3er\x22(?\x26lt;!123)[a-z]\x2b\x22\x3c\/span\x3e\nreplaceString = \x3cspan class=\x22hljs-string\x22\x3e\x22456\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eprint\x3c\/span\x3e re.sub(regExp,replaceString,data) \x3cspan class=\x22hljs-comment\x22\x3e# 123a456789\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e需要注意的是: python 和 perl 语言中的 \x3cstrong\x3e逆序环视\x3c\/strong\x3e 的子表达式只能使用定长的文本. 比如将上述 \x22(?\x26lt;=123)\x22 (逆序肯定环视)子表达式写成 \x22(?\x26lt;=[0-9]\x2b)\x22, python解释器将会报错: \x22error: look-behind requires fixed-width pattern\x22.\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader27\x22\x3e场景回顾\x3c\/h3\x3e\n\x3ch3 id=\x22articleHeader28\x22\x3e获取html片段\x3c\/h3\x3e\n\x3cp\x3e假如现在, js 通过 ajax 获取到一段 html 代码如下:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var responseText = \x26quot;\x3cdiv data=\x27dev.xxx.txt\x27\x3e\x3c\/div\x3e\x3cimg src=\x27dev.xxx.png\x27 \/\x3e\x26quot;;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22xml hljs\x22\x3e\x3ccode class=\x22html\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3evar responseText = \x22\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3edata\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x27dev.xxx.txt\x27\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eimg\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3esrc\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x27dev.xxx.png\x27\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e\x22;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e现我们需要替换img标签的src 属性中的 \x22dev\x22字符串 为 \x22test\x22 字符串. \x3c\/p\x3e\n\x3cp\x3e① 由于上述 responseText 字符串中包含至少两个子字符串 \x22dev\x22, 显然不能直接 replace 字符串 \x22dev\x22为 \x22test\x22. \x3c\/p\x3e\n\x3cp\x3e② 同时由于 js 中不支持逆序环视, 我们也不能在正则中判断前缀为 \x22src=\x27\x22, 然后再替换\x22dev\x22. \x3c\/p\x3e\n\x3cp\x3e③ 我们注意到 img 标签的 src 属性以 \x22.png\x22 结尾, 基于此, 就可以使用顺序肯定环视. 如下:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var reg = \/dev(?=[^\x27]*png)\/; \/\/为了防止匹配到第一个dev, 通配符前面需要排除单引号或者是尖括号\nvar str = responseText.replace(reg,\x26quot;test\x26quot;);\nconsole.log(str);\/\/\x3cdiv data=\x27dev.xxx\x27\x3e\x3c\/div\x3e\x3cimg src=\x27test.xxx.png\x27 \/\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e reg = \x3cspan class=\x22hljs-regexp\x22\x3e\/dev(?=[^\x27]*png)\/\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/为了防止匹配到第一个dev, 通配符前面需要排除单引号或者是尖括号\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e str = responseText.replace(reg,\x3cspan class=\x22hljs-string\x22\x3e\x22test\x22\x3c\/span\x3e);\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(str);\x3cspan class=\x22hljs-comment\x22\x3e\/\/\x26lt;div data=\x27dev.xxx\x27\x26gt;\x26lt;\/div\x26gt;\x26lt;img src=\x27test.xxx.png\x27 \/\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当然, 以上不止顺序肯定环视一种解法, 捕获性分组同样可以做到. 那么环视高级在哪里呢? 环视高级的地方就在于它通过一次捕获就可以定位到一个位置, 对于复杂的文本替换场景, 常有奇效, 而分组则需要更多的操作.\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader29\x22\x3e千位分割符\x3c\/h3\x3e\n\x3cblockquote\x3e\x3cp\x3e千位分隔符, 顾名思义, 就是数字中的逗号. 参考西方的习惯, 数字之中加入一个符号, 避免因数字太长难以直观的看出它的值. 故而数字之中, 每隔三位添加一个逗号, 即千位分隔符.\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e那么怎么将一串数字转化为千位分隔符形式呢?\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var str = \x26quot;1234567890\x26quot;;\n(\x2bstr).toLocaleString();\/\/\x26quot;1,234,567,890\x26quot;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e str = \x3cspan class=\x22hljs-string\x22\x3e\x221234567890\x22\x3c\/span\x3e;\n(\x2bstr).toLocaleString();\x3cspan class=\x22hljs-comment\x22\x3e\/\/\x221,234,567,890\x22\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如上, \x3ccode\x3etoLocaleString()\x3c\/code\x3e 返回当前对象的\x22本地化\x22字符串形式.\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e如果该对象是Number类型, 那么将返回该数值的按照特定符号分割的字符串形式.\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e如果该对象是Array类型, 那么先将数组中的每项转化为字符串, 然后将这些字符串以指定分隔符连接起来并返回.\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3ccode\x3etoLocaleString\x3c\/code\x3e 方法特殊, 有本地化特性, 对于天朝, 默认的分隔符是英文逗号. 因此使用它恰好可以将数值转化为千位分隔符形式的字符串. 如果考虑到国际化, 以上方法就有可能会失效了.\x3c\/p\x3e\n\x3cp\x3e我们尝试使用环视来处理下.\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function thousand(str){\n  return str.replace(\/(?!^)(?=([0-9]{3})\x2b$)\/g,\x27,\x27);\n}\nconsole.log(thousand(str));\/\/\x26quot;1,234,567,890\x26quot;\nconsole.log(thousand(\x26quot;123456\x26quot;));\/\/\x26quot;123,456\x26quot;\nconsole.log(thousand(\x26quot;1234567879876543210\x26quot;));\/\/\x26quot;1,234,567,879,876,543,210\x26quot;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ethousand\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3estr\x3c\/span\x3e)\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e str.replace(\x3cspan class=\x22hljs-regexp\x22\x3e\/(?!^)(?=([0-9]{3})\x2b$)\/g\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27,\x27\x3c\/span\x3e);\n}\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(thousand(str));\x3cspan class=\x22hljs-comment\x22\x3e\/\/\x221,234,567,890\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(thousand(\x3cspan class=\x22hljs-string\x22\x3e\x22123456\x22\x3c\/span\x3e));\x3cspan class=\x22hljs-comment\x22\x3e\/\/\x22123,456\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(thousand(\x3cspan class=\x22hljs-string\x22\x3e\x221234567879876543210\x22\x3c\/span\x3e));\x3cspan class=\x22hljs-comment\x22\x3e\/\/\x221,234,567,879,876,543,210\x22\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上述使用到的正则分为两块. \x3ccode\x3e(?!^)\x3c\/code\x3e 和 \x3ccode\x3e(?=([0-9]{3})\x2b$)\x3c\/code\x3e. 我们先来看后面的部分, 然后逐步分析之.\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e\x22[0-9]{3}\x22 表示连续3位数字.\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x22([0-9]{3})\x2b\x22 表示连续3位数字至少出现一次或更多次.\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x22([0-9]{3})\x2b$\x22 表示连续3的正整数倍的数字, 直到字符串末尾.\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e那么 \x3ccode\x3e(?=([0-9]{3})\x2b$)\x3c\/code\x3e 就表示匹配一个零宽度的位置, 并且从这个位置到字符串末尾, 中间拥有3的正整数倍的数字.\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e正则表达式使用全局匹配g, 表示匹配到一个位置后, 它会继续匹配, 直至匹配不到.\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e将这个位置替换为逗号, 实际上就是每3位数字添加一个逗号.\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e当然对于字符串\x22123456\x22这种刚好拥有3的正整数倍的数字的, 当然不能在1前面添加逗号. 那么使用 \x3ccode\x3e(?!^)\x3c\/code\x3e 就指定了这个替换的位置不能为起始位置.\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e千位分隔符实例, 展示了环视的强大, 一步到位.\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader30\x22\x3e正则表达式在JS中的应用\x3c\/h3\x3e\n\x3ch3 id=\x22articleHeader31\x22\x3eES6对正则的扩展\x3c\/h3\x3e\n\x3cp\x3eES6对正则扩展了又两种修饰符(其他语言可能不支持):\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3ey (粘连sticky修饰符), 与g类似, 也是全局匹配, 并且下一次匹配都是从上一次匹配成功的下一个位置开始, 不同之处在于, g修饰符只要剩余位置中存在匹配即可, 而y修饰符确保匹配必须从剩余的第一个位置开始.\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var s = \x26quot;abc_ab_a\x26quot;;\nvar r1 = \/[a-z]\x2b\/g;\nvar r2 = \/[a-z]\x2b\/y;\nconsole.log(r1.exec(s),r1.lastIndex); \/\/ [\x26quot;abc\x26quot;, index: 0, input: \x26quot;abc_ab_a\x26quot;] 3\nconsole.log(r2.exec(s),r2.lastIndex); \/\/ [\x26quot;abc\x26quot;, index: 0, input: \x26quot;abc_ab_a\x26quot;] 3\n\nconsole.log(r1.exec(s),r1.lastIndex); \/\/ [\x26quot;ab\x26quot;, index: 4, input: \x26quot;abc_ab_a\x26quot;] 6\nconsole.log(r2.exec(s),r2.lastIndex); \/\/ null 0\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e s = \x3cspan class=\x22hljs-string\x22\x3e\x22abc_ab_a\x22\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e r1 = \x3cspan class=\x22hljs-regexp\x22\x3e\/[a-z]\x2b\/g\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e r2 = \x3cspan class=\x22hljs-regexp\x22\x3e\/[a-z]\x2b\/y\x3c\/span\x3e;\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(r1.exec(s),r1.lastIndex); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ [\x22abc\x22, index: 0, input: \x22abc_ab_a\x22] 3\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(r2.exec(s),r2.lastIndex); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ [\x22abc\x22, index: 0, input: \x22abc_ab_a\x22] 3\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(r1.exec(s),r1.lastIndex); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ [\x22ab\x22, index: 4, input: \x22abc_ab_a\x22] 6\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(r2.exec(s),r2.lastIndex); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ null 0\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如上, 由于第二次匹配的开始位置是下标3,  对应的字符串是 \x22_\x22, 而使用y修饰符的正则对象r2, 需要从剩余的第一个位置开始, 所以匹配失败, 返回null.\x3c\/p\x3e\n\x3cp\x3e正则对象的 sticky 属性, 表示是否设置了y修饰符. 这点将会在后面讲到.\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3eu 修饰符, 提供了对正则表达式添加4字节码点的支持. 比如 \x22?\x22 字符是一个4字节字符, 直接使用正则匹配将会失败, 而使用u修饰符后, 将会等到正确的结果.\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var s = \x26quot;?\x26quot;;\nconsole.log(\/^.$\/.test(s));\/\/false\nconsole.log(\/^.$\/u.test(s));\/\/true\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e s = \x3cspan class=\x22hljs-string\x22\x3e\x22?\x22\x3c\/span\x3e;\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-regexp\x22\x3e\/^.$\/\x3c\/span\x3e.test(s));\x3cspan class=\x22hljs-comment\x22\x3e\/\/false\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-regexp\x22\x3e\/^.$\/u\x3c\/span\x3e.test(s));\x3cspan class=\x22hljs-comment\x22\x3e\/\/true\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader32\x22\x3eUCS-2字节码\x3c\/h3\x3e\n\x3cp\x3e有关字节码点, 稍微提下. javaScript 只能处理UCS-2编码(js于1995年5月被Brendan Eich花费10天设计出来, 比1996年7月发布的编码规范UTF-16早了一年多, 当时只有UCS-2可选). 由于UCS-2先天不足, 造成了所有字符在js中都是2个字节. 如果是4个字节的字符, 将会默认被当作两个双字节字符处理. 因此 js 的字符处理函数都会受到限制, 无法返回正确结果. 如下:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var s = \x26quot;?\x26quot;;\nconsole.log(s == \x26quot;\\uD834\\uDF06\x26quot;);\/\/true ?相当于UTF-16中的0xD834DF06\nconsole.log(s.length);\/\/2 长度为2, 表示这是4字节字符\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e s = \x3cspan class=\x22hljs-string\x22\x3e\x22?\x22\x3c\/span\x3e;\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(s == \x3cspan class=\x22hljs-string\x22\x3e\x22\\uD834\\uDF06\x22\x3c\/span\x3e);\x3cspan class=\x22hljs-comment\x22\x3e\/\/true ?相当于UTF-16中的0xD834DF06\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(s.length);\x3cspan class=\x22hljs-comment\x22\x3e\/\/2 长度为2, 表示这是4字节字符\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e幸运的是, ES6可以自动识别4字节的字符.因此遍历字符串可以直接使用for of循环. 同时, js中如果直接使用码点表示Unicode字符, 对于4字节字符, ES5里是没办法识别的. 为此ES6修复了这个问题, 只需将码点放在大括号内即可.\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22console.log(s === \x26quot;\\u1D306\x26quot;);\/\/false   ES5无法识别?\nconsole.log(s === \x26quot;\\u{1D306}\x26quot;);\/\/true  ES6可以借助大括号识别?\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(s === \x3cspan class=\x22hljs-string\x22\x3e\x22\\u1D306\x22\x3c\/span\x3e);\x3cspan class=\x22hljs-comment\x22\x3e\/\/false   ES5无法识别?\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(s === \x3cspan class=\x22hljs-string\x22\x3e\x22\\u{1D306}\x22\x3c\/span\x3e);\x3cspan class=\x22hljs-comment\x22\x3e\/\/true  ES6可以借助大括号识别?\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader33\x22\x3e附: ES6新增的处理4字节码的函数\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3eString.fromCodePoint()\x3c\/strong\x3e：从Unicode码点返回对应字符\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3eString.prototype.codePointAt()\x3c\/strong\x3e：从字符返回对应的码点\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3eString.prototype.at()\x3c\/strong\x3e：返回字符串给定位置的字符\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e有关js中的unicode字符集, 请参考阮一峰老师的 \x3ca href=\x22http:\/\/www.ruanyifeng.com\/blog\/2014\/12\/unicode.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\x3ccode\x3eUnicode与JavaScript详解 \x3c\/code\x3e\x3c\/a\x3e.\x3c\/p\x3e\n\x3cp\x3e以上是ES6对正则的扩展. 另一个方面, 从方法上看, javaScript 中与正则表达式有关的方法有:\x3c\/p\x3e\n\x3ctable\x3e\n\x3cthead\x3e\x3ctr\x3e\n\x3cth\x3e方法名\x3c\/th\x3e\n\x3cth\x3ecompile\x3c\/th\x3e\n\x3cth\x3etest\x3c\/th\x3e\n\x3cth\x3eexec\x3c\/th\x3e\n\x3cth\x3ematch\x3c\/th\x3e\n\x3cth\x3esearch\x3c\/th\x3e\n\x3cth\x3ereplace\x3c\/th\x3e\n\x3cth\x3esplit\x3c\/th\x3e\n\x3c\/tr\x3e\x3c\/thead\x3e\n\x3ctbody\x3e\x3ctr\x3e\n\x3ctd\x3e所属对象\x3c\/td\x3e\n\x3ctd\x3eRegExp\x3c\/td\x3e\n\x3ctd\x3eRegExp\x3c\/td\x3e\n\x3ctd\x3eRegExp\x3c\/td\x3e\n\x3ctd\x3eString\x3c\/td\x3e\n\x3ctd\x3eString\x3c\/td\x3e\n\x3ctd\x3eString\x3c\/td\x3e\n\x3ctd\x3eString\x3c\/td\x3e\n\x3c\/tr\x3e\x3c\/tbody\x3e\n\x3c\/table\x3e\n\x3cp\x3e由上, 一共有7个与js相关的方法, 这些方法分别来自于 RegExp 与 String 对象. 首先我们先来看看js中的正则类 RegExp.\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader34\x22\x3eRegExp\x3c\/h3\x3e\n\x3cp\x3eRegExp 对象表示正则表达式, 主要用于对字符串执行模式匹配.\x3c\/p\x3e\n\x3cp\x3e语法: new RegExp(pattern[, flags])\x3c\/p\x3e\n\x3cp\x3e参数 \x3cem\x3epattern\x3c\/em\x3e 是一个字符串, 指定了正则表达式字符串或其他的正则表达式对象.\x3c\/p\x3e\n\x3cp\x3e参数 \x3cem\x3eflags\x3c\/em\x3e 是一个可选的字符串, 包含属性 \x22g\x22、\x22i\x22 和 \x22m\x22, 分别用于指定全局匹配、区分大小写的匹配和多行匹配. 如果\x3cem\x3epattern\x3c\/em\x3e 是正则表达式, 而不是字符串, 则必须省略该参数.\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var pattern = \x26quot;[0-9]\x26quot;;\nvar reg = new RegExp(pattern,\x26quot;g\x26quot;);\n\/\/ 上述创建正则表达式对象,可以用对象字面量形式代替,也推荐下面这种\nvar reg = \/[0-9]\/g;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e pattern = \x3cspan class=\x22hljs-string\x22\x3e\x22[0-9]\x22\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e reg = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eRegExp\x3c\/span\x3e(pattern,\x3cspan class=\x22hljs-string\x22\x3e\x22g\x22\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 上述创建正则表达式对象,可以用对象字面量形式代替,也推荐下面这种\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e reg = \x3cspan class=\x22hljs-regexp\x22\x3e\/[0-9]\/g\x3c\/span\x3e;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上, 通过对象字面量和构造函数创建正则表达式, 有个小插曲.\x3c\/p\x3e\n\x3cp\x3e\x22对于正则表达式的直接量, ECMAscript 3规定在每次它时都会返回同一个RegExp对象, 因此用直接量创建的正则表达式的会共享一个实例. 直到ECMAScript 5才规定每次返回不同的实例.\x22\x3c\/p\x3e\n\x3cp\x3e所以, 现在我们基本不用担心这个问题, 只需要注意在低版本的非IE浏览器中尽量使用构造函数创建正则(这点上, IE一直遵守ES5规定, 其他浏览器的低级版本遵循ES3规定).\x3c\/p\x3e\n\x3cp\x3eRegExp 实例对象包含如下属性:\x3c\/p\x3e\n\x3ctable\x3e\n\x3cthead\x3e\x3ctr\x3e\n\x3cth align=\x22center\x22\x3e实例属性\x3c\/th\x3e\n\x3cth align=\x22center\x22\x3e描述\x3c\/th\x3e\n\x3c\/tr\x3e\x3c\/thead\x3e\n\x3ctbody\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3eglobal\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e是否包含全局标志(true\/false)\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3eignoreCase\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e是否包含区分大小写标志(true\/false)\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3emultiline\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e是否包含多行标志(true\/false)\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3esource\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e返回创建RegExp对象实例时指定的表达式文本字符串形式\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3elastIndex\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e表示原字符串中匹配的字符串末尾的后一个位置, 默认为0\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3eflags(ES6)\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e返回正则表达式的修饰符\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3esticky(ES6)\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e是否设置了y(粘连)修饰符(true\/false)\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3c\/tbody\x3e\n\x3c\/table\x3e\n\x3ch3 id=\x22articleHeader35\x22\x3ecompile\x3c\/h3\x3e\n\x3cp\x3ecompile 方法用于在执行过程中改变和重新编译正则表达式.\x3c\/p\x3e\n\x3cp\x3e语法: compile(pattern[, flags])\x3c\/p\x3e\n\x3cp\x3e参数介绍请参考上述 RegExp 构造器. 用法如下:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var reg = new RegExp(\x26quot;abc\x26quot;, \x26quot;gi\x26quot;); \nvar reg2 = reg.compile(\x26quot;new abc\x26quot;, \x26quot;g\x26quot;);\nconsole.log(reg);\/\/ \/new abc\/g\nconsole.log(reg2);\/\/ undefined\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e reg = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eRegExp\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22abc\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22gi\x22\x3c\/span\x3e); \n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e reg2 = reg.compile(\x3cspan class=\x22hljs-string\x22\x3e\x22new abc\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22g\x22\x3c\/span\x3e);\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(reg);\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \/new abc\/g\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(reg2);\x3cspan class=\x22hljs-comment\x22\x3e\/\/ undefined\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可见 compile 方法会改变原正则表达式对象, 并重新编译, 而且它的返回值为空.\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader36\x22\x3etest\x3c\/h3\x3e\n\x3cp\x3etest 方法用于检测一个字符串是否匹配某个正则规则, 只要是字符串中含有与正则规则匹配的文本, 该方法就返回true, 否则返回 false.\x3c\/p\x3e\n\x3cp\x3e语法: test(string), 用法如下:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22console.log(\/[0-9]\x2b\/.test(\x26quot;abc123\x26quot;));\/\/true\nconsole.log(\/[0-9]\x2b\/.test(\x26quot;abc\x26quot;));\/\/false\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-regexp\x22\x3e\/[0-9]\x2b\/\x3c\/span\x3e.test(\x3cspan class=\x22hljs-string\x22\x3e\x22abc123\x22\x3c\/span\x3e));\x3cspan class=\x22hljs-comment\x22\x3e\/\/true\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-regexp\x22\x3e\/[0-9]\x2b\/\x3c\/span\x3e.test(\x3cspan class=\x22hljs-string\x22\x3e\x22abc\x22\x3c\/span\x3e));\x3cspan class=\x22hljs-comment\x22\x3e\/\/false\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上, 字符串\x22abc123\x22 包含数字, 故 test 方法返回 true; 而 字符串\x22abc\x22 不包含数字, 故返回 false.\x3c\/p\x3e\n\x3cp\x3e如果需要使用 test 方法测试字符串是否完成匹配某个正则规则, 那么可以在正则表达式里增加开始(^)和结束($)元字符. 如下:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22console.log(\/^[0-9]\x2b$\/.test(\x26quot;abc123\x26quot;));\/\/false\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-regexp\x22\x3e\/^[0-9]\x2b$\/\x3c\/span\x3e.test(\x3cspan class=\x22hljs-string\x22\x3e\x22abc123\x22\x3c\/span\x3e));\x3cspan class=\x22hljs-comment\x22\x3e\/\/false\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上, 由于字符串\x22abc123\x22 并非以数字开始, 也并非以数字结束, 故 test 方法返回false.\x3c\/p\x3e\n\x3cp\x3e实际上, 如果正则表达式带有全局标志(带有参数g)时, test 方法还受正则对象的lastIndex属性影响,如下:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var reg = \/[a-z]\x2b\/;\/\/正则不带全局标志\nconsole.log(reg.test(\x26quot;abc\x26quot;));\/\/true\nconsole.log(reg.test(\x26quot;de\x26quot;));\/\/true\n\nvar reg = \/[a-z]\x2b\/g;\/\/正则带有全局标志g\nconsole.log(reg.test(\x26quot;abc\x26quot;));\/\/true\nconsole.log(reg.lastIndex);\/\/3, 下次运行test时,将从索引为3的位置开始查找\nconsole.log(reg.test(\x26quot;de\x26quot;));\/\/false\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e reg = \x3cspan class=\x22hljs-regexp\x22\x3e\/[a-z]\x2b\/\x3c\/span\x3e;\x3cspan class=\x22hljs-comment\x22\x3e\/\/正则不带全局标志\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(reg.test(\x3cspan class=\x22hljs-string\x22\x3e\x22abc\x22\x3c\/span\x3e));\x3cspan class=\x22hljs-comment\x22\x3e\/\/true\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(reg.test(\x3cspan class=\x22hljs-string\x22\x3e\x22de\x22\x3c\/span\x3e));\x3cspan class=\x22hljs-comment\x22\x3e\/\/true\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e reg = \x3cspan class=\x22hljs-regexp\x22\x3e\/[a-z]\x2b\/g\x3c\/span\x3e;\x3cspan class=\x22hljs-comment\x22\x3e\/\/正则带有全局标志g\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(reg.test(\x3cspan class=\x22hljs-string\x22\x3e\x22abc\x22\x3c\/span\x3e));\x3cspan class=\x22hljs-comment\x22\x3e\/\/true\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(reg.lastIndex);\x3cspan class=\x22hljs-comment\x22\x3e\/\/3, 下次运行test时,将从索引为3的位置开始查找\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(reg.test(\x3cspan class=\x22hljs-string\x22\x3e\x22de\x22\x3c\/span\x3e));\x3cspan class=\x22hljs-comment\x22\x3e\/\/false\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e该影响将在exec 方法讲解中予以分析.\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader37\x22\x3eexec\x3c\/h3\x3e\n\x3cp\x3eexec 方法用于检测字符串对正则表达式的匹配, 如果找到了匹配的文本, 则返回一个结果数组, 否则返回null.\x3c\/p\x3e\n\x3cp\x3e语法: exec(string)\x3c\/p\x3e\n\x3cp\x3eexec 方法返回的数组中包含两个额外的属性, index 和 input. 并且该数组具有如下特点:\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e第 0 个项表示正则表达式捕获的文本\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e第 1~n 项表示第 1~n 个反向引用, 依次指向第 1~n 个分组捕获的文本, 可以使用RegExp.$ \x2b \x22编号1~n\x22  依次获取分组中的文本\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eindex 表示匹配字符串的初始位置\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3einput 表示正在检索的字符串\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e无论正则表达式有无全局标示\x22g\x22, exec 的表现都相同. 但正则表达式对象的表现却有些不同. 下面我们来详细说明下正则表达式对象的表现都有哪些不同.\x3c\/p\x3e\n\x3cp\x3e假设正则表达式对象为 reg , 检测的字符为 string , reg.exec(string) 返回值为 array.\x3c\/p\x3e\n\x3cp\x3e若 reg 包含全局标示\x22g\x22, 那么 reg.lastIndex 属性表示原字符串中匹配的字符串末尾的后一个位置, 即下次匹配开始的位置, 此时 reg.lastIndex == array.index(匹配开始的位置) \x2b array[0].length(匹配字符串的长度). 如下:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var reg = \/([a-z]\x2b)\/gi,\n    string = \x26quot;World Internet Conference\x26quot;;\nvar array = reg.exec(string);\nconsole.log(array);\/\/[\x26quot;World\x26quot;, \x26quot;World\x26quot;, index: 0, input: \x26quot;World Internet Conference\x26quot;]\nconsole.log(RegExp.$1);\/\/World\nconsole.log(reg.lastIndex);\/\/5, 刚好等于 array.index \x2b array[0].length\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e reg = \x3cspan class=\x22hljs-regexp\x22\x3e\/([a-z]\x2b)\/gi\x3c\/span\x3e,\n    string = \x3cspan class=\x22hljs-string\x22\x3e\x22World Internet Conference\x22\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e array = reg.exec(string);\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(array);\x3cspan class=\x22hljs-comment\x22\x3e\/\/[\x22World\x22, \x22World\x22, index: 0, input: \x22World Internet Conference\x22]\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-built_in\x22\x3eRegExp\x3c\/span\x3e.$\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\x3cspan class=\x22hljs-comment\x22\x3e\/\/World\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(reg.lastIndex);\x3cspan class=\x22hljs-comment\x22\x3e\/\/5, 刚好等于 array.index \x2b array[0].length\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e随着检索继续, array.index 的值将往后递增, 也就是说, reg.lastIndex 的值也会同步往后递增. 因此, 我们也可以通过反复调用 exec 方法来遍历字符串中所有的匹配文本. 直到 exec 方法再也匹配不到文本时, 它将返回 null, 并把 reg.lastIndex 属性重置为 0. \x3c\/p\x3e\n\x3cp\x3e接着上述例子, 我们继续执行代码, 看看上面说的对不对, 如下所示:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22array = reg.exec(string);\nconsole.log(array);\/\/[\x26quot;Internet\x26quot;, \x26quot;Internet\x26quot;, index: 6, input: \x26quot;World Internet Conference\x26quot;]\nconsole.log(reg.lastIndex);\/\/14\n\narray = reg.exec(string);\nconsole.log(array);\/\/[\x26quot;Conference\x26quot;, \x26quot;Conference\x26quot;, index: 15, input: \x26quot;World Internet Conference\x26quot;]\nconsole.log(reg.lastIndex);\/\/25\n\narray = reg.exec(string);\nconsole.log(array);\/\/null\nconsole.log(reg.lastIndex);\/\/0\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3earray = reg.exec(string);\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(array);\x3cspan class=\x22hljs-comment\x22\x3e\/\/[\x22Internet\x22, \x22Internet\x22, index: 6, input: \x22World Internet Conference\x22]\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(reg.lastIndex);\x3cspan class=\x22hljs-comment\x22\x3e\/\/14\x3c\/span\x3e\n\narray = reg.exec(string);\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(array);\x3cspan class=\x22hljs-comment\x22\x3e\/\/[\x22Conference\x22, \x22Conference\x22, index: 15, input: \x22World Internet Conference\x22]\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(reg.lastIndex);\x3cspan class=\x22hljs-comment\x22\x3e\/\/25\x3c\/span\x3e\n\narray = reg.exec(string);\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(array);\x3cspan class=\x22hljs-comment\x22\x3e\/\/null\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(reg.lastIndex);\x3cspan class=\x22hljs-comment\x22\x3e\/\/0\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上代码中, 随着反复调用 exec 方法, reg.lastIndex 属性最终被重置为 0.\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e问题回顾\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e在 test 方法的讲解中, 我们留下了一个问题. 如果正则表达式带有全局标志g, 以上 test 方法的执行结果将受 reg.lastIndex影响, 不仅如此, exec 方法也一样. 由于 reg.lastIndex 的值并不总是为零, 并且它决定了下次匹配开始的位置, 如果在一个字符串中完成了一次匹配之后要开始检索新的字符串, 那就必须要手动地把 lastIndex 属性重置为 0. 避免出现下面这种错误:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var reg = \/[0-9]\x2b\/g,\n    str1 = \x26quot;123abc\x26quot;,\n    str2 = \x26quot;123456\x26quot;;\nreg.exec(str1);\nconsole.log(reg.lastIndex);\/\/3\nvar array = reg.exec(str2);\nconsole.log(array);\/\/[\x26quot;456\x26quot;, index: 3, input: \x26quot;123456\x26quot;]\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e reg = \x3cspan class=\x22hljs-regexp\x22\x3e\/[0-9]\x2b\/g\x3c\/span\x3e,\n    str1 = \x3cspan class=\x22hljs-string\x22\x3e\x22123abc\x22\x3c\/span\x3e,\n    str2 = \x3cspan class=\x22hljs-string\x22\x3e\x22123456\x22\x3c\/span\x3e;\nreg.exec(str1);\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(reg.lastIndex);\x3cspan class=\x22hljs-comment\x22\x3e\/\/3\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e array = reg.exec(str2);\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(array);\x3cspan class=\x22hljs-comment\x22\x3e\/\/[\x22456\x22, index: 3, input: \x22123456\x22]\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上代码, 正确执行结果应该是 \x22123456\x22,  因此建议在第二次执行 exec 方法前, 增加一句 \x22reg.lastIndex = 0;\x22.\x3c\/p\x3e\n\x3cp\x3e若 reg 不包含全局标示\x22g\x22, 那么 exec 方法的执行结果(array)将与 string.match(reg) 方法执行结果完全相同.\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader38\x22\x3eString\x3c\/h3\x3e\n\x3cp\x3ematch, search, replace, split 方法请参考 \x3ca href=\x22http:\/\/louiszhai.github.io\/2016\/01\/12\/js.String\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\x3ccode\x3e字符串常用方法\x3c\/code\x3e\x3c\/a\x3e 中的讲解.\x3c\/p\x3e\n\x3cp\x3e如下展示了使用捕获性分组处理文本模板, 最终生成完整字符串的过程:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var tmp = \x26quot;An ${a} a ${b} keeps the ${c} away\x26quot;;\nvar obj = {\n  a:\x26quot;apple\x26quot;,\n  b:\x26quot;day\x26quot;,\n  c:\x26quot;doctor\x26quot;\n};\nfunction tmpl(t,o){\n  return t.replace(\/\\${(.)}\/g,function(m,p){\n    console.log(\x27m:\x27\x2bm\x2b\x27 p:\x27\x2bp);\n    return o[p];\n  });\n}\ntmpl(tmp,obj);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e tmp = \x3cspan class=\x22hljs-string\x22\x3e\x22An ${a} a ${b} keeps the ${c} away\x22\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj = {\n  \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x22apple\x22\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3eb\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x22day\x22\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3ec\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x22doctor\x22\x3c\/span\x3e\n};\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3etmpl\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3et,o\x3c\/span\x3e)\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e t.replace(\x3cspan class=\x22hljs-regexp\x22\x3e\/\\${(.)}\/g\x3c\/span\x3e,\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3em,p\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27m:\x27\x3c\/span\x3e\x2bm\x2b\x3cspan class=\x22hljs-string\x22\x3e\x27 p:\x27\x3c\/span\x3e\x2bp);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e o[p];\n  });\n}\ntmpl(tmp,obj);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上述功能使用ES6可这么实现:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var obj = {\n  a:\x26quot;apple\x26quot;,\n  b:\x26quot;day\x26quot;,\n  c:\x26quot;doctor\x26quot;\n};\nwith(obj){\n  console.log(`An ${a} a ${b} keeps the ${c} away`);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj = {\n  \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x22apple\x22\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3eb\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x22day\x22\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3ec\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x22doctor\x22\x3c\/span\x3e\n};\n\x3cspan class=\x22hljs-keyword\x22\x3ewith\x3c\/span\x3e(obj){\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e`An \x3cspan class=\x22hljs-subst\x22\x3e${a}\x3c\/span\x3e a \x3cspan class=\x22hljs-subst\x22\x3e${b}\x3c\/span\x3e keeps the \x3cspan class=\x22hljs-subst\x22\x3e${c}\x3c\/span\x3e away`\x3c\/span\x3e);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader39\x22\x3e正则表达式在H5中的应用\x3c\/h3\x3e\n\x3cp\x3eH5中新增了 pattern 属性, 规定了用于验证输入字段的模式, pattern的模式匹配支持正则表达式的书写方式. 默认 pattern 属性是全部匹配, 即无论正则表达式中有无 \x22^\x22, \x22$\x22 元字符, 它都是匹配所有文本.\x3c\/p\x3e\n\x3cp\x3e注: pattern 适用于以下 input 类型：text, search, url, telephone, email 以及 password. 如果需要取消表单验证, 在form标签上增加 novalidate 属性即可.\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader40\x22\x3e正则引擎\x3c\/h3\x3e\n\x3cp\x3e目前正则引擎有两种, DFA 和 NFA, NFA又可以分为传统型NFA和POSIX NFA.\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eDFA\x26nbsp;Deterministic finite automaton 确定型有穷自动机\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eNFA Non-deterministic finite automaton　非确定型有穷自动机\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eTraditional NFA\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ePOSIX NFA\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3eDFA引擎不支持回溯, 匹配快速, 并且不支持捕获组, 因此也就不支持反向引用. 上述awk, egrep命令均支持 DFA引擎. \x3c\/p\x3e\n\x3cp\x3ePOSIX NFA主要指符合POSIX标准的NFA引擎, 像 javaScript, java, php, python, c#等语言均实现了NFA引擎.\x3c\/p\x3e\n\x3cp\x3e有关正则表达式详细的匹配原理, 暂时没在网上看到适合的文章, 建议选读 Jeffrey Friedl 的 \x26lt;精通正则表达式\x26gt;[第三版] 中第4章-表达式的匹配原理(p143-p183), Jeffrey Friedl 对正则表达式有着深刻的理解, 相信他能够帮助您更好的学习正则.\x3c\/p\x3e\n\x3cp\x3e有关NFA引擎的简单实现, 可以参考文章 \x3ca href=\x22http:\/\/www.cnblogs.com\/catch\/p\/3722082.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e基于ε-NFA的正则表达式引擎 - twoon\x3c\/a\x3e.\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader41\x22\x3e总结\x3c\/h3\x3e\n\x3cp\x3e在学习正则的初级阶段, 重在理解 ①贪婪与非贪婪模式, ②分组, ③捕获性与非捕获性分组, ④命名分组, ⑤固化分组, 体会设计的精妙之处. 而高级阶段, 主要在于熟练运用⑥零宽断言(或环视)解决问题, 并且熟悉正则匹配的原理. \x3c\/p\x3e\n\x3cp\x3e实际上, 正则在 javaScript 中的功能不算强大, js 仅仅支持了①贪婪与非贪婪模式, ②分组, ③捕获性与非捕获性分组 以及 ⑥零宽断言中的顺序环视. 如果再稍微熟悉些 js 中7种与正则有关的方法(compile, test, exec, match, search, replace, split), 那么处理文本或字符串将游刃有余.\x3c\/p\x3e\n\x3cp\x3e正则表达式, 在文本处理方面天赋异禀, 它的功能十分强大, 很多时候甚至是唯一解决方案. 正则不局限于js, 当下热门的编辑器(比如Sublime, Atom) 以及 IDE(比如WebStorm, IntelliJ\x26nbsp;IDEA) 都支持它. 您甚至可以在任何时候任何语言中, 尝试使用正则解决问题, 也许之前不能解决的问题, 现在可以轻松的解决.\x3c\/p\x3e\n\x3cp\x3e附其他语言正则资料:\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/wiki.ubuntu.org.cn\/Python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ePython正则表达式操作指南\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/blog.csdn.net\/allwefantasy\/article\/details\/3136570\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ejava正则表达式\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3chr\x3e\n\x3cp\x3e本文作者: \x3ca href=\x22https:\/\/github.com\/Louiszhai\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3elouis\x3c\/a\x3e\x3cbr\x3e本文简介: 本文断断续续历时两个月而成, 共计12k字, 为求简洁全面地还原前端场景中正则的使用规律, 搜集了大量正则相关资料, 并剔除不少冗余字句, 码字不易, 喜欢的请点个赞?或者收藏, 我将持续保持更新.\x3cbr\x3e原文地址: \x3ca href=\x22http:\/\/louiszhai.github.io\/2016\/06\/13\/regexp\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/louiszhai.github.io\/20...\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e参考文章\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eJeffrey Friedl 的 \x26lt;精通正则表达式\x26gt;[第三版]\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/blog.csdn.net\/fdl19881\/article\/details\/7800877\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3elinux shell 正则表达式(BREs,EREs,PREs)差异比较\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/www.jb51.net\/article\/28035.htm\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e正则表达式之捕获组\/非捕获组介绍_正则表达式_脚本之家\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/www.cnblogs.com\/kissdodog\/archive\/2013\/04\/22\/3036649.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e正则表达式(一) -- 元字符 - 逆心 - 博客园\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/blog.csdn.net\/hguisu\/article\/details\/8244560\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e正则表达式详解 - guisu，程序人生。 逆水行舟，不进则退。 - 博客频道 - CSDN.NET\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/www.cnblogs.com\/taek\/archive\/2012\/02\/08\/2342741.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e正则表达式之固化分组 - taek - 博客园\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/www.jb51.net\/article\/31491.htm\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e正则表达式之 贪婪与非贪婪模式详解（概述）_正则表达式_脚本之家\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/blog.csdn.net\/nebula1982\/article\/details\/6659702\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eJAVASCRIPT 正则表达式学习--\x26gt;基础与零宽断言（转自司徒正美） - 随风之羽 - 博客频道 - CSDN.NET\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/www.ruanyifeng.com\/blog\/2014\/12\/unicode.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eUnicode与JavaScript详解 - 阮一峰的网络日志\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3chr\x3e\n\x3col\x3e\n\x3cli\x3e0-9 \x3ca class=\x22footnote-backref\x22\x3e↩\x3c\/a\x3e\n\x3c\/li\x3e\n\x3cli\x3efnrtv \x3ca class=\x22footnote-backref\x22\x3e↩\x3c\/a\x3e\n\x3c\/li\x3e\n\x3cli\x3eA-Za-z0-9_ \x3ca class=\x22footnote-backref\x22\x3e↩\x3c\/a\x3e\n\x3c\/li\x3e\n\x3c\/ol\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>正则表达式前端使用手册</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000008367185">https://segmentfault.com/a/1190000008367185</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/id4zuqtn0q/" target="_blank">https://alili.tech/archive/id4zuqtn0q/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>