<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="React Component里的状态机Pattern"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>React Component里的状态机Pattern | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/mn938vwhal/",
				"appid": "1613049289050283", 
				"title": "React Component里的状态机Pattern | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-29T02:30:10"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/jgugdyg50l/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/6zyet64jeml/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fmn938vwhal%2f&text=React%20Component%e9%87%8c%e7%9a%84%e7%8a%b6%e6%80%81%e6%9c%baPattern"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fmn938vwhal%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fmn938vwhal%2f&text=React%20Component%e9%87%8c%e7%9a%84%e7%8a%b6%e6%80%81%e6%9c%baPattern"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fmn938vwhal%2f&title=React%20Component%e9%87%8c%e7%9a%84%e7%8a%b6%e6%80%81%e6%9c%baPattern"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fmn938vwhal%2f&is_video=false&description=React%20Component%e9%87%8c%e7%9a%84%e7%8a%b6%e6%80%81%e6%9c%baPattern"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=React%20Component%e9%87%8c%e7%9a%84%e7%8a%b6%e6%80%81%e6%9c%baPattern&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fmn938vwhal%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fmn938vwhal%2f&title=React%20Component%e9%87%8c%e7%9a%84%e7%8a%b6%e6%80%81%e6%9c%baPattern"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fmn938vwhal%2f&title=React%20Component%e9%87%8c%e7%9a%84%e7%8a%b6%e6%80%81%e6%9c%baPattern"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fmn938vwhal%2f&title=React%20Component%e9%87%8c%e7%9a%84%e7%8a%b6%e6%80%81%e6%9c%baPattern"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fmn938vwhal%2f&title=React%20Component%e9%87%8c%e7%9a%84%e7%8a%b6%e6%80%81%e6%9c%baPattern"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">React Component里的状态机Pattern</h1><div class="meta"><div class="postdate"><time datetime="2019-01-29" itemprop="datePublished">2019-01-29</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch2 id=\x22articleHeader0\x22\x3eState Machine in React Component\x3c\/h2\x3e\n\x3cp\x3eReact的工程实践中大多数团队都只关注了state该怎么存放的问题，没有意识到真正导致问题复杂的是组合状态机，后面这句话对于UI而言是放之四海皆准的；\x3c\/p\x3e\n\x3cp\x3e一个React Component对象作为UI层元素，在很多情况下我们并不希望在状态迁移时创建新的实例替代旧的，这直接意味着UI组件和状态机之间是binding关系而不是composition，所以React提供了一个this.state用于解耦，这是它很聪明的一个设计；但是这个this.state只有值成员，没有方法成员；这意味着写在Component上的方法里面要switch\/case状态，这非常不方便。\x3c\/p\x3e\n\x3cp\x3e其次React Component的setState方法是merge逻辑而不是replace逻辑，它意味着state下一级props之间必须是平行子状态机而不是单一状态机互斥状态（除非你只有一个状态机，其他状态用值表示）；或者换句话说，如果你把不同的互斥状态下的资源和值都放在一个篮子里时，你每次自己去手动倒空旧的，这一点是个坑。\x3c\/p\x3e\n\x3cp\x3e第三，那些early binding语言的状态机Pattern在js和immutable要求下并不适用，他们都是内部值状态的迁移而不是对象本身被替代，而对象本身被替代这个问题制造了一个问题，就是该对象的方法并不能用于UI的行为binding，因为状态迁移后这个旧状态机对象就废弃了，调用它的行为方法当然是不对的；\x3c\/p\x3e\n\x3cp\x3e解决这个问题并不难，行为binding使用Component对象上的方法，它是稳定的，不会因为model的状态机更迭而变化，但它是一个proxy，需要把方法分发到子状态机上；这样我们就得到了状态机Pattern的最大优势：每个状态只关注属于自己的子状态，值，资源，和行为，不用在所有行为处理上都狂写switch\/case。\x3c\/p\x3e\n\x3cp\x3e熟悉状态机Pattern的开发者不难想像出满足上述要求的代码结构；Component是稳定的，它即使一个子状态机的容器，又是一个行为的Proxy层，向this.state下的子状态机（例如命名为this.state.stm1）分发行为；逻辑上是下图所示：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22React Component\n\n  this.state {\n    stm1: \/\/ --------------------------------\x3e stm1对象\n  }\n\n  this.handleToggleButton() {\n    this.state.stm1.handleToggleButton() \/\/ -\x3e stm1.handleToggleButton()\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eReact Component\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state {\n    \x3cspan class=\x22hljs-attr\x22\x3estm1\x3c\/span\x3e: \x3cspan class=\x22hljs-comment\x22\x3e\/\/ --------------------------------\x26gt; stm1对象\x3c\/span\x3e\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handleToggleButton() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.stm1.handleToggleButton() \x3cspan class=\x22hljs-comment\x22\x3e\/\/ -\x26gt; stm1.handleToggleButton()\x3c\/span\x3e\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e同时分发的行为必须返回一个新的状态机对象用于替代旧的，它可能导致一次状态迁移，例如方法调用之前this.state.stm1是一个ListViewState对象，而调用后变成了ListEditState对象；如果是这样，上述行为方法得加一个逻辑：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  this.handleToggleButton() {\n    let newStm1 = this.state.stm1.handleToggleButton()\n    if (newStm1)\n      this.setState({ stm1: newStm1 })\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handleToggleButton() {\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e newStm1 = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.stm1.handleToggleButton()\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (newStm1)\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({ \x3cspan class=\x22hljs-attr\x22\x3estm1\x3c\/span\x3e: newStm1 })\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这个逻辑会反复使用，我们不妨把它抽象出来\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  this.dispatch = (name, method, ...args) =\x3e {\n    if (this.state[name] \x26amp;\x26amp;\n      typeof this.state[name] === \x27object\x27 \x26amp;\x26amp;\n      typeof this.state[name][method] === \x27function\x27) {\n      let next = this.state[name][method](...args)\n      if (next) {\n        let obj = {}\n        obj[name] = next\n        this.setState(obj)\n      }\n    }\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.dispatch = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3ename, method, ...args\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state[name] \x26amp;\x26amp;\n      \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state[name] === \x3cspan class=\x22hljs-string\x22\x3e\x27object\x27\x3c\/span\x3e \x26amp;\x26amp;\n      \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state[name][method] === \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e next = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state[name][method](...args)\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (next) {\n        \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e obj = {}\n        obj[name] = next\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState(obj)\n      }\n    }\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样在控件的JSX代码中使用时：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  onToggle={e =\x3e this.dispatch(\x27stm1\x27, \x27handleToggleButton\x27)}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e  onToggle={e =\x26gt; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.dispatch(\x3cspan class=\x22hljs-string\x22\x3e\x27stm1\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27handleToggleButton\x27\x3c\/span\x3e)}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这不是唯一的写法，也许你不喜欢这样把所有的fallback都处理掉连错误通知也没有；你可以自己添加，写成自己喜欢的方式。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3eImmutable State Machine in JavaScript\x3c\/h2\x3e\n\x3cp\x3e剩下的问题回到如何在JS下书写一个immutable的状态机问题，基于Class仍然是直觉的方式，不同之处在于状态迁移时是用旧的Class对象作为参数传递给新的Class对象，新对象的构造函数第一件事情是复制旧对象的全部自有属性，这个行为可以写在原型类的构造函数里。\x3c\/p\x3e\n\x3cp\x3e较为简洁的写法是状态机自己实现一个setState方法（setState是状态机Pattern的iconic方法，其次才是entry\/exit）；该方法只是用于状态机自己的状态迁移，和它的容器对象（React Component对象）上的setState方法无关；不要搞混了。（当然你应该想想为什么React Component上有这个状态机Pattern里的标志性方法）\x3c\/p\x3e\n\x3cp\x3e简明实现的关键点是setState接受两个参数，第一个是下一状态的Class名（即构造函数），第二个是...args用于传参；所有子状态机的constructor都是(obj, ...args)的形式，obj是上一状态机；这样写可以避免实现setState时写switch\/case。\x3c\/p\x3e\n\x3cp\x3e它的简单实现可以是：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22setState(NextState, ...args) {\n  \/\/ 当前状态机迁出\n  this.exit()\n  \/\/ 构造新对象，immutable，同时下一状态机迁入，\n  return new NextState(this, ...args)\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3esetState(NextState, ...args) {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当前状态机迁出\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.exit()\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 构造新对象，immutable，同时下一状态机迁入，\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e NextState(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, ...args)\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e原型类的构造函数可以看起来这样：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22constructor(obj) {\n  Object.assign(this, obj)\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(obj) {\n  \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.assign(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, obj)\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e用于复制上一状态的所有属性。\x3c\/p\x3e\n\x3cp\x3e最后这个状态机的基类需要一个exit方法，如果子类不需要实现，这是个fallback。\x3c\/p\x3e\n\x3cp\x3e综上所述这个基类看起来大概是这样：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class STM {\n\n  constructor(obj) {\n    Object.assign(this, obj)\n  }\n\n  setState(NextState, ...args) {\n    this.exit()\n    return new NextState(this, ...args)\n  }\n\n  exit() {}\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eSTM\x3c\/span\x3e \x3c\/span\x3e{\n\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(obj) {\n    \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.assign(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, obj)\n  }\n\n  setState(NextState, ...args) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.exit()\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e NextState(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, ...args)\n  }\n\n  exit() {}\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在实际使用的时候你可能需要自己的基类，因为\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e你需要一些context，对所有状态都需要的值、属性、资源等\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e你需要一些共同的方法，如果对某个行为的处理大部分状态都是一样的，那么可以写在这个原型类里，具体某个状态的行为不同，它可以去重载；所以一个真正的原型类和继承类可能是这样的：\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class MySTM extends STM {\n\n  constructor(obj) {\n    super(obj)\n  }\n\n  this.handleToggleButton = () =\x3e {\n    \/\/ ...\n  }\n}\n\nclass MySTMInitState extends MySTM {\n  \/\/ ...\n}\n\nclass MySTMAnotherState extends MySTM {\n  \/\/ ...\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eMySTM\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eSTM\x3c\/span\x3e \x3c\/span\x3e{\n\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(obj) {\n    \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(obj)\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handleToggleButton = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n  }\n}\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eMySTMInitState\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eMySTM\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eMySTMAnotherState\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eMySTM\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e需要注意的是不要在\x3ccode\x3eMySTM\x3c\/code\x3e的构造函数里写其他逻辑，如果有其他逻辑，写在React Component的constructor里，相当于是这个状态机原型对象的工厂。\x3c\/p\x3e\n\x3cp\x3e在React Component的构造函数里，可以这样使用：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\n  \/\/ 如果props和进入时的上下文有关，在这里处理\n  let props = {\n    ...\n  }\n\n  \/\/ 创建了一个原型\n  let stm1 = new MySTMInitState(props)\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果props和进入时的上下文有关，在这里处理\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e props = {\n    ...\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建了一个原型\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e stm1 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e MySTMInitState(props)\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里有两个问题需要阐述一下。\x3c\/p\x3e\n\x3cp\x3e第一，基于class语法构造对象的本质，其实只是在子类构造函数里把父类构造函数全部调一遍，保证对象属性完整，以及原型链正确；它是用起来最简洁的方式，但不是唯一的方式；\x3c\/p\x3e\n\x3cp\x3eJavaScript提供了另一种方式来构造对象，即\x3ccode\x3eObject.create()\x3c\/code\x3e方法，两者是有区别的。\x3c\/p\x3e\n\x3cp\x3e基于class语法构造的对象，如果你尝试：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let x = new MySTMInitState({})\nlet y = new MySTMAnotherState({})\n\nconsole.log(x.__proto__ === y.__proto__)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e x = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e MySTMInitState({})\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e y = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e MySTMAnotherState({})\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(x.__proto__ === y.__proto__)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e你会得到一个\x3ccode\x3efalse\x3c\/code\x3e输出，即这两个状态机的原型对象并非同一个对象，他们只是同一个构造函数（MySTM）构造过，因此具有同样的properties（方法）。\x3c\/p\x3e\n\x3cp\x3e但是如果你使用\x3ccode\x3eObject.create()\x3c\/code\x3e来自己构造原型链，你可以有一个原型对象和React Component的生命周期一致，所有stm1状态机都以它为原型。这在某些情况下是有益的，例如：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e你可以在这个原型上放context，减少迁移时\x3ccode\x3eObject.assign()\x3c\/code\x3e复制properties的性能负担；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e如果某些context是需要被子类修改的，可以提供setter方法达到这个目的。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e事实上，这个方式更加符合JavaScript的原型化继承的设计初衷，但是语言是这样的一个东西，就是哪个语法简单，那个写法就被最广泛的使用，就像C\x2b\x2b\/Java里继承是最简单的语法，那么它就被用的最广泛，而写Pattern是复杂实现，他就被用的少，即使很多时候更应该写Pattern。\x3c\/p\x3e\n\x3cp\x3eAnyway，这个区别在实践上的意义很小。\x3c\/p\x3e\n\x3cp\x3e第二，是个对传统OO语言开发者来说比较难接受的地方，就是你可以这样写：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let x = new MySTM()\nlet y = new MySTMInitState(x)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e x = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e MySTM()\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e y = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e MySTMInitState(x)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这件事情幽默的地方是你可以用基类对象去构造继承类对象，仿佛Class和Object的区别被抹平的，他们在平行世界之间穿越。\x3c\/p\x3e\n\x3cp\x3e其实这正解释了JavaScript的所谓类，只是构造函数，所谓继承，就是把构造函数和原型对象串起来而已，类似Builder Pattern的思想；所以Build两步还是三步都是可能的。\x3c\/p\x3e\n\x3cp\x3e这样写有一点实践上的意义，你可以先创建一个基类对象初始化所有的上下文，然后根据实际情况用它来构造继承类对象，这样能重用一下继承类对象的enter逻辑（即constructor），不用重写。\x3c\/p\x3e\n\x3cp\x3eOK，这两个都是小问题，细节。move on。\x3c\/p\x3e\n\x3cp\x3e在所有子类中，constructor等价于状态机Pattern的enter，用于创建所有资源，而exit中需要销毁所有资源，尤其是那些出发但尚未完成的请求，以及尚未fire的timer。对付这种问题，状态机是第一首选Pattern，简直太容易写出行为复杂且健壮的代码了。\x3c\/p\x3e\n\x3cp\x3e事实上，任何其他形态的维护态的代码都可以看作是状态机Pattern的退化，所以对那些如果一开始就预见到未来会变得复杂的组件，应该一开始就写状态机；状态机牺牲的是代码量，但是对于行为定义的变化（迁移路径的增加，减少，改变，状态增减），它维护起来是无出其右的，是对付复杂多态行为的首选。\x3c\/p\x3e\n\x3cp\x3e本质上，状态机帮你拿掉在所有方法里的第一层switch\/case，代之以dispatch，或者是OO里说的多态；但是如果状态层叠呢？\x3c\/p\x3e\n\x3cp\x3e通常我们不在状态机里套状态机，一般只有在写复杂协议栈的时候这么写；一般而言，状态机两层最多了，内层的状态用值来表示状态，而不是用类来表示状态，足够了。\x3c\/p\x3e\n\x3cp\x3e举个例子看看你理解了没有：\x3c\/p\x3e\n\x3cp\x3e你的UI里有一个行为是操作一个列表中的单一对象；如果有一个对象被选中，然后按钮被点击，这是一种行为，另一种是用户先创建一个新对象，这是另一种行为；那么需要把Editing和EditingNew作为两种互斥状态处理吗？\x3c\/p\x3e\n\x3cp\x3e如果没有UI的颠覆性变化大多数情况不这样做，而是把Editing作为顶层状态机（superstate）处理，而New可以用一个props的值来表示，例如状态机对象里有一个叫做creating的prop，它是boolean类型。即顶层状态机用类对象表示，底层状态机回到土办法，用值表示。\x3c\/p\x3e\n\x3cp\x3e这样设计的好处是：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3eEditing和EditingNew有大量状态是重用的和persistent的，即从一个迁移到另一个，他们仍然是有效的，不应该被一个exit销毁，另一个enter重建。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e他们作为父子状态设计可以共用大量方法，而不是每个都提供自己的副本；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e如果从父状态迁出或者从外部状态向父状态迁入，销毁和构建资源的逻辑也大部分是相同的；\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e实际上的状态图上往往是有superstate（父状态）迁出的事件逻辑；那么执行方式是\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e直接调用父状态的exit\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e父状态的exit先dispatch子状态的exit\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e父状态的exit再调用自己的逻辑，即清理子状态的共享资源。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e如果是外部迁入父状态机，要有一个决策依据决定应该迁向那个子状态机作为初始状态，因为在runtime，组合状态机构成的tree结构，实际的状态机实例只能在leaf node上，superstate节点的存在是为了抽象子节点的共同行为，减少迁移路径和重用行为逻辑；\x3c\/p\x3e\n\x3cp\x3e因此迁入父状态机时（enter）的逻辑和迁出（exit）刚好相反：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e直接调用父状态机的enter\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e父状态机先构造对所有子状态都适用的资源\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e调用具体某个子状态机的enter（就是一个if \/ then来区分子状态机即可）\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e在OO领域，很多开发者信奉UML图；UML图对OO语言中最重要的类图，在JavaScript里毛用没有了，但是State Machine图，结合上述状态机设计，绝对是对付复杂UI的利器；尤其是对于初学者而言，在前端的状态逻辑上，你能掌握这一把刀就能砍倒所有的树；如果还不能砍倒，那其实问题本身不是UI构建域的，可能是其他问题，例如调度等等。\x3c\/p\x3e\n\x3cp\x3e很多写JavaScript的朋友，为了向世人证明自己根骨奇佳、习得真传，到处宣扬OO里的种种不是，以各种言辞抨击OO实践的方方面面。\x3c\/p\x3e\n\x3cp\x3e他们不懂OO。\x3c\/p\x3e\n\x3cp\x3eOO里在语言层面可能有一些设计问题，但是OO里的封装思想是绝对正确的；\x3c\/p\x3e\n\x3cp\x3e为什么会有对象这个概念被提出来？就是因为一些态的生命周期超过函数调用的执行时间，你需要一种方式来管理这些态。\x3c\/p\x3e\n\x3cp\x3e封装的本质是：在内部有一个state space，在外部看，只看到内部的state space的superstate。物理学上称之为简并，degeneration。\x3c\/p\x3e\n\x3cp\x3e这是我们对付所有复杂状态的唯一手段，不管态放在花盆里、银行里、还是藏在自己的内裤里，他们都是客观存在，你不可能去消灭态，你只能organize他们；而且你同时需要organize应用在态上过程（function）。\x3c\/p\x3e\n\x3cp\x3e状态机把这个organization完完全全一览无遗的展露出来，无论你用class写，用闭包写，用c语言写，行为和状态的structure都不会变，想成为一个合格的程序员，尤其是写ui的程序员，state machine pattern是必修课。\x3c\/p\x3e\n\x3cp\x3e～～～～～～～～～～～～～～～～～～～\x3c\/p\x3e\n\x3cp\x3e先写这么多，我得按照上述逻辑扣代码去了。\x3c\/p\x3e\n\x3cp\x3e祝大家圣诞节快乐。\x3c\/p\x3e\n\x3cp\x3e欢迎探讨。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>React Component里的状态机Pattern</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000007913083">https://segmentfault.com/a/1190000007913083</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/mn938vwhal/" target="_blank">https://alili.tech/archive/mn938vwhal/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>