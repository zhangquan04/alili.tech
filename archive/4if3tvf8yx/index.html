<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="React 组件"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>React 组件 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/4if3tvf8yx/",
				"appid": "1613049289050283", 
				"title": "React 组件 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-10T02:30:08"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/cuo467v39nb/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/lezt7ytb91/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f4if3tvf8yx%2f&text=React%20%e7%bb%84%e4%bb%b6"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f4if3tvf8yx%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f4if3tvf8yx%2f&text=React%20%e7%bb%84%e4%bb%b6"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f4if3tvf8yx%2f&title=React%20%e7%bb%84%e4%bb%b6"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f4if3tvf8yx%2f&is_video=false&description=React%20%e7%bb%84%e4%bb%b6"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=React%20%e7%bb%84%e4%bb%b6&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f4if3tvf8yx%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f4if3tvf8yx%2f&title=React%20%e7%bb%84%e4%bb%b6"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f4if3tvf8yx%2f&title=React%20%e7%bb%84%e4%bb%b6"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f4if3tvf8yx%2f&title=React%20%e7%bb%84%e4%bb%b6"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f4if3tvf8yx%2f&title=React%20%e7%bb%84%e4%bb%b6"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">React 组件</h1><div class="meta"><div class="postdate"><time datetime="2019-01-10" itemprop="datePublished">2019-01-10</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch1 id=\x22articleHeader0\x22\x3eReact 组件\x3c\/h1\x3e\n\x3cp\x3e一个 \x3ccode\x3eReact\x3c\/code\x3e 应用就是构建在\x3ccode\x3eReact组件\x3c\/code\x3e之上的。\x3c\/p\x3e\n\x3cp\x3e组件有两个核心概念：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eprops\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3estate\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e一个组件就是通过这两个属性的值在 \x3ccode\x3erender\x3c\/code\x3e 方法里面生成这个组件对应的 \x3ccode\x3eHTML\x3c\/code\x3e 结构。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e\x3cstrong\x3e注意：组件生成的 \x3ccode\x3eHTML\x3c\/code\x3e 结构只能有一个单一的根节点。\x3c\/strong\x3e\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e\x3cstrong\x3eprops\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eprops\x3c\/code\x3e 就是组件的属性，由外部通过 \x3ccode\x3eJSX\x3c\/code\x3e 属性传入设置，一旦初始设置完成，就可以认为 \x3ccode\x3ethis.props\x3c\/code\x3e 是不可更改的，所以不要轻易更改设置 \x3ccode\x3ethis.props\x3c\/code\x3e 里面的值（虽然对于一个 \x3ccode\x3eJS\x3c\/code\x3e 对象你可以做任何事）。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3estate\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3estate\x3c\/code\x3e 是组件的当前状态，可以把组件简单看成一个\x3ccode\x3e“状态机”\x3c\/code\x3e，根据状态 \x3ccode\x3estate\x3c\/code\x3e 呈现不同的 \x3ccode\x3eUI\x3c\/code\x3e 展示。\x3c\/p\x3e\n\x3cp\x3e一旦状态（数据）更改，组件就会自动调用 \x3ccode\x3erender\x3c\/code\x3e 重新渲染 \x3ccode\x3eUI\x3c\/code\x3e，这个更改的动作会通过 \x3ccode\x3ethis.setState\x3c\/code\x3e 方法来触发。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e划分状态数据\x3c\/h2\x3e\n\x3cp\x3e一条原则：让组件尽可能地少状态。\x3c\/p\x3e\n\x3cp\x3e这样组件逻辑就越容易维护。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e什么样的数据属性可以当作状态？\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e当更改这个状态（数据）需要更新组件 \x3ccode\x3eUI\x3c\/code\x3e 的就可以认为是 \x3ccode\x3estate\x3c\/code\x3e，下面这些可以认为不是状态：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e可计算的数据：比如一个数组的长度\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e和 \x3ccode\x3eprops\x3c\/code\x3e 重复的数据：除非这个数据是要做变更的\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e无状态组件\x3c\/h2\x3e\n\x3cp\x3e你也可以用纯粹的函数来定义\x3ccode\x3e无状态的组件(stateless function)\x3c\/code\x3e，\x3ccode\x3e这种组件没有状态，没有生命周期\x3c\/code\x3e，只是简单的接受 \x3ccode\x3eprops\x3c\/code\x3e 渲染生成 \x3ccode\x3eDOM\x3c\/code\x3e 结构。无状态组件非常简单，开销很低，如果可能的话尽量使用无状态组件。比如使用箭头函数定义：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const HelloMessage = (props) =\x3e \x3cdiv\x3eHello {props.name}\x3c\/div\x3e;\nrender(\x3cHelloMessage name=\x26quot;Jim\x26quot;\/\x3e, app);\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs dust\x22\x3e\x3ccode\x3e\x3cspan class=\x22xml\x22\x3econst HelloMessage = (props) =\x26gt; \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3eHello \x3c\/span\x3e\x3cspan class=\x22hljs-template-variable\x22\x3e{props.name}\x3c\/span\x3e\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e;\nrender(\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eHelloMessage\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22Jim\x22\x3c\/span\x3e\/\x26gt;\x3c\/span\x3e, app);\n\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e因为无状态组件\x3ccode\x3e只是函数\x3c\/code\x3e，所以它\x3ccode\x3e没有实例返回\x3c\/code\x3e，这点在想用 \x3ccode\x3erefs\x3c\/code\x3e 获取无状态组件的时候要注意。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader3\x22\x3e组件生命周期\x3c\/h1\x3e\n\x3cp\x3e一般来说，一个组件类由 \x3ccode\x3eextends Component\x3c\/code\x3e 创建，并且提供一个 \x3ccode\x3erender\x3c\/code\x3e 方法以及其他\x3ccode\x3e可选的生命周期函数\x3c\/code\x3e、\x3ccode\x3e组件相关的事件或方法\x3c\/code\x3e来定义。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3egetInitialState\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e初始化 \x3ccode\x3ethis.state\x3c\/code\x3e 的值，只在组件装载之前调用一次。\x3c\/p\x3e\n\x3cp\x3e如果是使用 \x3ccode\x3eES6\x3c\/code\x3e 的语法，你也可以\x3ccode\x3e在构造函数中初始化状态\x3c\/code\x3e，比如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Counter extends Component {\n    constructor(props) {\n        super(props);\n        this.state = {count: props.initialCount};\n    }\n\n    render() {\n        \n    }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eCounter\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n    constructor(props) {\n        \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(props);\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = {count: props.initialCount};\n    }\n\n    render() {\n        \n    }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3egetDefaultProps\x3c\/h2\x3e\n\x3cp\x3e只在组件\x3ccode\x3e创建时调用一次并缓存返回的对象\x3c\/code\x3e（即在 \x3ccode\x3eReact.createClass\x3c\/code\x3e 之后就会调用）。\x3c\/p\x3e\n\x3cp\x3e因为这个方法在实例初始化之前调用，所以在这个方法里面不能依赖 \x3ccode\x3ethis\x3c\/code\x3e 获取到这个组件的实例。\x3c\/p\x3e\n\x3cp\x3e在组件装载之后，这个方法缓存的结果会用来保证访问 \x3ccode\x3ethis.props\x3c\/code\x3e 的属性时，当这个属性没有在父组件中传入（在这个组件的 \x3ccode\x3eJSX\x3c\/code\x3e 属性里设置），也总是有值的。\x3c\/p\x3e\n\x3cp\x3e如果是使用 \x3ccode\x3eES6\x3c\/code\x3e 语法，可以直接定义 \x3ccode\x3edefaultProps\x3c\/code\x3e 这个类属性来替代，这样能更直观的知道 \x3ccode\x3edefault props\x3c\/code\x3e 是预先定义好的对象值：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Counter.defaultProps = {initialCount: 0};\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs dust\x22\x3e\x3ccode\x3e\x3cspan class=\x22xml\x22\x3eCounter.defaultProps = \x3c\/span\x3e\x3cspan class=\x22hljs-template-variable\x22\x3e{initialCount: 0}\x3c\/span\x3e\x3cspan class=\x22xml\x22\x3e;\n\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3erender\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e组装生成这个组件的 \x3ccode\x3eHTML\x3c\/code\x3e 结构（使用原生 \x3ccode\x3eHTML\x3c\/code\x3e 标签或者子组件），也可以返回 \x3ccode\x3enull\x3c\/code\x3e 或者 \x3ccode\x3efalse\x3c\/code\x3e，这时候 \x3ccode\x3eReactDOM.findDOMNode(this)\x3c\/code\x3e 会返回 \x3ccode\x3enull\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader5\x22\x3e生命周期函数\x3c\/h1\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3e装载组件触发\x3c\/h2\x3e\n\x3cp\x3e\x3cstrong\x3ecomponentWillMount\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e只会在装载之前调用一次，在 \x3ccode\x3erender\x3c\/code\x3e 之前调用，你可以在这个方法里面调用 \x3ccode\x3esetState\x3c\/code\x3e 改变状态，并且不会导致额外调用一次 \x3ccode\x3erender\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3ecomponentDidMount\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e只会在装载完成之后调用一次，在 \x3ccode\x3erender\x3c\/code\x3e 之后调用，从这里开始可以通过 \x3ccode\x3eReactDOM.findDOMNode(this)\x3c\/code\x3e 获取到组件的 \x3ccode\x3eDOM\x3c\/code\x3e 节点。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3e更新组件触发\x3c\/h2\x3e\n\x3cp\x3e这些方法不会在首次 \x3ccode\x3erender\x3c\/code\x3e 组件的周期调用\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3ecomponentWillReceiveProps\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3ecomponentWillUpdate\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3ecomponentDidUpdate\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3e卸载组件触发\x3c\/h2\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3e\x3ccode\x3ecomponentWillUnmount\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3ch1 id=\x22articleHeader9\x22\x3e事件处理\x3c\/h1\x3e\n\x3cp\x3e可以看到 \x3ccode\x3eReact\x3c\/code\x3e 里面绑定事件的方式和在 \x3ccode\x3eHTML\x3c\/code\x3e 中绑定事件类似，使用驼峰式命名指定要绑定的 \x3ccode\x3eonClick\x3c\/code\x3e 属性为组件定义的一个方法 \x3ccode\x3e{this.handleClick.bind(this)}\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e注意要显式调用 \x3ccode\x3ebind(this)\x3c\/code\x3e \x3ccode\x3e将事件函数上下文绑定要组件实例上\x3c\/code\x3e，这也是 \x3ccode\x3eReact\x3c\/code\x3e 推崇的原则：没有黑科技，尽量使用显式的容易理解的 \x3ccode\x3eJavaScript\x3c\/code\x3e 代码。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader10\x22\x3e“合成事件”和“原生事件”\x3c\/h2\x3e\n\x3cp\x3e\x3ccode\x3eReact\x3c\/code\x3e 实现了一个“合成事件”层（\x3ccode\x3esynthetic event system\x3c\/code\x3e），这个事件模型保证了和 \x3cstrong\x3eW3C\x3c\/strong\x3e 标准保持一致，所以不用担心有什么诡异的用法，并且这个事件层消除了 \x3cstrong\x3eIE\x3c\/strong\x3e 与 \x3cstrong\x3eW3C\x3c\/strong\x3e 标准实现之间的兼容问题。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e“合成事件”还提供了额外的好处：\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e事件委托\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e“合成事件”会以\x3ccode\x3e事件委托\x3c\/code\x3e（\x3ccode\x3eevent delegation\x3c\/code\x3e）的方式绑定到\x3ccode\x3e组件最上层\x3c\/code\x3e，并且在\x3ccode\x3e组件卸载\x3c\/code\x3e（\x3ccode\x3eunmount\x3c\/code\x3e）的时候\x3ccode\x3e自动销毁绑定的事件\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e什么是“原生事件”？\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e比如你在 \x3ccode\x3ecomponentDidMount\x3c\/code\x3e 方法里面通过 \x3ccode\x3eaddEventListener\x3c\/code\x3e 绑定的事件就是浏览器原生事件。\x3c\/p\x3e\n\x3cp\x3e使用原生事件的时候注意在 \x3ccode\x3ecomponentWillUnmount\x3c\/code\x3e 解除绑定 \x3ccode\x3eremoveEventListener\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e所有通过 \x3ccode\x3eJSX\x3c\/code\x3e 这种方式绑定的事件都是绑定到“合成事件”，除非你有特别的理由，建议总是用 \x3ccode\x3eReact\x3c\/code\x3e 的方式处理事件。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3eTips\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e如果混用“合成事件”和“原生事件”，比如一种常见的场景是用原生事件在 \x3ccode\x3edocument\x3c\/code\x3e 上绑定，然后在组件里面绑定的合成事件想要通过 \x3ccode\x3ee.stopPropagation()\x3c\/code\x3e 来阻止事件冒泡到 \x3ccode\x3edocument\x3c\/code\x3e，这时候是行不通的，参见 \x3ca href=\x22https:\/\/stackoverflow.com\/questions\/24415631\/reactjs-syntheticevent-stoppropagation-only-works-with-react-events\/24421834#24421834\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eEvent delegation\x3c\/a\x3e，因为 \x3ccode\x3ee.stopPropagation\x3c\/code\x3e 是内部“合成事件” 层面的，解决方法是要用 \x3ccode\x3ee.nativeEvent.stopImmediatePropagation()\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e“合成事件” 的 \x3ccode\x3eevent\x3c\/code\x3e 对象只在当前 \x3ccode\x3eevent loop\x3c\/code\x3e 有效，比如你想在事件里面调用一个 \x3ccode\x3epromise\x3c\/code\x3e，在 \x3ccode\x3eresolve\x3c\/code\x3e 之后去拿 \x3ccode\x3eevent\x3c\/code\x3e 对象会拿不到（并且没有错误抛出）：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22handleClick(e) {\n  promise.then(() =\x3e doSomethingWith(e));\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3ehandleClick(e) {\n  promise.\x3cspan class=\x22hljs-keyword\x22\x3ethen\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e doSomethingWith(e));\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader11\x22\x3e参数传递\x3c\/h2\x3e\n\x3cp\x3e给事件处理函数传递额外参数的方式：\x3ccode\x3ebind(this, arg1, arg2, ...)\x3c\/code\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22render: function() {\n    return \x3cp onClick={this.handleClick.bind(this, \x27extra param\x27)}\x3e;\n},\nhandleClick: function(param, event) {\n    \/\/ handle click\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3erender: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x26lt;p onClick={\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handleClick.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27extra param\x27\x3c\/span\x3e)}\x26gt;;\n},\nhandleClick: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(param, event)\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ handle click\x3c\/span\x3e\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch1 id=\x22articleHeader12\x22\x3eDOM 操作\x3c\/h1\x3e\n\x3cp\x3e大部分情况下你不需要通过查询 \x3ccode\x3eDOM\x3c\/code\x3e 元素去更新组件的 \x3ccode\x3eUI\x3c\/code\x3e，你只要关注设置组件的状态（\x3ccode\x3esetState\x3c\/code\x3e）。但是可能在某些情况下你确实需要直接操作 \x3ccode\x3eDOM\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e首先我们要了解 \x3ccode\x3eReactDOM.render\x3c\/code\x3e 组件返回的是什么？\x3c\/p\x3e\n\x3cp\x3e它会返回\x3ccode\x3e对组件的引用\x3c\/code\x3e也就是\x3ccode\x3e组件实例\x3c\/code\x3e（对于\x3ccode\x3e无状态状态组件\x3c\/code\x3e来说返回 \x3ccode\x3enull\x3c\/code\x3e），注意 \x3ccode\x3eJSX\x3c\/code\x3e 返回的不是组件实例，它只是一个 \x3ccode\x3eReactElement\x3c\/code\x3e 对象（还记得我们用纯 \x3ccode\x3eJS\x3c\/code\x3e 来构建 \x3ccode\x3eJSX\x3c\/code\x3e 的方式吗），比如这种：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ A ReactElement\nconst myComponent = \x3cMyComponent \/\x3e\n\n\/\/ render\nconst myComponentInstance = ReactDOM.render(myComponent, mountNode);\nmyComponentInstance.doSomething();\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ A ReactElement\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e myComponent = \x26lt;MyComponent \/\x26gt;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ render\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e myComponentInstance = ReactDOM.render(myComponent, mountNode);\nmyComponentInstance.doSomething();\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3efindDOMNode()\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e当组件加载到页面上之后（\x3ccode\x3emounted\x3c\/code\x3e），你都可以通过 \x3ccode\x3ereact-dom\x3c\/code\x3e 提供的 \x3ccode\x3efindDOMNode()\x3c\/code\x3e 方法拿到组件对应的 \x3ccode\x3eDOM\x3c\/code\x3e 元素。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import { findDOMNode } from \x27react-dom\x27;\n\n\/\/ Inside Component class\ncomponentDidMound() {\n  const el = findDOMNode(this);\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { findDOMNode } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react-dom\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e Inside Component \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e\x3c\/span\x3e\ncomponentDidMound() {\n  const el = findDOMNode(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3efindDOMNode()\x3c\/code\x3e 不能用在无状态组件上。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3eRefs\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e另外一种方式就是通过在要引用的 \x3ccode\x3eDOM\x3c\/code\x3e 元素上面设置一个 \x3ccode\x3eref\x3c\/code\x3e 属性指定一个名称，然后通过 \x3ccode\x3ethis.refs.name\x3c\/code\x3e 来访问对应的 \x3ccode\x3eDOM\x3c\/code\x3e 元素。\x3c\/p\x3e\n\x3cp\x3e比如有一种情况是必须\x3ccode\x3e直接操作 DOM\x3c\/code\x3e 来实现的，你希望一个 \x3ccode\x3e\x26lt;input\/\x26gt;\x3c\/code\x3e 元素在你清空它的值时 \x3ccode\x3efocus\x3c\/code\x3e，你没法仅仅靠 \x3ccode\x3estate\x3c\/code\x3e 来实现这个功能。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class App extends Component {\n  constructor() {\n    return { userInput: \x27\x27 };\n  }\n\n  handleChange(e) {\n    this.setState({ userInput: e.target.value });\n  }\n\n  clearAndFocusInput() {\n    this.setState({ userInput: \x27\x27 }, () =\x3e {\n      this.refs.theInput.focus();\n    });\n  }\n\n  render() {\n    return (\n      \x3cdiv\x3e\n        \x3cdiv onClick={this.clearAndFocusInput.bind(this)}\x3e\n          Click to Focus and Reset\n        \x3c\/div\x3e\n        \x3cinput\n          ref=\x26quot;theInput\x26quot;\n          value={this.state.userInput}\n          onChange={this.handleChange.bind(this)}\n        \/\x3e\n      \x3c\/div\x3e\n    );\n  }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eApp\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e { userInput: \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e };\n  }\n\n  handleChange(e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({ userInput: e.target.value });\n  }\n\n  clearAndFocusInput() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({ userInput: \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e }, () =\x26gt; {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.refs.theInput.focus();\n    });\n  }\n\n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x26lt;div\x26gt;\n        \x26lt;div onClick={\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.clearAndFocusInput.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e)}\x26gt;\n          Click to Focus and Reset\n        \x26lt;\/div\x26gt;\n        \x26lt;input\n          ref=\x3cspan class=\x22hljs-string\x22\x3e\x22theInput\x22\x3c\/span\x3e\n          value={\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.userInput}\n          onChange={\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handleChange.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e)}\n        \/\x26gt;\n      \x26lt;\/div\x26gt;\n    );\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果 \x3ccode\x3eref\x3c\/code\x3e 是设置在原生 \x3ccode\x3eHTML\x3c\/code\x3e 元素上，它拿到的就是 \x3ccode\x3eDOM\x3c\/code\x3e 元素，如果设置在自定义组件上，它拿到的就是组件实例，这时候就需要通过 \x3ccode\x3efindDOMNode\x3c\/code\x3e 来拿到组件的 \x3ccode\x3eDOM\x3c\/code\x3e 元素。\x3c\/p\x3e\n\x3cp\x3e因为无状态组件没有实例，所以 \x3ccode\x3eref\x3c\/code\x3e 不能设置在无状态组件上，一般来说这没什么问题，因为无状态组件没有实例方法，不需要 \x3ccode\x3eref\x3c\/code\x3e 去拿实例调用相关的方法，但是如果想要拿无状态组件的 \x3ccode\x3eDOM\x3c\/code\x3e 元素的时候，就需要用一个状态组件封装一层，然后通过 \x3ccode\x3eref\x3c\/code\x3e 和 \x3ccode\x3efindDOMNode\x3c\/code\x3e 去获取。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e总结\x3c\/strong\x3e\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e你可以使用 \x3ccode\x3eref\x3c\/code\x3e 到的组件定义的任何公共方法，比如 \x3ccode\x3ethis.refs.myTypeahead.reset()\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eRefs\x3c\/code\x3e 是访问到组件内部 \x3ccode\x3eDOM\x3c\/code\x3e 节点唯一\x3cstrong\x3e可靠\x3c\/strong\x3e的方法\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3cstrong\x3e注意事项\x3c\/strong\x3e\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e不要在 \x3ccode\x3erender\x3c\/code\x3e 或者 \x3ccode\x3erender 之前\x3c\/code\x3e访问 \x3ccode\x3erefs\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e不要滥用 \x3ccode\x3erefs\x3c\/code\x3e，比如只是用它来按照传统的方式操作界面 \x3ccode\x3eUI\x3c\/code\x3e：找到 \x3ccode\x3eDOM\x3c\/code\x3e -\x26gt; 更新 \x3ccode\x3eDOM\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch1 id=\x22articleHeader13\x22\x3e组合组件\x3c\/h1\x3e\n\x3cp\x3e使用组件的目的就是通过构建模块化的组件，相互组合组件最后组装成一个复杂的应用。\x3c\/p\x3e\n\x3cp\x3e在 \x3ccode\x3eReact\x3c\/code\x3e 组件中要包含其他组件作为子组件，只需要把组件当作一个 \x3ccode\x3eDOM\x3c\/code\x3e 元素引入就可以了。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader14\x22\x3e循环插入子元素\x3c\/h2\x3e\n\x3cp\x3e如果组件中包含通过循环插入的子元素，为了保证重新渲染 \x3ccode\x3eUI\x3c\/code\x3e 的时候能够正确显示这些子元素，每个元素都需要通过一个特殊的 \x3ccode\x3ekey\x3c\/code\x3e 属性指定一个唯一值。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3ekey\x3c\/code\x3e 必须直接在循环中设置：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const MyComponent = (props) =\x3e {\n    return (\n        \x3cul\x3e\n            {props.results.map((result) =\x3e {\n                return \x3cListItemWrapper key={result.id} data={result}\/\x3e;\n            })}\n        \x3c\/ul\x3e\n    );\n};\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e MyComponent = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eprops\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n        \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eul\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n            {props.results.map((result) =\x26gt; {\n                return \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eListItemWrapper\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ekey\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{result.id}\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3edata\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{result}\/\x3c\/span\x3e\x26gt;\x3c\/span\x3e;\n            })}\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eul\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    );\n};\n\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e你也可以用一个 \x3ccode\x3ekey\x3c\/code\x3e 值作为属性，子元素作为属性值的对象字面量来显示子元素列表。\x3c\/p\x3e\n\x3cp\x3e实际上浏览器在遍历一个字面量对象的时候会保持顺序一致，除非存在属性值可以被转换成整数值，这种属性值会排序并放在其他属性之前被遍历到，所以为了防止这种情况发生，可以在构建这个字面量的时候在 \x3ccode\x3ekey\x3c\/code\x3e 值前面加字符串前缀。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eHTML\x3c\/code\x3e 元素会作为 \x3ccode\x3eReact\x3c\/code\x3e 组件对象、\x3ccode\x3eJS\x3c\/code\x3e 表达式结果是一个文字节点，都会存入 \x3ccode\x3eParent\x3c\/code\x3e 组件的 \x3ccode\x3eprops.children\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e一般来说，可以直接将这个属性作为父组件的子元素 \x3ccode\x3erender\x3c\/code\x3e：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const Parent = (props) =\x3e \x3cdiv\x3e{props.children}\x3c\/div\x3e;\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3econst Parent = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(props)\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x26lt;div\x26gt;{props.children}\x26lt;\/div\x26gt;;\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3eprops.children\x3c\/code\x3e 通常是一个组件对象的数组，但是当只有一个子元素的时候，\x3ccode\x3eprops.children\x3c\/code\x3e 将是这个唯一的子元素，而不是数组了。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eReact.Children\x3c\/code\x3e 提供了额外的方法方便操作这个属性。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader15\x22\x3e组件间通信\x3c\/h1\x3e\n\x3ch2 id=\x22articleHeader16\x22\x3e父子组件间通信\x3c\/h2\x3e\n\x3cp\x3e这种情况下很简单，就是通过 \x3ccode\x3eprops\x3c\/code\x3e 属性传递，在父组件给子组件设置 \x3ccode\x3eprops\x3c\/code\x3e，然后子组件就可以通过 \x3ccode\x3eprops\x3c\/code\x3e 访问到父组件的数据／方法，这样就搭建起了父子组件间通信的桥梁。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3ediv\x3c\/code\x3e 可以看作一个子组件，指定它的 \x3ccode\x3eonClick\x3c\/code\x3e 事件调用父组件的方法。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import React, {Component} from \x27react\x27;\nimport {render} from \x27react-dom\x27;\n\nclass GroceryList extends Component {\n    handleClick(i) {\n        console.log(\x27You clicked: \x27 \x2b this.props.items[i]);\n    }\n\n    render() {\n        return (\n            \x3cul\x3e\n                {this.props.items.map((item, i) =\x3e {\n                    return (\n                        \x3cli onClick={this.handleClick.bind(this, i)} key={i}\x3e{item}\x3c\/li\x3e\n                    )\n                })}\n            \x3c\/ul\x3e\n        )\n    }\n}\nrender(\n    \x3cGroceryList items={[\x27Apple\x27, \x27Banana\x27, \x27Cranberry\x27]}\/\x3e,\n    mountNode\n);\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eReact\x3c\/span\x3e, {\x3cspan class=\x22hljs-type\x22\x3eComponent\x3c\/span\x3e} from \x3cspan class=\x22hljs-symbol\x22\x3e\x27reac\x3c\/span\x3et\x27;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e {render} from \x3cspan class=\x22hljs-symbol\x22\x3e\x27react\x3c\/span\x3e-dom\x27;\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eGroceryList\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n    handleClick(i) {\n        console.log(\x3cspan class=\x22hljs-symbol\x22\x3e\x27You\x3c\/span\x3e clicked: \x27 \x2b \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.items[i]);\n    }\n\n    render() {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n            \x26lt;ul\x26gt;\n                {\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.items.map((item, i) =\x26gt; {\n                    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n                        \x26lt;li onClick={\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handleClick.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, i)} key={i}\x26gt;{item}\x26lt;\/li\x26gt;\n                    )\n                })}\n            \x26lt;\/ul\x26gt;\n        )\n    }\n}\nrender(\n    \x26lt;\x3cspan class=\x22hljs-type\x22\x3eGroceryList\x3c\/span\x3e items={[\x3cspan class=\x22hljs-symbol\x22\x3e\x27Appl\x3c\/span\x3ee\x27, \x3cspan class=\x22hljs-symbol\x22\x3e\x27Banan\x3c\/span\x3ea\x27, \x3cspan class=\x22hljs-symbol\x22\x3e\x27Cranberr\x3c\/span\x3ey\x27]}\/\x26gt;,\n    mountNode\n);\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3ediv\x3c\/code\x3e 可以看作一个子组件，指定它的 \x3ccode\x3eonClick\x3c\/code\x3e 事件调用父组件的方法。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader17\x22\x3e非父子组件间的通信\x3c\/h2\x3e\n\x3cp\x3e使用\x3ccode\x3e全局事件 Pub\/Sub 模式\x3c\/code\x3e，在 \x3ccode\x3ecomponentDidMount\x3c\/code\x3e 里面\x3ccode\x3e订阅事件\x3c\/code\x3e，在 \x3ccode\x3ecomponentWillUnmount\x3c\/code\x3e 里面\x3ccode\x3e取消订阅\x3c\/code\x3e，当收到事件触发的时候调用 \x3ccode\x3esetState\x3c\/code\x3e 更新 \x3ccode\x3eUI\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e这种模式在复杂的系统里面可能会变得难以维护，所以看个人权衡是否将组件封装到大的组件，甚至整个页面或者应用就封装到一个组件。\x3c\/p\x3e\n\x3cp\x3e一般来说，对于比较复杂的应用，推荐使用类似 \x3ccode\x3eFlux\x3c\/code\x3e 这种单项数据流架构。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>React 组件</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000010020334">https://segmentfault.com/a/1190000010020334</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/4if3tvf8yx/" target="_blank">https://alili.tech/archive/4if3tvf8yx/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>