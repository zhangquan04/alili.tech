<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="造轮子系列(一): 一个速度九分快的JSON解析器"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>造轮子系列(一): 一个速度九分快的JSON解析器 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/4qhdoesmclk/",
				"appid": "1613049289050283", 
				"title": "造轮子系列(一): 一个速度九分快的JSON解析器 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-07T02:30:11"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/mjkudrqaglo/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/7j5cy44e9uw/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f4qhdoesmclk%2f&text=%e9%80%a0%e8%bd%ae%e5%ad%90%e7%b3%bb%e5%88%97%28%e4%b8%80%29%3a%20%e4%b8%80%e4%b8%aa%e9%80%9f%e5%ba%a6%e4%b9%9d%e5%88%86%e5%bf%ab%e7%9a%84JSON%e8%a7%a3%e6%9e%90%e5%99%a8"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f4qhdoesmclk%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f4qhdoesmclk%2f&text=%e9%80%a0%e8%bd%ae%e5%ad%90%e7%b3%bb%e5%88%97%28%e4%b8%80%29%3a%20%e4%b8%80%e4%b8%aa%e9%80%9f%e5%ba%a6%e4%b9%9d%e5%88%86%e5%bf%ab%e7%9a%84JSON%e8%a7%a3%e6%9e%90%e5%99%a8"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f4qhdoesmclk%2f&title=%e9%80%a0%e8%bd%ae%e5%ad%90%e7%b3%bb%e5%88%97%28%e4%b8%80%29%3a%20%e4%b8%80%e4%b8%aa%e9%80%9f%e5%ba%a6%e4%b9%9d%e5%88%86%e5%bf%ab%e7%9a%84JSON%e8%a7%a3%e6%9e%90%e5%99%a8"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f4qhdoesmclk%2f&is_video=false&description=%e9%80%a0%e8%bd%ae%e5%ad%90%e7%b3%bb%e5%88%97%28%e4%b8%80%29%3a%20%e4%b8%80%e4%b8%aa%e9%80%9f%e5%ba%a6%e4%b9%9d%e5%88%86%e5%bf%ab%e7%9a%84JSON%e8%a7%a3%e6%9e%90%e5%99%a8"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e9%80%a0%e8%bd%ae%e5%ad%90%e7%b3%bb%e5%88%97%28%e4%b8%80%29%3a%20%e4%b8%80%e4%b8%aa%e9%80%9f%e5%ba%a6%e4%b9%9d%e5%88%86%e5%bf%ab%e7%9a%84JSON%e8%a7%a3%e6%9e%90%e5%99%a8&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f4qhdoesmclk%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f4qhdoesmclk%2f&title=%e9%80%a0%e8%bd%ae%e5%ad%90%e7%b3%bb%e5%88%97%28%e4%b8%80%29%3a%20%e4%b8%80%e4%b8%aa%e9%80%9f%e5%ba%a6%e4%b9%9d%e5%88%86%e5%bf%ab%e7%9a%84JSON%e8%a7%a3%e6%9e%90%e5%99%a8"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f4qhdoesmclk%2f&title=%e9%80%a0%e8%bd%ae%e5%ad%90%e7%b3%bb%e5%88%97%28%e4%b8%80%29%3a%20%e4%b8%80%e4%b8%aa%e9%80%9f%e5%ba%a6%e4%b9%9d%e5%88%86%e5%bf%ab%e7%9a%84JSON%e8%a7%a3%e6%9e%90%e5%99%a8"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f4qhdoesmclk%2f&title=%e9%80%a0%e8%bd%ae%e5%ad%90%e7%b3%bb%e5%88%97%28%e4%b8%80%29%3a%20%e4%b8%80%e4%b8%aa%e9%80%9f%e5%ba%a6%e4%b9%9d%e5%88%86%e5%bf%ab%e7%9a%84JSON%e8%a7%a3%e6%9e%90%e5%99%a8"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f4qhdoesmclk%2f&title=%e9%80%a0%e8%bd%ae%e5%ad%90%e7%b3%bb%e5%88%97%28%e4%b8%80%29%3a%20%e4%b8%80%e4%b8%aa%e9%80%9f%e5%ba%a6%e4%b9%9d%e5%88%86%e5%bf%ab%e7%9a%84JSON%e8%a7%a3%e6%9e%90%e5%99%a8"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">造轮子系列(一): 一个速度九分快的JSON解析器</h1><div class="meta"><div class="postdate"><time datetime="2019-01-07" itemprop="datePublished">2019-01-07</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e前一阵子看到了一个Golang的JSON库\x3ccode\x3ego-simplejson\x3c\/code\x3e，用来封装与解析匿名的JSON，说白了就是用\x3ccode\x3emap\x3c\/code\x3e或者\x3ccode\x3eslice\x3c\/code\x3e等来解析JSON，觉得挺好玩，后来有个项目恰好要解析JSON，于是就试了试，不小心看了一眼源代码，发现竟然是用的Golang自带的\x3ccode\x3eencoding\/json\x3c\/code\x3e库去做的解析，而其本身只是把这个库封装了一层，看起来更好看罢了。于是心想能不能徒手写一个解析器，毕竟写了这么多年代码了，也\x3ccode\x3eJSON.parse\x3c\/code\x3e，\x3ccode\x3eJSON.stringify\x3c\/code\x3e了无数次。捣腾了两天，终于成了，测试了一下，性能比自带的库要高很多，速度基本上在\x3ccode\x3e1.6\x3c\/code\x3e到\x3ccode\x3e7\x3c\/code\x3e倍之间（视JSON串的大小和结构而定），所以决定写这篇文章分享一下思路。\x3c\/p\x3e\n\x3cp\x3e先插一个段子，作为一个已经完完整整写了将近三年代码的\x3cem\x3e老码农\x3c\/em\x3e，前一段面试，不止一次有面试官问我：如何深拷贝一个对象（JS），我笑笑说写一个Walk函数递归一下就行了啊，如果要考虑到Stackoverflow，那就用栈\x2b迭代就好了。然后他们老是问我，有没有更好的办法，然后自言自语的说你可以用JSON先序列化一遍再反序列化……\x3c\/p\x3e\n\x3cp\x3e项目取名\x3ccode\x3echeapjson\x3c\/code\x3e，意思是便宜的，因为你不光不需要定义各个struct，性能还比原生的快，所以很便宜。地址在 \x3ca href=\x22https:\/\/github.com\/acrazing\/cheapjson\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/acrazing\/c...\x3c\/a\x3e，有兴趣的可以看看~\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3eJSON value\x3c\/h2\x3e\n\x3cp\x3e首先既然是便宜的，便和反射无关了，所以\x3ccode\x3evoid *\x3c\/code\x3e是必需的，当然在Golang里面是\x3ccode\x3einterface{}\x3c\/code\x3e，然后需要一个结构来保存必需的信息，进行类型判断以及边界检查。如果是C的话，数组大小，字符串长度，对象Key\/Value映射都是必需的工作。不过在Golang里面就不需要了，编译器已经搞定了所有的工作。\x3c\/p\x3e\n\x3cp\x3e在JSON当中，一个完整的JSON应该包含\x3cstrong\x3e一个\x3c\/strong\x3e\x3ccode\x3evalue\x3c\/code\x3e，这个\x3ccode\x3evalue\x3c\/code\x3e的类型可能是\x3ccode\x3enull\x3c\/code\x3e，\x3ccode\x3etrue\x3c\/code\x3e，\x3ccode\x3efalse\x3c\/code\x3e，\x3ccode\x3enumber\x3c\/code\x3e，\x3ccode\x3estring\x3c\/code\x3e， \x3ccode\x3earray\x3c\/code\x3e以及 \x3ccode\x3eobject\x3c\/code\x3e共6种。而\x3ccode\x3earray\x3c\/code\x3e和\x3ccode\x3eobject\x3c\/code\x3e还有可能包含子\x3ccode\x3evalue\x3c\/code\x3e结构。这些类型的值映射到Golang当中，便是\x3ccode\x3enil\x3c\/code\x3e, \x3ccode\x3ebool\x3c\/code\x3e, \x3ccode\x3ebool\x3c\/code\x3e, \x3ccode\x3eint64\/float64\x3c\/code\x3e, \x3ccode\x3estring\x3c\/code\x3e, \x3ccode\x3e[]interface{}\x3c\/code\x3e, \x3ccode\x3emap[string]interface{}\x3c\/code\x3e，用一个\x3ccode\x3eunion\x3c\/code\x3e结构便可以搞定。注意这里的\x3ccode\x3enumber\x3c\/code\x3e有可以转换成整数或者是浮点数，在JavaScript中，全部用\x3ccode\x3e64\x3c\/code\x3e位双精度浮点数储存，所以最大的精确整数也就是非规约数是尾数部分\x3ccode\x3e2^53 - 1\x3c\/code\x3e，已经远远大于\x3ccode\x3eint32\x3c\/code\x3e了，所以这里将整数映射成了\x3ccode\x3eint64\x3c\/code\x3e而不是\x3ccode\x3eint\x3c\/code\x3e，因为在部分机器上可能溢出，严格的区分一个\x3ccode\x3eIEEE-754\x3c\/code\x3e格式的整数和浮点数并不是一件轻松的事情，这里简化成了\x3cstrong\x3e如果尾数中的小数部分以及指数部分均不存在，则认为是一个整数\x3c\/strong\x3e，此外，为了简化操作，\x3cstrong\x3e对于任何不合法的\x3ccode\x3eUTF-16\x3c\/code\x3e字符串，都认为结构有问题，而终止解析\x3c\/strong\x3e。为了方便，定义一个结构来保存一个JSON的\x3ccode\x3evalue\x3c\/code\x3e：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22type struct Value {\n  value interface{}\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22go hljs\x22\x3e\x3ccode class=\x22go\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3estruct\x3c\/span\x3e Value {\n  value \x3cspan class=\x22hljs-keyword\x22\x3einterface\x3c\/span\x3e{}\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e结构中的\x3ccode\x3evalue\x3c\/code\x3e字段保存这个JSON\x3ccode\x3eValue\x3c\/code\x3e的实际值，通过类型判定来确定其类型。因此会有很多的判定，赋值，以及取值函数，比如针对一个\x3ccode\x3estring\x3c\/code\x3e类型的\x3ccode\x3eValue\x3c\/code\x3e需要有判定是否为\x3ccode\x3estring\x3c\/code\x3e的操作\x3ccode\x3eIsString()\x3c\/code\x3e，赋值\x3ccode\x3eAsString()\x3c\/code\x3e，以及获取真实值的操作\x3ccode\x3eString()\x3c\/code\x3e：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 判定是否为string，如果是，则返回true，否则返回false\nfunc (v *Value) IsString() bool {\n  if _, ok := v.value.(string); ok {\n    return true\n  }\n  return false\n}\n\n\/\/ 将一个Value赋值为一个string\nfunc (v *Value) AsString(value string) {\n  v.value = value\n}\n\n\/\/ 从一个string类型的Value中取出String值\nfunc (v *Value) String() string {\n  if value, ok := v.value.(string); ok {\n    return value\n  }\n  \/\/ 如果不是一个string类型，则报错，所以需要先判定是否为string类型\n  panic(\x26quot;not a string value\x26quot;)\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22go hljs\x22\x3e\x3ccode class=\x22go\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 判定是否为string，如果是，则返回true，否则返回false\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunc\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(v *Value)\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eIsString\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ebool\x3c\/span\x3e\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e _, ok := v.value.(\x3cspan class=\x22hljs-keyword\x22\x3estring\x3c\/span\x3e); ok {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将一个Value赋值为一个string\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunc\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(v *Value)\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eAsString\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(value \x3cspan class=\x22hljs-keyword\x22\x3estring\x3c\/span\x3e)\x3c\/span\x3e\x3c\/span\x3e {\n  v.value = value\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 从一个string类型的Value中取出String值\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunc\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(v *Value)\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eString\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3estring\x3c\/span\x3e\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e value, ok := v.value.(\x3cspan class=\x22hljs-keyword\x22\x3estring\x3c\/span\x3e); ok {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e value\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果不是一个string类型，则报错，所以需要先判定是否为string类型\x3c\/span\x3e\n  \x3cspan class=\x22hljs-built_in\x22\x3epanic\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22not a string value\x22\x3c\/span\x3e)\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e针对这样的操作还有很多，可以参考 \x3ca href=\x22https:\/\/github.com\/acrazing\/cheapjson\/blob\/master\/value.go\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3echeapjson\/value.go\x3c\/a\x3e.\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3eJSON parser\x3c\/h2\x3e\n\x3cp\x3e对于\x3ccode\x3estring\x3c\/code\x3e, \x3ccode\x3etrue\x3c\/code\x3e, \x3ccode\x3efalse\x3c\/code\x3e, \x3ccode\x3enull\x3c\/code\x3e, \x3ccode\x3enumber\x3c\/code\x3e这样的值，都属于字面量，即没有深层结构，可取直接读取，并且中间不可能被空白字符切断，所以可以直接读取。而对于一个\x3ccode\x3earray\x3c\/code\x3e或者\x3ccode\x3eobject\x3c\/code\x3e，则是一个多层的树状结构。最直接的想法肯定是用递归，但是大家都知道这是不可行的，因为在解析大JSON的时候很可能栈溢出了，所以只能用栈\x2b迭代的办法。\x3c\/p\x3e\n\x3cp\x3e学过编译原理的人都知道，做AST分析的时候首先要分析Token，然后再分析AST，在解析JSON的时候也应该这样，虽然Token比较少：只有几个字面量以及\x3ccode\x3e{\x3c\/code\x3e, \x3ccode\x3e[\x3c\/code\x3e, \x3ccode\x3e:\x3c\/code\x3e, \x3ccode\x3e]\x3c\/code\x3e, \x3ccode\x3e}\x3c\/code\x3e几个界定符。可惜我并没有学过编译原理，上来就拿状态机来迭代了。因为JSON是一棵树，其解析过程是从树根一直遍历到各个叶节点再返回树根的过程。自然就会涉及到栈的压入及弹出操作。具体来讲，就是在遇到\x3ccode\x3earray\x3c\/code\x3e和\x3ccode\x3eobject\x3c\/code\x3e的子节点的时候要压入栈，遇到一个\x3ccode\x3evalue\x3c\/code\x3e的结束符的时候要弹出栈。同时还要保存栈结点对应的\x3ccode\x3eValue\x3c\/code\x3e以及其状态信息。所以我定义了一个栈结点结构：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22type struct state {\n  state int\n  value *Value\n  parent *state\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22go hljs\x22\x3e\x3ccode class=\x22go\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3estruct\x3c\/span\x3e state {\n  state \x3cspan class=\x22hljs-keyword\x22\x3eint\x3c\/span\x3e\n  value *Value\n  parent *state\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e其中\x3ccode\x3estate\x3c\/code\x3e表示当前栈节点的状态，\x3ccode\x3evalue\x3c\/code\x3e表示其所代表的值\x3ccode\x3eparent\x3c\/code\x3e表示其父节点，根节点的父节点为\x3ccode\x3enil\x3c\/code\x3e。当要压入栈时，只需要新建一个节点，将其\x3ccode\x3eparent\x3c\/code\x3e设置为当前节点即可，要弹出时，将当前结点设置为当前结点的\x3ccode\x3eparent\x3c\/code\x3e。如果当前节点为\x3ccode\x3enil\x3c\/code\x3e，则表示遍历结束，JSON自身也应该结束，除了空白字符外，不应该还包含任何字符。\x3c\/p\x3e\n\x3cp\x3e一个节点可能的状态有：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const (\n    \/\/ start of a value\n    stateNone = iota\n    stateString\n    \/\/ after [ must be a value or ]\n    stateArrayValueOrEnd\n    \/\/ after a value, must be a , or ]\n    stateArrayEndOrComma\n    \/\/ after a {, must be a key string or }\n    stateObjectKeyOrEnd\n    \/\/ after a key string must be a :\n    stateObjectColon\n    \/\/ after a : must be a value\n    \/\/ after a value, must be , or }\n    stateObjectEndOrComma\n    \/\/ after a , must be key string\n    stateObjectKey\n)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22go hljs\x22\x3e\x3ccode class=\x22go\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e (\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ start of a value\x3c\/span\x3e\n    stateNone = \x3cspan class=\x22hljs-literal\x22\x3eiota\x3c\/span\x3e\n    stateString\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ after [ must be a value or ]\x3c\/span\x3e\n    stateArrayValueOrEnd\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ after a value, must be a , or ]\x3c\/span\x3e\n    stateArrayEndOrComma\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ after a {, must be a key string or }\x3c\/span\x3e\n    stateObjectKeyOrEnd\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ after a key string must be a :\x3c\/span\x3e\n    stateObjectColon\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ after a : must be a value\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ after a value, must be , or }\x3c\/span\x3e\n    stateObjectEndOrComma\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ after a , must be key string\x3c\/span\x3e\n    stateObjectKey\n)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e状态的含义和字面意思一样，比如对于状态\x3ccode\x3estateArrayValueOrEnd\x3c\/code\x3e表示当前栈节点遇到了一个array的起始标志\x3ccode\x3e[\x3c\/code\x3e，在等待一个子\x3ccode\x3eValue\x3c\/code\x3e或者一个array的结束符\x3ccode\x3e]\x3c\/code\x3e，而状态\x3ccode\x3estateArrayEndOrComma\x3c\/code\x3e表示一个array已经遇到了子\x3ccode\x3eValue\x3c\/code\x3e，在等待结束符\x3ccode\x3e]\x3c\/code\x3e或者\x3ccode\x3eValue\x3c\/code\x3e的分隔符\x3ccode\x3e,\x3c\/code\x3e。因此，在解析一个数组的时候，完整的栈操作过程是：遇到\x3ccode\x3e[\x3c\/code\x3e，将当前结点的状态设置为\x3ccode\x3estateArrayValueOrEnd\x3c\/code\x3e，然后过滤空白字符，判定第一个字符是\x3ccode\x3e]\x3c\/code\x3e还是其它字符，如果是\x3ccode\x3e]\x3c\/code\x3e，则array结束，弹出栈，如果不是，则将自身状态修改为\x3ccode\x3estateArrayEndOrComma\x3c\/code\x3e，并压入一个新栈结点，将其状态设置为\x3ccode\x3estateNone\x3c\/code\x3e，重新开始解析，此结点解析完成之后，弹出此结点，判定是\x3ccode\x3e,\x3c\/code\x3e还是\x3ccode\x3e]\x3c\/code\x3e，如果是\x3ccode\x3e]\x3c\/code\x3e，则结束弹出，如果是\x3ccode\x3e,\x3c\/code\x3e则不改变自身状态，并重新一个新栈结点，开始新的循环。完事的状态机如下：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010331726\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010331726\x22 alt=\x22state.png\x22 title=\x22state.png\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e其含义如下：\x3c\/p\x3e\n\x3cp\x3e首先初始化一个空节点，状态设置为\x3ccode\x3estateNone\x3c\/code\x3e，然后判断第一个非空字符，如果是\x3ccode\x3et\/f\/n\/[-0-9]\x3c\/code\x3e，则直接解析字面量，然后弹出，如果是\x3ccode\x3e[\x3c\/code\x3e，则将状态设置为\x3ccode\x3estateArrayValueOrEnd\x3c\/code\x3e，然后判定第一个字符，如果是\x3ccode\x3e]\x3c\/code\x3e，则结束弹出，否则压入新栈，并将自身状态设置为\x3ccode\x3estateArrayEndOrComma\x3c\/code\x3e，开始新的循环，如果是\x3ccode\x3e{\x3c\/code\x3e，则将状态设置为\x3ccode\x3estateObjectKeyOrEnd\x3c\/code\x3e，如果下一个非空字符为\x3ccode\x3e}\x3c\/code\x3e，则结束弹出，否则解析\x3ccode\x3ekey\x3c\/code\x3e，完成之后，压入新栈，并将自身状态设置为\x3ccode\x3estateObjectEndOrComma\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e比较特殊的是\x3ccode\x3estateString\x3c\/code\x3e，按道理其也是一个字面量，不需要到一个新的循环里面去解析。但是因为一个\x3ccode\x3eobject\x3c\/code\x3e的\x3ccode\x3ekey\x3c\/code\x3e也是一个\x3ccode\x3estring\x3c\/code\x3e，为了复用代码，并避免调用函数产生的性能开销，将\x3ccode\x3estring\x3c\/code\x3e类型和object的\x3ccode\x3ekey\x3c\/code\x3e当作同一类型来处理，具体如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22root := \x26amp;state{\x26amp;Value{nil}, stateNone, nil}\ncurr := root\nfor {\n  \/\/ ignore whitespace\n  \/\/ check curr is nil or not\n  switch curr.state {\n    case stateNone:\n      switch data[offset] {\n        case \x27\x26quot;\x27:\n          \/\/ go to new loop\n          curr.state = stateString\n          continue\n      }\n    case stateObjectKey, stateString:\n      \/\/ parse string\n      if curr.state == stateObjectKey {\n        \/\/ create new stack node\n      } else {\n        \/\/ pop stack\n      }\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs go\x22\x3e\x3ccode\x3eroot := \x26amp;state{\x26amp;Value{\x3cspan class=\x22hljs-literal\x22\x3enil\x3c\/span\x3e}, stateNone, \x3cspan class=\x22hljs-literal\x22\x3enil\x3c\/span\x3e}\ncurr := root\n\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ignore whitespace\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ check curr is nil or not\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eswitch\x3c\/span\x3e curr.state {\n    \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e stateNone:\n      \x3cspan class=\x22hljs-keyword\x22\x3eswitch\x3c\/span\x3e data[offset] {\n        \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27\x22\x27\x3c\/span\x3e:\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ go to new loop\x3c\/span\x3e\n          curr.state = stateString\n          \x3cspan class=\x22hljs-keyword\x22\x3econtinue\x3c\/span\x3e\n      }\n    \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e stateObjectKey, stateString:\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ parse string\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e curr.state == stateObjectKey {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ create new stack node\x3c\/span\x3e\n      } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ pop stack\x3c\/span\x3e\n      }\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e此外比较特殊的是在解析完一个object的key之后，立即压入了一个新栈结点，并将其状态设置为\x3ccode\x3estateObjectColon\x3c\/code\x3e，同时将自身的状态设置为\x3ccode\x3estateObjectEndOrComma\x3c\/code\x3e，在解析完colon之后再这个节点的状态设置为\x3ccode\x3estateNone\x3c\/code\x3e，开始新的循环，具体来说：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22if curr.state == stateObjectKey {\n  curr.state = stateObjectEndOrComma\n  curr = \x26amp;state{\x26amp;Value{nil}, stateObjectColon, nil}\n  continue\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22go hljs\x22\x3e\x3ccode class=\x22go\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e curr.state == stateObjectKey {\n  curr.state = stateObjectEndOrComma\n  curr = \x26amp;state{\x26amp;Value{\x3cspan class=\x22hljs-literal\x22\x3enil\x3c\/span\x3e}, stateObjectColon, \x3cspan class=\x22hljs-literal\x22\x3enil\x3c\/span\x3e}\n  \x3cspan class=\x22hljs-keyword\x22\x3econtinue\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这是因为在\x3ccode\x3e:\x3c\/code\x3e之前和之后都可能有空白字符，这里是为了复用代码逻辑：即在每一次迭代开始之时都把所有的空白过滤掉。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22for {\n  LOOP_WS:\n  for ; offset \x3c len(data); offset\x2b\x2b {\n    switch data[offset] {\n    case \x27\\t\x27, \x27\\r\x27, \x27\\n\x27, \x27 \x27:\n      continue\n    default:\n      break LOOP_WS\n  }\n  \/\/ do staff\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22go hljs\x22\x3e\x3ccode class=\x22go\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e {\n  LOOP_WS:\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e ; offset \x26lt; \x3cspan class=\x22hljs-built_in\x22\x3elen\x3c\/span\x3e(data); offset\x2b\x2b {\n    \x3cspan class=\x22hljs-keyword\x22\x3eswitch\x3c\/span\x3e data[offset] {\n    \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27\\t\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27\\r\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27\\n\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27 \x27\x3c\/span\x3e:\n      \x3cspan class=\x22hljs-keyword\x22\x3econtinue\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e:\n      \x3cspan class=\x22hljs-keyword\x22\x3ebreak\x3c\/span\x3e LOOP_WS\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ do staff\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在过滤掉空白后，如果当前栈为\x3ccode\x3enil\x3c\/code\x3e，则不应该有字符存在，整个解析结束，否则一定有字符，并且需要进行解析：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22for {\n  \/\/ ignore whitespace\n  if curr == nil {\n    if offset == len(data) {\n      return\n    } else {\n      \/\/ unexpected char data[offset] at offset\n    }\n  } else if offset == len(data) {\n    \/\/ unexpected EOF at offset\n  }\n  \/\/ do staff\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22go hljs\x22\x3e\x3ccode class=\x22go\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ignore whitespace\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e curr == \x3cspan class=\x22hljs-literal\x22\x3enil\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e offset == \x3cspan class=\x22hljs-built_in\x22\x3elen\x3c\/span\x3e(data) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ unexpected char data[offset] at offset\x3c\/span\x3e\n    }\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e offset == \x3cspan class=\x22hljs-built_in\x22\x3elen\x3c\/span\x3e(data) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ unexpected EOF at offset\x3c\/span\x3e\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ do staff\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e随后便是根据当前状态来进行相应的解析了。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e后记\x3c\/h2\x3e\n\x3cp\x3e从目前的开源项目上来看，性能上应该还有优化的空间，毕竟有人已经做到号称\x3ccode\x3e2-4x\x3c\/code\x3e的速度，而且现在已经有很多项目在搞将Golang的Struct先编译一遍，再调用生成的函数针对特定的结构进行解析，速度更快，不过既然就预先编译了，干嘛还要用JSON啊，直接PB\/MsgPack得了。特别是\x3ccode\x3edjson\x3c\/code\x3e这个库，解析小JSON的时候速度是原生的3-4倍，但是大的时候只有2倍，而\x3ccode\x3echeapjson\x3c\/code\x3e则在解析大JSON的时候性能几乎是原生的7倍，相当搞笑。而从测试结果上来看，整体上性能和内存都还可以，但是在解析数组的时候比原生的还要差。所以值得改进，尤其是频繁的创建和销毁\x3ccode\x3estate\x3c\/code\x3e节点这一点，还有数组的动态扩容等。\x3c\/p\x3e\n\x3cp\x3e以后有空再慢慢搞吧，我不想白头发越来越多了。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>造轮子系列(一): 一个速度九分快的JSON解析器</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000010331737">https://segmentfault.com/a/1190000010331737</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/4qhdoesmclk/" target="_blank">https://alili.tech/archive/4qhdoesmclk/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>