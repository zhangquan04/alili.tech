<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="使用 Proxy 实现简单的 MVVM 模型"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>使用 Proxy 实现简单的 MVVM 模型 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/intcmuqtk4/",
				"appid": "1613049289050283", 
				"title": "使用 Proxy 实现简单的 MVVM 模型 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-06T02:30:10"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/qnkq2h1jixj/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/li2jyk2fwbc/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fintcmuqtk4%2f&text=%e4%bd%bf%e7%94%a8%20Proxy%20%e5%ae%9e%e7%8e%b0%e7%ae%80%e5%8d%95%e7%9a%84%20MVVM%20%e6%a8%a1%e5%9e%8b"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fintcmuqtk4%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fintcmuqtk4%2f&text=%e4%bd%bf%e7%94%a8%20Proxy%20%e5%ae%9e%e7%8e%b0%e7%ae%80%e5%8d%95%e7%9a%84%20MVVM%20%e6%a8%a1%e5%9e%8b"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fintcmuqtk4%2f&title=%e4%bd%bf%e7%94%a8%20Proxy%20%e5%ae%9e%e7%8e%b0%e7%ae%80%e5%8d%95%e7%9a%84%20MVVM%20%e6%a8%a1%e5%9e%8b"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fintcmuqtk4%2f&is_video=false&description=%e4%bd%bf%e7%94%a8%20Proxy%20%e5%ae%9e%e7%8e%b0%e7%ae%80%e5%8d%95%e7%9a%84%20MVVM%20%e6%a8%a1%e5%9e%8b"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e4%bd%bf%e7%94%a8%20Proxy%20%e5%ae%9e%e7%8e%b0%e7%ae%80%e5%8d%95%e7%9a%84%20MVVM%20%e6%a8%a1%e5%9e%8b&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fintcmuqtk4%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fintcmuqtk4%2f&title=%e4%bd%bf%e7%94%a8%20Proxy%20%e5%ae%9e%e7%8e%b0%e7%ae%80%e5%8d%95%e7%9a%84%20MVVM%20%e6%a8%a1%e5%9e%8b"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fintcmuqtk4%2f&title=%e4%bd%bf%e7%94%a8%20Proxy%20%e5%ae%9e%e7%8e%b0%e7%ae%80%e5%8d%95%e7%9a%84%20MVVM%20%e6%a8%a1%e5%9e%8b"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fintcmuqtk4%2f&title=%e4%bd%bf%e7%94%a8%20Proxy%20%e5%ae%9e%e7%8e%b0%e7%ae%80%e5%8d%95%e7%9a%84%20MVVM%20%e6%a8%a1%e5%9e%8b"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fintcmuqtk4%2f&title=%e4%bd%bf%e7%94%a8%20Proxy%20%e5%ae%9e%e7%8e%b0%e7%ae%80%e5%8d%95%e7%9a%84%20MVVM%20%e6%a8%a1%e5%9e%8b"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">使用 Proxy 实现简单的 MVVM 模型</h1><div class="meta"><div class="postdate"><time datetime="2019-01-06" itemprop="datePublished">2019-01-06</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch2 id=\x22articleHeader0\x22\x3e绑定实现的历史\x3c\/h2\x3e\n\x3cp\x3e绑定的基础是 \x3ccode\x3epropertyChange\x3c\/code\x3e 事件。如何得知 \x3ccode\x3eviewModel\x3c\/code\x3e 成员值的改变一直是开发 \x3ccode\x3eMVVM\x3c\/code\x3e 框架的首要问题。主流框架的处理有一下三大类：\x3c\/p\x3e\n\x3col\x3e\x3cli\x3e另外开发一套 API。典型框架：Backbone.js\x3c\/li\x3e\x3c\/ol\x3e\n\x3cp\x3eBackbone 有自己的 \x3ca href=\x22http:\/\/www.css88.com\/doc\/backbone\/#Model\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e模型类\x3c\/a\x3e 和 \x3ca href=\x22http:\/\/www.css88.com\/doc\/backbone\/#Collection\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e集合类\x3c\/a\x3e。这样做虽然框架开发简单运行效率也高，但开发者不得不使用这套 API 操作 viewModel，导致上手复杂、代码繁琐。\x3c\/p\x3e\n\x3col\x3e\x3cli\x3e脏检查机制。典型框架：angularjs\x3c\/li\x3e\x3c\/ol\x3e\n\x3cp\x3e特点是直接使用 JS 原生操作对象的语法操作 viewModel，开发者上手简单、代码简单。但脏检查机制随之带来的就是性能问题。这点在我另外的一篇博文 《\x3ca href=\x22https:\/\/my.oschina.net\/u\/724721\/blog\/912190\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eAngular 1 深度解析：脏数据检查与 angular 性能优化\x3c\/a\x3e》 有详细讲解这里不另加赘述。\x3c\/p\x3e\n\x3col\x3e\x3cli\x3e替换属性。典型框架：vuejs\x3cbr\x3evuejs 把开发者定义的 viewModel 对象（即 data 函数返回的对象）中所有的（除某些前缀开头的）成员替换为属性。这样既可以使用 JS 原生操作对象的语法，又是主动触发 \x3ccode\x3epropertyChange\x3c\/code\x3e 事件，效率也高。但这种方法也有一些限制，后文会分析。\x3c\/li\x3e\x3c\/ol\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e\x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/JavaScript\/Reference\/Global_Objects\/Object\/observe\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eObject.observe\x3c\/a\x3e\x3c\/h2\x3e\n\x3cp\x3eObject.observe 是谷歌对于简化双向绑定机制的尝试，在 Chrome 49 中引入。然而由于性能等问题，并没有被其他各大浏览器及 ES 标准所接受。挣扎了一段时间后谷歌 Chrome 团队宣布收回 Object.observe 的提议，并在 Chrome 50 中完全删除了 Object.observe 实现。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e\x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/JavaScript\/Reference\/Global_Objects\/Proxy\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eProxy\x3c\/a\x3e\x3c\/h2\x3e\n\x3cp\x3eProxy（代理）是 ES2015 加入的新特性，用于对某些基本操作定义自定义行为，类似于其他语言中的面向切面编程。它的其中一个作用就是用于（部分）替代 Object.observe 以实现双向绑定。\x3c\/p\x3e\n\x3cp\x3e例如有一个对象\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let viewModel = {};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e viewModel = {};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可以构造对应的代理类实现对 viewModel 的属性赋值操作的监听：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22viewModel = new Proxy(viewModel, {\n  set(obj, prop, value) {\n    if (obj[prop] !== value) {\n      obj[prop] = value;\n      console.log(`${prop} 属性被改为 ${value}`);\n    }\n    return true;\n  }\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3eviewModel = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eProxy\x3c\/span\x3e(viewModel, {\n  set(obj, prop, value) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (obj[prop] !== value) {\n      obj[prop] = value;\n      \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e`\x3cspan class=\x22hljs-subst\x22\x3e${prop}\x3c\/span\x3e 属性被改为 \x3cspan class=\x22hljs-subst\x22\x3e${value}\x3c\/span\x3e`\x3c\/span\x3e);\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n  }\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这时所有对 viewModel 的属性赋值的操作都不会直接生效，而是将这个操作转发给 \x3ccode\x3eProxy\x3c\/code\x3e 中注册的 \x3ccode\x3eset\x3c\/code\x3e 方法，其中的参数 \x3ccode\x3eobj\x3c\/code\x3e 是原始对象（注意不能直接用 a，否则还会触发代理函数，造成无限递归），\x3ccode\x3eprop\x3c\/code\x3e 是被赋值的属性名，\x3ccode\x3evalue\x3c\/code\x3e 是待赋的值。\x3cbr\x3e如果有：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22viewModel.test = 1;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3eviewModel.test = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这时就会输出 \x3ccode\x3etest 属性被改为 1\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e用 Proxy 实现简单的单向绑定。\x3c\/h2\x3e\n\x3cp\x3e有了 \x3ccode\x3eProxy\x3c\/code\x3e 就可以得知 \x3ccode\x3eviewModel\x3c\/code\x3e 中属性的变更了，还需要更新页面上绑定此属性的元素。\x3c\/p\x3e\n\x3cp\x3e简单起见，我们用 \x3ccode\x3ethis\x3c\/code\x3e 表示 \x3ccode\x3eviewModel\x3c\/code\x3e 本身，使用 \x3ccode\x3ethis.XXX\x3c\/code\x3e 就表示依赖 \x3ccode\x3eXXX\x3c\/code\x3e 属性。有 DOM 如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  \x3cdiv my-bind=\x26quot;\x27str1 \x2b str2 = \x27 \x2b (this.str1 \x2b this.str2)\x26quot;\x3e\x3c\/div\x3e\n  \x3cdiv my-bind=\x26quot;\x27num1 - num2 = \x27 \x2b (this.num1 - this.num2)\x26quot;\x3e\x3c\/div\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22xml hljs\x22\x3e\x3ccode class=\x22html\x22\x3e  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3emy-bind\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22\x27str1 \x2b str2 = \x27 \x2b (this.str1 \x2b this.str2)\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3emy-bind\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22\x27num1 - num2 = \x27 \x2b (this.num1 - this.num2)\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e首先要获得所有使用了单向绑定的元素：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const bindingElements = [...document.querySelectorAll(\x27[my-bind]\x27)];\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e bindingElements = [...document.querySelectorAll(\x3cspan class=\x22hljs-string\x22\x3e\x27[my-bind]\x27\x3c\/span\x3e)];\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e获取绑定表达式：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22bindingElements.forEach(el =\x3e {\n  const expression = el.getAttribute(\x27my-bind\x27);\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3ebindingElements.forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eel\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e expression = el.getAttribute(\x3cspan class=\x22hljs-string\x22\x3e\x27my-bind\x27\x3c\/span\x3e);\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e由于获得的表达式是个字符串，需要构造一个函数去执行它，得到表达式的结果：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const expression = el.getAttribute(\x27my-bind\x27);\nconst result = new Function(\x27\x26quot;use strict\x26quot;;\\nreturn \x27 \x2b expression).call(viewModel);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e expression = el.getAttribute(\x3cspan class=\x22hljs-string\x22\x3e\x27my-bind\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e result = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eFunction\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27\x22use strict\x22;\\nreturn \x27\x3c\/span\x3e \x2b expression).call(viewModel);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e代码中会动态创建一个函数，内容就是将字符串解析执行后将其结果返回（类似 eval，但更安全）。将结果放到页面上就可以了：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22el.textContent = result;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3eel.textContent = result;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e与上文的 \x3ccode\x3eviewModel\x3c\/code\x3e 结合起来：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const bindingElements = [...document.querySelectorAll(\x27[my-bind]\x27)];\n\nwindow.viewModel = new Proxy({}, { \/\/ 设置全局变量方便调试\n  set(obj, prop, value) {\n    if (obj[prop] !== value) {\n      obj[prop] = value;\n\n      bindingElements.forEach(el =\x3e {\n        const expression = el.getAttribute(\x27my-bind\x27);\n        const result = new Function(\x27\x26quot;use strict\x26quot;;\\nreturn \x27 \x2b expression)\n          .call(obj);\n        el.textContent = result;\n      });\n    }\n    return true;\n  }\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e bindingElements = [...document.querySelectorAll(\x3cspan class=\x22hljs-string\x22\x3e\x27[my-bind]\x27\x3c\/span\x3e)];\n\n\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.viewModel = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eProxy\x3c\/span\x3e({}, { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 设置全局变量方便调试\x3c\/span\x3e\n  set(obj, prop, value) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (obj[prop] !== value) {\n      obj[prop] = value;\n\n      bindingElements.forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eel\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e expression = el.getAttribute(\x3cspan class=\x22hljs-string\x22\x3e\x27my-bind\x27\x3c\/span\x3e);\n        \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e result = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eFunction\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27\x22use strict\x22;\\nreturn \x27\x3c\/span\x3e \x2b expression)\n          .call(obj);\n        el.textContent = result;\n      });\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n  }\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果实际放在浏览器中运行的话，改变 \x3ccode\x3eviewModel\x3c\/code\x3e 中属性的值就会触发页面的更新。\x3c\/p\x3e\n\x3cp\x3e示例中写了循环会更新所有绑定元素，比较好的方式是只更新对当前变更属性有依赖的元素。这时就要分析绑定表达式的属性依赖。\x3cbr\x3e简单起见可以使用正则表达式解析属性依赖：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let match;\nwhile (match = \/this(?:\\.(\\w\x2b))\x2b\/g.exec(expression)) {\n  match[1] \/\/ 属性依赖\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e match;\n\x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (match = \x3cspan class=\x22hljs-regexp\x22\x3e\/this(?:\\.(\\w\x2b))\x2b\/g\x3c\/span\x3e.exec(expression)) {\n  match[\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e] \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 属性依赖\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e添加事件绑定\x3c\/h2\x3e\n\x3cp\x3e事件绑定即绑定原生事件，在事件触发时执行绑定表达式，表达式调用 \x3ccode\x3eviewModel\x3c\/code\x3e 中的某个回调函数。\x3c\/p\x3e\n\x3cp\x3e以 \x3ccode\x3eclick\x3c\/code\x3e 事件为例。依然是获取所有绑定了 \x3ccode\x3eclick\x3c\/code\x3e 事件的元素，并执行表达式（表达式的值被丢弃）。与单项绑定不同的是：执行表达式需要传入事件的 event 参数。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22[...document.querySelectorAll(\x27[my-click]\x27)].forEach(el =\x3e {\n  const expression = el.getAttribute(\x27my-click\x27);\n  const fn = new Function(\x27$event\x27, \x27\x26quot;use strict\x26quot;;\\n\x27 \x2b expression);\n  el.addEventListener(\x27click\x27, event =\x3e {\n    fn.call(viewModel, event);\n  });\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e[...document.querySelectorAll(\x3cspan class=\x22hljs-string\x22\x3e\x27[my-click]\x27\x3c\/span\x3e)].forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eel\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e expression = el.getAttribute(\x3cspan class=\x22hljs-string\x22\x3e\x27my-click\x27\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e fn = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eFunction\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27$event\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27\x22use strict\x22;\\n\x27\x3c\/span\x3e \x2b expression);\n  el.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27click\x27\x3c\/span\x3e, event =\x26gt; {\n    fn.call(viewModel, event);\n  });\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3eFunction\x3c\/code\x3e 对象的构造函数，前 n-1 个参数是生成的函数对象的参数名，最后一个是函数体。代码中构造了包含一个 \x3ccode\x3e$event\x3c\/code\x3e 参数的函数，函数体就是直接执行绑定表达式。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e双向绑定\x3c\/h2\x3e\n\x3cp\x3e双向绑定就是单项绑定和事件绑定的结合体。绑定元素的 \x3ccode\x3einput\x3c\/code\x3e 事件来修改 \x3ccode\x3eviewModel\x3c\/code\x3e 的属性，然后再单项绑定元素的 \x3ccode\x3evalue\x3c\/code\x3e 属性修改元素的值。\x3c\/p\x3e\n\x3cp\x3e这里是一个较为完整的示例：\x3ca href=\x22http:\/\/sandbox.runjs.cn\/show\/7wqpuofo\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/sandbox.runjs.cn\/show\/...\x3c\/a\x3e。完整的代码放在我的 \x3ca href=\x22https:\/\/github.com\/CarterLi\/TestMvvm\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eGitHub\x3c\/a\x3e 仓库\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3e使用 Proxy 实现双向绑定的优缺点\x3c\/h2\x3e\n\x3cp\x3e相较于 vuejs 的属性替换，Proxy 实现的绑定至少有如下三个优点：\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e无需预先定义待绑定的属性。\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3evuejs 要做属性（getter, setter 方法）替换，首先需要知道有哪些属性需要替换，这样导致必须预先定义需要替换的属性，也就是 vuejs 中的 data 方法。vuejs 中 data 方法必须定义完整所有绑定属性，否则对应绑定不能正常工作。  \x3cbr\x3e\x3ca href=\x22https:\/\/cn.vuejs.org\/v2\/guide\/reactivity.html#\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eVue 不能检测到对象属性的添加或删除\x3c\/a\x3e：\x3ccode\x3eProperty or method \x22XXX\x22 is not defined on the instance but referenced during render. Make sure to declare reactive data properties in the data option.\x3c\/code\x3e\x3cbr\x3e而 \x3ccode\x3eProxy\x3c\/code\x3e 不需要，因为它监听的是整个对象。\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e对数组相性良好。\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e虽说数组里的方法可以替换（push、pop等），\x3ca href=\x22https:\/\/cn.vuejs.org\/v2\/guide\/list.html#\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e但是数组下标却不能替换为属性，以致必须搞出一个 set 方法用于对数组下标赋值\x3c\/a\x3e。\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e更容易调试的 viewModel 对象。\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e由于 vuejs 把对象中的所有成员全部替换成了属性，如果想直接用 Chrome 的原生调试工具查看属性值，你不得不挨个去点属性后面的 \x3ccode\x3e(...)\x3c\/code\x3e：因为获取属性的值其实是执行了属性的 \x3ccode\x3eget\x3c\/code\x3e 方法，执行一个方法可能会产生副作用，Chrome 把这个决定权留给开发者。  \x3cbr\x3e\x3ccode\x3eProxy\x3c\/code\x3e 对象不需要。\x3ccode\x3eProxy\x3c\/code\x3e 的 \x3ccode\x3eset\x3c\/code\x3e 方法只是一层包装，\x3ccode\x3eProxy\x3c\/code\x3e 对象自身维护原始对象的值，自然也可以直接拿出原始值给开发者看。查看一个 \x3ccode\x3eProxy\x3c\/code\x3e 对象，只需要展开其内置属性 \x3ccode\x3e[[Target]]\x3c\/code\x3e 即可看到原始对象的所有成员的值。你甚至还可以看到包装原始对象的哪些 \x3ccode\x3eget\x3c\/code\x3e、\x3ccode\x3eset\x3c\/code\x3e 函数——如果你感兴趣的话。\x3c\/p\x3e\n\x3cp\x3e虽说使用 \x3ccode\x3eProxy\x3c\/code\x3e 实现双向绑定的优点很明显，但是缺点也很明显：\x3ccode\x3eProxy\x3c\/code\x3e 是 \x3ccode\x3eES2015\x3c\/code\x3e 的特性，它\x3cstrong\x3e无法被编译为 ES5，也无法 Polyfill\x3c\/strong\x3e。IE 自然全军覆没；其他各大浏览器实现的时间也较晚：Chrome 49、Safari 10。浏览器兼容性极大的限制了 \x3ccode\x3eProxy\x3c\/code\x3e 的使用。但是我相信，随着时间的推移，基于 \x3ccode\x3eProxy\x3c\/code\x3e 的前端 \x3ccode\x3eMVVM\x3c\/code\x3e 框架也会出现在开发者眼前。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>使用 Proxy 实现简单的 MVVM 模型</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000010433537">https://segmentfault.com/a/1190000010433537</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/intcmuqtk4/" target="_blank">https://alili.tech/archive/intcmuqtk4/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>