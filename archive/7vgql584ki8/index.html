<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="虚拟DOM内部是如何工作的"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>虚拟DOM内部是如何工作的 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/7vgql584ki8/",
				"appid": "1613049289050283", 
				"title": "虚拟DOM内部是如何工作的 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-09T02:30:11"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/ooeky4znhld/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/nrj6dt1s5e/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f7vgql584ki8%2f&text=%e8%99%9a%e6%8b%9fDOM%e5%86%85%e9%83%a8%e6%98%af%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c%e7%9a%84"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f7vgql584ki8%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f7vgql584ki8%2f&text=%e8%99%9a%e6%8b%9fDOM%e5%86%85%e9%83%a8%e6%98%af%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c%e7%9a%84"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f7vgql584ki8%2f&title=%e8%99%9a%e6%8b%9fDOM%e5%86%85%e9%83%a8%e6%98%af%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c%e7%9a%84"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f7vgql584ki8%2f&is_video=false&description=%e8%99%9a%e6%8b%9fDOM%e5%86%85%e9%83%a8%e6%98%af%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c%e7%9a%84"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e8%99%9a%e6%8b%9fDOM%e5%86%85%e9%83%a8%e6%98%af%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c%e7%9a%84&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f7vgql584ki8%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f7vgql584ki8%2f&title=%e8%99%9a%e6%8b%9fDOM%e5%86%85%e9%83%a8%e6%98%af%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c%e7%9a%84"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f7vgql584ki8%2f&title=%e8%99%9a%e6%8b%9fDOM%e5%86%85%e9%83%a8%e6%98%af%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c%e7%9a%84"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f7vgql584ki8%2f&title=%e8%99%9a%e6%8b%9fDOM%e5%86%85%e9%83%a8%e6%98%af%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c%e7%9a%84"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f7vgql584ki8%2f&title=%e8%99%9a%e6%8b%9fDOM%e5%86%85%e9%83%a8%e6%98%af%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c%e7%9a%84"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">虚拟DOM内部是如何工作的</h1><div class="meta"><div class="postdate"><time datetime="2019-01-09" itemprop="datePublished">2019-01-09</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e\x3ca href=\x22https:\/\/medium.com\/@rajaraodv\/the-inner-workings-of-virtual-dom-666ee7ad47cf\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e英文原文链接\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3eVirtual DOM很神奇，同时也比较复杂，难以理解。react,preact和相似的js库都使用了virtual dom。然而，我找不到任何好的文章或者文档，可以详细地又容易理解的方式来解释它。因此我决定自己写一篇。\x3c\/p\x3e\n\x3cp\x3e注意：文章篇幅较长，文中有大量的图片来帮助理解。文中使用的是preact的代码，因为它体积小，容易阅读。但是它与React里大部分的概率是保持一致的。希望阅读完这篇文章后，你可以更好地理解React和Preact这样的类库，甚至为它们作出贡献。\x3c\/p\x3e\n\x3cp\x3e在这篇文章中，我将列举一个简单的例子来解释以下这些是如何工作的：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3eBabel和JSX\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e创建VNode-一个简单的virtual DOM元素\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e处理组件和子组件\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e初始化渲染和创建一个DOM元素\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e重新渲染\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e移除DOM元素\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e替换DOM元素\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3eThe app\x3c\/h2\x3e\n\x3cp\x3e这是一个简单地可筛选的搜索应用，它包含了两个组件\x3ccode\x3eFilteredList\x3c\/code\x3e和\x3ccode\x3eList\x3c\/code\x3e。\x3ccode\x3eList\x3c\/code\x3e组件用来渲染一组items(默认：\x22California\x22和\x22New York\x22)。这个应用有一个搜索框，可以根据字母来过滤列表项。非常地直观：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010157282\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010157282\x22 alt=\x22img\x22 title=\x22img\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e概览图\x3c\/h2\x3e\n\x3cp\x3e我们用jsx来写组件，它会被babel转换成纯js，然后Preact的\x3ccode\x3eh\x3c\/code\x3e函数会将这段js转换成DOM树，最后Preact的Virtual DOM算法会将virtual DOM转换成真实的DOM树，来构建我们的应用。\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010157283\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010157283\x22 alt=\x22img\x22 title=\x22img\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e在深入Virtual DOM的生命周期之前，我们先理解一下jsx，因为它为库提供了入口。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3eBabel And JSX\x3c\/h2\x3e\n\x3cp\x3e在React，Preact这样的类库中，没有HTML标签，取而代之的是，一切都是javascript。所以我们要在js中写HTML标签，但是在js中写HTML简直就是噩梦?\x3c\/p\x3e\n\x3cp\x3e对于我们的应用来说，我们将会像下面这样来写HTML\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010157284\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010157284\x22 alt=\x22img\x22 title=\x22img\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010157285\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010157285\x22 alt=\x22img\x22 title=\x22img\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e这就是jsx的由来。jsx本质上就是允许我们在javascript中书写HTML!并且允许我们在HTML中通过使用花括号来使用js。\x3cbr\x3ejsx帮助我们像下面这样写组件\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010157286\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010157286\x22 alt=\x22img\x22 title=\x22img\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010157287\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010157287\x22 alt=\x22img\x22 title=\x22img\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3ejsx转换成js\x3c\/h3\x3e\n\x3cp\x3ejsx很酷，但它不是合法的js，并且最终我们需要的是真实的DOM。JSX只是帮助编写一个真实DOM的替代品，除此之外，它别无用处。所以我们需要一种方法将它转换成对应的JSON对象(也就是Virtual DOM)，作为转化成真实DOM的输入。我们需要一个函数来实现这个功能。\x3c\/p\x3e\n\x3cp\x3e在Preact中\x3ccode\x3eh\x3c\/code\x3e函数就是干这件事情的，等同于React中的\x3ccode\x3eReact.createElement\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e但是如何将jsx转换成\x3ccode\x3eh\x3c\/code\x3e函数的调用呢？Babel就是干这件事情的。Babel遍历每个jsx节点，并将它们转换成\x3ccode\x3eh\x3c\/code\x3e函数调用。\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010157288\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010157288\x22 alt=\x22img\x22 title=\x22img\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3eBabel JSX(React vs Preact)\x3c\/h3\x3e\n\x3cp\x3e默认情况下，Babel将jsx转换成React.createElement调用\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010157289\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010157289\x22 alt=\x22img\x22 title=\x22img\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3cbr\x3e但是我们可以很容易地将函数名修改成任何名称，只需要在babelrc中配置一下即可\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Option 1:\n\/\/.babelrc\n{   \x26quot;plugins\x26quot;: [\n      [\x26quot;transform-react-jsx\x26quot;, { \x26quot;pragma\x26quot;: \x26quot;h\x26quot; }]\n     ]\n}\nOption 2:\n\/\/Add the below comment as the 1st line in every JSX file\n\/** @jsx h *\/\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs rust\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-built_in\x22\x3eOption\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e:\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/.babelrc\x3c\/span\x3e\n{   \x3cspan class=\x22hljs-string\x22\x3e\x22plugins\x22\x3c\/span\x3e: [\n      [\x3cspan class=\x22hljs-string\x22\x3e\x22transform-react-jsx\x22\x3c\/span\x3e, { \x3cspan class=\x22hljs-string\x22\x3e\x22pragma\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22h\x22\x3c\/span\x3e }]\n     ]\n}\n\x3cspan class=\x22hljs-built_in\x22\x3eOption\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e:\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/Add the below comment as the 1st line in every JSX file\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/** @jsx h *\/\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010157290\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010157290\x22 alt=\x22img\x22 title=\x22img\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e挂载到真实DOM\x3c\/h3\x3e\n\x3cp\x3e不仅仅是render中的代码会被转换成\x3ccode\x3eh\x3c\/code\x3e函数，最初的挂载也会！\x3c\/p\x3e\n\x3cp\x3e这就是代码执行开始的地方\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/Mount to real DOM\nrender(\x3cFilteredList\/\x3e, document.getElementById(‘app’));\n\/\/Converted to \x26quot;h\x26quot;:\nrender(h(FilteredList), document.getElementById(‘app’));\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/Mount to real DOM\x3c\/span\x3e\nrender(\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eFilteredList\x3c\/span\x3e\/\x26gt;\x3c\/span\x3e\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.getElementById(‘app’));\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/Converted to \x22h\x22:\x3c\/span\x3e\nrender(h(FilteredList), \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.getElementById(‘app’));\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e\n\x3ccode\x3eh\x3c\/code\x3e函数的输出\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3eh\x3c\/code\x3e函数将jsx转化后的内容转换成Virtual DOM节点。一个Preact的Virtual DOM节点就是一个简单的代表了单个包含属性和子节点的DOM节点的js对象，如下所示：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n   \x26quot;nodeName\x26quot;: \x26quot;\x26quot;,\n   \x26quot;attributes\x26quot;: {},\n   \x26quot;children\x26quot;: []\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs json\x22\x3e\x3ccode\x3e{\n   \x3cspan class=\x22hljs-attr\x22\x3e\x22nodeName\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22\x22\x3c\/span\x3e,\n   \x3cspan class=\x22hljs-attr\x22\x3e\x22attributes\x22\x3c\/span\x3e: {},\n   \x3cspan class=\x22hljs-attr\x22\x3e\x22children\x22\x3c\/span\x3e: []\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e比如，应用的input标签对应的Virtual DOM如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n   \x26quot;nodeName\x26quot;: \x26quot;input\x26quot;,\n   \x26quot;attributes\x26quot;: {\n    \x26quot;type\x26quot;: \x26quot;text\x26quot;,\n    \x26quot;placeholder\x26quot;: \x26quot;Search\x26quot;,\n    \x26quot;onChange\x26quot;: \x26quot;\x26quot;\n   },\n   \x26quot;children\x26quot;: []\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs json\x22\x3e\x3ccode\x3e{\n   \x3cspan class=\x22hljs-attr\x22\x3e\x22nodeName\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22input\x22\x3c\/span\x3e,\n   \x3cspan class=\x22hljs-attr\x22\x3e\x22attributes\x22\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-attr\x22\x3e\x22type\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22text\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3e\x22placeholder\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22Search\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3e\x22onChange\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22\x22\x3c\/span\x3e\n   },\n   \x3cspan class=\x22hljs-attr\x22\x3e\x22children\x22\x3c\/span\x3e: []\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e注意：\x3cstrong\x3e\x3ccode\x3eh\x3c\/code\x3e函数并不是创建整棵树！\x3c\/strong\x3e它只是简单地创建某个节点的js对象。但是因为\x3ccode\x3erender\x3c\/code\x3e方法。。。\x3c\/p\x3e\n\x3cp\x3e好了，让我们看看Virtual DOM是如何工作的。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3ePreact中的Virtual DOM算法\x3c\/h2\x3e\n\x3cp\x3e在下面的流程图中，展示了在Preact中，组件是如何被创建、更新和删除的过程。同时也展示了像\x3ccode\x3ecomponentWillMount\x3c\/code\x3e这样的生命周期事件是什么时候被调用的。\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010157291\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010157291\x22 alt=\x22img\x22 title=\x22img\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e现在理解起来有些困难，所以我们一步一步来拆解流程图中的每种情况。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e情景1：初始化app\x3c\/h3\x3e\n\x3ch4\x3e1.1 创建Virtual DOM\x3c\/h4\x3e\n\x3cp\x3e高亮的部分展示了根据给定的组件生成的Virtual DOM树。注意一点这里并没有为子组件创建Virtual DOM\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010157292\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010157292\x22 alt=\x22img\x22 title=\x22img\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3cbr\x3e下面这幅图展示了应用首次加载时发生的情况。这个库最后为FilteredList组件创建了带有子节点和属性\x3cbr\x3e的Virtual DOM\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010157293\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010157293\x22 alt=\x22img\x22 title=\x22img\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3cbr\x3e注意：在这个过程中还调用了\x3ccode\x3ecomponentWillMount\x3c\/code\x3e和\x3ccode\x3erender\x3c\/code\x3e生命周期方法(在上图中的绿色区块)\x3c\/p\x3e\n\x3cp\x3e此时，我们有了一个Virtual DOM，div元素是父亲节点，带有一个input和一个list的子节点\x3c\/p\x3e\n\x3ch4\x3e1.2 如果不是一个组件，则创建真实的DOM\x3c\/h4\x3e\n\x3cp\x3e在这一步中，它只是为父亲节点创建一个真实DOM，对于子节点，重复这个过程\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010157294\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010157294\x22 alt=\x22img\x22 title=\x22img\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3cbr\x3e此时，我们在下图中只有一个div展示出来\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010157295\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010157295\x22 alt=\x22img\x22 title=\x22img\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch4\x3e1.3 对于子元素重复这个过程\x3c\/h4\x3e\n\x3cp\x3e在这一步中，循环所有的子节点。在我们的应用中，将会循环input和list\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010157296\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010157296\x22 alt=\x22img\x22 title=\x22img\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch4\x3e1.4 处理孩子节点和添加到父亲节点\x3c\/h4\x3e\n\x3cp\x3e在这一步中，我们将会处理叶子节点，由于input有个父节点div，那么我们将会将input添加到div中作为\x3cbr\x3e子节点。然后流程转向创建\x3ccode\x3eList\x3c\/code\x3e(第二个子节点是div)\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010157297\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010157297\x22 alt=\x22img\x22 title=\x22img\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3cbr\x3e此时，我们的app长下面这样\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010157298\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010157298\x22 alt=\x22img\x22 title=\x22img\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e注意：在\x3ccode\x3einput\x3c\/code\x3e被创建之后，由于它没有任何子节点，并不会立马就去循环和创建List组件。相反地，它会首先\x3cbr\x3e把\x3ccode\x3einput\x3c\/code\x3e标签添加到父节点div中去，完事之后再返回处理List标签\x3c\/p\x3e\n\x3ch4\x3e1.5 处理子节点\x3c\/h4\x3e\n\x3cp\x3e现在控制流回到了步骤1.1，并且开始处理\x3ccode\x3eList\x3c\/code\x3e组件。但是由于\x3ccode\x3eList\x3c\/code\x3e是一个组件，所以它会遍历执行自身的\x3cstrong\x3erender\x3c\/strong\x3e方法，从而获得一组VNodes，就像下面这样：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010157299\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010157299\x22 alt=\x22img\x22 title=\x22img\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3cbr\x3e当\x3ccode\x3eList\x3c\/code\x3e组件的循环完成时，它会返回\x3ccode\x3eList\x3c\/code\x3e的VNode，就像下面这样：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010157300\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010157300\x22 alt=\x22img\x22 title=\x22img\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch4\x3e1.6 对于所有的子节点，重复步骤1.1到1.4\x3c\/h4\x3e\n\x3cp\x3e对于每个节点，它将会重复以上的每一步。一旦到达叶子节点，它将会被加入到父节点中去，并且重复这个过程。\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010157301\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010157301\x22 alt=\x22img\x22 title=\x22img\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3cbr\x3e下面的图片展示了每个节点是如何添加上去的(深度优先遍历)\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010157302\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010157302\x22 alt=\x22img\x22 title=\x22img\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch4\x3e1.7 处理完成\x3c\/h4\x3e\n\x3cp\x3e此时已经完成了处理过程。然后对于所有的组件，会调用\x3ccode\x3ecomponentDidMount\x3c\/code\x3e方法(从子组件开始，直到父组件)\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010157303\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010157303\x22 alt=\x22img\x22 title=\x22img\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e注意：当一切准备就绪，一个真实DOM的引用会被添加到每个组件的实例中。这个引用会在接下来的一些更新操作(创建、更新、删除)被用来比较，避免重复创建相同的DOM节点\x3c\/strong\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3e情景2：删除叶子节点\x3c\/h3\x3e\n\x3cp\x3e当输入\x22cal\x22并按回车，这将会删除第二个列表子元素，也就是一个叶子节点(New York)，同时其他父元素都会保留。\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010157304\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010157304\x22 alt=\x22img\x22 title=\x22img\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e让我们看下这种情景下，流程是怎么样的\x3c\/p\x3e\n\x3ch4\x3e2.1 创建VNodes\x3c\/h4\x3e\n\x3cp\x3e在初始化渲染之后，后面的每次改变都是一次\x22更新\x22。当创建VNodes时，更新周期与创建周期非常相似，并且再一次创建所有的VNodes。不过既然是更新(不是创建)组件，将会调用每个组件和子组件相应的\x3ccode\x3ecomponentWillReceiveProps\x3c\/code\x3e,\x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e和\x3ccode\x3ecomponentWillUpdate\x3c\/code\x3e方法。\x3c\/p\x3e\n\x3cp\x3e另外，更新周期并不会重新创建已经存在的DOM元素。\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010157305\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010157305\x22 alt=\x22img\x22 title=\x22img\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch4\x3e2.2 使用真实DOM引用，避免创建重复的节点\x3c\/h4\x3e\n\x3cp\x3e之前提到过，在初始化加载期间，每个组件都有一个指向真实DOM树的引用。下面的图展示了引用是如何寻找我们的应用的。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010157306\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010157306\x22 alt=\x22img\x22 title=\x22img\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3cbr\x3e当VNodes被创建后，每个VNode的属性都会与真实DOM的属性相比较。\x3cstrong\x3e如果真实DOM存在，循环将会转移到下个节点\x3c\/strong\x3e\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010157307\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010157307\x22 alt=\x22img\x22 title=\x22img\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch4\x3e2.3 如果在真实DOM中有其它的节点，则删除\x3c\/h4\x3e\n\x3cp\x3e下面的图展示了真实DOM和VNode之间的不同\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010157308\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010157308\x22 alt=\x22img\x22 title=\x22img\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3cbr\x3e由于存在不同，真实DOM中的\x22New York\x22节点会被算法删除掉，正如下面图展示的那样。这个算法也称为\x22componentDidUpdate\x22生命周期。\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010157309\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010157309\x22 alt=\x22img\x22 title=\x22img\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3e情景3-卸载整个组件\x3c\/h3\x3e\n\x3cp\x3e举例：当输入\x3ccode\x3eblabla\x3c\/code\x3e时，由于不匹配\x22California\x22和\x22New York\x22，我们将不会渲染子组件\x3ccode\x3eList\x3c\/code\x3e。这意味着，我们需要卸载整个组件\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010157310\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010157310\x22 alt=\x22img\x22 title=\x22img\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010157311\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010157311\x22 alt=\x22img\x22 title=\x22img\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3cbr\x3e删除一个组件类似于删除一个单独的节点。除此之外，当我们删除一个包含组件引用的节点，将会调用\x22componentWillUnmount\x22，然后递归删除所有的DOM元素。在删除了所有的真实DOM元素之后，\x22componentDidUnmount\x22将会被调用。\x3cbr\x3e下面的图片展示了真实DOM元素\x22ul\x22包含了指向\x22List\x22组件的引用。\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010157312\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010157312\x22 alt=\x22img\x22 title=\x22img\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3cbr\x3e下面的图片在流程图中高亮了deleting\/unmounting一个组件是如何工作的\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010157313\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010157313\x22 alt=\x22img\x22 title=\x22img\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader11\x22\x3e最后\x3c\/h2\x3e\n\x3cp\x3e希望这篇文章能帮助你理解Virtual DOM是如何工作的(至少在Preact中)\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>虚拟DOM内部是如何工作的</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000010157277">https://segmentfault.com/a/1190000010157277</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/7vgql584ki8/" target="_blank">https://alili.tech/archive/7vgql584ki8/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>