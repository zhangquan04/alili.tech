<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="React性能优化总结"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>React性能优化总结 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/efgdmbjqz7/",
				"appid": "1613049289050283", 
				"title": "React性能优化总结 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-29T02:30:10"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/u1071t0ddqf/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/pg6nckv86q/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fefgdmbjqz7%2f&text=React%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96%e6%80%bb%e7%bb%93"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fefgdmbjqz7%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fefgdmbjqz7%2f&text=React%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96%e6%80%bb%e7%bb%93"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fefgdmbjqz7%2f&title=React%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96%e6%80%bb%e7%bb%93"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fefgdmbjqz7%2f&is_video=false&description=React%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96%e6%80%bb%e7%bb%93"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=React%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96%e6%80%bb%e7%bb%93&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fefgdmbjqz7%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fefgdmbjqz7%2f&title=React%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96%e6%80%bb%e7%bb%93"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fefgdmbjqz7%2f&title=React%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96%e6%80%bb%e7%bb%93"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fefgdmbjqz7%2f&title=React%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96%e6%80%bb%e7%bb%93"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fefgdmbjqz7%2f&title=React%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96%e6%80%bb%e7%bb%93"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">React性能优化总结</h1><div class="meta"><div class="postdate"><time datetime="2019-01-29" itemprop="datePublished">2019-01-29</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e\x3cp\x3e文章同步于Github \x3ca href=\x22https:\/\/github.com\/Pines-Cheng\/blog\/issues\/13\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ePines-Cheng\/blog\x3c\/a\x3e\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e初学者对React可能满怀期待，觉得React可能完爆其它一切框架，甚至不切实际地认为React可能连原生的渲染都能完爆——对框架的狂热确实会出现这样的不切实际的期待。让我们来看看React的官方是怎么说的。React官方文档在Advanced Performanec这一节，这样写道：\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3eOne of the first questions people ask when considering React for a project is whether their application will be as fast and responsive as an equivalent non-React version\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e显然React自己也其实只是想尽量达到跟非React版本相当的性能。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e你所不知道的render\x3c\/h2\x3e\n\x3cp\x3ereact的组件渲染分为初始化渲染和更新渲染。\x3cbr\x3e在初始化渲染的时候会调用根组件下的所有组件的render方法进行渲染，如下图（绿色表示已渲染，这一层是没有问题的）：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVGUAs?w=864\x26amp;h=326\x22 src=\x22https:\/\/static.alili.tech\/img\/bVGUAs?w=864\x26amp;h=326\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e但是当我们要更新某个子组件的时候，如下图的绿色组件（从根组件传递下来应用在绿色组件上的数据发生改变）：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVGUAL?w=850\x26amp;h=316\x22 src=\x22https:\/\/static.alili.tech\/img\/bVGUAL?w=850\x26amp;h=316\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e我们的理想状态是只调用关键路径上组件的render，如下图：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVGUAR?w=843\x26amp;h=309\x22 src=\x22https:\/\/static.alili.tech\/img\/bVGUAR?w=843\x26amp;h=309\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e但是react的默认做法是\x3ccode\x3e调用所有组件的render\x3c\/code\x3e，再对\x3ccode\x3e生成的虚拟DOM进行对比\x3c\/code\x3e，如不变则不进行更新。这样的render和虚拟DOM的对比明显是在浪费，如下图（黄色表示浪费的render和虚拟DOM对比）\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVGUBc?w=846\x26amp;h=309\x22 src=\x22https:\/\/static.alili.tech\/img\/bVGUBc?w=846\x26amp;h=309\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3eTips:\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e拆分组件是有利于复用和组件优化的。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e生成虚拟DOM并进行比对发生在render()后，而不是render()前。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3e更新阶段的生命周期\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3ecomponentWillReceiveProps(object nextProps)\x3c\/code\x3e：当挂载的组件接收到新的props时被调用。此方法应该被用于比较this.props 和 nextProps以用于使用this.setState()执行状态转换。（组件内部数据有变化，使用state，但是在更新阶段又要在props改变的时候改变state，则在这个生命周期里面）\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eshouldComponentUpdate(object nextProps, object nextState)\x3c\/code\x3e： -boolean 当组件决定任何改变是否要更新到DOM时被调用。作为一个\x3ccode\x3e优化\x3c\/code\x3e实现比较this.props 和 nextProps 、this.state 和 nextState ，如果React应该跳过更新，返回false。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3ecomponentWillUpdate(object nextProps, object nextState)\x3c\/code\x3e：在更新发生前被立即调用。你不能在此调用\x3ccode\x3ethis.setState()\x3c\/code\x3e。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3ecomponentDidUpdate(object prevProps, object prevState)\x3c\/code\x3e： 在更新发生后被立即调用。（可以在DOM更新完之后，做一些收尾的工作）\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cblockquote\x3e\n\x3cp\x3eTips:\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3eReact的优化是基于\x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e的，该生命周期默认返回true，所以一旦prop或state有任何变化，都会引起重新render。\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3eshouldComponentUpdate\x3c\/h3\x3e\n\x3cp\x3ereact在每个组件生命周期更新的时候都会调用一个shouldComponentUpdate(nextProps, nextState)函数。它的职责就是返回true或false，true表示需要更新，false表示不需要，\x3ccode\x3e默认返回为true\x3c\/code\x3e，即便你没有显示地定义 shouldComponentUpdate 函数。这就不难解释上面发生的资源浪费了。\x3c\/p\x3e\n\x3cp\x3e为了进一步说明问题，我们再引用一张官网的图来解释，如下图（ SCU表示shouldComponentUpdate，绿色表示返回true(需要更新)，红色表示返回false(不需要更新)；vDOMEq表示虚拟DOM比对，绿色表示一致(不需要更新)，红色表示发生改变(需要更新)）：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVGVzv?w=679\x26amp;h=389\x22 src=\x22https:\/\/static.alili.tech\/img\/bVGVzv?w=679\x26amp;h=389\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e根据渲染流程，首先会判断shouldComponentUpdate(SCU)是否需要更新。如果需要更新，则调用组件的render生成新的虚拟DOM，然后再与旧的虚拟DOM对比(vDOMEq)，如果对比一致就不更新，如果对比不同，则根据最小粒度改变去更新DOM；如果SCU不需要更新，则直接保持不变，同时其子元素也保持不变。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eC1根节点，绿色SCU (true)，表示需要更新，然后vDOMEq红色，表示虚拟DOM不一致，需要更新。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eC2节点，红色SCU (false)，表示不需要更新，所以C4,C5均不再进行检查\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eC3节点同C1，需要更新\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eC6节点，绿色SCU (true)，表示需要更新，然后vDOMEq红色，表示虚拟DOM不一致，更新DOM。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eC7节点同C2\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eC8节点，绿色SCU (true)，表示需要更新，然后vDOMEq绿色，表示虚拟DOM一致，不更新DOM。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e带坑的写法：\x3c\/h2\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3e{...this.props}\x3c\/code\x3e (不要滥用，请只传递component需要的props，传得太多，或者层次传得太深，都会加重shouldComponentUpdate里面的数据比较负担，因此，请慎用spread attributes（\x26lt;Component {...props} \/\x26gt;）)。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3e::this.handleChange()\x3c\/code\x3e。(请将方法的bind一律置于constructor)\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3ethis.handleChange.bind(this,id)\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e复杂的页面不要在一个组件里面写完。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e请尽量使用\x3ccode\x3econst element\x3c\/code\x3e。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3emap里面添加key，并且key不要使用index（可变的）。具体可参考\x3ca href=\x22http:\/\/levy.work\/2016-08-31-debug-react-key-with-performance-tool\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e使用Perf工具研究React Key对渲染的影响\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e尽量少用\x3ccode\x3esetTimeOut\x3c\/code\x3e或不可控的refs、DOM操作。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eprops\x3c\/code\x3e和\x3ccode\x3estate\x3c\/code\x3e的数据尽可能简单明了，扁平化。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e使用\x3ccode\x3ereturn null\x3c\/code\x3e而不是CSS的\x3ccode\x3edisplay:none\x3c\/code\x3e来控制节点的显示隐藏。保证同一时间页面的DOM节点尽可能的少。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e性能检测工具\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3eReact官方提供的：React.addons.Perf\x3c\/h3\x3e\n\x3cp\x3ereact官方提供一个插件\x3ccode\x3eReact.addons.Perf\x3c\/code\x3e可以帮助我们分析组件的性能，以确定是否需要优化。\x3cbr\x3e打开console面板，先输入\x3ccode\x3ePerf.start()\x3c\/code\x3e执行一些组件操作，引起数据变动，组件更新，然后输入\x3ccode\x3ePerf.stop()\x3c\/code\x3e。（建议一次只执行一个操作，好进行分析）\x3cbr\x3e再输入\x3ccode\x3ePerf.printInclusive\x3c\/code\x3e查看所有涉及到的组件render，如下图（官方图片）：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVGVGJ?w=687\x26amp;h=62\x22 src=\x22https:\/\/static.alili.tech\/img\/bVGVGJ?w=687\x26amp;h=62\x22 alt=\x22Flfo-tdhVWQNu3Qou1bPgIlHFLln\x22 title=\x22Flfo-tdhVWQNu3Qou1bPgIlHFLln\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e或者输入Perf.printWasted()查看下不需要的的浪费组件render，如下图（官方图片）： \x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVGVG7?w=687\x26amp;h=62\x22 src=\x22https:\/\/static.alili.tech\/img\/bVGVG7?w=687\x26amp;h=62\x22 alt=\x22Fpcch1iZkcJU9U-mlUxjnX9lcO9S\x22 title=\x22Fpcch1iZkcJU9U-mlUxjnX9lcO9S\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e优化前：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVGVJo?w=1026\x26amp;h=332\x22 src=\x22https:\/\/static.alili.tech\/img\/bVGVJo?w=1026\x26amp;h=332\x22 alt=\x22FuX9A-2VfmgFMDycQYvtnR1ovBEb\x22 title=\x22FuX9A-2VfmgFMDycQYvtnR1ovBEb\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3cbr\x3e优化后：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVGVJv?w=535\x26amp;h=192\x22 src=\x22https:\/\/static.alili.tech\/img\/bVGVJv?w=535\x26amp;h=192\x22 alt=\x22Fi4w1W_Fq4A3eUdsv_0U67Z5WZ8N\x22 title=\x22Fi4w1W_Fq4A3eUdsv_0U67Z5WZ8N\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e其他的检测工具\x3c\/h3\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/RamonGebben\/react-perf-tool\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ereact-perf-tool\x3c\/a\x3e为React应用提供了一种可视化的性能检测方案，该工程同样是基于React.addons，但是使用图表来显示结果，更加方便。\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVGVPq?w=895\x26amp;h=353\x22 src=\x22https:\/\/static.alili.tech\/img\/bVGVPq?w=895\x26amp;h=353\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3eReact官方的解决方案\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3ePureRenderMixin(es5)\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var PureRenderMixin = require(\x27react-addons-pure-render-mixin\x27);\nReact.createClass({\n  mixins: [PureRenderMixin],\n\n  render: function() {\n    return \x3cdiv className={this.props.className}\x3efoo\x3c\/div\x3e;\n  }\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e PureRenderMixin = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27react-addons-pure-render-mixin\x27\x3c\/span\x3e);\nReact.createClass({\n  \x3cspan class=\x22hljs-attr\x22\x3emixins\x3c\/span\x3e: [PureRenderMixin],\n\n  \x3cspan class=\x22hljs-attr\x22\x3erender\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eclassName\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{this.props.className}\x3c\/span\x3e\x26gt;\x3c\/span\x3efoo\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e;\n  }\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3eShallow Compare (es6)\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var shallowCompare = require(\x27react-addons-shallow-compare\x27);\nexport class SampleComponent extends React.Component {\n  shouldComponentUpdate(nextProps, nextState) {\n    return shallowCompare(this, nextProps, nextState);\n  }\n\n  render() {\n    return \x3cdiv className={this.props.className}\x3efoo\x3c\/div\x3e;\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e shallowCompare = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27react-addons-shallow-compare\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eSampleComponent\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  shouldComponentUpdate(nextProps, nextState) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e shallowCompare(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, nextProps, nextState);\n  }\n\n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eclassName\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{this.props.className}\x3c\/span\x3e\x26gt;\x3c\/span\x3efoo\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e;\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3ees7装饰器的写法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import pureRender from \x26quot;pure-render-decorator\x26quot;\n...\n\n@pureRender\nclass Person  extends Component {\n  render() {\n    console.log(\x26quot;我re-render了\x26quot;);\n    const {name,age} = this.props;\n\n      return (\n        \x3cdiv\x3e\n          \x3cspan\x3e姓名:\x3c\/span\x3e\n          \x3cspan\x3e{name}\x3c\/span\x3e\n          \x3cspan\x3e age:\x3c\/span\x3e\n          \x3cspan\x3e{age}\x3c\/span\x3e\n        \x3c\/div\x3e\n      )\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e pureRender \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22pure-render-decorator\x22\x3c\/span\x3e\n...\n\n@pureRender\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePerson\x3c\/span\x3e  \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  render() {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22我re-render了\x22\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e {name,age} = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props;\n\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n        \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n          \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3espan\x3c\/span\x3e\x26gt;\x3c\/span\x3e姓名:\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3espan\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n          \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3espan\x3c\/span\x3e\x26gt;\x3c\/span\x3e{name}\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3espan\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n          \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3espan\x3c\/span\x3e\x26gt;\x3c\/span\x3e age:\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3espan\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n          \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3espan\x3c\/span\x3e\x26gt;\x3c\/span\x3e{age}\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3espan\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n      )\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3epureRender很简单，就是把传进来的component的shouldComponentUpdate给重写掉了，原来的shouldComponentUpdate，无论怎样都是return ture，现在不了，我要用shallowCompare比一比，shallowCompare代码及其简单，如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function shallowCompare(instance, nextProps, nextState) {\n  return !shallowEqual(instance.props, nextProps) || !shallowEqual(instance.state, nextState);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs ada\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eshallowCompare\x3c\/span\x3e(instance, nextProps, nextState) {\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3e!shallowEqual(instance.props,\x3c\/span\x3e nextProps) || !shallowEqual(instance.state, nextState);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3e缺点\x3c\/h3\x3e\n\x3cp\x3eshallowEqual其实只比较props的\x3ccode\x3e第一层\x3c\/code\x3e子属性是不是相同，如果props是如下\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n  detail: {\n    name: \x26quot;123\x26quot;,\n    age: \x26quot;123\x26quot;\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e{\n  \x3cspan class=\x22hljs-attr\x22\x3edetail\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22123\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3eage\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22123\x22\x3c\/span\x3e\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e他只会比较\x3ccode\x3eprops.detail ===nextProps.detail\x3c\/code\x3e，导致在传入复杂的数据的情况下，优化失效。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader11\x22\x3e补充（4.25）\x3c\/h3\x3e\n\x3cp\x3eReact在\x3ccode\x3e15.3.0\x3c\/code\x3e里面加入了了\x3ccode\x3eReact.PureComponent\x3c\/code\x3e - 一个可继承的新的基础类, 用来替换\x3ccode\x3ereact-addons-pure-render-mixin\x3c\/code\x3e。用法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class CounterButton extends React.PureComponent {\n  constructor(props) {\n    super(props);\n    this.state = {count: 1};\n  }\n\n  render() {\n    return (\n      \x3cbutton\n        color={this.props.color}\n        onClick={() =\x3e this.setState(state =\x3e ({count: state.count \x2b 1}))}\x3e\n        Count: {this.state.count}\n      \x3c\/button\x3e\n    );\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs pf\x22\x3e\x3ccode\x3eclass CounterButton extends React.PureComponent {\n  constructor(props) {\n    super(props);\n    this.\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e = {count: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e};\n  }\n\n  render() {\n    return (\n      \x3cspan class=\x22hljs-variable\x22\x3e\x26lt;button\n        color={this.props.color}\n        onClick={() =\x26gt;\x3c\/span\x3e this.\x3cspan class=\x22hljs-built_in\x22\x3eset\x3c\/span\x3eState(\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e =\x26gt; ({count: \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e.count \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e}))}\x26gt;\n        Count: {this.\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e.count}\n      \x26lt;\/button\x26gt;\n    );\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在ES6里面写起来简直爽歪歪，可惜一样只支持浅比较。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader12\x22\x3eimmutable.js\x3c\/h2\x3e\n\x3cp\x3e我们也可以在 \x3ccode\x3eshouldComponentUpdate()\x3c\/code\x3e 中使用使用 deepCopy 和 deepCompare 来避免无必要的 render()，但 deepCopy 和 deepCompare 一般都是非常耗性能的。\x3c\/p\x3e\n\x3cp\x3eImmutable Data 就是一旦创建，就不能再被更改的数据。对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象。\x3c\/p\x3e\n\x3cp\x3eImmutable 实现的原理是 \x3ccode\x3ePersistent Data Structure\x3c\/code\x3e（持久化数据结构），也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时为了避免 deepCopy 把所有节点都复制一遍带来的性能损耗，Immutable 使用了 \x3ccode\x3eStructural Sharing\x3c\/code\x3e（结构共享），即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。请看下面动画：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVsXeZ\x22 src=\x22https:\/\/static.alili.tech\/img\/bVsXeZ\x22 alt=\x22FpPDekdncL-A9N69NnI3-O8CgGQ8\x22 title=\x22FpPDekdncL-A9N69NnI3-O8CgGQ8\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3eImmutable 则提供了简洁高效的判断数据是否变化的方法，只需 === 和 is 比较就能知道是否需要执行 render()，而这个操作几乎 0 成本，所以可以极大提高性能。修改后的 \x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e 是这样的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import { is } from \x27immutable\x27;\n\nshouldComponentUpdate: (nextProps = {}, nextState = {}) =\x3e {\n  const thisProps = this.props || {}, thisState = this.state || {};\n\n  if (Object.keys(thisProps).length !== Object.keys(nextProps).length ||\n      Object.keys(thisState).length !== Object.keys(nextState).length) {\n    return true;\n  }\n\n  for (const key in nextProps) {\n    if (!is(thisProps[key], nextProps[key])) {\n      return true;\n    }\n  }\n\n  for (const key in nextState) {\n    if (thisState[key] !== nextState[key] || !is(thisState[key], nextState[key])) {\n      return true;\n    }\n  }\n  return false;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { is } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27immutable\x27\x3c\/span\x3e;\n\nshouldComponentUpdate: \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3enextProps = {}, nextState = {}\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e thisProps = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props || {}, thisState = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state || {};\n\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.keys(thisProps).length !== \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.keys(nextProps).length ||\n      \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.keys(thisState).length !== \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.keys(nextState).length) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e key \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e nextProps) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!is(thisProps[key], nextProps[key])) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n    }\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e key \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e nextState) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (thisState[key] !== nextState[key] || !is(thisState[key], nextState[key])) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n    }\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader13\x22\x3ereact-immutable-render-mixin\x3c\/h3\x3e\n\x3cp\x3e这是一个facebook\/immutable-js的react pure render mixin 的库，可以简化很多写法。\x3cbr\x3e使用\x3ca href=\x22https:\/\/github.com\/jurassix\/react-immutable-render-mixin\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ereact-immutable-render-mixin\x3c\/a\x3e可以实现装饰器的写法。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import React from \x27react\x27;\nimport { immutableRenderDecorator } from \x27react-immutable-render-mixin\x27;\n\n@immutableRenderDecorator\nclass Test extends React.Component {\n  render() {\n    return \x3cdiv\x3e\x3c\/div\x3e;\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e React \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { immutableRenderDecorator } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react-immutable-render-mixin\x27\x3c\/span\x3e;\n\n@immutableRenderDecorator\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eTest\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e;\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里可参考我的另一篇blog:\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000010438089\x22\x3e使用immutable优化React\x3c\/a\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader14\x22\x3e无状态组件\x3c\/h2\x3e\n\x3cp\x3e为了避免一定程度的浪费，react官方还在0.14版本中加入了\x3ccode\x3e无状态组件\x3c\/code\x3e，\x3cbr\x3e这种组件没有状态，没有生命周期，只是简单的接受 props 渲染生成 DOM 结构。无状态组件非常简单，开销很低，如果可能的话尽量使用无状态组件。比如使用箭头函数定义：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ es6\nconst HelloMessage = (props) =\x3e \x3cdiv\x3e Hello {props.name}\x3c\/div\x3e;\nrender(\x3cHelloMessage name=\x26quot;John\x26quot; \/\x3e, mountNode);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ es6\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e HelloMessage = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eprops\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e \x26lt;div\x26gt; Hello {props.name}\x26lt;\x3cspan class=\x22hljs-regexp\x22\x3e\/div\x26gt;;\nrender(\x26lt;HelloMessage name=\x22John\x22 \/\x3c\/span\x3e\x26gt;, mountNode);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e因为无状态组件只是函数，所以它没有实例返回，这点在想用 refs 获取无状态组件的时候要注意，参见DOM 操作。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader15\x22\x3e高阶组件（接下来的方向）\x3c\/h2\x3e\n\x3cblockquote\x3e\x3cp\x3e大部分使用mixin和class extends的地方，高阶组件都是更好的方案——毕竟\x3ccode\x3e组合优于继承\x3c\/code\x3e。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader16\x22\x3e参考文章\x3c\/h3\x3e\n\x3cp\x3e\x3ca href=\x22http:\/\/wwsun.github.io\/posts\/react-with-es6-part-4.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e使用ES6编写React应用（4）：使用高阶组件替代Mixins\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22http:\/\/efe.baidu.com\/blog\/mixins-are-dead-long-live-the-composition\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eMixin 已死，Composition 万岁\x3c\/a\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader17\x22\x3eReact同构直出（接下来方向）\x3c\/h2\x3e\n\x3cblockquote\x3e\x3cp\x3e同构基于服务端渲染，却不止是服务端渲染。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3eReact在减少重复渲染方面确实是有一套独特的处理办法，那就是virtual DOM，但显示在首次渲染的时候React绝无可能超越原生的速度。因此，我们在做优化的时候，接下来可以做的事情就是：\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3e首屏时间可能会比较原生的慢一些，但可以尝试用React Server Render (又称Isomorphic)去提高效率\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader18\x22\x3e参考文章\x3c\/h3\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/joeyguo\/blog\/issues\/9\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eReact同构直出优化总结\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22http:\/\/www.alloyteam.com\/2016\/06\/tencent-news-react-isomorphic-straight-out-optimization\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e腾讯新闻React同构直出优化实践\x3c\/a\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader19\x22\x3e参考文章\x3c\/h2\x3e\n\x3cp\x3e\x3ca href=\x22http:\/\/imweb.io\/topic\/577512fe732b4107576230b9\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ereact组件性能优化探索实践\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22https:\/\/github.com\/lcxfs1991\/blog\/issues\/8\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eReact移动web极致优化\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22https:\/\/zhuanlan.zhihu.com\/p\/20549104?columnSlug=FrontendMagazine\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eReact vs Angular 2：冰与火之歌\x3c\/a\x3e\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e时间仓促，难免有遗漏，如果觉得对你有帮助，请点\x3ccode\x3e推荐\x3c\/code\x3e。\x3c\/p\x3e\x3c\/blockquote\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>React性能优化总结</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000007811296">https://segmentfault.com/a/1190000007811296</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/efgdmbjqz7/" target="_blank">https://alili.tech/archive/efgdmbjqz7/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>