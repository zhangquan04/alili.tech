<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="【译】JavaScript数据结构（4）：树"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>【译】JavaScript数据结构（4）：树 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/95lqazllq5m/",
				"appid": "1613049289050283", 
				"title": "【译】JavaScript数据结构（4）：树 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-06T02:30:10"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/e37ocycp33e/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/rp0rk4xmvdi/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f95lqazllq5m%2f&text=%e3%80%90%e8%af%91%e3%80%91JavaScript%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%ef%bc%884%ef%bc%89%ef%bc%9a%e6%a0%91"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f95lqazllq5m%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f95lqazllq5m%2f&text=%e3%80%90%e8%af%91%e3%80%91JavaScript%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%ef%bc%884%ef%bc%89%ef%bc%9a%e6%a0%91"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f95lqazllq5m%2f&title=%e3%80%90%e8%af%91%e3%80%91JavaScript%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%ef%bc%884%ef%bc%89%ef%bc%9a%e6%a0%91"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f95lqazllq5m%2f&is_video=false&description=%e3%80%90%e8%af%91%e3%80%91JavaScript%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%ef%bc%884%ef%bc%89%ef%bc%9a%e6%a0%91"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e3%80%90%e8%af%91%e3%80%91JavaScript%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%ef%bc%884%ef%bc%89%ef%bc%9a%e6%a0%91&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f95lqazllq5m%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f95lqazllq5m%2f&title=%e3%80%90%e8%af%91%e3%80%91JavaScript%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%ef%bc%884%ef%bc%89%ef%bc%9a%e6%a0%91"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f95lqazllq5m%2f&title=%e3%80%90%e8%af%91%e3%80%91JavaScript%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%ef%bc%884%ef%bc%89%ef%bc%9a%e6%a0%91"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f95lqazllq5m%2f&title=%e3%80%90%e8%af%91%e3%80%91JavaScript%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%ef%bc%884%ef%bc%89%ef%bc%9a%e6%a0%91"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f95lqazllq5m%2f&title=%e3%80%90%e8%af%91%e3%80%91JavaScript%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%ef%bc%884%ef%bc%89%ef%bc%9a%e6%a0%91"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">【译】JavaScript数据结构（4）：树</h1><div class="meta"><div class="postdate"><time datetime="2019-01-06" itemprop="datePublished">2019-01-06</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e\x3cp\x3e\x3cstrong\x3e翻译\x3c\/strong\x3e：疯狂的技术宅\x3cbr\x3e\x3cstrong\x3e英文\x3c\/strong\x3e：\x3ca href=\x22https:\/\/code.tutsplus.com\/articles\/data-structures-with-javascript-tree--cms-23393\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/code.tutsplus.com\/art...\x3c\/a\x3e\x3cbr\x3e\x3cstrong\x3e说明\x3c\/strong\x3e：本文翻译自系列文章《Data Structures With JavaScript》，总共为四篇，原作者是在美国硅谷工作的工程师 Cho S. Kim。这是本系列的第四篇。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e说明：本专栏文章首发于公众号：jingchengyideng 。\x3c\/p\x3e\n\x3cp\x3e树是 web 开发中最常用的数据结构之一。 这种说法对开发者和用户都是正确的。每个编写HTML的开发者，只要把网页载入浏览器就会创建一个树，树通常被称为文档对象模型（DOM）。相应地，每个在互联网上浏览信息的人，也都是以DOM树的形式接受信息。 每个编写HTML并且将其加载到Web浏览器的Web开发人员都创建了一个树，这被称为文档对象模型（DOM）。互联网上的所有用户，在获取信息时，都是以树的形式收——即DOM。 \x3c\/p\x3e\n\x3cp\x3e现在，高潮来了：你正在读的本文在浏览器中就是以树的形式进行渲染的。文字由\x3ccode\x3e\x26lt;p\x26gt;\x3c\/code\x3e元素进行表示；\x3ccode\x3e\x26lt;p\x26gt;\x3c\/code\x3e元素又嵌套在\x3ccode\x3e\x26lt;body\x26gt;\x3c\/code\x3e元素中；\x3ccode\x3e\x26lt;body\x26gt;\x3c\/code\x3e元素又嵌套在\x3ccode\x3e\x26lt;html\x26gt;\x3c\/code\x3e元素中。  您正在阅读的段落表示为\x3ccode\x3e\x26lt;p\x26gt;\x3c\/code\x3e元素中的文本；\x3ccode\x3e\x26lt;p\x26gt;\x3c\/code\x3e元素嵌套在\x3ccode\x3e\x26lt;body\x26gt;\x3c\/code\x3e元素中；\x3ccode\x3e\x26lt;body\x26gt;\x3c\/code\x3e元素嵌套在\x3ccode\x3e\x26lt;html\x26gt;\x3c\/code\x3e元素中。\x3c\/p\x3e\n\x3cp\x3e这些嵌套数据和家族数类似。 \x3ccode\x3e\x26lt;heml\x26gt;\x3c\/code\x3e是父元素，\x3ccode\x3e\x26lt;body\x26gt;\x3c\/code\x3e是子元素，\x3ccode\x3e\x26lt;p\x26gt;\x3c\/code\x3e又是\x3ccode\x3e\x26lt;body\x26gt;\x3c\/code\x3e的子元素 如果这个比喻对你有点用的话，你将会发现在我们介绍树的时候会用到更多的类比。\x3c\/p\x3e\n\x3cp\x3e在本文中，我们将会通过两种不同的遍历方式来创建一个树：深度优先(DFS)和广度优先(BFS)。 （如果你对遍历这个词感到比较陌生，不妨将他想象成访问树中的每一个节点。） 这两种类型的遍历强调了与树交互的不同方式， DFS和BFS分别用栈和队列来访问节点。 这听起来很酷！\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader0\x22\x3e\x3cstrong\x3e树（深度搜索和广度搜索）\x3c\/strong\x3e\x3c\/h1\x3e\n\x3cp\x3e在计算机科学中，树是一种用节点来模拟分层数据的数据结构。每个树节点都包含他本身的数据及指向其他节点的指针。\x3c\/p\x3e\n\x3cp\x3e节点和指针这些术语可能对一些读者来说比较陌生，所以让我们用类比来进一步描述他们。 让我们将树与组织图结构图进行比较。 这个结构图有一个顶级位置（根节点），比如CEO。 在这个节点下面还有一些其他的节点，比如副总裁(VP)。\x3c\/p\x3e\n\x3cp\x3e为了表示这种关系，我们用箭头从CEO指向VP。 一个位置，比如CEO，是一个节点；我们创建的CEO到VP的关系是一个指针。 在我们的组织结构图中去创建更多的关系，我们只要重复这些步骤即可---我们让一个节点指向另一个节点。\x3c\/p\x3e\n\x3cp\x3e在概念层次上，我希望节点和指针有意义。 在实际中，我们能从更科学的实例中获取收益。 让我们来思考DOM。 DOM有\x3ccode\x3e\x26lt;html\x26gt;\x3c\/code\x3e元素作为其顶级位置（根节点）。 这个节点指向\x3ccode\x3e\x26lt;head\x26gt;\x3c\/code\x3e元素和\x3ccode\x3e\x26lt;body\x26gt;\x3c\/code\x3e元素。 这些步骤在DOM的所有节点中重复。\x3c\/p\x3e\n\x3cp\x3e这种设计的一个优点是能够嵌套节点：例如：一个\x3ccode\x3e\x26lt;ul\x26gt;\x3c\/code\x3e元素能够包含很多个\x3ccode\x3e\x26lt;li\x26gt;\x3c\/code\x3e元素；此外，每个\x3ccode\x3e\x26lt;li\x26gt;\x3c\/code\x3e元素能拥有兄弟\x3ccode\x3e\x26lt;li\x26gt;\x3c\/code\x3e元素。这很怪异，但是确实真实有趣！\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e\x3cstrong\x3e操作树\x3c\/strong\x3e\x3c\/h2\x3e\n\x3cp\x3e由于每个树都包含节点，其可以是来自树的单独构造器，我们将概述两个构造函数的操作：\x3ccode\x3eNode\x3c\/code\x3e和\x3ccode\x3eTree\x3c\/code\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e\x3cstrong\x3e节点\x3c\/strong\x3e\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3edata\x3c\/code\x3e 存储值。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eparent\x3c\/code\x3e 指向节点的父节点。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3echildren\x3c\/code\x3e 指向列表中的下一个节点。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e\x3cstrong\x3e树\x3c\/strong\x3e\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3e_root\x3c\/code\x3e 指向一个树的根节点。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3etraverseDF(callback)\x3c\/code\x3e 对树进行DFS遍历。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3etraverseBF(callback)\x3c\/code\x3e 对树进行BFS遍历。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3econtains(data, traversal)\x3c\/code\x3e 搜索树中的节点。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eadd(data, toData, traverse)\x3c\/code\x3e 向树中添加节点。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eremove(child, parent)\x3c\/code\x3e 移除树中的节点。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e\x3cstrong\x3e实现树\x3c\/strong\x3e\x3c\/h2\x3e\n\x3cp\x3e现在开始写树的代码！\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e\x3cstrong\x3e节点的属性\x3c\/strong\x3e\x3c\/h3\x3e\n\x3cp\x3e在实现中，我们首先定义一个叫做\x3ccode\x3eNode\x3c\/code\x3e的函数，然后构造一个\x3ccode\x3eTree\x3c\/code\x3e。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Node(data) {\n    this.data = data;\n    this.parent = null;\n    this.children = [];\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eNode\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.data = data;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.parent = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.children = [];\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e每一个\x3ccode\x3eNode\x3c\/code\x3e的实例都包含三个属性：\x3ccode\x3edata\x3c\/code\x3e，\x3ccode\x3eparant\x3c\/code\x3e，和\x3ccode\x3echildren\x3c\/code\x3e。 第一个属性保存与节点相关联的数据。 第二个属性指向一个节点。 第三个属性指向许多子节点。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e\x3cstrong\x3e树的属性\x3c\/strong\x3e\x3c\/h3\x3e\n\x3cp\x3e现在让我们来定义\x3ccode\x3eTree\x3c\/code\x3e的构造函数，其中包括Node构造函数的定义：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Tree(data) {\n    var node = new Node(data);\n    this._root = node;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eTree\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e node = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Node(data);\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._root = node;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3eTree\x3c\/code\x3e包含两行代码。 第一行创建了一个\x3ccode\x3eNode\x3c\/code\x3e的新实例；第二行让node等于树的根节点。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eTree\x3c\/code\x3e和\x3ccode\x3eNode\x3c\/code\x3e的定义只需要几行代码。 但是，通过这几行足以帮助我们模拟分层数据。 为了证明这一点，让我们用一些示例数据去创建Tree的示例（和间接的\x3ccode\x3eNode\x3c\/code\x3e）。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var tree = new Tree(\x27CEO\x27);\n \n\/\/ {data: \x27CEO\x27, parent: null, children: []}\ntree._root;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e tree = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Tree(\x3cspan class=\x22hljs-string\x22\x3e\x27CEO\x27\x3c\/span\x3e);\n \n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ {data: \x27CEO\x27, parent: null, children: []}\x3c\/span\x3e\ntree._root;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e幸好有\x3ccode\x3eparent\x3c\/code\x3e和\x3ccode\x3echildren\x3c\/code\x3e的存在，我们可以为\x3ccode\x3e_root\x3c\/code\x3e添加子节点和让这些子节点的父节点等于\x3ccode\x3e_root\x3c\/code\x3e。 换一种说法，我们可以模拟分层数据的创建。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e\x3cstrong\x3eTree的方法\x3c\/strong\x3e\x3c\/h3\x3e\n\x3cp\x3e接下来我们将要创建以下五种方法。\x3c\/p\x3e\n\x3ch4\x3e\x3cstrong\x3e树\x3c\/strong\x3e\x3c\/h4\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3etraverseDF(callback)\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3etraverseBF(callback)\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3econtains(data, traversal)\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eadd(child, parent)\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eremove(node, parent)\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e因为每种方法都需要遍历一个树，所以我们首先要实现一个方法去定义不同的树遍历。 （遍历树是访问树的每个节点的正式方式。）\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e方法1\/5: \x3ccode\x3etraverseDF(callback)\x3c\/code\x3e\n\x3c\/h3\x3e\n\x3cp\x3e这种方法以深度优先方式遍历树。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Tree.prototype.traverseDF = function(callback) {\n \n    \/\/ this is a recurse and immediately-invoking function \n    (function recurse(currentNode) {\n        \/\/ step 2\n        for (var i = 0, length = currentNode.children.length; i \x3c length; i\x2b\x2b) {\n            \/\/ step 3\n            recurse(currentNode.children[i]);\n        }\n \n        \/\/ step 4\n        callback(currentNode);\n         \n        \/\/ step 1\n    })(this._root);\n \n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eTree.prototype.traverseDF = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ecallback\x3c\/span\x3e) \x3c\/span\x3e{\n \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ this is a recurse and immediately-invoking function \x3c\/span\x3e\n    (\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3erecurse\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ecurrentNode\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ step 2\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, length = currentNode.children.length; i \x26lt; length; i\x2b\x2b) {\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ step 3\x3c\/span\x3e\n            recurse(currentNode.children[i]);\n        }\n \n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ step 4\x3c\/span\x3e\n        callback(currentNode);\n         \n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ step 1\x3c\/span\x3e\n    })(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._root);\n \n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3etraverseDF(callback)\x3c\/code\x3e有一个参数\x3ccode\x3ecallback\x3c\/code\x3e。 如果对这个名字不明白，\x3ccode\x3ecallback\x3c\/code\x3e被假定是一个函数，将在后面被\x3ccode\x3etraverseDF(callback)\x3c\/code\x3e调用。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3etraverseDF(callback)\x3c\/code\x3e的函数体含有另一个叫做\x3ccode\x3erecurse\x3c\/code\x3e的函数。 这个函数是一个递归函数！ 换句话说，它是自我调用和自我终止。 使用\x3ccode\x3erecurse\x3c\/code\x3e的注释中提到的步骤，我将描述递归用来\x3ccode\x3erecurse\x3c\/code\x3e整个树的一般过程。\x3c\/p\x3e\n\x3cp\x3e这里是步骤：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e立即使用树的根节点作为其参数调用\x3ccode\x3erecurse\x3c\/code\x3e。 此时，\x3ccode\x3ecurrentNode\x3c\/code\x3e指向当前节点。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e进入\x3ccode\x3efor\x3c\/code\x3e循环并且从第一个子节点开始，每一个子节点都迭代一次\x3ccode\x3ecurrentNode\x3c\/code\x3e函数。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e在\x3ccode\x3efor\x3c\/code\x3e循环体内，使用\x3ccode\x3ecurrentNode\x3c\/code\x3e的子元素调用递归。 确切的子节点取决于当前\x3ccode\x3efor\x3c\/code\x3e循环的当前迭代。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e当\x3ccode\x3ecurrentNode\x3c\/code\x3e不存在子节点时，我们退出\x3ccode\x3efor\x3c\/code\x3e循环并\x3ccode\x3ecallback\x3c\/code\x3e我们在调用\x3ccode\x3etraverseDF（callback）\x3c\/code\x3e期间传递的回调。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e步骤2（自终止），3（自调用）和4（回调）重复，直到我们遍历树的每个节点。 \x3c\/p\x3e\n\x3cp\x3e递归是一个非常困难的话题，需要一个完整的文章来充分解释它。由于递归的解释不是本文的重点 —— 重点是实现一棵树 —— 我建议任何读者没有很好地掌握递归做以下两件事。 \x3c\/p\x3e\n\x3cp\x3e首先，实验我们当前的\x3ccode\x3etraverseDF(callback)\x3c\/code\x3e实现，并尝试一定程度上理解它是如何工作的。 第二，如果你想要我写一篇关于递归的文章，那么请在本文的评论中请求它。 \x3c\/p\x3e\n\x3cp\x3e以下示例演示如何使用\x3ccode\x3etraverseDF(callback)\x3c\/code\x3e遍历树。要遍历树，我将在下面的示例中创建一个。我现在使用的方法不是罪理想的，但它能很好的工作。 一个更好的方法是使用\x3ccode\x3eadd(value)\x3c\/code\x3e，我们将在第4步和第5步中实现。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var tree = new Tree(\x27one\x27);\n \ntree._root.children.push(new Node(\x27two\x27));\ntree._root.children[0].parent = tree;\n \ntree._root.children.push(new Node(\x27three\x27));\ntree._root.children[1].parent = tree;\n \ntree._root.children.push(new Node(\x27four\x27));\ntree._root.children[2].parent = tree;\n \ntree._root.children[0].children.push(new Node(\x27five\x27));\ntree._root.children[0].children[0].parent = tree._root.children[0];\n \ntree._root.children[0].children.push(new Node(\x27six\x27));\ntree._root.children[0].children[1].parent = tree._root.children[0];\n \ntree._root.children[2].children.push(new Node(\x27seven\x27));\ntree._root.children[2].children[0].parent = tree._root.children[2];\n \n\/*\n \ncreates this tree\n \n one\n ├── two\n │   ├── five\n │   └── six\n ├── three\n └── four\n     └── seven\n \n*\/\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e tree = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Tree(\x3cspan class=\x22hljs-string\x22\x3e\x27one\x27\x3c\/span\x3e);\n \ntree._root.children.push(\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Node(\x3cspan class=\x22hljs-string\x22\x3e\x27two\x27\x3c\/span\x3e));\ntree._root.children[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e].parent = tree;\n \ntree._root.children.push(\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Node(\x3cspan class=\x22hljs-string\x22\x3e\x27three\x27\x3c\/span\x3e));\ntree._root.children[\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e].parent = tree;\n \ntree._root.children.push(\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Node(\x3cspan class=\x22hljs-string\x22\x3e\x27four\x27\x3c\/span\x3e));\ntree._root.children[\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e].parent = tree;\n \ntree._root.children[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e].children.push(\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Node(\x3cspan class=\x22hljs-string\x22\x3e\x27five\x27\x3c\/span\x3e));\ntree._root.children[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e].children[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e].parent = tree._root.children[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e];\n \ntree._root.children[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e].children.push(\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Node(\x3cspan class=\x22hljs-string\x22\x3e\x27six\x27\x3c\/span\x3e));\ntree._root.children[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e].children[\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e].parent = tree._root.children[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e];\n \ntree._root.children[\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e].children.push(\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Node(\x3cspan class=\x22hljs-string\x22\x3e\x27seven\x27\x3c\/span\x3e));\ntree._root.children[\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e].children[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e].parent = tree._root.children[\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e];\n \n\x3cspan class=\x22hljs-comment\x22\x3e\/*\n \ncreates this tree\n \n one\n ├── two\n │   ├── five\n │   └── six\n ├── three\n └── four\n     └── seven\n \n*\/\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e现在，让我们调用\x3ccode\x3etraverseDF(callback)\x3c\/code\x3e。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22tree.traverseDF(function(node) {\n    console.log(node.data)\n});\n \n\/*\n \nlogs the following strings to the console\n \n\x27five\x27\n\x27six\x27\n\x27two\x27\n\x27three\x27\n\x27seven\x27\n\x27four\x27\n\x27one\x27\n \n*\/\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3etree.traverseDF(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3enode\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(node.data)\n});\n \n\x3cspan class=\x22hljs-comment\x22\x3e\/*\n \nlogs the following strings to the console\n \n\x27five\x27\n\x27six\x27\n\x27two\x27\n\x27three\x27\n\x27seven\x27\n\x27four\x27\n\x27one\x27\n \n*\/\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e\x3cstrong\x3e方法2\/5: \x3ccode\x3etraverseBF(callback)\x3c\/code\x3e\x3c\/strong\x3e\x3c\/h4\x3e\n\x3cp\x3e这个方法使用深度优先搜索去遍历树\x3c\/p\x3e\n\x3cp\x3e深度优先搜索和广度优先搜索之间的差别涉及树的节点访问的序列。 为了说明这一点，让我们使用\x3ccode\x3etraverseDF(callback)\x3c\/code\x3e创建的树。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/* \n tree\n \n one (depth: 0)\n ├── two (depth: 1)\n │   ├── five (depth: 2)\n │   └── six (depth: 2)\n ├── three (depth: 1)\n └── four (depth: 1)\n     └── seven (depth: 2)\n *\/\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/* \n tree\n \n one (depth: 0)\n ├── two (depth: 1)\n │   ├── five (depth: 2)\n │   └── six (depth: 2)\n ├── three (depth: 1)\n └── four (depth: 1)\n     └── seven (depth: 2)\n *\/\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e现在，让我们传递\x3ccode\x3etraverseBF(callback)\x3c\/code\x3e和我们用于traverseDF（callback）的回调。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22tree.traverseBF(function(node) {\n    console.log(node.data)\n});\n \n\/*\n \nlogs the following strings to the console\n \n\x27one\x27\n\x27two\x27\n\x27three\x27\n\x27four\x27\n\x27five\x27\n\x27six\x27\n\x27seven\x27\n \n*\/\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3etree.traverseBF(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3enode\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(node.data)\n});\n \n\x3cspan class=\x22hljs-comment\x22\x3e\/*\n \nlogs the following strings to the console\n \n\x27one\x27\n\x27two\x27\n\x27three\x27\n\x27four\x27\n\x27five\x27\n\x27six\x27\n\x27seven\x27\n \n*\/\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e来自控制台的日志和我们的树的图显示了关于广度优先搜索的模式。从根节点开始；然后行进一个深度并访问该深度从左到右的每个节点。重复此过程，直到没有更多的深度要移动。 \x3c\/p\x3e\n\x3cp\x3e由于我们有一个广度优先搜索的概念模型，现在让我们实现使我们的示例工作的代码。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Tree.prototype.traverseBF = function(callback) {\n    var queue = new Queue();\n     \n    queue.enqueue(this._root);\n \n    currentTree = queue.dequeue();\n \n    while(currentTree){\n        for (var i = 0, length = currentTree.children.length; i \x3c length; i\x2b\x2b) {\n            queue.enqueue(currentTree.children[i]);\n        }\n \n        callback(currentTree);\n        currentTree = queue.dequeue();\n    }\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eTree.prototype.traverseBF = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ecallback\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e queue = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Queue();\n     \n    queue.enqueue(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._root);\n \n    currentTree = queue.dequeue();\n \n    \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e(currentTree){\n        \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, length = currentTree.children.length; i \x26lt; length; i\x2b\x2b) {\n            queue.enqueue(currentTree.children[i]);\n        }\n \n        callback(currentTree);\n        currentTree = queue.dequeue();\n    }\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们对\x3ccode\x3etraverseBF(callback)\x3c\/code\x3e的定义包含了很多逻辑。 因此，我会用下面的步骤解释这些逻辑：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e创建 \x3ccode\x3eQueue\x3c\/code\x3e的实例。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e调用\x3ccode\x3etraverseBF(callback)\x3c\/code\x3e产生的节点添加到\x3ccode\x3eQueue\x3c\/code\x3e的实例。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e定义一个变量\x3ccode\x3ecurrentNode\x3c\/code\x3e并且将其值初始化为刚才添加到队列里的\x3ccode\x3enode\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e当\x3ccode\x3ecurrentNode\x3c\/code\x3e指向一个节点时，执行\x3ccode\x3ewille\x3c\/code\x3e循环里面的代码。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e用\x3ccode\x3efor\x3c\/code\x3e循环去迭代\x3ccode\x3ecurrentNode\x3c\/code\x3e的子节点。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e在\x3ccode\x3efor\x3c\/code\x3e循环体内，将每个子元素加入队列。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e获取\x3ccode\x3ecurrentNode\x3c\/code\x3e并将其作为\x3ccode\x3ecallback\x3c\/code\x3e的参数传递。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e将\x3ccode\x3ecurrentNode\x3c\/code\x3e重新分配给正从队列中删除的节点。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e直到\x3ccode\x3ecurrentNode\x3c\/code\x3e不再指向任何节点——也就是说树中的每个节点都访问过了——重复4-8步。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch4\x3e\x3cstrong\x3e方法3\/5 \x3ccode\x3econtains(callback, traversal)\x3c\/code\x3e\x3c\/strong\x3e\x3c\/h4\x3e\n\x3cp\x3e让我们定义一个方法，可以在树中搜索一个特定的值。去使用我们创建的任意一种树的遍历方法，我们已经定义了\x3ccode\x3econtains(callback, traversal)\x3c\/code\x3e接收两个参数：搜索的数据和遍历的类型。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Tree.prototype.contains = function(callback, traversal) {\n    traversal.call(this, callback);\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eTree.prototype.contains = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ecallback, traversal\x3c\/span\x3e) \x3c\/span\x3e{\n    traversal.call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, callback);\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在\x3ccode\x3econtains(callback, traversal)\x3c\/code\x3e函数体内，我们用\x3ccode\x3ecall\x3c\/code\x3e方法去传递\x3ccode\x3ethis\x3c\/code\x3e和\x3ccode\x3ecallback\x3c\/code\x3e。 第一个参数将\x3ccode\x3etraversal\x3c\/code\x3e绑定到被调用的树\x3ccode\x3econtains（callback，traversal）\x3c\/code\x3e；第二个参数是在树中每个节点上调用的函数。\x3c\/p\x3e\n\x3cp\x3e想象一下，我们要将包含奇数数据的任何节点记录到控制台，并使用BFS遍历树中的每个节点。 我们可以这么写代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ tree is an example of a root node\ntree.contains(function(node){\n    if (node.data === \x27two\x27) {\n        console.log(node);\n    }\n}, tree.traverseBF);\nadd(data, toData, traversal) \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ tree is an example of a root node\x3c\/span\x3e\ntree.contains(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3enode\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (node.data === \x3cspan class=\x22hljs-string\x22\x3e\x27two\x27\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(node);\n    }\n}, tree.traverseBF);\nadd(data, toData, traversal) \x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e\x3cstrong\x3e方法4\/5: \x3ccode\x3eadd(data, toData, traversal)\x3c\/code\x3e\x3c\/strong\x3e\x3c\/h4\x3e\n\x3cp\x3e现在有了一个可以搜索树中特定节点的方法。 让我们定义一个允许向指定节点添加节点的方法。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Tree.prototype.add = function(data, toData, traversal) {\n    var child = new Node(data),\n        parent = null,\n        callback = function(node) {\n            if (node.data === toData) {\n                parent = node;\n            }\n        };\n \n    this.contains(callback, traversal);\n \n    if (parent) {\n        parent.children.push(child);\n        child.parent = parent;\n    } else {\n        throw new Error(\x27Cannot add node to a non-existent parent.\x27);\n    }\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eTree.prototype.add = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edata, toData, traversal\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e child = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Node(data),\n        parent = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e,\n        callback = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3enode\x3c\/span\x3e) \x3c\/span\x3e{\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (node.data === toData) {\n                parent = node;\n            }\n        };\n \n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.contains(callback, traversal);\n \n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (parent) {\n        parent.children.push(child);\n        child.parent = parent;\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27Cannot add node to a non-existent parent.\x27\x3c\/span\x3e);\n    }\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3eadd(data, toData, traversal)\x3c\/code\x3e定义了三个参数。 第一个参数\x3ccode\x3edata\x3c\/code\x3e用来创建一个\x3ccode\x3eNode\x3c\/code\x3e的新实例。 第二个参数\x3ccode\x3etoData\x3c\/code\x3e用来比较树中的每个节点。 第三个参数\x3ccode\x3etraversal\x3c\/code\x3e，是这个方法中用来遍历树的类型。\x3c\/p\x3e\n\x3cp\x3e在\x3ccode\x3eadd(data, toData, traversal)\x3c\/code\x3e函数体内，我们声明了三个变量。 第一个变量\x3ccode\x3echild\x3c\/code\x3e代表初始化的\x3ccode\x3eNode\x3c\/code\x3e实例。 第二个变量\x3ccode\x3eparent\x3c\/code\x3e初始化为\x3ccode\x3enull\x3c\/code\x3e；但是将来会指向匹配\x3ccode\x3etoData\x3c\/code\x3e值的树中的任意节点。\x3ccode\x3eparent\x3c\/code\x3e的重新分配发生在我们声明的第三个变量，这就是\x3ccode\x3ecallback\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3ecallback\x3c\/code\x3e是一个将\x3ccode\x3etoData\x3c\/code\x3e和每一个节点的\x3ccode\x3edata\x3c\/code\x3e属性做比较的函数。 如果\x3ccode\x3eif\x3c\/code\x3e语句的值是\x3ccode\x3etrue\x3c\/code\x3e，那么\x3ccode\x3eparent\x3c\/code\x3e将被赋值给\x3ccode\x3eif\x3c\/code\x3e语句中匹配比较的节点。\x3c\/p\x3e\n\x3cp\x3e每个节点的\x3ccode\x3etoData\x3c\/code\x3e在\x3ccode\x3econtains(callback, traversal)\x3c\/code\x3e中进行比较。遍历类型和\x3ccode\x3ecallback\x3c\/code\x3e必须作为\x3ccode\x3econtains(callback, traversal)\x3c\/code\x3e的参数进行传递。\x3c\/p\x3e\n\x3cp\x3e最后，如果\x3ccode\x3eparent\x3c\/code\x3e不存在于树中，我们将\x3ccode\x3echild\x3c\/code\x3e推入\x3ccode\x3eparent.children\x3c\/code\x3e； 同时也要将\x3ccode\x3eparent\x3c\/code\x3e赋值给\x3ccode\x3echild\x3c\/code\x3e的父级。否则，将抛出错误。\x3c\/p\x3e\n\x3cp\x3e让我们用\x3ccode\x3eadd(data, toData, traversal)\x3c\/code\x3e做个例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var tree = new Tree(\x27CEO\x27);\n \ntree.add(\x27VP of Happiness\x27, \x27CEO\x27, tree.traverseBF);\n \n\/*\n \nour tree\n \n\x27CEO\x27\n└── \x27VP of Happiness\x27\n \n*\/\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e tree = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Tree(\x3cspan class=\x22hljs-string\x22\x3e\x27CEO\x27\x3c\/span\x3e);\n \ntree.add(\x3cspan class=\x22hljs-string\x22\x3e\x27VP of Happiness\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27CEO\x27\x3c\/span\x3e, tree.traverseBF);\n \n\x3cspan class=\x22hljs-comment\x22\x3e\/*\n \nour tree\n \n\x27CEO\x27\n└── \x27VP of Happiness\x27\n \n*\/\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里是\x3ccode\x3eadd(addData, toData, traversal)\x3c\/code\x3e的更加复杂的例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var tree = new Tree(\x27CEO\x27);\n \ntree.add(\x27VP of Happiness\x27, \x27CEO\x27, tree.traverseBF);\ntree.add(\x27VP of Finance\x27, \x27CEO\x27, tree.traverseBF);\ntree.add(\x27VP of Sadness\x27, \x27CEO\x27, tree.traverseBF);\n \ntree.add(\x27Director of Puppies\x27, \x27VP of Finance\x27, tree.traverseBF);\ntree.add(\x27Manager of Puppies\x27, \x27Director of Puppies\x27, tree.traverseBF);\n \n\/*\n \n tree\n \n \x27CEO\x27\n ├── \x27VP of Happiness\x27\n ├── \x27VP of Finance\x27\n │   ├── \x27Director of Puppies\x27\n │   └── \x27Manager of Puppies\x27\n └── \x27VP of Sadness\x27\n \n *\/\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e tree = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Tree(\x3cspan class=\x22hljs-string\x22\x3e\x27CEO\x27\x3c\/span\x3e);\n \ntree.add(\x3cspan class=\x22hljs-string\x22\x3e\x27VP of Happiness\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27CEO\x27\x3c\/span\x3e, tree.traverseBF);\ntree.add(\x3cspan class=\x22hljs-string\x22\x3e\x27VP of Finance\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27CEO\x27\x3c\/span\x3e, tree.traverseBF);\ntree.add(\x3cspan class=\x22hljs-string\x22\x3e\x27VP of Sadness\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27CEO\x27\x3c\/span\x3e, tree.traverseBF);\n \ntree.add(\x3cspan class=\x22hljs-string\x22\x3e\x27Director of Puppies\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27VP of Finance\x27\x3c\/span\x3e, tree.traverseBF);\ntree.add(\x3cspan class=\x22hljs-string\x22\x3e\x27Manager of Puppies\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27Director of Puppies\x27\x3c\/span\x3e, tree.traverseBF);\n \n\x3cspan class=\x22hljs-comment\x22\x3e\/*\n \n tree\n \n \x27CEO\x27\n ├── \x27VP of Happiness\x27\n ├── \x27VP of Finance\x27\n │   ├── \x27Director of Puppies\x27\n │   └── \x27Manager of Puppies\x27\n └── \x27VP of Sadness\x27\n \n *\/\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e\x3cstrong\x3e方法5\/5:\x3ccode\x3eremove(data, fromData, traversal)\x3c\/code\x3e\x3c\/strong\x3e\x3c\/h4\x3e\n\x3cp\x3e为了完成\x3ccode\x3eTree\x3c\/code\x3e的实现，我们将添加一个叫做\x3ccode\x3eremove(data, fromData, traversal)\x3c\/code\x3e的方法。 跟从DOM里面移除节点类似，这个方法将移除一个节点和他的所有子级。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Tree.prototype.remove = function(data, fromData, traversal) {\n    var tree = this,\n        parent = null,\n        childToRemove = null,\n        index;\n \n    var callback = function(node) {\n        if (node.data === fromData) {\n            parent = node;\n        }\n    };\n \n    this.contains(callback, traversal);\n \n    if (parent) {\n        index = findIndex(parent.children, data);\n \n        if (index === undefined) {\n            throw new Error(\x27Node to remove does not exist.\x27);\n        } else {\n            childToRemove = parent.children.splice(index, 1);\n        }\n    } else {\n        throw new Error(\x27Parent does not exist.\x27);\n    }\n \n    return childToRemove;\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eTree.prototype.remove = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edata, fromData, traversal\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e tree = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e,\n        parent = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e,\n        childToRemove = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e,\n        index;\n \n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e callback = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3enode\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (node.data === fromData) {\n            parent = node;\n        }\n    };\n \n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.contains(callback, traversal);\n \n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (parent) {\n        index = findIndex(parent.children, data);\n \n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (index === \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e) {\n            \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27Node to remove does not exist.\x27\x3c\/span\x3e);\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n            childToRemove = parent.children.splice(index, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\n        }\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27Parent does not exist.\x27\x3c\/span\x3e);\n    }\n \n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e childToRemove;\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e与\x3ccode\x3eadd(data, toData, traversal)\x3c\/code\x3e类似，移除将遍历树以查找包含第二个参数的节点，现在为\x3ccode\x3efromData\x3c\/code\x3e。 如果这个节点被发现了，那么\x3ccode\x3eparent\x3c\/code\x3e将指向它。\x3c\/p\x3e\n\x3cp\x3e在这时候，我们到达了第一个\x3ccode\x3eif\x3c\/code\x3e语句。 如果parent不存在，将抛出错误。 如果\x3ccode\x3eparent\x3c\/code\x3e不存在，我们使用\x3ccode\x3eparent.children\x3c\/code\x3e调用\x3ccode\x3efindIndex（）\x3c\/code\x3e和我们要从\x3ccode\x3eparent\x3c\/code\x3e节点的子节点中删除的数据 （\x3ccode\x3efindIndex（）\x3c\/code\x3e是一个帮助方法，我将在下面定义。）\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function findIndex(arr, data) {\n    var index;\n \n    for (var i = 0; i \x3c arr.length; i\x2b\x2b) {\n        if (arr[i].data === data) {\n            index = i;\n        }\n    }\n \n    return index;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efindIndex\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3earr, data\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e index;\n \n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; arr.length; i\x2b\x2b) {\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (arr[i].data === data) {\n            index = i;\n        }\n    }\n \n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e index;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在\x3ccode\x3efindIndex()\x3c\/code\x3e里面，以下逻辑将发生。 如果\x3ccode\x3eparent.children\x3c\/code\x3e中的任意一个节点包含匹配\x3ccode\x3edata\x3c\/code\x3e值的数据,那么变量\x3ccode\x3eindex\x3c\/code\x3e赋值为一个整数。 如果没有子级的数值属性匹配\x3ccode\x3edata\x3c\/code\x3e，那么index保留他的默认值\x3ccode\x3eundefined\x3c\/code\x3e。 在最后一行的\x3ccode\x3efindIndex()\x3c\/code\x3e方法，我们返回一个index。\x3c\/p\x3e\n\x3cp\x3e我们现在去\x3ccode\x3eremove(data, fromData, traversal) \x3c\/code\x3e如果\x3ccode\x3eindex\x3c\/code\x3e的值是\x3ccode\x3eundefined\x3c\/code\x3e，将会抛出错误。 如果\x3ccode\x3eindex\x3c\/code\x3e的值存在，我们用它来拼接我们想从\x3ccode\x3eparent\x3c\/code\x3e的子节点中删除的节点。同样我们给删除的子级赋值为\x3ccode\x3echildToRemove\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e最后，我们返回\x3ccode\x3echildToRemove\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader9\x22\x3e\x3cstrong\x3e树的的完整实现\x3c\/strong\x3e\x3c\/h1\x3e\n\x3cp\x3e到此为止\x3ccode\x3eTree\x3c\/code\x3e已经完全实现。回过头看看，我们到底完成了多少工作：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\nfunction Node(data) {\n    this.data = data;\n    this.parent = null;\n    this.children = [];\n}\n \nfunction Tree(data) {\n    var node = new Node(data);\n    this._root = node;\n}\n \nTree.prototype.traverseDF = function(callback) {\n \n    \/\/ this is a recurse and immediately-invoking function\n    (function recurse(currentNode) {\n        \/\/ step 2\n        for (var i = 0, length = currentNode.children.length; i \x3c length; i\x2b\x2b) {\n            \/\/ step 3\n            recurse(currentNode.children[i]);\n        }\n \n        \/\/ step 4\n        callback(currentNode);\n \n        \/\/ step 1\n    })(this._root);\n \n};\n \nTree.prototype.traverseBF = function(callback) {\n    var queue = new Queue();\n \n    queue.enqueue(this._root);\n \n    currentTree = queue.dequeue();\n \n    while(currentTree){\n        for (var i = 0, length = currentTree.children.length; i \x3c length; i\x2b\x2b) {\n            queue.enqueue(currentTree.children[i]);\n        }\n \n        callback(currentTree);\n        currentTree = queue.dequeue();\n    }\n};\n \nTree.prototype.contains = function(callback, traversal) {\n    traversal.call(this, callback);\n};\n \nTree.prototype.add = function(data, toData, traversal) {\n    var child = new Node(data),\n        parent = null,\n        callback = function(node) {\n            if (node.data === toData) {\n                parent = node;\n            }\n        };\n \n    this.contains(callback, traversal);\n \n    if (parent) {\n        parent.children.push(child);\n        child.parent = parent;\n    } else {\n        throw new Error(\x27Cannot add node to a non-existent parent.\x27);\n    }\n};\n \nTree.prototype.remove = function(data, fromData, traversal) {\n    var tree = this,\n        parent = null,\n        childToRemove = null,\n        index;\n \n    var callback = function(node) {\n        if (node.data === fromData) {\n            parent = node;\n        }\n    };\n \n    this.contains(callback, traversal);\n \n    if (parent) {\n        index = findIndex(parent.children, data);\n \n        if (index === undefined) {\n            throw new Error(\x27Node to remove does not exist.\x27);\n        } else {\n            childToRemove = parent.children.splice(index, 1);\n        }\n    } else {\n        throw new Error(\x27Parent does not exist.\x27);\n    }\n \n    return childToRemove;\n};\n \nfunction findIndex(arr, data) {\n    var index;\n \n    for (var i = 0; i \x3c arr.length; i\x2b\x2b) {\n        if (arr[i].data === data) {\n            index = i;\n        }\n    }\n \n    return index;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eNode\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.data = data;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.parent = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.children = [];\n}\n \n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eTree\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e node = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Node(data);\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._root = node;\n}\n \nTree.prototype.traverseDF = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ecallback\x3c\/span\x3e) \x3c\/span\x3e{\n \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ this is a recurse and immediately-invoking function\x3c\/span\x3e\n    (\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3erecurse\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ecurrentNode\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ step 2\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, length = currentNode.children.length; i \x26lt; length; i\x2b\x2b) {\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ step 3\x3c\/span\x3e\n            recurse(currentNode.children[i]);\n        }\n \n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ step 4\x3c\/span\x3e\n        callback(currentNode);\n \n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ step 1\x3c\/span\x3e\n    })(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._root);\n \n};\n \nTree.prototype.traverseBF = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ecallback\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e queue = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Queue();\n \n    queue.enqueue(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._root);\n \n    currentTree = queue.dequeue();\n \n    \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e(currentTree){\n        \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, length = currentTree.children.length; i \x26lt; length; i\x2b\x2b) {\n            queue.enqueue(currentTree.children[i]);\n        }\n \n        callback(currentTree);\n        currentTree = queue.dequeue();\n    }\n};\n \nTree.prototype.contains = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ecallback, traversal\x3c\/span\x3e) \x3c\/span\x3e{\n    traversal.call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, callback);\n};\n \nTree.prototype.add = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edata, toData, traversal\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e child = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Node(data),\n        parent = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e,\n        callback = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3enode\x3c\/span\x3e) \x3c\/span\x3e{\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (node.data === toData) {\n                parent = node;\n            }\n        };\n \n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.contains(callback, traversal);\n \n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (parent) {\n        parent.children.push(child);\n        child.parent = parent;\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27Cannot add node to a non-existent parent.\x27\x3c\/span\x3e);\n    }\n};\n \nTree.prototype.remove = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edata, fromData, traversal\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e tree = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e,\n        parent = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e,\n        childToRemove = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e,\n        index;\n \n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e callback = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3enode\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (node.data === fromData) {\n            parent = node;\n        }\n    };\n \n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.contains(callback, traversal);\n \n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (parent) {\n        index = findIndex(parent.children, data);\n \n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (index === \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e) {\n            \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27Node to remove does not exist.\x27\x3c\/span\x3e);\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n            childToRemove = parent.children.splice(index, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\n        }\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27Parent does not exist.\x27\x3c\/span\x3e);\n    }\n \n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e childToRemove;\n};\n \n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efindIndex\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3earr, data\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e index;\n \n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; arr.length; i\x2b\x2b) {\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (arr[i].data === data) {\n            index = i;\n        }\n    }\n \n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e index;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch1 id=\x22articleHeader10\x22\x3e\x3cstrong\x3e总结\x3c\/strong\x3e\x3c\/h1\x3e\n\x3cp\x3e树可以用来模拟分层数据。我们周围有许多类似这种类型的层次结构，例如网页和族谱。当你发现自己需要使用层次结构来结构化数据时，可以考虑使用树。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e 欢迎扫描二维码关注公众号，每天推送我翻译的技术文章。\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVRyYe?w=430\x26amp;h=430\x22 src=\x22https:\/\/static.alili.tech\/img\/bVRyYe?w=430\x26amp;h=430\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>【译】JavaScript数据结构（4）：树</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000010345441">https://segmentfault.com/a/1190000010345441</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/95lqazllq5m/" target="_blank">https://alili.tech/archive/95lqazllq5m/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>