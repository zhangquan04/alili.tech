<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="WebViewJavascriptBridge原理解析"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>WebViewJavascriptBridge原理解析 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/iw3pn1g3s7/",
				"appid": "1613049289050283", 
				"title": "WebViewJavascriptBridge原理解析 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-17T02:30:25"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/oi6abiw4f3b/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/t3hi4duhnk/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fiw3pn1g3s7%2f&text=WebViewJavascriptBridge%e5%8e%9f%e7%90%86%e8%a7%a3%e6%9e%90"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fiw3pn1g3s7%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fiw3pn1g3s7%2f&text=WebViewJavascriptBridge%e5%8e%9f%e7%90%86%e8%a7%a3%e6%9e%90"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fiw3pn1g3s7%2f&title=WebViewJavascriptBridge%e5%8e%9f%e7%90%86%e8%a7%a3%e6%9e%90"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fiw3pn1g3s7%2f&is_video=false&description=WebViewJavascriptBridge%e5%8e%9f%e7%90%86%e8%a7%a3%e6%9e%90"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=WebViewJavascriptBridge%e5%8e%9f%e7%90%86%e8%a7%a3%e6%9e%90&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fiw3pn1g3s7%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fiw3pn1g3s7%2f&title=WebViewJavascriptBridge%e5%8e%9f%e7%90%86%e8%a7%a3%e6%9e%90"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fiw3pn1g3s7%2f&title=WebViewJavascriptBridge%e5%8e%9f%e7%90%86%e8%a7%a3%e6%9e%90"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fiw3pn1g3s7%2f&title=WebViewJavascriptBridge%e5%8e%9f%e7%90%86%e8%a7%a3%e6%9e%90"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fiw3pn1g3s7%2f&title=WebViewJavascriptBridge%e5%8e%9f%e7%90%86%e8%a7%a3%e6%9e%90"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">WebViewJavascriptBridge原理解析</h1><div class="meta"><div class="postdate"><time datetime="2019-01-17" itemprop="datePublished">2019-01-17</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch2 id=\x22articleHeader0\x22\x3e基本说明\x3c\/h2\x3e\n\x3cp\x3e我们的项目是一个OC与javascript重度交互的app，OC与javascript交互的那部分是在\x3ca href=\x22https:\/\/github.com\/marcuswestin\/WebViewJavascriptBridge\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eWebViewJavascriptBridge的github地址\x3c\/a\x3e的基础上修改的，WebViewJavascriptBridge应该是当前最流行最成功的OC与Web交互实现了。最近看了一下他的实现原理，顺便也为后面项目扩展打下基础。\x3cbr\x3e为了简化讲解过程，我忽略了UIWebView的实现过程，只解析WKWebView的实现过程。\x3c\/p\x3e\n\x3cp\x3e我们可以在OC中调用javascript方法，但是反过来不能在javascript中调用OC方法。所以\x3ccode\x3eWebViewJavascriptBridge\x3c\/code\x3e的实现过程就是在OC环境和javascript环境各自保存一个相互调用的信息。每一个调用之间都有id和callbackid来找到两个环境对应的处理。下图是我对于每个类的讲解：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000008948597?w=906\x26amp;h=614\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000008948597?w=906\x26amp;h=614\x22 alt=\x22img\x22 title=\x22img\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3enouse文件夹下面的文件是与UIWebView相关的东西，我们暂时不管，基本原理和WKWebView一样。其中\x3ccode\x3eWebViewJavascriptBridge_JS.m\x3c\/code\x3e中是javascript代码，为了方便理解，我直接新建了一个\x3ccode\x3eWebViewJavascriptBridge_JS.js\x3c\/code\x3e文件来代替，方便后面解析。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eWebViewJavascriptBridge_JS.js\x3c\/code\x3e文件中是javascript环境的bridge初始化和处理，里面负责接收oc发给javascript的消息，并且把javascript环境的消息发送给oc。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eWKWebViewJavascriptBridge.m\x3c\/code\x3e主要负责OC环境的消息处理，并且把OC环境的消息发送给javascript环境。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eWebViewJavascriptBridgeBase.m\x3c\/code\x3e主要实现了OC环境的bridge初始化和处理。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eExampleApp.html\x3c\/code\x3e主要用于模拟生产环境下的web端。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e初始化过程\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e1、OC环境初始化\x3c\/h3\x3e\n\x3cp\x3e我们从OC环境的初始化开始。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/初始化一个OC环境的桥WKWebViewJavascriptBridge并且初始化。\n\x2b (instancetype)bridgeForWebView:(WKWebView*)webView {\n    WKWebViewJavascriptBridge* bridge = [[self alloc] init];\n    \/\/调用下面那个方法\n    [bridge _setupInstance:webView];\n    [bridge reset];\n    return bridge;\n}\n\/\/初始化\n- (void) _setupInstance:(WKWebView*)webView {\n    _webView = webView;\n    _webView.navigationDelegate = self;\n    _base = [[WebViewJavascriptBridgeBase alloc] init];\n    _base.delegate = self;\n}\n\n\/\/messageHandlers用于保存OC环境注册的方法，key是方法名，value是这个方法对应的回调block\n\/\/startupMessageQueue用于保存是实话过程中需要发送给javascirpt环境的消息。\n\/\/responseCallbacks用于保存OC于javascript环境相互调用的回调模块。通过_uniqueId加上时间戳来确定每个调用的回调。\n- (id)init {\n    if (self = [super init]) {\n        self.messageHandlers = [NSMutableDictionary dictionary];\n        self.startupMessageQueue = [NSMutableArray array];\n        self.responseCallbacks = [NSMutableDictionary dictionary];\n        _uniqueId = 0;\n    }\n    return self;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs objectivec\x22\x3e\x3ccode class=\x22objc\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/初始化一个OC环境的桥WKWebViewJavascriptBridge并且初始化。\x3c\/span\x3e\n\x2b (\x3cspan class=\x22hljs-keyword\x22\x3einstancetype\x3c\/span\x3e)bridgeForWebView:(\x3cspan class=\x22hljs-built_in\x22\x3eWKWebView\x3c\/span\x3e*)webView {\n    \x3cspan class=\x22hljs-built_in\x22\x3eWKWebViewJavascriptBridge\x3c\/span\x3e* bridge = [[\x3cspan class=\x22hljs-keyword\x22\x3eself\x3c\/span\x3e alloc] init];\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/调用下面那个方法\x3c\/span\x3e\n    [bridge _setupInstance:webView];\n    [bridge reset];\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e bridge;\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/初始化\x3c\/span\x3e\n- (\x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e) _setupInstance:(\x3cspan class=\x22hljs-built_in\x22\x3eWKWebView\x3c\/span\x3e*)webView {\n    _webView = webView;\n    _webView.navigationDelegate = \x3cspan class=\x22hljs-keyword\x22\x3eself\x3c\/span\x3e;\n    _base = [[WebViewJavascriptBridgeBase alloc] init];\n    _base.delegate = \x3cspan class=\x22hljs-keyword\x22\x3eself\x3c\/span\x3e;\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/messageHandlers用于保存OC环境注册的方法，key是方法名，value是这个方法对应的回调block\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/startupMessageQueue用于保存是实话过程中需要发送给javascirpt环境的消息。\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/responseCallbacks用于保存OC于javascript环境相互调用的回调模块。通过_uniqueId加上时间戳来确定每个调用的回调。\x3c\/span\x3e\n- (\x3cspan class=\x22hljs-keyword\x22\x3eid\x3c\/span\x3e)init {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3eself\x3c\/span\x3e = [\x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e init]) {\n        \x3cspan class=\x22hljs-keyword\x22\x3eself\x3c\/span\x3e.messageHandlers = [\x3cspan class=\x22hljs-built_in\x22\x3eNSMutableDictionary\x3c\/span\x3e dictionary];\n        \x3cspan class=\x22hljs-keyword\x22\x3eself\x3c\/span\x3e.startupMessageQueue = [\x3cspan class=\x22hljs-built_in\x22\x3eNSMutableArray\x3c\/span\x3e array];\n        \x3cspan class=\x22hljs-keyword\x22\x3eself\x3c\/span\x3e.responseCallbacks = [\x3cspan class=\x22hljs-built_in\x22\x3eNSMutableDictionary\x3c\/span\x3e dictionary];\n        _uniqueId = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eself\x3c\/span\x3e;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e所有与javascript之间交互的信息都存储在\x3ccode\x3emessageHandlers\x3c\/code\x3e和\x3ccode\x3eresponseCallbacks\x3c\/code\x3e中。这两个属性记录了OC环境与javascript交互的信息。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e2、OC环境注册方法\x3c\/h3\x3e\n\x3cp\x3e注册一个OC方法\x3ccode\x3eOC提供方法给JS调用\x3c\/code\x3e给javascript调用，并且把他的回调实现保存在\x3ccode\x3emessageHandlers\x3c\/code\x3e中。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22[_bridge registerHandler:@\x26quot;OC提供方法给JS调用\x26quot; handler:^(id data, WVJBResponseCallback responseCallback) {\n    \/\/NSLog(@\x26quot;testObjcCallback called: %@\x26quot;, data);\n    responseCallback(@\x26quot;OC发给JS的返回值\x26quot;);\n}];\n\n- (void)registerHandler:(NSString *)handlerName handler:(WVJBHandler)handler {\n    _base.messageHandlers[handlerName] = [handler copy];\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs aspectj\x22\x3e\x3ccode class=\x22objc\x22\x3e[_bridge registerHandler:@\x3cspan class=\x22hljs-string\x22\x3e\x22OC提供方法给JS调用\x22\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ehandler\x3c\/span\x3e:^(id data, WVJBResponseCallback responseCallback) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/NSLog(@\x22testObjcCallback called: %@\x22, data);\x3c\/span\x3e\n    responseCallback(@\x3cspan class=\x22hljs-string\x22\x3e\x22OC发给JS的返回值\x22\x3c\/span\x3e);\n}];\n\n- (\x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e)registerHandler:(NSString *)handlerName \x3cspan class=\x22hljs-keyword\x22\x3ehandler\x3c\/span\x3e:(WVJBHandler)\x3cspan class=\x22hljs-keyword\x22\x3ehandler\x3c\/span\x3e {\n    _base.messageHandlers[handlerName] = [\x3cspan class=\x22hljs-keyword\x22\x3ehandler\x3c\/span\x3e copy];\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e3、Web环境初始化\x3c\/h3\x3e\n\x3cp\x3e加载Web环境的html,这里就是\x3ccode\x3eExampleAPP.html\x3c\/code\x3e文件,我删除了非关键部分。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function setupWebViewJavascriptBridge(callback) {\n     \/\/第一次调用这个方法的时候，为false\n    if (window.WebViewJavascriptBridge) {\n        var result = callback(WebViewJavascriptBridge);\n        return result;\n    }\n    \/\/第一次调用的时候，也是false\n    if (window.WVJBCallbacks) {\n        var result = window.WVJBCallbacks.push(callback);\n        return result;\n    }\n    \/\/把callback对象赋值给对象。\n    window.WVJBCallbacks = [callback];\n    \/\/这段代码的意思就是执行加载WebViewJavascriptBridge_JS.js中代码的作用\n    var WVJBIframe = document.createElement(\x27iframe\x27);\n    WVJBIframe.style.display = \x27none\x27;\n    WVJBIframe.src = \x27https:\/\/__bridge_loaded__\x27;\n    document.documentElement.appendChild(WVJBIframe);\n    setTimeout(function() {\n        document.documentElement.removeChild(WVJBIframe)\n    }, 0);\n}\n\n\/\/setupWebViewJavascriptBridge执行的时候传入的参数，这是一个方法。\nfunction callback(bridge) {\n    var uniqueId = 1\n    \/\/把WEB中要注册的方法注册到bridge里面\n    bridge.registerHandler(\x27OC调用JS提供的方法\x27, function(data, responseCallback) {\n        log(\x27OC调用JS方法成功\x27, data)\n        var responseData = { \x27JS给OC调用的回调\x27:\x27回调值!\x27 }\n        log(\x27OC调用JS的返回值\x27, responseData)\n        responseCallback(responseData)\n    })\n};\n\/\/驱动所有hander的初始化\nsetupWebViewJavascriptBridge(callback);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3esetupWebViewJavascriptBridge\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ecallback\x3c\/span\x3e) \x3c\/span\x3e{\n     \x3cspan class=\x22hljs-comment\x22\x3e\/\/第一次调用这个方法的时候，为false\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.WebViewJavascriptBridge) {\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e result = callback(WebViewJavascriptBridge);\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e result;\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/第一次调用的时候，也是false\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.WVJBCallbacks) {\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e result = \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.WVJBCallbacks.push(callback);\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e result;\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/把callback对象赋值给对象。\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.WVJBCallbacks = [callback];\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/这段代码的意思就是执行加载WebViewJavascriptBridge_JS.js中代码的作用\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e WVJBIframe = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.createElement(\x3cspan class=\x22hljs-string\x22\x3e\x27iframe\x27\x3c\/span\x3e);\n    WVJBIframe.style.display = \x3cspan class=\x22hljs-string\x22\x3e\x27none\x27\x3c\/span\x3e;\n    WVJBIframe.src = \x3cspan class=\x22hljs-string\x22\x3e\x27https:\/\/__bridge_loaded__\x27\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.documentElement.appendChild(WVJBIframe);\n    setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.documentElement.removeChild(WVJBIframe)\n    }, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/setupWebViewJavascriptBridge执行的时候传入的参数，这是一个方法。\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecallback\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ebridge\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e uniqueId = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/把WEB中要注册的方法注册到bridge里面\x3c\/span\x3e\n    bridge.registerHandler(\x3cspan class=\x22hljs-string\x22\x3e\x27OC调用JS提供的方法\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edata, responseCallback\x3c\/span\x3e) \x3c\/span\x3e{\n        log(\x3cspan class=\x22hljs-string\x22\x3e\x27OC调用JS方法成功\x27\x3c\/span\x3e, data)\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e responseData = { \x3cspan class=\x22hljs-string\x22\x3e\x27JS给OC调用的回调\x27\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x27回调值!\x27\x3c\/span\x3e }\n        log(\x3cspan class=\x22hljs-string\x22\x3e\x27OC调用JS的返回值\x27\x3c\/span\x3e, responseData)\n        responseCallback(responseData)\n    })\n};\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/驱动所有hander的初始化\x3c\/span\x3e\nsetupWebViewJavascriptBridge(callback);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们调用\x3ccode\x3esetupWebViewJavascriptBridge\x3c\/code\x3e函数，并且这个函数传入的callback也是一个函数。callback函数中有我们在javascript环境中注册的\x3ccode\x3eOC调用JS提供的方法\x3c\/code\x3e方法。\x3ccode\x3esetupWebViewJavascriptBridge\x3c\/code\x3e的实现过程中我们可以发现，如果不是第一次初始化，会通过\x3ccode\x3ewindow.WebViewJavascriptBridge\x3c\/code\x3e或者\x3ccode\x3ewindow.WVJBCallbacks\x3c\/code\x3e两个判断返回。\x3c\/p\x3e\n\x3cp\x3eiframe可以理解为webview中的窗口，当我们改变iframe的src属性的时候，相当于我们浏览器实现了链接的跳转。比如从\x3ccode\x3ewww.baidu.com\x3c\/code\x3e跳转到\x3ccode\x3ewww.google.com\x3c\/code\x3e。下面这段代码的目的就是实现一个到\x3ccode\x3ehttps:\/\/__bridge_loaded__\x3c\/code\x3e的跳转。从而达到初始化javascript环境的bridge的作用。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/这段代码的意思就是执行加载WebViewJavascriptBridge_JS.js中代码的作用\nvar WVJBIframe = document.createElement(\x27iframe\x27);\nWVJBIframe.style.display = \x27none\x27;\nWVJBIframe.src = \x27https:\/\/__bridge_loaded__\x27;\ndocument.documentElement.appendChild(WVJBIframe);\nsetTimeout(function() {\n    document.documentElement.removeChild(WVJBIframe)\n}, 0);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/这段代码的意思就是执行加载WebViewJavascriptBridge_JS.js中代码的作用\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e WVJBIframe = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.createElement(\x3cspan class=\x22hljs-string\x22\x3e\x27iframe\x27\x3c\/span\x3e);\nWVJBIframe.style.display = \x3cspan class=\x22hljs-string\x22\x3e\x27none\x27\x3c\/span\x3e;\nWVJBIframe.src = \x3cspan class=\x22hljs-string\x22\x3e\x27https:\/\/__bridge_loaded__\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.documentElement.appendChild(WVJBIframe);\nsetTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.documentElement.removeChild(WVJBIframe)\n}, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们知道只要webview有跳转，就会调用webview的代理方法。我们重点看下面这个代理方法。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler {\n    if (webView != _webView) { return; }\n    NSURL *url = navigationAction.request.URL;\n    NSLog(@\x26quot;点开URL%@\x26quot;,url);\n    __strong typeof(_webViewDelegate) strongDelegate = _webViewDelegate;\n    \/\/如果是WebViewJavascriptBridge发送或者接受的消息，则特殊处理。否则按照正常流程处理。\n    if ([_base isWebViewJavascriptBridgeURL:url]) {\n        \/\/1第一次注入JS代码\n        if ([_base isBridgeLoadedURL:url]) {\n            [_base injectJavascriptFile];\n        \/\/处理WEB发过来的消息\n        } else if ([_base isQueueMessageURL:url]) {\n            [self WKFlushMessageQueue];\n        } else {\n            [_base logUnkownMessage:url];\n        }\n        decisionHandler(WKNavigationActionPolicyCancel);\n    }\n    \/\/下面是webview的正常代理执行流程，不用管。\n    if (strongDelegate \x26amp;\x26amp; [strongDelegate respondsToSelector:@selector(webView:decidePolicyForNavigationAction:decisionHandler:)]) {\n        [_webViewDelegate webView:webView decidePolicyForNavigationAction:navigationAction decisionHandler:decisionHandler];\n    } else {\n        decisionHandler(WKNavigationActionPolicyAllow);\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs groovy\x22\x3e\x3ccode class=\x22objc\x22\x3e- (\x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e)\x3cspan class=\x22hljs-string\x22\x3ewebView:\x3c\/span\x3e(WKWebView *)webView \x3cspan class=\x22hljs-string\x22\x3edecidePolicyForNavigationAction:\x3c\/span\x3e(WKNavigationAction *)navigationAction \x3cspan class=\x22hljs-string\x22\x3edecisionHandler:\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e (^)(WKNavigationActionPolicy))decisionHandler {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (webView != _webView) { \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e; }\n    NSURL *url = navigationAction.request.URL;\n    NSLog(@\x3cspan class=\x22hljs-string\x22\x3e\x22点开URL%@\x22\x3c\/span\x3e,url);\n    __strong typeof(_webViewDelegate) strongDelegate = _webViewDelegate;\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果是WebViewJavascriptBridge发送或者接受的消息，则特殊处理。否则按照正常流程处理。\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ([_base \x3cspan class=\x22hljs-string\x22\x3eisWebViewJavascriptBridgeURL:\x3c\/span\x3eurl]) {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/1第一次注入JS代码\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ([_base \x3cspan class=\x22hljs-string\x22\x3eisBridgeLoadedURL:\x3c\/span\x3eurl]) {\n            [_base injectJavascriptFile];\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/处理WEB发过来的消息\x3c\/span\x3e\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ([_base \x3cspan class=\x22hljs-string\x22\x3eisQueueMessageURL:\x3c\/span\x3eurl]) {\n            [self WKFlushMessageQueue];\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n            [_base \x3cspan class=\x22hljs-string\x22\x3elogUnkownMessage:\x3c\/span\x3eurl];\n        }\n        decisionHandler(WKNavigationActionPolicyCancel);\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/下面是webview的正常代理执行流程，不用管。\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (strongDelegate \x26amp;\x26amp; [strongDelegate \x3cspan class=\x22hljs-string\x22\x3erespondsToSelector:\x3c\/span\x3e\x3cspan class=\x22hljs-meta\x22\x3e@selector\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3ewebView:\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3edecidePolicyForNavigationAction:\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3edecisionHandler:\x3c\/span\x3e)]) {\n        [_webViewDelegate \x3cspan class=\x22hljs-string\x22\x3ewebView:\x3c\/span\x3ewebView \x3cspan class=\x22hljs-string\x22\x3edecidePolicyForNavigationAction:\x3c\/span\x3enavigationAction \x3cspan class=\x22hljs-string\x22\x3edecisionHandler:\x3c\/span\x3edecisionHandler];\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        decisionHandler(WKNavigationActionPolicyAllow);\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在这段代码中，我们首先通过\x3ccode\x3e[_base isWebViewJavascriptBridgeURL:url]\x3c\/code\x3e来判断是否是普通的跳转还是\x3ccode\x3ewebViewjavascriptBridege\x3c\/code\x3e的跳转。如果是\x3ccode\x3e__bridge_loaded__\x3c\/code\x3e表示是初始化javascript环境的消息，如果是\x3ccode\x3e__wvjb_queue_message__\x3c\/code\x3e则表示是发送javascript消息。\x3ccode\x3ehttps:\/\/__bridge_loaded__\x3c\/code\x3e显然是第一种消息。OC具体具体判断逻辑代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22#define kOldProtocolScheme @\x26quot;wvjbscheme\x26quot;\n#define kNewProtocolScheme @\x26quot;https\x26quot;\n#define kQueueHasMessage   @\x26quot;__wvjb_queue_message__\x26quot;\n#define kBridgeLoaded      @\x26quot;__bridge_loaded__\x26quot;\n\n\/\/是否是WebViewJavascriptBridge框架相关的链接\n- (BOOL)isWebViewJavascriptBridgeURL:(NSURL*)url {\n    if (![self isSchemeMatch:url]) {\n        return NO;\n    }\n    BOOL result =  [self isBridgeLoadedURL:url] || [self isQueueMessageURL:url];\n    return result;\n}\n\/*\n    是否是WebViewJavascriptBridge发送或者接受的消息\n *\/\n- (BOOL)isSchemeMatch:(NSURL*)url {\n    NSString* scheme = url.scheme.lowercaseString;\n    BOOL result = [scheme isEqualToString:kNewProtocolScheme] || [scheme isEqualToString:kOldProtocolScheme];\n    return result;\n}\n\/\/是WebViewJavascriptBridge发送的消息还是WebViewJavascriptBridge的初始化消息。\n- (BOOL)isQueueMessageURL:(NSURL*)url {\n    NSString* host = url.host.lowercaseString;\n    return [self isSchemeMatch:url] \x26amp;\x26amp; [host isEqualToString:kQueueHasMessage];\n}\n\/\/是否是https:\/\/__bridge_loaded__这种初始化加载消息\n- (BOOL)isBridgeLoadedURL:(NSURL*)url {\n    NSString* host = url.host.lowercaseString;\n    BOOL result = [self isSchemeMatch:url] \x26amp;\x26amp; [host isEqualToString:kBridgeLoaded];\n    return result;\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs objectivec\x22\x3e\x3ccode class=\x22objc\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3e#define kOldProtocolScheme @\x3cspan class=\x22hljs-meta-string\x22\x3e\x22wvjbscheme\x22\x3c\/span\x3e\x3c\/span\x3e\n\x3cspan class=\x22hljs-meta\x22\x3e#define kNewProtocolScheme @\x3cspan class=\x22hljs-meta-string\x22\x3e\x22https\x22\x3c\/span\x3e\x3c\/span\x3e\n\x3cspan class=\x22hljs-meta\x22\x3e#define kQueueHasMessage   @\x3cspan class=\x22hljs-meta-string\x22\x3e\x22__wvjb_queue_message__\x22\x3c\/span\x3e\x3c\/span\x3e\n\x3cspan class=\x22hljs-meta\x22\x3e#define kBridgeLoaded      @\x3cspan class=\x22hljs-meta-string\x22\x3e\x22__bridge_loaded__\x22\x3c\/span\x3e\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/是否是WebViewJavascriptBridge框架相关的链接\x3c\/span\x3e\n- (\x3cspan class=\x22hljs-built_in\x22\x3eBOOL\x3c\/span\x3e)isWebViewJavascriptBridgeURL:(\x3cspan class=\x22hljs-built_in\x22\x3eNSURL\x3c\/span\x3e*)url {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (![\x3cspan class=\x22hljs-keyword\x22\x3eself\x3c\/span\x3e isSchemeMatch:url]) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3eNO\x3c\/span\x3e;\n    }\n    \x3cspan class=\x22hljs-built_in\x22\x3eBOOL\x3c\/span\x3e result =  [\x3cspan class=\x22hljs-keyword\x22\x3eself\x3c\/span\x3e isBridgeLoadedURL:url] || [\x3cspan class=\x22hljs-keyword\x22\x3eself\x3c\/span\x3e isQueueMessageURL:url];\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e result;\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/*\n    是否是WebViewJavascriptBridge发送或者接受的消息\n *\/\x3c\/span\x3e\n- (\x3cspan class=\x22hljs-built_in\x22\x3eBOOL\x3c\/span\x3e)isSchemeMatch:(\x3cspan class=\x22hljs-built_in\x22\x3eNSURL\x3c\/span\x3e*)url {\n    \x3cspan class=\x22hljs-built_in\x22\x3eNSString\x3c\/span\x3e* scheme = url.scheme.lowercaseString;\n    \x3cspan class=\x22hljs-built_in\x22\x3eBOOL\x3c\/span\x3e result = [scheme isEqualToString:kNewProtocolScheme] || [scheme isEqualToString:kOldProtocolScheme];\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e result;\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/是WebViewJavascriptBridge发送的消息还是WebViewJavascriptBridge的初始化消息。\x3c\/span\x3e\n- (\x3cspan class=\x22hljs-built_in\x22\x3eBOOL\x3c\/span\x3e)isQueueMessageURL:(\x3cspan class=\x22hljs-built_in\x22\x3eNSURL\x3c\/span\x3e*)url {\n    \x3cspan class=\x22hljs-built_in\x22\x3eNSString\x3c\/span\x3e* host = url.host.lowercaseString;\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e [\x3cspan class=\x22hljs-keyword\x22\x3eself\x3c\/span\x3e isSchemeMatch:url] \x26amp;\x26amp; [host isEqualToString:kQueueHasMessage];\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/是否是https:\/\/__bridge_loaded__这种初始化加载消息\x3c\/span\x3e\n- (\x3cspan class=\x22hljs-built_in\x22\x3eBOOL\x3c\/span\x3e)isBridgeLoadedURL:(\x3cspan class=\x22hljs-built_in\x22\x3eNSURL\x3c\/span\x3e*)url {\n    \x3cspan class=\x22hljs-built_in\x22\x3eNSString\x3c\/span\x3e* host = url.host.lowercaseString;\n    \x3cspan class=\x22hljs-built_in\x22\x3eBOOL\x3c\/span\x3e result = [\x3cspan class=\x22hljs-keyword\x22\x3eself\x3c\/span\x3e isSchemeMatch:url] \x26amp;\x26amp; [host isEqualToString:kBridgeLoaded];\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e result;\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e接下来调用\x3ccode\x3e[_base injectJavascriptFile]\x3c\/code\x3e方法，这个方法的作用就是把\x3ccode\x3eWebViewJavascriptBridge_JS.js\x3c\/code\x3e中的方法注入到webview中并且执行，从而达到初始化javascript环境的brige的作用。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/初始化的是否注入WebViewJavascriptBridge_JS.js\n- (void)injectJavascriptFile {\n    NSString *js;\n    \/\/WebViewJavascriptBridge_JS.js文件内容其实就是WebViewJavascriptBridge_JS.m对应的内容，我只是把它整理方便阅读。\n    if (true) {\n        js = [NSString stringWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@\x26quot;WebViewJavascriptBridge_JS.js\x26quot; ofType:nil] encoding:NSUTF8StringEncoding error:nil];\n    }else{\n        js = WebViewJavascriptBridge_js();\n    }\n    \/\/把javascript代码注入webview中执行,这里执行具体的注入操作。\n    [self _evaluateJavascript:js];\n    \/\/如果javascript环境初始化完成以后，有startupMessageQueue消息。则立即发送消息。\n    if (self.startupMessageQueue) {\n        NSArray* queue = self.startupMessageQueue;\n        self.startupMessageQueue = nil;\n        for (id queuedMessage in queue) {\n            [self _dispatchMessage:queuedMessage];\n        }\n    }\n}\n\/\/把javascript代码写入webview\n- (NSString*) _evaluateJavascript:(NSString*)javascriptCommand {\n    [_webView evaluateJavaScript:javascriptCommand completionHandler:nil];\n    return NULL;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs objectivec\x22\x3e\x3ccode class=\x22objc\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/初始化的是否注入WebViewJavascriptBridge_JS.js\x3c\/span\x3e\n- (\x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e)injectJavascriptFile {\n    \x3cspan class=\x22hljs-built_in\x22\x3eNSString\x3c\/span\x3e *js;\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/WebViewJavascriptBridge_JS.js文件内容其实就是WebViewJavascriptBridge_JS.m对应的内容，我只是把它整理方便阅读。\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e) {\n        js = [\x3cspan class=\x22hljs-built_in\x22\x3eNSString\x3c\/span\x3e stringWithContentsOfFile:[[\x3cspan class=\x22hljs-built_in\x22\x3eNSBundle\x3c\/span\x3e mainBundle] pathForResource:\x3cspan class=\x22hljs-string\x22\x3e@\x22WebViewJavascriptBridge_JS.js\x22\x3c\/span\x3e ofType:\x3cspan class=\x22hljs-literal\x22\x3enil\x3c\/span\x3e] encoding:\x3cspan class=\x22hljs-built_in\x22\x3eNSUTF8StringEncoding\x3c\/span\x3e error:\x3cspan class=\x22hljs-literal\x22\x3enil\x3c\/span\x3e];\n    }\x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e{\n        js = WebViewJavascriptBridge_js();\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/把javascript代码注入webview中执行,这里执行具体的注入操作。\x3c\/span\x3e\n    [\x3cspan class=\x22hljs-keyword\x22\x3eself\x3c\/span\x3e _evaluateJavascript:js];\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果javascript环境初始化完成以后，有startupMessageQueue消息。则立即发送消息。\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3eself\x3c\/span\x3e.startupMessageQueue) {\n        \x3cspan class=\x22hljs-built_in\x22\x3eNSArray\x3c\/span\x3e* queue = \x3cspan class=\x22hljs-keyword\x22\x3eself\x3c\/span\x3e.startupMessageQueue;\n        \x3cspan class=\x22hljs-keyword\x22\x3eself\x3c\/span\x3e.startupMessageQueue = \x3cspan class=\x22hljs-literal\x22\x3enil\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3eid\x3c\/span\x3e queuedMessage \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e queue) {\n            [\x3cspan class=\x22hljs-keyword\x22\x3eself\x3c\/span\x3e _dispatchMessage:queuedMessage];\n        }\n    }\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/把javascript代码写入webview\x3c\/span\x3e\n- (\x3cspan class=\x22hljs-built_in\x22\x3eNSString\x3c\/span\x3e*) _evaluateJavascript:(\x3cspan class=\x22hljs-built_in\x22\x3eNSString\x3c\/span\x3e*)javascriptCommand {\n    [_webView evaluateJavaScript:javascriptCommand completionHandler:\x3cspan class=\x22hljs-literal\x22\x3enil\x3c\/span\x3e];\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3eNULL\x3c\/span\x3e;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e3、WebViewJavascriptBridge_JS.js解析\x3c\/h3\x3e\n\x3cp\x3e上面我们讲到了注入javascript方法到webview中。具体的代码就是\x3ccode\x3eWebViewJavascriptBridge_JS.js\x3c\/code\x3e这个文件中的方法。我们通过分析这个文件的代码可以知道javascript环境的bridge是如何初始化的。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22;(function() {\n    \/\/如果已经初始化了，则返回。\n    if (window.WebViewJavascriptBridge) {\n        return;\n    }\n    if (!window.onerror) {\n        window.onerror = function(msg, url, line) {\n            console.log(\x26quot;WebViewJavascriptBridge: ERROR:\x26quot; \x2b msg \x2b \x26quot;@\x26quot; \x2b url \x2b \x26quot;:\x26quot; \x2b line);\n        }\n    }\n    \/\/初始化一些属性。\n    var messagingIframe;\n    \/\/用于存储消息列表\n    var sendMessageQueue = [];\n    \/\/用于存储消息\n    var messageHandlers = {};\n    \/\/通过下面两个协议组合来确定是否是特定的消息，然后拦击。\n    var CUSTOM_PROTOCOL_SCHEME = \x27https\x27;\n    var QUEUE_HAS_MESSAGE = \x27__wvjb_queue_message__\x27;\n    \/\/oc调用js的回调\n    var responseCallbacks = {};\n    \/\/消息对应的id\n    var uniqueId = 1;\n    \/\/是否设置消息超时\n    var dispatchMessagesWithTimeoutSafety = true;\n    \/\/web端注册一个消息方法\n    function registerHandler(handlerName, handler) {\n        messageHandlers[handlerName] = handler;\n    }\n    \/\/web端调用一个OC注册的消息\n    function callHandler(handlerName, data, responseCallback) {\n        if (arguments.length == 2 \x26amp;\x26amp; typeof data == \x27function\x27) {\n            responseCallback = data;\n            data = null;\n        }\n        _doSend({ handlerName: handlerName, data: data }, responseCallback);\n    }\n    function disableJavscriptAlertBoxSafetyTimeout() {\n        dispatchMessagesWithTimeoutSafety = false;\n    }\n        \/\/把消息转换成JSON字符串返回\n    function _fetchQueue() {\n        var messageQueueString = JSON.stringify(sendMessageQueue);\n        sendMessageQueue = [];\n        return messageQueueString;\n    }\n    \/\/OC调用JS的入口方法\n    function _handleMessageFromObjC(messageJSON) {\n        _dispatchMessageFromObjC(messageJSON);\n    }\n\n    \/\/初始化桥接对象，OC可以通过WebViewJavascriptBridge来调用JS里面的各种方法。\n    window.WebViewJavascriptBridge = {\n        registerHandler: registerHandler,\n        callHandler: callHandler,\n        disableJavscriptAlertBoxSafetyTimeout: disableJavscriptAlertBoxSafetyTimeout,\n        _fetchQueue: _fetchQueue,\n        _handleMessageFromObjC: _handleMessageFromObjC\n    };\n\n\n    \/\/处理从OC返回的消息。\n    function _dispatchMessageFromObjC(messageJSON) {\n        if (dispatchMessagesWithTimeoutSafety) {\n            setTimeout(_doDispatchMessageFromObjC);\n        } else {\n            _doDispatchMessageFromObjC();\n        }\n\n        function _doDispatchMessageFromObjC() {\n            var message = JSON.parse(messageJSON);\n            var messageHandler;\n            var responseCallback;\n            \/\/回调\n            if (message.responseId) {\n                responseCallback = responseCallbacks[message.responseId];\n                if (!responseCallback) {\n                    return;\n                }\n                responseCallback(message.responseData);\n                delete responseCallbacks[message.responseId];\n            } else {\/\/主动调用\n                if (message.callbackId) {\n                    var callbackResponseId = message.callbackId;\n                    responseCallback = function(responseData) {\n                        _doSend({ handlerName: message.handlerName, responseId: callbackResponseId, responseData: responseData });\n                    };\n                }\n                \/\/获取JS注册的函数\n                var handler = messageHandlers[message.handlerName];\n                if (!handler) {\n                    console.log(\x26quot;WebViewJavascriptBridge: WARNING: no handler for message from ObjC:\x26quot;, message);\n                } else {\n                    \/\/调用JS中的对应函数处理\n                    handler(message.data, responseCallback);\n                }\n            }\n        }\n    }\n    \/\/把消息从JS发送到OC，执行具体的发送操作。\n    function _doSend(message, responseCallback) {\n        if (responseCallback) {\n            var callbackId = \x27cb_\x27 \x2b (uniqueId\x2b\x2b) \x2b \x27_\x27 \x2b new Date().getTime();\n            \/\/存储消息的回调ID\n            responseCallbacks[callbackId] = responseCallback;\n            \/\/把消息对应的回调ID和消息一起发送，以供消息返回以后使用。\n            message[\x27callbackId\x27] = callbackId;\n        }\n        \/\/把消息放入消息列表\n        sendMessageQueue.push(message);\n        \/\/下面这句话会出发JS对OC的调用\n        \/\/让webview执行跳转操作，从而可以在\n        \/\/webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler 中拦截到JS发给OC的消息\n        messagingIframe.src = CUSTOM_PROTOCOL_SCHEME \x2b \x27:\/\/\x27 \x2b QUEUE_HAS_MESSAGE;\n    }\n\n\n    messagingIframe = document.createElement(\x27iframe\x27);\n    messagingIframe.style.display = \x27none\x27;\n    \/\/messagingIframe.body.style.backgroundColor=\x26quot;#0000ff\x26quot;;\n    messagingIframe.src = CUSTOM_PROTOCOL_SCHEME \x2b \x27:\/\/\x27 \x2b QUEUE_HAS_MESSAGE;\n    document.documentElement.appendChild(messagingIframe);\n\n\n    \/\/注册_disableJavascriptAlertBoxSafetyTimeout方法，让OC可以关闭回调超时，默认是开启的。\n    registerHandler(\x26quot;_disableJavascriptAlertBoxSafetyTimeout\x26quot;, disableJavscriptAlertBoxSafetyTimeout);\n    \/\/执行_callWVJBCallbacks方法\n    setTimeout(_callWVJBCallbacks, 0);\n\n    \/\/初始化WEB中注册的方法。这个方法会把WEB中的hander注册到bridge中。\n    \/\/下面的代码其实就是执行WEB中的callback函数。\n    function _callWVJBCallbacks() {\n        var callbacks = window.WVJBCallbacks;\n        delete window.WVJBCallbacks;\n        for (var i = 0; i \x3c callbacks.length; i\x2b\x2b) {\n            callbacks[i](WebViewJavascriptBridge);\n        }\n    }\n})();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e;(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果已经初始化了，则返回。\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.WebViewJavascriptBridge) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.onerror) {\n        \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.onerror = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3emsg, url, line\x3c\/span\x3e) \x3c\/span\x3e{\n            \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22WebViewJavascriptBridge: ERROR:\x22\x3c\/span\x3e \x2b msg \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22@\x22\x3c\/span\x3e \x2b url \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22:\x22\x3c\/span\x3e \x2b line);\n        }\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/初始化一些属性。\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e messagingIframe;\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/用于存储消息列表\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e sendMessageQueue = [];\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/用于存储消息\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e messageHandlers = {};\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/通过下面两个协议组合来确定是否是特定的消息，然后拦击。\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e CUSTOM_PROTOCOL_SCHEME = \x3cspan class=\x22hljs-string\x22\x3e\x27https\x27\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e QUEUE_HAS_MESSAGE = \x3cspan class=\x22hljs-string\x22\x3e\x27__wvjb_queue_message__\x27\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/oc调用js的回调\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e responseCallbacks = {};\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/消息对应的id\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e uniqueId = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/是否设置消息超时\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e dispatchMessagesWithTimeoutSafety = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/web端注册一个消息方法\x3c\/span\x3e\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eregisterHandler\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ehandlerName, handler\x3c\/span\x3e) \x3c\/span\x3e{\n        messageHandlers[handlerName] = handler;\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/web端调用一个OC注册的消息\x3c\/span\x3e\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecallHandler\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ehandlerName, data, responseCallback\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e.length == \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e \x26amp;\x26amp; \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e data == \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e) {\n            responseCallback = data;\n            data = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n        }\n        _doSend({ \x3cspan class=\x22hljs-attr\x22\x3ehandlerName\x3c\/span\x3e: handlerName, \x3cspan class=\x22hljs-attr\x22\x3edata\x3c\/span\x3e: data }, responseCallback);\n    }\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3edisableJavscriptAlertBoxSafetyTimeout\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        dispatchMessagesWithTimeoutSafety = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n    }\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/把消息转换成JSON字符串返回\x3c\/span\x3e\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e_fetchQueue\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e messageQueueString = \x3cspan class=\x22hljs-built_in\x22\x3eJSON\x3c\/span\x3e.stringify(sendMessageQueue);\n        sendMessageQueue = [];\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e messageQueueString;\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/OC调用JS的入口方法\x3c\/span\x3e\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e_handleMessageFromObjC\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3emessageJSON\x3c\/span\x3e) \x3c\/span\x3e{\n        _dispatchMessageFromObjC(messageJSON);\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/初始化桥接对象，OC可以通过WebViewJavascriptBridge来调用JS里面的各种方法。\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.WebViewJavascriptBridge = {\n        \x3cspan class=\x22hljs-attr\x22\x3eregisterHandler\x3c\/span\x3e: registerHandler,\n        \x3cspan class=\x22hljs-attr\x22\x3ecallHandler\x3c\/span\x3e: callHandler,\n        \x3cspan class=\x22hljs-attr\x22\x3edisableJavscriptAlertBoxSafetyTimeout\x3c\/span\x3e: disableJavscriptAlertBoxSafetyTimeout,\n        \x3cspan class=\x22hljs-attr\x22\x3e_fetchQueue\x3c\/span\x3e: _fetchQueue,\n        \x3cspan class=\x22hljs-attr\x22\x3e_handleMessageFromObjC\x3c\/span\x3e: _handleMessageFromObjC\n    };\n\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/处理从OC返回的消息。\x3c\/span\x3e\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e_dispatchMessageFromObjC\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3emessageJSON\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (dispatchMessagesWithTimeoutSafety) {\n            setTimeout(_doDispatchMessageFromObjC);\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n            _doDispatchMessageFromObjC();\n        }\n\n        \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e_doDispatchMessageFromObjC\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n            \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e message = \x3cspan class=\x22hljs-built_in\x22\x3eJSON\x3c\/span\x3e.parse(messageJSON);\n            \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e messageHandler;\n            \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e responseCallback;\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/回调\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (message.responseId) {\n                responseCallback = responseCallbacks[message.responseId];\n                \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!responseCallback) {\n                    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n                }\n                responseCallback(message.responseData);\n                \x3cspan class=\x22hljs-keyword\x22\x3edelete\x3c\/span\x3e responseCallbacks[message.responseId];\n            } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\x3cspan class=\x22hljs-comment\x22\x3e\/\/主动调用\x3c\/span\x3e\n                \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (message.callbackId) {\n                    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e callbackResponseId = message.callbackId;\n                    responseCallback = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eresponseData\x3c\/span\x3e) \x3c\/span\x3e{\n                        _doSend({ \x3cspan class=\x22hljs-attr\x22\x3ehandlerName\x3c\/span\x3e: message.handlerName, \x3cspan class=\x22hljs-attr\x22\x3eresponseId\x3c\/span\x3e: callbackResponseId, \x3cspan class=\x22hljs-attr\x22\x3eresponseData\x3c\/span\x3e: responseData });\n                    };\n                }\n                \x3cspan class=\x22hljs-comment\x22\x3e\/\/获取JS注册的函数\x3c\/span\x3e\n                \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e handler = messageHandlers[message.handlerName];\n                \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!handler) {\n                    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22WebViewJavascriptBridge: WARNING: no handler for message from ObjC:\x22\x3c\/span\x3e, message);\n                } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n                    \x3cspan class=\x22hljs-comment\x22\x3e\/\/调用JS中的对应函数处理\x3c\/span\x3e\n                    handler(message.data, responseCallback);\n                }\n            }\n        }\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/把消息从JS发送到OC，执行具体的发送操作。\x3c\/span\x3e\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e_doSend\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3emessage, responseCallback\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (responseCallback) {\n            \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e callbackId = \x3cspan class=\x22hljs-string\x22\x3e\x27cb_\x27\x3c\/span\x3e \x2b (uniqueId\x2b\x2b) \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27_\x27\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e().getTime();\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/存储消息的回调ID\x3c\/span\x3e\n            responseCallbacks[callbackId] = responseCallback;\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/把消息对应的回调ID和消息一起发送，以供消息返回以后使用。\x3c\/span\x3e\n            message[\x3cspan class=\x22hljs-string\x22\x3e\x27callbackId\x27\x3c\/span\x3e] = callbackId;\n        }\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/把消息放入消息列表\x3c\/span\x3e\n        sendMessageQueue.push(message);\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/下面这句话会出发JS对OC的调用\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/让webview执行跳转操作，从而可以在\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler 中拦截到JS发给OC的消息\x3c\/span\x3e\n        messagingIframe.src = CUSTOM_PROTOCOL_SCHEME \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27:\/\/\x27\x3c\/span\x3e \x2b QUEUE_HAS_MESSAGE;\n    }\n\n\n    messagingIframe = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.createElement(\x3cspan class=\x22hljs-string\x22\x3e\x27iframe\x27\x3c\/span\x3e);\n    messagingIframe.style.display = \x3cspan class=\x22hljs-string\x22\x3e\x27none\x27\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/messagingIframe.body.style.backgroundColor=\x22#0000ff\x22;\x3c\/span\x3e\n    messagingIframe.src = CUSTOM_PROTOCOL_SCHEME \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27:\/\/\x27\x3c\/span\x3e \x2b QUEUE_HAS_MESSAGE;\n    \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.documentElement.appendChild(messagingIframe);\n\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/注册_disableJavascriptAlertBoxSafetyTimeout方法，让OC可以关闭回调超时，默认是开启的。\x3c\/span\x3e\n    registerHandler(\x3cspan class=\x22hljs-string\x22\x3e\x22_disableJavascriptAlertBoxSafetyTimeout\x22\x3c\/span\x3e, disableJavscriptAlertBoxSafetyTimeout);\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/执行_callWVJBCallbacks方法\x3c\/span\x3e\n    setTimeout(_callWVJBCallbacks, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/初始化WEB中注册的方法。这个方法会把WEB中的hander注册到bridge中。\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/下面的代码其实就是执行WEB中的callback函数。\x3c\/span\x3e\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e_callWVJBCallbacks\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e callbacks = \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.WVJBCallbacks;\n        \x3cspan class=\x22hljs-keyword\x22\x3edelete\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.WVJBCallbacks;\n        \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; callbacks.length; i\x2b\x2b) {\n            callbacks[i](WebViewJavascriptBridge);\n        }\n    }\n})();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e其实我们发现整个js文件就是一个立即执行的javascript方法。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e首先我们发现会初始化一个WebViewJavascriptBridge对象。并且这个对象是赋值给window对象，这里window对象可以理解为webview。所以说我们后面在OC环境中如果要调用js方法，就可以通过\x3ccode\x3ewindow.WebViewJavascriptBridge\x3c\/code\x3e在加上具体方法来调用。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eWebViewJavascriptBridge对象中有javascript环境注入的提供给OC调用的方法registerHandler，javascript调用OC环境方法的callHandler。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e_fetchQueue这个方法的作用就是把javascript环境的方法序列化成JSON字符串，然后传入OC环境再转换。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e_handleMessageFromObjC就是处理OC发给javascript环境的方法。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e在这个文件中也初始化了一个iframe实现webview的url跳转功能，从而激发webview代理方法的调用。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    messagingIframe = document.createElement(\x27iframe\x27);\n    messagingIframe.style.display = \x27none\x27;\n    \/\/messagingIframe.body.style.backgroundColor=\x26quot;#0000ff\x26quot;;\n    messagingIframe.src = CUSTOM_PROTOCOL_SCHEME \x2b \x27:\/\/\x27 \x2b QUEUE_HAS_MESSAGE;\n    document.documentElement.appendChild(messagingIframe);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e    messagingIframe = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.createElement(\x3cspan class=\x22hljs-string\x22\x3e\x27iframe\x27\x3c\/span\x3e);\n    messagingIframe.style.display = \x3cspan class=\x22hljs-string\x22\x3e\x27none\x27\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/messagingIframe.body.style.backgroundColor=\x22#0000ff\x22;\x3c\/span\x3e\n    messagingIframe.src = CUSTOM_PROTOCOL_SCHEME \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27:\/\/\x27\x3c\/span\x3e \x2b QUEUE_HAS_MESSAGE;\n    \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.documentElement.appendChild(messagingIframe);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面的src就是\x3ccode\x3ehttps:\/\/__wvjb_queue_message__\/\x3c\/code\x3e。这个是javascript发送的OC的第一条消息，目的和上面OC环境的startupMessageQueue一样，就是在javascript环境初始化完成以后，把javascript要发送给OC的消息立即发送出去。\x3c\/p\x3e\n\x3cp\x3e然后我们看文件的最后面有如下代码。这段代码的作用就是立即执行ExampleApp.html中的callback方法。callback中传入的bridge参数就是我们这里初始化的window.WebViewJavascriptBridge对象。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    \/\/执行_callWVJBCallbacks方法\n    setTimeout(_callWVJBCallbacks, 0);\n\n    \/\/初始化WEB中注册的方法。这个方法会把WEB中的hander注册到bridge中。\n    \/\/下面的代码其实就是执行WEB中的callback函数。\n    function _callWVJBCallbacks() {\n        var callbacks = window.WVJBCallbacks;\n        delete window.WVJBCallbacks;\n        for (var i = 0; i \x3c callbacks.length; i\x2b\x2b) {\n            callbacks[i](WebViewJavascriptBridge);\n        }\n    }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e    \x3cspan class=\x22hljs-comment\x22\x3e\/\/执行_callWVJBCallbacks方法\x3c\/span\x3e\n    setTimeout(_callWVJBCallbacks, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/初始化WEB中注册的方法。这个方法会把WEB中的hander注册到bridge中。\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/下面的代码其实就是执行WEB中的callback函数。\x3c\/span\x3e\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e_callWVJBCallbacks\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e callbacks = \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.WVJBCallbacks;\n        \x3cspan class=\x22hljs-keyword\x22\x3edelete\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.WVJBCallbacks;\n        \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; callbacks.length; i\x2b\x2b) {\n            callbacks[i](WebViewJavascriptBridge);\n        }\n    }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e直到这里，OC环境和javascript环境的bridege都建立完毕。OC和javascript环境都有一个bridge对象，这个对象都保存着注册的每个方法和回调，并且维护着各自的消息队列、回调id、requestId等一系列信息。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3eOC发消息给WEB\x3c\/h2\x3e\n\x3cp\x3eOC要调用javascript环境的方法，其实就是调用\x3ccode\x3eExampleApp.html\x3c\/code\x3e中的\x3ccode\x3ebridge.registerHandler\x3c\/code\x3e注册的方法。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/点击按钮开始一个OC消息.ExampleWKWebViewController.m中一个方法开始。\n- (void)callHandler:(id)sender {\n    id data = @{ @\x26quot;OC调用JS方法\x26quot;: @\x26quot;OC调用JS方法的参数\x26quot; };\n    [_bridge callHandler:@\x26quot;OC调用JS提供的方法\x26quot; data:data responseCallback:^(id response) {\n       \/\/ NSLog(@\x26quot;testJavascriptHandler responded: %@\x26quot;, response);\n    }];\n}\n\/*\n    handerName:OC调用JS提供的方法\n    data:{@\x26quot;OC调用JS方法的参数\x26quot;:@\x26quot;OC调用JS方法\x26quot;}\n    responseCallback:回调block\n *\/\n- (void)callHandler:(NSString *)handlerName data:(id)data responseCallback:(WVJBResponseCallback)responseCallback {\n    [_base sendData:data responseCallback:responseCallback handlerName:handlerName];\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs haskell\x22\x3e\x3ccode class=\x22objc\x22\x3e\/\/点击按钮开始一个\x3cspan class=\x22hljs-type\x22\x3eOC\x3c\/span\x3e消息.\x3cspan class=\x22hljs-type\x22\x3eExampleWKWebViewController\x3c\/span\x3e.m中一个方法开始。\n- (void)callHandler:(id)sender {\n    id \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e = @{ @\x22\x3cspan class=\x22hljs-type\x22\x3eOC\x3c\/span\x3e调用\x3cspan class=\x22hljs-type\x22\x3eJS\x3c\/span\x3e方法\x22: @\x22\x3cspan class=\x22hljs-type\x22\x3eOC\x3c\/span\x3e调用\x3cspan class=\x22hljs-type\x22\x3eJS\x3c\/span\x3e方法的参数\x22 };\x3c\/span\x3e\n    [_bridge callHandler:@\x3cspan class=\x22hljs-string\x22\x3e\x22OC调用JS提供的方法\x22\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e:\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e responseCallback:^(\x3cspan class=\x22hljs-title\x22\x3eid\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eresponse\x3c\/span\x3e) {\n       \/\/ \x3cspan class=\x22hljs-type\x22\x3eNSLog\x3c\/span\x3e(@\x22\x3cspan class=\x22hljs-title\x22\x3etestJavascriptHandler\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eresponded\x3c\/span\x3e: %@\x22, \x3cspan class=\x22hljs-title\x22\x3eresponse\x3c\/span\x3e);\n    }];\x3c\/span\x3e\n}\n\/*\n    handerName:\x3cspan class=\x22hljs-type\x22\x3eOC\x3c\/span\x3e调用\x3cspan class=\x22hljs-type\x22\x3eJS\x3c\/span\x3e提供的方法\n    \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e:{@\x22\x3cspan class=\x22hljs-type\x22\x3eOC\x3c\/span\x3e调用\x3cspan class=\x22hljs-type\x22\x3eJS\x3c\/span\x3e方法的参数\x22:@\x22\x3cspan class=\x22hljs-type\x22\x3eOC\x3c\/span\x3e调用\x3cspan class=\x22hljs-type\x22\x3eJS\x3c\/span\x3e方法\x22}\x3c\/span\x3e\n    responseCallback:回调block\n *\/\n- (void)callHandler:(\x3cspan class=\x22hljs-type\x22\x3eNSString\x3c\/span\x3e *)handlerName \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e:(\x3cspan class=\x22hljs-title\x22\x3eid\x3c\/span\x3e)\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e responseCallback:(\x3cspan class=\x22hljs-type\x22\x3eWVJBResponseCallback\x3c\/span\x3e)responseCallback {\n    [\x3cspan class=\x22hljs-title\x22\x3e_base\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3esendData\x3c\/span\x3e:\x3cspan class=\x22hljs-title\x22\x3edata\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eresponseCallback\x3c\/span\x3e:\x3cspan class=\x22hljs-title\x22\x3eresponseCallback\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ehandlerName\x3c\/span\x3e:\x3cspan class=\x22hljs-title\x22\x3ehandlerName\x3c\/span\x3e];\n}\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e把所有信息存入一个名字为message的字典中。里面拼装好参数\x3ccode\x3edata\x3c\/code\x3e、回调ID\x3ccode\x3ecallbackId\x3c\/code\x3e、消息名字\x3ccode\x3ehandlerName\x3c\/code\x3e。具体如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22- (void)sendData:(id)data responseCallback:(WVJBResponseCallback)responseCallback handlerName:(NSString*)handlerName {\n    NSMutableDictionary* message = [NSMutableDictionary dictionary];\n    \n    if (data) {\n        message[@\x26quot;data\x26quot;] = data;\n    }\n    \n    if (responseCallback) {\n        NSString* callbackId = [NSString stringWithFormat:@\x26quot;objc_cb_%ld\x26quot;, \x2b\x2b_uniqueId];\n        self.responseCallbacks[callbackId] = [responseCallback copy];\n        message[@\x26quot;callbackId\x26quot;] = callbackId;\n    }\n    \n    if (handlerName) {\n        message[@\x26quot;handlerName\x26quot;] = handlerName;\n    }\n    [self _queueMessage:message];\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs objectivec\x22\x3e\x3ccode class=\x22objc\x22\x3e- (\x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e)sendData:(\x3cspan class=\x22hljs-keyword\x22\x3eid\x3c\/span\x3e)data responseCallback:(WVJBResponseCallback)responseCallback handlerName:(\x3cspan class=\x22hljs-built_in\x22\x3eNSString\x3c\/span\x3e*)handlerName {\n    \x3cspan class=\x22hljs-built_in\x22\x3eNSMutableDictionary\x3c\/span\x3e* message = [\x3cspan class=\x22hljs-built_in\x22\x3eNSMutableDictionary\x3c\/span\x3e dictionary];\n    \n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (data) {\n        message[\x3cspan class=\x22hljs-string\x22\x3e@\x22data\x22\x3c\/span\x3e] = data;\n    }\n    \n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (responseCallback) {\n        \x3cspan class=\x22hljs-built_in\x22\x3eNSString\x3c\/span\x3e* callbackId = [\x3cspan class=\x22hljs-built_in\x22\x3eNSString\x3c\/span\x3e stringWithFormat:\x3cspan class=\x22hljs-string\x22\x3e@\x22objc_cb_%ld\x22\x3c\/span\x3e, \x2b\x2b_uniqueId];\n        \x3cspan class=\x22hljs-keyword\x22\x3eself\x3c\/span\x3e.responseCallbacks[callbackId] = [responseCallback \x3cspan class=\x22hljs-keyword\x22\x3ecopy\x3c\/span\x3e];\n        message[\x3cspan class=\x22hljs-string\x22\x3e@\x22callbackId\x22\x3c\/span\x3e] = callbackId;\n    }\n    \n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (handlerName) {\n        message[\x3cspan class=\x22hljs-string\x22\x3e@\x22handlerName\x22\x3c\/span\x3e] = handlerName;\n    }\n    [\x3cspan class=\x22hljs-keyword\x22\x3eself\x3c\/span\x3e _queueMessage:message];\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e把OC消息序列化、并且转化为javascript环境的格式。然后在主线程中调用_evaluateJavascript。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/把消息发送给WEB环境\n- (void)_dispatchMessage:(WVJBMessage*)message {\n    NSString *messageJSON = [self _serializeMessage:message pretty:NO];\n    [self _log:@\x26quot;SEND\x26quot; json:messageJSON];\n    messageJSON = [messageJSON stringByReplacingOccurrencesOfString:@\x26quot;\\\\\x26quot; withString:@\x26quot;\\\\\\\\\x26quot;];\n    messageJSON = [messageJSON stringByReplacingOccurrencesOfString:@\x26quot;\\\x26quot;\x26quot; withString:@\x26quot;\\\\\\\x26quot;\x26quot;];\n    messageJSON = [messageJSON stringByReplacingOccurrencesOfString:@\x26quot;\\\x27\x26quot; withString:@\x26quot;\\\\\\\x27\x26quot;];\n    messageJSON = [messageJSON stringByReplacingOccurrencesOfString:@\x26quot;\\n\x26quot; withString:@\x26quot;\\\\n\x26quot;];\n    messageJSON = [messageJSON stringByReplacingOccurrencesOfString:@\x26quot;\\r\x26quot; withString:@\x26quot;\\\\r\x26quot;];\n    messageJSON = [messageJSON stringByReplacingOccurrencesOfString:@\x26quot;\\f\x26quot; withString:@\x26quot;\\\\f\x26quot;];\n    messageJSON = [messageJSON stringByReplacingOccurrencesOfString:@\x26quot;\\u2028\x26quot; withString:@\x26quot;\\\\u2028\x26quot;];\n    messageJSON = [messageJSON stringByReplacingOccurrencesOfString:@\x26quot;\\u2029\x26quot; withString:@\x26quot;\\\\u2029\x26quot;];\n    \n    NSString* javascriptCommand = [NSString stringWithFormat:@\x26quot;WebViewJavascriptBridge._handleMessageFromObjC(\x27%@\x27);\x26quot;, messageJSON];\n    if ([[NSThread currentThread] isMainThread]) {\n        [self _evaluateJavascript:javascriptCommand];\n\n    } else {\n        dispatch_sync(dispatch_get_main_queue(), ^{\n            [self _evaluateJavascript:javascriptCommand];\n        });\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs groovy\x22\x3e\x3ccode class=\x22objc\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/把消息发送给WEB环境\x3c\/span\x3e\n- (\x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e)\x3cspan class=\x22hljs-string\x22\x3e_dispatchMessage:\x3c\/span\x3e(WVJBMessage*)message {\n    NSString *messageJSON = [self \x3cspan class=\x22hljs-string\x22\x3e_serializeMessage:\x3c\/span\x3emessage \x3cspan class=\x22hljs-string\x22\x3epretty:\x3c\/span\x3eNO];\n    [self \x3cspan class=\x22hljs-string\x22\x3e_log:\x3c\/span\x3e@\x3cspan class=\x22hljs-string\x22\x3e\x22SEND\x22\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3ejson:\x3c\/span\x3emessageJSON];\n    messageJSON = [messageJSON \x3cspan class=\x22hljs-string\x22\x3estringByReplacingOccurrencesOfString:\x3c\/span\x3e@\x3cspan class=\x22hljs-string\x22\x3e\x22\\\\\x22\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3ewithString:\x3c\/span\x3e@\x3cspan class=\x22hljs-string\x22\x3e\x22\\\\\\\\\x22\x3c\/span\x3e];\n    messageJSON = [messageJSON \x3cspan class=\x22hljs-string\x22\x3estringByReplacingOccurrencesOfString:\x3c\/span\x3e@\x3cspan class=\x22hljs-string\x22\x3e\x22\\\x22\x22\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3ewithString:\x3c\/span\x3e@\x3cspan class=\x22hljs-string\x22\x3e\x22\\\\\\\x22\x22\x3c\/span\x3e];\n    messageJSON = [messageJSON \x3cspan class=\x22hljs-string\x22\x3estringByReplacingOccurrencesOfString:\x3c\/span\x3e@\x3cspan class=\x22hljs-string\x22\x3e\x22\\\x27\x22\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3ewithString:\x3c\/span\x3e@\x3cspan class=\x22hljs-string\x22\x3e\x22\\\\\\\x27\x22\x3c\/span\x3e];\n    messageJSON = [messageJSON \x3cspan class=\x22hljs-string\x22\x3estringByReplacingOccurrencesOfString:\x3c\/span\x3e@\x3cspan class=\x22hljs-string\x22\x3e\x22\\n\x22\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3ewithString:\x3c\/span\x3e@\x3cspan class=\x22hljs-string\x22\x3e\x22\\\\n\x22\x3c\/span\x3e];\n    messageJSON = [messageJSON \x3cspan class=\x22hljs-string\x22\x3estringByReplacingOccurrencesOfString:\x3c\/span\x3e@\x3cspan class=\x22hljs-string\x22\x3e\x22\\r\x22\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3ewithString:\x3c\/span\x3e@\x3cspan class=\x22hljs-string\x22\x3e\x22\\\\r\x22\x3c\/span\x3e];\n    messageJSON = [messageJSON \x3cspan class=\x22hljs-string\x22\x3estringByReplacingOccurrencesOfString:\x3c\/span\x3e@\x3cspan class=\x22hljs-string\x22\x3e\x22\\f\x22\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3ewithString:\x3c\/span\x3e@\x3cspan class=\x22hljs-string\x22\x3e\x22\\\\f\x22\x3c\/span\x3e];\n    messageJSON = [messageJSON \x3cspan class=\x22hljs-string\x22\x3estringByReplacingOccurrencesOfString:\x3c\/span\x3e@\x3cspan class=\x22hljs-string\x22\x3e\x22\\u2028\x22\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3ewithString:\x3c\/span\x3e@\x3cspan class=\x22hljs-string\x22\x3e\x22\\\\u2028\x22\x3c\/span\x3e];\n    messageJSON = [messageJSON \x3cspan class=\x22hljs-string\x22\x3estringByReplacingOccurrencesOfString:\x3c\/span\x3e@\x3cspan class=\x22hljs-string\x22\x3e\x22\\u2029\x22\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3ewithString:\x3c\/span\x3e@\x3cspan class=\x22hljs-string\x22\x3e\x22\\\\u2029\x22\x3c\/span\x3e];\n    \n    NSString* javascriptCommand = [NSString \x3cspan class=\x22hljs-string\x22\x3estringWithFormat:\x3c\/span\x3e@\x3cspan class=\x22hljs-string\x22\x3e\x22WebViewJavascriptBridge._handleMessageFromObjC(\x27%@\x27);\x22\x3c\/span\x3e, messageJSON];\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ([[NSThread currentThread] isMainThread]) {\n        [self \x3cspan class=\x22hljs-string\x22\x3e_evaluateJavascript:\x3c\/span\x3ejavascriptCommand];\n\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        dispatch_sync(dispatch_get_main_queue(), ^{\n            [self \x3cspan class=\x22hljs-string\x22\x3e_evaluateJavascript:\x3c\/span\x3ejavascriptCommand];\n        });\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e具体注入的javascript字符串如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22WebViewJavascriptBridge._handleMessageFromObjC(\x27{\\\x26quot;callbackId\\\x26quot;:\\\x26quot;objc_cb_1\\\x26quot;,\\\x26quot;data\\\x26quot;:{\\\x26quot;OC调用JS方法\\\x26quot;:\\\x26quot;OC调用JS方法的参数\\\x26quot;},\\\x26quot;handlerName\\\x26quot;:\\\x26quot;OC调用JS提供的方法\\\x26quot;}\x27);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs taggerscript\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3eWebViewJavascriptBridge._handleMessageFromObjC(\x27{\x3cspan class=\x22hljs-symbol\x22\x3e\\\x22\x3c\/span\x3ecallbackId\x3cspan class=\x22hljs-symbol\x22\x3e\\\x22\x3c\/span\x3e:\x3cspan class=\x22hljs-symbol\x22\x3e\\\x22\x3c\/span\x3eobjc_cb_1\x3cspan class=\x22hljs-symbol\x22\x3e\\\x22\x3c\/span\x3e,\x3cspan class=\x22hljs-symbol\x22\x3e\\\x22\x3c\/span\x3edata\x3cspan class=\x22hljs-symbol\x22\x3e\\\x22\x3c\/span\x3e:{\x3cspan class=\x22hljs-symbol\x22\x3e\\\x22\x3c\/span\x3eOC调用JS方法\x3cspan class=\x22hljs-symbol\x22\x3e\\\x22\x3c\/span\x3e:\x3cspan class=\x22hljs-symbol\x22\x3e\\\x22\x3c\/span\x3eOC调用JS方法的参数\x3cspan class=\x22hljs-symbol\x22\x3e\\\x22\x3c\/span\x3e},\x3cspan class=\x22hljs-symbol\x22\x3e\\\x22\x3c\/span\x3ehandlerName\x3cspan class=\x22hljs-symbol\x22\x3e\\\x22\x3c\/span\x3e:\x3cspan class=\x22hljs-symbol\x22\x3e\\\x22\x3c\/span\x3eOC调用JS提供的方法\x3cspan class=\x22hljs-symbol\x22\x3e\\\x22\x3c\/span\x3e}\x27);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e其实就是通过javascript环境中的Bridge对象的\x3ccode\x3e_handleMessageFromObjC\x3c\/code\x3e方法。下面我们去\x3ccode\x3eWebViewJavascriptBridege_JS.js\x3c\/code\x3e中看\x3ccode\x3e_handleMessageFromObjC\x3c\/code\x3e的处理过程。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/处理从OC返回的消息。\nfunction _dispatchMessageFromObjC(messageJSON) {\n    if (dispatchMessagesWithTimeoutSafety) {\n        setTimeout(_doDispatchMessageFromObjC);\n    } else {\n        _doDispatchMessageFromObjC();\n    }\n\n    function _doDispatchMessageFromObjC() {\n        var message = JSON.parse(messageJSON);\n        var messageHandler;\n        var responseCallback;\n        \/\/回调\n        if (message.responseId) {\n            responseCallback = responseCallbacks[message.responseId];\n            if (!responseCallback) {\n                return;\n            }\n            responseCallback(message.responseData);\n            delete responseCallbacks[message.responseId];\n        } else {\/\/主动调用\n            if (message.callbackId) {\n                var callbackResponseId = message.callbackId;\n                responseCallback = function(responseData) {\n                    _doSend({ handlerName: message.handlerName, responseId: callbackResponseId, responseData: responseData });\n                };\n            }\n            \/\/获取JS注册的函数\n            var handler = messageHandlers[message.handlerName];\n            if (!handler) {\n                console.log(\x26quot;WebViewJavascriptBridge: WARNING: no handler for message from ObjC:\x26quot;, message);\n            } else {\n                \/\/调用JS中的对应函数处理\n                handler(message.data, responseCallback);\n            }\n        }\n    }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/处理从OC返回的消息。\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e_dispatchMessageFromObjC\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3emessageJSON\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (dispatchMessagesWithTimeoutSafety) {\n        setTimeout(_doDispatchMessageFromObjC);\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        _doDispatchMessageFromObjC();\n    }\n\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e_doDispatchMessageFromObjC\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e message = \x3cspan class=\x22hljs-built_in\x22\x3eJSON\x3c\/span\x3e.parse(messageJSON);\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e messageHandler;\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e responseCallback;\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/回调\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (message.responseId) {\n            responseCallback = responseCallbacks[message.responseId];\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!responseCallback) {\n                \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n            }\n            responseCallback(message.responseData);\n            \x3cspan class=\x22hljs-keyword\x22\x3edelete\x3c\/span\x3e responseCallbacks[message.responseId];\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\x3cspan class=\x22hljs-comment\x22\x3e\/\/主动调用\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (message.callbackId) {\n                \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e callbackResponseId = message.callbackId;\n                responseCallback = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eresponseData\x3c\/span\x3e) \x3c\/span\x3e{\n                    _doSend({ \x3cspan class=\x22hljs-attr\x22\x3ehandlerName\x3c\/span\x3e: message.handlerName, \x3cspan class=\x22hljs-attr\x22\x3eresponseId\x3c\/span\x3e: callbackResponseId, \x3cspan class=\x22hljs-attr\x22\x3eresponseData\x3c\/span\x3e: responseData });\n                };\n            }\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/获取JS注册的函数\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e handler = messageHandlers[message.handlerName];\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!handler) {\n                \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22WebViewJavascriptBridge: WARNING: no handler for message from ObjC:\x22\x3c\/span\x3e, message);\n            } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n                \x3cspan class=\x22hljs-comment\x22\x3e\/\/调用JS中的对应函数处理\x3c\/span\x3e\n                handler(message.data, responseCallback);\n            }\n        }\n    }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面这段代码很容易理解，其实就是如果消息中有callbackId则表示是一个回调。直接调用_doSend方法把信息返回OC。否则就是Web环境主动调用OC的情况。此时把callbackID、handlerName、responseCallback封装进一个message对象中保存起来(其实你会发现和OC环境的bridge处理一样)。然后通过_doSend发消息发送到OC环境。下面我们看看_doSend的具体实现：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/把消息从JS发送到OC，执行具体的发送操作。\nfunction _doSend(message, responseCallback) {\n    if (responseCallback) {\n        var callbackId = \x27cb_\x27 \x2b (uniqueId\x2b\x2b) \x2b \x27_\x27 \x2b new Date().getTime();\n        \/\/存储消息的回调ID\n        responseCallbacks[callbackId] = responseCallback;\n        \/\/把消息对应的回调ID和消息一起发送，以供消息返回以后使用。\n        message[\x27callbackId\x27] = callbackId;\n    }\n    \/\/把消息放入消息列表\n    sendMessageQueue.push(message);\n    \/\/下面这句话会出发JS对OC的调用\n    \/\/让webview执行跳转操作，从而可以在\n    \/\/webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler 中拦截到JS发给OC的消息\n    messagingIframe.src = CUSTOM_PROTOCOL_SCHEME \x2b \x27:\/\/\x27 \x2b QUEUE_HAS_MESSAGE;\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/把消息从JS发送到OC，执行具体的发送操作。\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e_doSend\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3emessage, responseCallback\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (responseCallback) {\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e callbackId = \x3cspan class=\x22hljs-string\x22\x3e\x27cb_\x27\x3c\/span\x3e \x2b (uniqueId\x2b\x2b) \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27_\x27\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e().getTime();\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/存储消息的回调ID\x3c\/span\x3e\n        responseCallbacks[callbackId] = responseCallback;\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/把消息对应的回调ID和消息一起发送，以供消息返回以后使用。\x3c\/span\x3e\n        message[\x3cspan class=\x22hljs-string\x22\x3e\x27callbackId\x27\x3c\/span\x3e] = callbackId;\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/把消息放入消息列表\x3c\/span\x3e\n    sendMessageQueue.push(message);\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/下面这句话会出发JS对OC的调用\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/让webview执行跳转操作，从而可以在\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler 中拦截到JS发给OC的消息\x3c\/span\x3e\n    messagingIframe.src = CUSTOM_PROTOCOL_SCHEME \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27:\/\/\x27\x3c\/span\x3e \x2b QUEUE_HAS_MESSAGE;\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e其中最重要还是最后面的通过改变iframe的\x3ccode\x3emessagingIframe.src\x3c\/code\x3e。从而触发webview的代理方法\x3ccode\x3ewebView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler\x3c\/code\x3e从而在OC中处理javascript环境触发过来的回调。具体如下:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22if ([_base isWebViewJavascriptBridgeURL:url]) {\n    \/\/第一次注入JS代码\n    if ([_base isBridgeLoadedURL:url]) {\n        [_base injectJavascriptFile];\n    \/\/处理WEB发过来的消息\n    } else if ([_base isQueueMessageURL:url]) {\n        [self WKFlushMessageQueue];\n    } else {\n        [_base logUnkownMessage:url];\n    }\n    decisionHandler(WKNavigationActionPolicyCancel);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs less\x22\x3e\x3ccode class=\x22objc\x22\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3eif\x3c\/span\x3e ([_base \x3cspan class=\x22hljs-attribute\x22\x3eisWebViewJavascriptBridgeURL\x3c\/span\x3e:url]) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/第一次注入JS代码\x3c\/span\x3e\n    \x3cspan class=\x22hljs-selector-tag\x22\x3eif\x3c\/span\x3e ([_base \x3cspan class=\x22hljs-attribute\x22\x3eisBridgeLoadedURL\x3c\/span\x3e:url]) {\n        \x3cspan class=\x22hljs-selector-attr\x22\x3e[_base injectJavascriptFile]\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/处理WEB发过来的消息\x3c\/span\x3e\n    } \x3cspan class=\x22hljs-selector-tag\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-selector-tag\x22\x3eif\x3c\/span\x3e ([_base \x3cspan class=\x22hljs-attribute\x22\x3eisQueueMessageURL\x3c\/span\x3e:url]) {\n        \x3cspan class=\x22hljs-selector-attr\x22\x3e[self WKFlushMessageQueue]\x3c\/span\x3e;\n    } \x3cspan class=\x22hljs-selector-tag\x22\x3eelse\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-selector-attr\x22\x3e[_base logUnkownMessage:url]\x3c\/span\x3e;\n    }\n    \x3cspan class=\x22hljs-selector-tag\x22\x3edecisionHandler\x3c\/span\x3e(WKNavigationActionPolicyCancel);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里会走\x3ccode\x3e[self WKFlushMessageQueue];\x3c\/code\x3e方法。然后通过调用\x3ccode\x3eWebViewJavascriptBridge._fetchQueue()\x3c\/code\x3e来获取javascript给OC的回调信息。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/获取WEB消息的JSON字符串\n- (NSString *)webViewJavascriptFetchQueyCommand {\n    return @\x26quot;WebViewJavascriptBridge._fetchQueue();\x26quot;;\n}\n\/\/\/\/把消息或者WEB回调从OC发送到OC\n- (void)WKFlushMessageQueue {\n    NSString *js = [_base webViewJavascriptFetchQueyCommand];\n    [_webView evaluateJavaScript:js completionHandler:^(NSString* result, NSError* error) {\n        if (error != nil) {\n            NSLog(@\x26quot;WebViewJavascriptBridge: WARNING: Error when trying to fetch data from WKWebView: %@\x26quot;, error);\n        }\n        \/\/把消息或者WEB回调从OC发送到OC\n        [_base flushMessageQueue:result];\n    }];\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs objectivec\x22\x3e\x3ccode class=\x22objc\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/获取WEB消息的JSON字符串\x3c\/span\x3e\n- (\x3cspan class=\x22hljs-built_in\x22\x3eNSString\x3c\/span\x3e *)webViewJavascriptFetchQueyCommand {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e@\x22WebViewJavascriptBridge._fetchQueue();\x22\x3c\/span\x3e;\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/\/\/把消息或者WEB回调从OC发送到OC\x3c\/span\x3e\n- (\x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e)\x3cspan class=\x22hljs-built_in\x22\x3eWKFlushMessageQueue\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-built_in\x22\x3eNSString\x3c\/span\x3e *js = [_base webViewJavascriptFetchQueyCommand];\n    [_webView evaluateJavaScript:js completionHandler:^(\x3cspan class=\x22hljs-built_in\x22\x3eNSString\x3c\/span\x3e* result, \x3cspan class=\x22hljs-built_in\x22\x3eNSError\x3c\/span\x3e* error) {\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (error != \x3cspan class=\x22hljs-literal\x22\x3enil\x3c\/span\x3e) {\n            \x3cspan class=\x22hljs-built_in\x22\x3eNSLog\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e@\x22WebViewJavascriptBridge: WARNING: Error when trying to fetch data from WKWebView: %@\x22\x3c\/span\x3e, error);\n        }\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/把消息或者WEB回调从OC发送到OC\x3c\/span\x3e\n        [_base flushMessageQueue:result];\n    }];\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e获取到javascript给OC的回调消息以后，然后把javascript的bridge返回的信息加工处理成OC环境的bridge能识别的信息。从而找到具体的实现执行。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/把从WEB发送的消息返回。然后在这里处理\n- (void)flushMessageQueue:(NSString *)messageQueueString{\n    if (messageQueueString == nil || messageQueueString.length == 0) {\n        NSLog(@\x26quot;WebViewJavascriptBridge: WARNING: ObjC got nil while fetching the message queue JSON from webview. This can happen if the WebViewJavascriptBridge JS is not currently present in the webview, e.g if the webview just loaded a new page.\x26quot;);\n        return;\n    }\n\n    id messages = [self _deserializeMessageJSON:messageQueueString];\n    for (WVJBMessage* message in messages) {\n        if (![message isKindOfClass:[WVJBMessage class]]) {\n            NSLog(@\x26quot;WebViewJavascriptBridge: WARNING: Invalid %@ received: %@\x26quot;, [message class], message);\n            continue;\n        }\n        [self _log:@\x26quot;RCVD\x26quot; json:message];\n        \n        NSString* responseId = message[@\x26quot;responseId\x26quot;];\n        if (responseId) {\n            WVJBResponseCallback responseCallback = _responseCallbacks[responseId];\n            responseCallback(message[@\x26quot;responseData\x26quot;]);\n            [self.responseCallbacks removeObjectForKey:responseId];\n        } else {\n            WVJBResponseCallback responseCallback = NULL;\n            NSString* callbackId = message[@\x26quot;callbackId\x26quot;];\n            if (callbackId) {\n                responseCallback = ^(id responseData) {\n                    if (responseData == nil) {\n                        responseData = [NSNull null];\n                    }\n                    \n                    WVJBMessage* msg = @{ @\x26quot;responseId\x26quot;:callbackId, @\x26quot;responseData\x26quot;:responseData };\n                    [self _queueMessage:msg];\n                };\n            } else {\n                responseCallback = ^(id ignoreResponseData) {\n                    \/\/ Do nothing\n                };\n            }\n            \n            WVJBHandler handler = self.messageHandlers[message[@\x26quot;handlerName\x26quot;]];\n            \n            if (!handler) {\n                NSLog(@\x26quot;WVJBNoHandlerException, No handler for message from JS: %@\x26quot;, message);\n                continue;\n            }\n            \n            handler(message[@\x26quot;data\x26quot;], responseCallback);\n        }\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs objectivec\x22\x3e\x3ccode class=\x22objc\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/把从WEB发送的消息返回。然后在这里处理\x3c\/span\x3e\n- (\x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e)flushMessageQueue:(\x3cspan class=\x22hljs-built_in\x22\x3eNSString\x3c\/span\x3e *)messageQueueString{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (messageQueueString == \x3cspan class=\x22hljs-literal\x22\x3enil\x3c\/span\x3e || messageQueueString.length == \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-built_in\x22\x3eNSLog\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e@\x22WebViewJavascriptBridge: WARNING: ObjC got nil while fetching the message queue JSON from webview. This can happen if the WebViewJavascriptBridge JS is not currently present in the webview, e.g if the webview just loaded a new page.\x22\x3c\/span\x3e);\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eid\x3c\/span\x3e messages = [\x3cspan class=\x22hljs-keyword\x22\x3eself\x3c\/span\x3e _deserializeMessageJSON:messageQueueString];\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (WVJBMessage* message \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e messages) {\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (![message isKindOfClass:[WVJBMessage \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e]]) {\n            \x3cspan class=\x22hljs-built_in\x22\x3eNSLog\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e@\x22WebViewJavascriptBridge: WARNING: Invalid %@ received: %@\x22\x3c\/span\x3e, [message \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e], message);\n            \x3cspan class=\x22hljs-keyword\x22\x3econtinue\x3c\/span\x3e;\n        }\n        [\x3cspan class=\x22hljs-keyword\x22\x3eself\x3c\/span\x3e _log:\x3cspan class=\x22hljs-string\x22\x3e@\x22RCVD\x22\x3c\/span\x3e json:message];\n        \n        \x3cspan class=\x22hljs-built_in\x22\x3eNSString\x3c\/span\x3e* responseId = message[\x3cspan class=\x22hljs-string\x22\x3e@\x22responseId\x22\x3c\/span\x3e];\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (responseId) {\n            WVJBResponseCallback responseCallback = _responseCallbacks[responseId];\n            responseCallback(message[\x3cspan class=\x22hljs-string\x22\x3e@\x22responseData\x22\x3c\/span\x3e]);\n            [\x3cspan class=\x22hljs-keyword\x22\x3eself\x3c\/span\x3e.responseCallbacks removeObjectForKey:responseId];\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n            WVJBResponseCallback responseCallback = \x3cspan class=\x22hljs-literal\x22\x3eNULL\x3c\/span\x3e;\n            \x3cspan class=\x22hljs-built_in\x22\x3eNSString\x3c\/span\x3e* callbackId = message[\x3cspan class=\x22hljs-string\x22\x3e@\x22callbackId\x22\x3c\/span\x3e];\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (callbackId) {\n                responseCallback = ^(\x3cspan class=\x22hljs-keyword\x22\x3eid\x3c\/span\x3e responseData) {\n                    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (responseData == \x3cspan class=\x22hljs-literal\x22\x3enil\x3c\/span\x3e) {\n                        responseData = [\x3cspan class=\x22hljs-built_in\x22\x3eNSNull\x3c\/span\x3e null];\n                    }\n                    \n                    WVJBMessage* msg = @{ \x3cspan class=\x22hljs-string\x22\x3e@\x22responseId\x22\x3c\/span\x3e:callbackId, \x3cspan class=\x22hljs-string\x22\x3e@\x22responseData\x22\x3c\/span\x3e:responseData };\n                    [\x3cspan class=\x22hljs-keyword\x22\x3eself\x3c\/span\x3e _queueMessage:msg];\n                };\n            } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n                responseCallback = ^(\x3cspan class=\x22hljs-keyword\x22\x3eid\x3c\/span\x3e ignoreResponseData) {\n                    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Do nothing\x3c\/span\x3e\n                };\n            }\n            \n            WVJBHandler handler = \x3cspan class=\x22hljs-keyword\x22\x3eself\x3c\/span\x3e.messageHandlers[message[\x3cspan class=\x22hljs-string\x22\x3e@\x22handlerName\x22\x3c\/span\x3e]];\n            \n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!handler) {\n                \x3cspan class=\x22hljs-built_in\x22\x3eNSLog\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e@\x22WVJBNoHandlerException, No handler for message from JS: %@\x22\x3c\/span\x3e, message);\n                \x3cspan class=\x22hljs-keyword\x22\x3econtinue\x3c\/span\x3e;\n            }\n            \n            handler(message[\x3cspan class=\x22hljs-string\x22\x3e@\x22data\x22\x3c\/span\x3e], responseCallback);\n        }\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里会调用handler方法，通过javascript传过来的responseId获取对应的\x3ccode\x3eWVJBResponseCallback\x3c\/code\x3e。然后执行这个block。到这里从OC发送消息到javascript并且javascript返回消息给OC的流程走完了。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3eWEB发消息给OC\x3c\/h2\x3e\n\x3cp\x3e首先通过\x3ccode\x3eExampleAPP.html\x3c\/code\x3e中的\x3ccode\x3ebridge.callHandler\x3c\/code\x3e方法，这里的bridge就是\x3ccode\x3ewindow.WebViewJavascriptBridge\x3c\/code\x3e对象：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22bridge.callHandler(\x27OC提供方法给JS调用\x27,params, function(response) {\n    log(\x27JS调用OC的返回值\x27, response)\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3ebridge.callHandler(\x3cspan class=\x22hljs-string\x22\x3e\x27OC提供方法给JS调用\x27\x3c\/span\x3e,params, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eresponse\x3c\/span\x3e) \x3c\/span\x3e{\n    log(\x3cspan class=\x22hljs-string\x22\x3e\x27JS调用OC的返回值\x27\x3c\/span\x3e, response)\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e接下来调用\x3ccode\x3ewindow.WebViewJavascriptBridge\x3c\/code\x3e中的callHander方法\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/web端调用一个OC注册的消息\nfunction callHandler(handlerName, data, responseCallback) {\n    if (arguments.length == 2 \x26amp;\x26amp; typeof data == \x27function\x27) {\n        responseCallback = data;\n        data = null;\n    }\n    _doSend({ handlerName: handlerName, data: data }, responseCallback);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/web端调用一个OC注册的消息\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecallHandler\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ehandlerName, data, responseCallback\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e.length == \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e \x26amp;\x26amp; \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e data == \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e) {\n        responseCallback = data;\n        data = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n    }\n    _doSend({ \x3cspan class=\x22hljs-attr\x22\x3ehandlerName\x3c\/span\x3e: handlerName, \x3cspan class=\x22hljs-attr\x22\x3edata\x3c\/span\x3e: data }, responseCallback);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e然后调用\x3ccode\x3eWebViewJavascriptBridge_JS.js\x3c\/code\x3e中的方法执行具体的操作。具体就和OC调用javascript过程一样了，就不解释了。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/把消息从JS发送到OC，执行具体的发送操作。\nfunction _doSend(message, responseCallback) {\n    if (responseCallback) {\n        var callbackId = \x27cb_\x27 \x2b (uniqueId\x2b\x2b) \x2b \x27_\x27 \x2b new Date().getTime();\n        \/\/存储消息的回调ID\n        responseCallbacks[callbackId] = responseCallback;\n        \/\/把消息对应的回调ID和消息一起发送，以供消息返回以后使用。\n        message[\x27callbackId\x27] = callbackId;\n    }\n    \/\/把消息放入消息列表\n    sendMessageQueue.push(message);\n    \/\/下面这句话会出发JS对OC的调用\n    \/\/让webview执行跳转操作，从而可以在\n    \/\/webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler 中拦截到JS发给OC的消息\n    messagingIframe.src = CUSTOM_PROTOCOL_SCHEME \x2b \x27:\/\/\x27 \x2b QUEUE_HAS_MESSAGE;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/把消息从JS发送到OC，执行具体的发送操作。\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e_doSend\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3emessage, responseCallback\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (responseCallback) {\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e callbackId = \x3cspan class=\x22hljs-string\x22\x3e\x27cb_\x27\x3c\/span\x3e \x2b (uniqueId\x2b\x2b) \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27_\x27\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e().getTime();\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/存储消息的回调ID\x3c\/span\x3e\n        responseCallbacks[callbackId] = responseCallback;\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/把消息对应的回调ID和消息一起发送，以供消息返回以后使用。\x3c\/span\x3e\n        message[\x3cspan class=\x22hljs-string\x22\x3e\x27callbackId\x27\x3c\/span\x3e] = callbackId;\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/把消息放入消息列表\x3c\/span\x3e\n    sendMessageQueue.push(message);\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/下面这句话会出发JS对OC的调用\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/让webview执行跳转操作，从而可以在\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler 中拦截到JS发给OC的消息\x3c\/span\x3e\n    messagingIframe.src = CUSTOM_PROTOCOL_SCHEME \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27:\/\/\x27\x3c\/span\x3e \x2b QUEUE_HAS_MESSAGE;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3e总结\x3c\/h2\x3e\n\x3cp\x3e其实现在想想，原理很简单。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e分别在OC环境和javascript环境都保存一个bridge对象，里面维持着requestId,callbackId,以及每个id对应的具体实现。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eOC通过javascript环境的\x3ccode\x3ewindow.WebViewJavascriptBridge\x3c\/code\x3e对象来找到具体的方法，然后执行。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ejavascript通过改变iframe的src来出发webview的代理方法\x3ccode\x3ewebView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler\x3c\/code\x3e从而实现把javascript消息发送给OC这个功能。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e其实这里只是解析了webview与OC交互的桥接问题，其他比如webview中的请求拦截、添加进度条、运营商劫持、如何组织交互规则等问题这里还没有涉及。这些在我们项目中运用，具体就不抽出来了。\x3c\/p\x3e\n\x3cp\x3e最后，具体的源码在\x3ca href=\x22https:\/\/github.com\/huang303513\/iOSSourceCodeStudy\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3egithub地址\x3c\/a\x3e。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>WebViewJavascriptBridge原理解析</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000008948594">https://segmentfault.com/a/1190000008948594</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/iw3pn1g3s7/" target="_blank">https://alili.tech/archive/iw3pn1g3s7/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>