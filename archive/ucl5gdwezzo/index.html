<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="HTML5中手势原理分析与数学知识的实践"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>HTML5中手势原理分析与数学知识的实践 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/ucl5gdwezzo/",
				"appid": "1613049289050283", 
				"title": "HTML5中手势原理分析与数学知识的实践 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-05T02:30:11"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/whj15gl2og/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/6ljl45l4wk5/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fucl5gdwezzo%2f&text=HTML5%e4%b8%ad%e6%89%8b%e5%8a%bf%e5%8e%9f%e7%90%86%e5%88%86%e6%9e%90%e4%b8%8e%e6%95%b0%e5%ad%a6%e7%9f%a5%e8%af%86%e7%9a%84%e5%ae%9e%e8%b7%b5"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fucl5gdwezzo%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fucl5gdwezzo%2f&text=HTML5%e4%b8%ad%e6%89%8b%e5%8a%bf%e5%8e%9f%e7%90%86%e5%88%86%e6%9e%90%e4%b8%8e%e6%95%b0%e5%ad%a6%e7%9f%a5%e8%af%86%e7%9a%84%e5%ae%9e%e8%b7%b5"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fucl5gdwezzo%2f&title=HTML5%e4%b8%ad%e6%89%8b%e5%8a%bf%e5%8e%9f%e7%90%86%e5%88%86%e6%9e%90%e4%b8%8e%e6%95%b0%e5%ad%a6%e7%9f%a5%e8%af%86%e7%9a%84%e5%ae%9e%e8%b7%b5"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fucl5gdwezzo%2f&is_video=false&description=HTML5%e4%b8%ad%e6%89%8b%e5%8a%bf%e5%8e%9f%e7%90%86%e5%88%86%e6%9e%90%e4%b8%8e%e6%95%b0%e5%ad%a6%e7%9f%a5%e8%af%86%e7%9a%84%e5%ae%9e%e8%b7%b5"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=HTML5%e4%b8%ad%e6%89%8b%e5%8a%bf%e5%8e%9f%e7%90%86%e5%88%86%e6%9e%90%e4%b8%8e%e6%95%b0%e5%ad%a6%e7%9f%a5%e8%af%86%e7%9a%84%e5%ae%9e%e8%b7%b5&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fucl5gdwezzo%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fucl5gdwezzo%2f&title=HTML5%e4%b8%ad%e6%89%8b%e5%8a%bf%e5%8e%9f%e7%90%86%e5%88%86%e6%9e%90%e4%b8%8e%e6%95%b0%e5%ad%a6%e7%9f%a5%e8%af%86%e7%9a%84%e5%ae%9e%e8%b7%b5"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fucl5gdwezzo%2f&title=HTML5%e4%b8%ad%e6%89%8b%e5%8a%bf%e5%8e%9f%e7%90%86%e5%88%86%e6%9e%90%e4%b8%8e%e6%95%b0%e5%ad%a6%e7%9f%a5%e8%af%86%e7%9a%84%e5%ae%9e%e8%b7%b5"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fucl5gdwezzo%2f&title=HTML5%e4%b8%ad%e6%89%8b%e5%8a%bf%e5%8e%9f%e7%90%86%e5%88%86%e6%9e%90%e4%b8%8e%e6%95%b0%e5%ad%a6%e7%9f%a5%e8%af%86%e7%9a%84%e5%ae%9e%e8%b7%b5"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fucl5gdwezzo%2f&title=HTML5%e4%b8%ad%e6%89%8b%e5%8a%bf%e5%8e%9f%e7%90%86%e5%88%86%e6%9e%90%e4%b8%8e%e6%95%b0%e5%ad%a6%e7%9f%a5%e8%af%86%e7%9a%84%e5%ae%9e%e8%b7%b5"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">HTML5中手势原理分析与数学知识的实践</h1><div class="meta"><div class="postdate"><time datetime="2019-01-05" itemprop="datePublished">2019-01-05</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch1 id=\x22articleHeader0\x22\x3eHTML5中手势原理分析与数学知识的实践\x3c\/h1\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e引言\x3c\/h2\x3e\n\x3cp\x3e在这触控屏的时代，人性化的手势操作已经深入了我们生活的每个部分。现代应用越来越重视与用户的交互及体验，手势是最直接且最为有效的交互方式，一个好的手势交互，能降低用户的使用成本和流程，大大提高了用户的体验。\x3c\/p\x3e\n\x3cp\x3e近期，公司的多个项目中都对手势有着较高的需求，已有的手势库无法完全cover，因此便撸了一个轻量、便于使用的移动端手势库。这篇博文主要是解析了移动端常用手势的原理，及从前端的角度学习过程中所使用的数学知识。希望能对大家有一点点的启发作用，也期待大神们指出不足甚至错误，感恩。\x3c\/p\x3e\n\x3cp\x3e主要讲解项目中经常使用到的五种手势：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e拖动: \x3ccode\x3edrag\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e双指缩放: \x3ccode\x3epinch\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e双指旋转: \x3ccode\x3erotate\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e单指缩放: \x3ccode\x3esinglePinch\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e单指旋转: \x3ccode\x3esingleRotate\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cblockquote\x3e\x3cp\x3eTips :\x3cbr\x3e因为 \x3ccode\x3etap\x3c\/code\x3e 及 \x3ccode\x3eswipe\x3c\/code\x3e 很多基础库中包含，为了轻便，因此并没有包含,但如果需要，可进行扩展;\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e实现原理\x3c\/h2\x3e\n\x3cp\x3e众所周知，所有的手势都是基于浏览器原生事件\x3ccode\x3etouchstart\x3c\/code\x3e, \x3ccode\x3etouchmove\x3c\/code\x3e, \x3ccode\x3etouchend\x3c\/code\x3e, \x3ccode\x3etouchcancel\x3c\/code\x3e进行的上层封装，因此封装的思路是通过一个个相互独立的事件回调仓库\x3ccode\x3ehandleBus\x3c\/code\x3e，然后在原生\x3ccode\x3etouch\x3c\/code\x3e事件中符合条件的时机触发并传出计算后的参数值，完成手势的操作。实现原理较为简单清晰，先不急，我们先来理清一些使用到的数学概念并结合代码，将数学运用到实际问题中，数学部分可能会比较枯燥，但希望大家坚持读完，相信会收益良多。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e基础数学知识函数\x3c\/h2\x3e\n\x3cp\x3e我们常见的坐标系属于线性空间，或称向量空间(Vector Space)。这个空间是一个由点(Point) 和 向量(Vector) 所组成集合；\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e点(Point)\x3c\/h3\x3e\n\x3cp\x3e可以理解为我们的坐标点,例如原点\x3ccode\x3eO(0,0),A(-1,2)\x3c\/code\x3e，通过原生事件对象的\x3ccode\x3etouches\x3c\/code\x3e可以获取触摸点的坐标，参数\x3ccode\x3eindex\x3c\/code\x3e代表第几接触点；\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVSgD3?w=922\x26amp;h=336\x22 src=\x22https:\/\/static.alili.tech\/img\/bVSgD3?w=922\x26amp;h=336\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e向量(Vector)\x3c\/h3\x3e\n\x3cp\x3e是坐标系中一种 \x3cstrong\x3e既有大小也有方向的线段\x3c\/strong\x3e，例如由原点\x3ccode\x3eO(0,0)\x3c\/code\x3e指向点\x3ccode\x3eA(1,1)\x3c\/code\x3e的箭头线段，称为向量\x3ccode\x3ea\x3c\/code\x3e，则\x3ccode\x3ea=(1-0,1-0)=(1,1)\x3c\/code\x3e;\x3c\/p\x3e\n\x3cp\x3e如下图所示，其中\x3ccode\x3ei\x3c\/code\x3e与\x3ccode\x3ej\x3c\/code\x3e向量称为该坐标系的单位向量，也称为基向量，我们常见的坐标系单位为\x3ccode\x3e1\x3c\/code\x3e,即\x3ccode\x3ei=(1,0)；j=(0,1)\x3c\/code\x3e；\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVSgD7?w=600\x26amp;h=560\x22 src=\x22https:\/\/static.alili.tech\/img\/bVSgD7?w=600\x26amp;h=560\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e获取向量的函数：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVSgD8?w=724\x26amp;h=290\x22 src=\x22https:\/\/static.alili.tech\/img\/bVSgD8?w=724\x26amp;h=290\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e向量模\x3c\/h3\x3e\n\x3cp\x3e代表 \x3cstrong\x3e向量的长度\x3c\/strong\x3e，记为\x3ccode\x3e|a|\x3c\/code\x3e，是一个标量，只有大小，没有方向;\x3c\/p\x3e\n\x3cp\x3e几何意义代表的是以\x3ccode\x3ex,y\x3c\/code\x3e为直角边的直角三角形的斜边，通过勾股定理进行计算；\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVSgEc?w=552\x26amp;h=452\x22 src=\x22https:\/\/static.alili.tech\/img\/bVSgEc?w=552\x26amp;h=452\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3egetLength\x3c\/code\x3e函数：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVSgEg?w=946\x26amp;h=166\x22 src=\x22https:\/\/static.alili.tech\/img\/bVSgEg?w=946\x26amp;h=166\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e向量的数量积\x3c\/h3\x3e\n\x3cp\x3e向量同样也具有可以运算的属性，它可以进行加、减、乘、数量积和向量积等运算，接下来就介绍下我们使用到的数量积这个概念，也称为点积，被定义为公式：\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e当a=(x1,y1),b=(x2,y2)，则a·b=|a|·|b|·cosθ=x1·x2\x2by1·y2；\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e共线定理\x3c\/h3\x3e\n\x3cp\x3e共线，即两个向量处于 \x3cstrong\x3e平行\x3c\/strong\x3e 的状态，当\x3ccode\x3ea=(x1,y1),b=(x2,y2)\x3c\/code\x3e，则存在唯一的一个实数λ，使得\x3ccode\x3ea=λb\x3c\/code\x3e，代入坐标点后，可以得到 \x3ccode\x3ex1·y2= y1·x2\x3c\/code\x3e;\x3c\/p\x3e\n\x3cp\x3e因此当\x3ccode\x3ex1·y2-x2·y1\x26gt;0\x3c\/code\x3e 时，既斜率 \x3cstrong\x3eka \x26gt; kb\x3c\/strong\x3e ，所以此时\x3ccode\x3eb\x3c\/code\x3e向量相对于\x3ccode\x3ea\x3c\/code\x3e向量是属于顺时针旋转，反之，则为逆时针；\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3e旋转角度\x3c\/h3\x3e\n\x3cp\x3e通过数量积公式我们可以推到求出两个向量的夹角：\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3ecosθ=(x1·x2\x2by1·y2)\/(|a|·|b|);\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e然后通过共线定理我们可以判断出旋转的方向，函数定义为：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVSgEh?w=1128\x26amp;h=1002\x22 src=\x22https:\/\/static.alili.tech\/img\/bVSgEh?w=1128\x26amp;h=1002\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3e矩阵与变换\x3c\/h3\x3e\n\x3cp\x3e由于空间最本质的特征就是其可以容纳运动，因此在线性空间中，\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e我们用向量来刻画对象，而矩阵便是用来描述对象的运动；\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch4\x3e而矩阵是如何描述运动的呢?\x3c\/h4\x3e\n\x3cp\x3e我们知道，通过一个坐标系基向量便可以确定一个向量，例如 \x3ccode\x3ea=(-1,2)\x3c\/code\x3e,我们通常约定的基向量是 i = (1,0) 与 j = (0,1)； 因此:\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3ea = -1i \x2b 2j = -1\x3cem\x3e(1,0) \x2b 2\x3c\/em\x3e(0,1) = (-1\x2b0,0\x2b2) = (-1,2);\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e而矩阵变换的，其实便是通过矩阵转换了基向量，从而完成了向量的变换；\x3c\/p\x3e\n\x3cp\x3e例如上面的栗子，把\x3ccode\x3ea\x3c\/code\x3e向量通过矩阵(1,2,3,0)进行变换，此时基向量\x3ccode\x3ei\x3c\/code\x3e由 \x3ccode\x3e(1,0)\x3c\/code\x3e变换成\x3ccode\x3e(1,-2)\x3c\/code\x3e与\x3ccode\x3ej\x3c\/code\x3e由\x3ccode\x3e(0,1)\x3c\/code\x3e变换成\x3ccode\x3e(3,0)\x3c\/code\x3e,沿用上面的推导，则\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3ea = -1i \x2b 2j = -1(-1,2) \x2b 2(3,0) = (5,-2);\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e如下图所示：\x3cbr\x3eA图表示变换之前的坐标系，此时\x3ccode\x3ea=(-1,2)\x3c\/code\x3e，通过矩阵变换后，基向量\x3ccode\x3ei，j\x3c\/code\x3e的变换引起了坐标系的变换，变成了下图B，因此\x3ccode\x3ea\x3c\/code\x3e向量由\x3ccode\x3e(-1,2)\x3c\/code\x3e变换成了\x3ccode\x3e(5,-2)\x3c\/code\x3e；\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e其实向量与坐标系的关联不变(\x3ccode\x3ea = -1i\x2b2j\x3c\/code\x3e)，是基向量引起坐标系变化，然后坐标系沿用关联导致了向量的变化；\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVSgEW?w=593\x26amp;h=473\x22 src=\x22https:\/\/static.alili.tech\/img\/bVSgEW?w=593\x26amp;h=473\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch4\x3e结合代码\x3c\/h4\x3e\n\x3cp\x3e其实CSS的\x3ccode\x3etransform\x3c\/code\x3e等变换便是通过矩阵进行的，我们平时所写的\x3ccode\x3etranslate\/rotate\x3c\/code\x3e等语法类似于一种封装好的语法糖，便于快捷使用，而在底层都会被转换成矩阵的形式。例如\x3ccode\x3etransform:translate(-30px,-30px)\x3c\/code\x3e编译后会被转换成\x3ccode\x3etransform : matrix(1,0,0,1,30,30)\x3c\/code\x3e;\x3c\/p\x3e\n\x3cp\x3e通常在二维坐标系中，只需要 2X2 的矩阵便足以描述所有的变换了， 但由于CSS是处于3D环境中的，因此CSS中使用的是 3X3 的矩阵，表示为：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVSgE1?w=254\x26amp;h=164\x22 src=\x22https:\/\/static.alili.tech\/img\/bVSgE1?w=254\x26amp;h=164\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e其中第三行的\x3ccode\x3e0,0,1\x3c\/code\x3e代表的就是\x3ccode\x3ez\x3c\/code\x3e轴的默认参数。这个矩阵中，\x3ccode\x3e(a,b)\x3c\/code\x3e 即为坐标轴的 \x3ccode\x3ei\x3c\/code\x3e基，而\x3ccode\x3e(c,d)\x3c\/code\x3e既为\x3ccode\x3ej\x3c\/code\x3e基,\x3ccode\x3ee\x3c\/code\x3e为\x3ccode\x3ex\x3c\/code\x3e轴的偏移量,\x3ccode\x3ef\x3c\/code\x3e为\x3ccode\x3ey\x3c\/code\x3e轴的偏移量;因此上栗便很好理解，\x3cstrong\x3e\x3ccode\x3etranslate\x3c\/code\x3e并没有导致\x3ccode\x3ei，j\x3c\/code\x3e基改变，只是发生了偏移\x3c\/strong\x3e，因此\x3ccode\x3etranslate(-30px,-30px) ==\x26gt; matrix(1,0,0,1,30,30)\x3c\/code\x3e~\x3c\/p\x3e\n\x3cp\x3e所有的\x3ccode\x3etransform\x3c\/code\x3e语句，都会发生对应的转换，如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 发生偏移，但基向量不变；\ntransform:translate(x,y) ==\x3e transform:matrix(1,0,0,1,x,y)\n\n\/\/ 基向量旋转；\ntransform:rotate(θdeg)==\x3e transform:matrix(cos(θ·π\/180),sin(θ·π\/180),-sin(θ·π\/180),cos(θ·π\/180),0,0)\n\n\/\/ 基向量放大且方向不变；\ntransform:scale(s) ==\x3e transform:matrix(s,0,0,s,0,0)\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs rsl\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 发生偏移，但基向量不变；\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3etransform\x3c\/span\x3e:translate(x,y) ==\x26gt; \x3cspan class=\x22hljs-built_in\x22\x3etransform\x3c\/span\x3e:\x3cspan class=\x22hljs-keyword\x22\x3ematrix\x3c\/span\x3e(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,x,y)\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 基向量旋转；\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3etransform\x3c\/span\x3e:rotate(θdeg)==\x26gt; \x3cspan class=\x22hljs-built_in\x22\x3etransform\x3c\/span\x3e:\x3cspan class=\x22hljs-keyword\x22\x3ematrix\x3c\/span\x3e(\x3cspan class=\x22hljs-built_in\x22\x3ecos\x3c\/span\x3e(θ·π\/\x3cspan class=\x22hljs-number\x22\x3e180\x3c\/span\x3e),\x3cspan class=\x22hljs-built_in\x22\x3esin\x3c\/span\x3e(θ·π\/\x3cspan class=\x22hljs-number\x22\x3e180\x3c\/span\x3e),-\x3cspan class=\x22hljs-built_in\x22\x3esin\x3c\/span\x3e(θ·π\/\x3cspan class=\x22hljs-number\x22\x3e180\x3c\/span\x3e),\x3cspan class=\x22hljs-built_in\x22\x3ecos\x3c\/span\x3e(θ·π\/\x3cspan class=\x22hljs-number\x22\x3e180\x3c\/span\x3e),\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e)\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 基向量放大且方向不变；\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3etransform\x3c\/span\x3e:scale(s) ==\x26gt; \x3cspan class=\x22hljs-built_in\x22\x3etransform\x3c\/span\x3e:\x3cspan class=\x22hljs-keyword\x22\x3ematrix\x3c\/span\x3e(s,\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,s,\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e)\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3etranslate\/rotate\/scale\x3c\/code\x3e等语法十分强大，让我们的代码更为可读且方便书写，但是\x3ccode\x3ematrix\x3c\/code\x3e有着更强大的转换特性，通过\x3ccode\x3ematrix\x3c\/code\x3e，可以发生任何方式的变换，例如我们常见的\x3cstrong\x3e镜像对称\x3c\/strong\x3e，\x3ccode\x3etransform:matrix(-1,0,0,1,0,0)\x3c\/code\x3e;\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVSgE3?w=442\x26amp;h=129\x22 src=\x22https:\/\/static.alili.tech\/img\/bVSgE3?w=442\x26amp;h=129\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch4\x3eMatrixTo\x3c\/h4\x3e\n\x3cp\x3e然而\x3ccode\x3ematrix\x3c\/code\x3e虽然强大，但可读性却不好，而且我们的写入是通过\x3ccode\x3etranslate\/rotate\/scale\x3c\/code\x3e的属性,然而通过\x3ccode\x3egetComputedStyle\x3c\/code\x3e读取到的 \x3ccode\x3etransform\x3c\/code\x3e却是\x3ccode\x3ematrix\x3c\/code\x3e:\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3etransform:matrix(1.41421, 1.41421, -1.41421, 1.41421, -50, -50);\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e请问这个元素发生了怎么样的变化?。。这就一脸懵逼了。-_-|||\x3c\/p\x3e\n\x3cp\x3e因此，我们必须要有个方法，来将\x3ccode\x3ematrix\x3c\/code\x3e翻译成我们更为熟悉的\x3ccode\x3etranslate\/rotate\/scale\x3c\/code\x3e方式，在理解了其原理后，我们便可以着手开始表演咯~\x3c\/p\x3e\n\x3cp\x3e我们知道，前4个参数会同时受到\x3ccode\x3erotate\x3c\/code\x3e和\x3ccode\x3escale\x3c\/code\x3e的影响，具有两个变量，因此需要通过前两个参数根据上面的转换方式列出两个不等式：\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3ecos(θ·π\/180)*s=1.41421;\x3c\/p\x3e\n\x3cp\x3esin(θ·π\/180)*s=1.41421;\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e将两个不等式相除，即可以轻松求出\x3ccode\x3eθ\x3c\/code\x3e和\x3ccode\x3es\x3c\/code\x3e了，perfect！！函数如下：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVSgE6?w=1392\x26amp;h=1062\x22 src=\x22https:\/\/static.alili.tech\/img\/bVSgE6?w=1392\x26amp;h=1062\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader11\x22\x3e手势原理\x3c\/h2\x3e\n\x3cp\x3e接下来我们将上面的函数用到实际环境中，通过图示的方式来模拟手势的操作，简要地讲解手势计算的原理。希望各位大神理解这些基础的原理后，能创造出更多炫酷的手势，像我们在\x3ccode\x3emac\x3c\/code\x3e触控板上使用的一样。\x3c\/p\x3e\n\x3cp\x3e下面图例：\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3e圆点: 代表手指的触碰点;\x3c\/p\x3e\n\x3cp\x3e两个圆点之间的虚线段: 代表双指操作时组成的向量;\x3c\/p\x3e\n\x3cp\x3ea向量\/A点：代表在 touchstart 时获取的初始向量\/初始点；\x3c\/p\x3e\n\x3cp\x3eb向量\/B点：代表在 touchmove 时获取的实时向量\/实时点；\x3c\/p\x3e\n\x3cp\x3e坐标轴底部的公式代表需要计算的值；\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader12\x22\x3eDrag(拖动事件)\x3c\/h3\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVSgE7?w=616\x26amp;h=510\x22 src=\x22https:\/\/static.alili.tech\/img\/bVSgE7?w=616\x26amp;h=510\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e上图是模拟了拖动手势，由\x3ccode\x3eA\x3c\/code\x3e点移动到\x3ccode\x3eB\x3c\/code\x3e点，我们要计算的便是这个过程的偏移量；\x3c\/p\x3e\n\x3cp\x3e因此我们在\x3ccode\x3etouchstart\x3c\/code\x3e中记录初始点A的坐标：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 获取初始点A；\nlet startPoint = getPoint(ev,0);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 获取初始点A；\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e startPoint = getPoint(ev,\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e然后在\x3ccode\x3etouchmove\x3c\/code\x3e事件中获取当前点并实时的计算出\x3ccode\x3e△x\x3c\/code\x3e与\x3ccode\x3e△y\x3c\/code\x3e：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 实时获取初始点B；\nlet curPoint = getPoint(ev,0);\n\n\/\/ 通过A、B两点，实时的计算出位移增量，触发 drag 事件并传出参数；\n_eventFire(\x27drag\x27, {\n    delta: {\n        deltaX: curPoint.x - startPoint.x,\n        deltaY: curPoint.y - startPoint.y,\n    },\n    origin: ev,\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 实时获取初始点B；\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e curPoint = getPoint(ev,\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 通过A、B两点，实时的计算出位移增量，触发 drag 事件并传出参数；\x3c\/span\x3e\n_eventFire(\x3cspan class=\x22hljs-string\x22\x3e\x27drag\x27\x3c\/span\x3e, {\n    \x3cspan class=\x22hljs-attr\x22\x3edelta\x3c\/span\x3e: {\n        \x3cspan class=\x22hljs-attr\x22\x3edeltaX\x3c\/span\x3e: curPoint.x - startPoint.x,\n        \x3cspan class=\x22hljs-attr\x22\x3edeltaY\x3c\/span\x3e: curPoint.y - startPoint.y,\n    },\n    \x3cspan class=\x22hljs-attr\x22\x3eorigin\x3c\/span\x3e: ev,\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e\x3cp\x3eTips: \x3ccode\x3efire\x3c\/code\x3e函数即遍历执行\x3ccode\x3edrag\x3c\/code\x3e事件对应的回调仓库即可；\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader13\x22\x3ePinch(双指缩放)\x3c\/h3\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVSgE9?w=598\x26amp;h=554\x22 src=\x22https:\/\/static.alili.tech\/img\/bVSgE9?w=598\x26amp;h=554\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e上图是双指缩放的模拟图，双指由\x3ccode\x3ea\x3c\/code\x3e向量放大到\x3ccode\x3eb\x3c\/code\x3e向量，通过初始状态时的\x3ccode\x3ea\x3c\/code\x3e向量的模与\x3ccode\x3etouchmove\x3c\/code\x3e中获取的\x3ccode\x3eb\x3c\/code\x3e向量的模进行计算，便可得出缩放值：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ touchstart中计算初始双指的向量模；\nlet vector1 = getVector(secondPoint, startPoint);\nlet pinchStartLength = getLength(vector1);\n\n\/\/ touchmove中计算实时的双指向量模；\nlet vector2 = getVector(curSecPoint, curPoint);\nlet pinchLength = getLength(vector2);\nthis._eventFire(\x27pinch\x27, {\n    delta: {\n        scale: pinchLength \/ pinchStartLength,\n    },\n    origin: ev,\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ touchstart中计算初始双指的向量模；\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e vector1 = getVector(secondPoint, startPoint);\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e pinchStartLength = getLength(vector1);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ touchmove中计算实时的双指向量模；\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e vector2 = getVector(curSecPoint, curPoint);\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e pinchLength = getLength(vector2);\n\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._eventFire(\x3cspan class=\x22hljs-string\x22\x3e\x27pinch\x27\x3c\/span\x3e, {\n    \x3cspan class=\x22hljs-attr\x22\x3edelta\x3c\/span\x3e: {\n        \x3cspan class=\x22hljs-attr\x22\x3escale\x3c\/span\x3e: pinchLength \/ pinchStartLength,\n    },\n    \x3cspan class=\x22hljs-attr\x22\x3eorigin\x3c\/span\x3e: ev,\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader14\x22\x3eRotate(双指旋转)\x3c\/h3\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVSgFa?w=592\x26amp;h=566\x22 src=\x22https:\/\/static.alili.tech\/img\/bVSgFa?w=592\x26amp;h=566\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e初始时双指向量\x3ccode\x3ea\x3c\/code\x3e，旋转到\x3ccode\x3eb\x3c\/code\x3e向量，\x3ccode\x3eθ\x3c\/code\x3e便是我们需要的值，因此只要通过我们上面构建的\x3ccode\x3egetAngle\x3c\/code\x3e函数，便可求出旋转的角度：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ a向量；\nlet vector1 = getVector(secondPoint, startPoint);\n\n\/\/ b向量；\nlet vector2 = getVector(curSecPoint, curPoint);\n\n\/\/ 触发事件;\nthis._eventFire(\x27rotate\x27, {\n    delta: {\n        rotate: getAngle(vector1, vector2),\n    },\n    origin: ev,\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ a向量；\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e vector1 = getVector(secondPoint, startPoint);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ b向量；\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e vector2 = getVector(curSecPoint, curPoint);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 触发事件;\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._eventFire(\x3cspan class=\x22hljs-string\x22\x3e\x27rotate\x27\x3c\/span\x3e, {\n    \x3cspan class=\x22hljs-attr\x22\x3edelta\x3c\/span\x3e: {\n        \x3cspan class=\x22hljs-attr\x22\x3erotate\x3c\/span\x3e: getAngle(vector1, vector2),\n    },\n    \x3cspan class=\x22hljs-attr\x22\x3eorigin\x3c\/span\x3e: ev,\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader15\x22\x3esinglePinch(单指缩放)\x3c\/h3\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVSgFc?w=606\x26amp;h=584\x22 src=\x22https:\/\/static.alili.tech\/img\/bVSgFc?w=606\x26amp;h=584\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e与上面的手势不同，单指缩放和单指旋转都需要多个特有概念：\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3e操作元素(\x3ccode\x3eoperator\x3c\/code\x3e)：需要操作的元素。上面三个手势其实并不关心操作元素，因为单纯靠手势自身，便能计算得出正确的参数值，而单指缩放和旋转需要依赖于操作元素的基准点(操作元素的中心点)进行计算；\x3c\/p\x3e\n\x3cp\x3e按钮：因为单指的手势与拖动(drag)手势是相互冲突的，需要一种特殊的交互方式来进行区分，这里是通过特定的区域来区分，类似于一个按钮，当在按钮上操作时，是单指缩放或者旋转，而在按钮区域外，则是常规的拖动，实践证明，这是一个用户很容易接受且体验较好的操作方式；\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e图中由\x3ccode\x3ea\x3c\/code\x3e向量单指放大到\x3ccode\x3eb\x3c\/code\x3e向量，对操作元(正方形)素进行了中心放大，此时缩放值即为\x3ccode\x3eb\x3c\/code\x3e向量的模 \/ \x3ccode\x3ea\x3c\/code\x3e向量的模；\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 计算单指操作时的基准点，获取operator的中心点；\nlet singleBasePoint = getBasePoint(operator);\n\n\/\/ touchstart 中计算初始向量模；\nlet pinchV1 = getVector(startPoint,singleBasePoint);\nsinglePinchStartLength = getLength(pinchV1);\n\n\/\/ touchmove 中计算实时向量模；\npinchV2 = getVector(curPoint, singleBasePoint);\nsinglePinchLength = getLength(pinchV2);\n\n\/\/ 触发事件；\nthis._eventFire(\x27singlePinch\x27, {\n    delta: {\n        scale: singlePinchLength \/ singlePinchStartLength,\n    },\n    origin: ev,\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 计算单指操作时的基准点，获取operator的中心点；\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e singleBasePoint = getBasePoint(operator);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ touchstart 中计算初始向量模；\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e pinchV1 = getVector(startPoint,singleBasePoint);\nsinglePinchStartLength = getLength(pinchV1);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ touchmove 中计算实时向量模；\x3c\/span\x3e\npinchV2 = getVector(curPoint, singleBasePoint);\nsinglePinchLength = getLength(pinchV2);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 触发事件；\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._eventFire(\x3cspan class=\x22hljs-string\x22\x3e\x27singlePinch\x27\x3c\/span\x3e, {\n    \x3cspan class=\x22hljs-attr\x22\x3edelta\x3c\/span\x3e: {\n        \x3cspan class=\x22hljs-attr\x22\x3escale\x3c\/span\x3e: singlePinchLength \/ singlePinchStartLength,\n    },\n    \x3cspan class=\x22hljs-attr\x22\x3eorigin\x3c\/span\x3e: ev,\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader16\x22\x3esingleRotate(单指旋转)\x3c\/h3\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVSgFh?w=644\x26amp;h=640\x22 src=\x22https:\/\/static.alili.tech\/img\/bVSgFh?w=644\x26amp;h=640\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e结合单指缩放和双指旋转，可以很简单的知道 \x3ccode\x3eθ\x3c\/code\x3e便是我们需要的旋转角度；\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 获取初始向量与实时向量\nlet rotateV1 = getVector(startPoint, singleBasePoint);\nlet rotateV2 = getVector(curPoint, singleBasePoint);\n\n\/\/ 通过 getAngle 获取旋转角度并触发事件；\nthis._eventFire(\x27singleRotate\x27, {\n    delta: {\n        rotate: getAngle(rotateV1, rotateV2),\n    },\n    origin: ev,\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 获取初始向量与实时向量\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e rotateV1 = getVector(startPoint, singleBasePoint);\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e rotateV2 = getVector(curPoint, singleBasePoint);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 通过 getAngle 获取旋转角度并触发事件；\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._eventFire(\x3cspan class=\x22hljs-string\x22\x3e\x27singleRotate\x27\x3c\/span\x3e, {\n    \x3cspan class=\x22hljs-attr\x22\x3edelta\x3c\/span\x3e: {\n        \x3cspan class=\x22hljs-attr\x22\x3erotate\x3c\/span\x3e: getAngle(rotateV1, rotateV2),\n    },\n    \x3cspan class=\x22hljs-attr\x22\x3eorigin\x3c\/span\x3e: ev,\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader17\x22\x3e运动增量\x3c\/h3\x3e\n\x3cp\x3e由于\x3ccode\x3etouchmove\x3c\/code\x3e事件是个高频率的实时触发事件，一个拖动操作，其实触发了N次的\x3ccode\x3etouchmove\x3c\/code\x3e事件，因此计算出来的值只是一种增量，即代表的是一次 \x3ccode\x3etouchmove\x3c\/code\x3e事件增加的值，只代表一段很小的值，并不是最终的结果值，因此需要由\x3ccode\x3emtouch.js\x3c\/code\x3e外部维护一个位置数据，类似于:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/    真实位置数据；\nlet dragTrans = {x = 0,y = 0};\n\n\/\/ 累加上 mtouch 所传递出的增量 deltaX 与 deltaY;\ndragTrans.x \x2b= ev.delta.deltaX;\ndragTrans.y \x2b= ev.delta.deltaY;\n\n\/\/ 通过 transform 直接操作元素；\nset($drag,dragTrans);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/    真实位置数据；\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e dragTrans = {x = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,y = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e};\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 累加上 mtouch 所传递出的增量 deltaX 与 deltaY;\x3c\/span\x3e\ndragTrans.x \x2b= ev.delta.deltaX;\ndragTrans.y \x2b= ev.delta.deltaY;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 通过 transform 直接操作元素；\x3c\/span\x3e\nset($drag,dragTrans);\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader18\x22\x3e初始位置\x3c\/h3\x3e\n\x3cp\x3e维护外部的这个位置数据，如果初始值像上述那样直接取0，则遇到使用css设置了\x3ccode\x3etransform\x3c\/code\x3e属性的元素便无法正确识别了，会导致操作元素开始时瞬间跳回\x3ccode\x3e(0,0)\x3c\/code\x3e的点，因此我们需要初始去获取一个元素真实的位置值，再进行维护与操作。此时，便需要用到上面我们提到的\x3ccode\x3egetComputedStyle\x3c\/code\x3e方法与\x3ccode\x3ematrixTo\x3c\/code\x3e函数：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 获取css transform属性，此时得到的是一个矩阵数据；\n\/\/ transform:matrix(1.41421,1.41421,-1.41421,1.41421,-50,-50);\nlet style = window.getComputedStyle(el,null);\nlet cssTrans = style.transform || style.webkitTransform;\n\n\/\/ 按规则进行转换，得到：\nlet initTrans = _.matrixTo(cssTrans);\n\n\/\/ {x:-50,y:-50,scale:2,rotate:45};\n\/\/ 即该元素设置了：transform:translate(-50px,-50px) scale(2) rotate(45deg);\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 获取css transform属性，此时得到的是一个矩阵数据；\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ transform:matrix(1.41421,1.41421,-1.41421,1.41421,-50,-50);\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e style = \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.getComputedStyle(el,\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e cssTrans = style.transform || style.webkitTransform;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 按规则进行转换，得到：\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e initTrans = _.matrixTo(cssTrans);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ {x:-50,y:-50,scale:2,rotate:45};\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 即该元素设置了：transform:translate(-50px,-50px) scale(2) rotate(45deg);\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader19\x22\x3e结语\x3c\/h2\x3e\n\x3cp\x3e至此，相信大家对手势的原理已经有基础的了解，基于这些原理，我们可以再封装出更多的手势，例如双击，长按，扫动，甚至更酷炫的三指、四指操作等，让应用拥有更多人性化的特质。\x3c\/p\x3e\n\x3cp\x3e基于以上原理，我封装了几个常见的工具：（求star -.-）\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3eTips: 因为只针对移动端，需在移动设备中打开\x3ccode\x3edemo\x3c\/code\x3e，或者pc端开启mobile调试模式！\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3emtouch.js : 移动端的手势库，封装了上述的五种手势，精简的api设计，涵盖了常见的手势交互，基于此也可以很方便的进行扩展。\x3cbr\x3e\x3cstrong\x3e\x3ca href=\x22http:\/\/f2er.meitu.com\/gxd\/mtouch\/example\/index.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3edemo\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22https:\/\/github.com\/xd-tayde\/mtouch\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3egithub\x3c\/a\x3e\x3c\/strong\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3etouchkit.js : 基于\x3ccode\x3emtouch\x3c\/code\x3e所封装的一层更贴近业务的工具包，可用于制作多种手势操作业务，一键开启，一站式服务。\x3cbr\x3e\x3cstrong\x3e\x3ca href=\x22http:\/\/f2er.meitu.com\/gxd\/touchkit\/example\/index.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3edemo\x3c\/a\x3e\x3c\/strong\x3e\x3cbr\x3e\x3cstrong\x3e\x3ca href=\x22https:\/\/github.com\/xd-tayde\/touchkit\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3egithub\x3c\/a\x3e\x3c\/strong\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3emcanvas.js : 基于canvas 开放极简的api实现图片\x26lt;段落文字\x26gt; \x26lt;混排文字\x26gt; \x26lt;裁剪\x26gt; \x26lt;平移\x26gt; \x26lt;旋转\x26gt; \x26lt;缩放\x26gt; \x26lt;水印添加\x26gt; 一键导出等。\x3cbr\x3e\x3cstrong\x3e\x3ca href=\x22http:\/\/f2er.meitu.com\/gxd\/mcanvas\/example\/index.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3edemo\x3c\/a\x3e\x3c\/strong\x3e \x3cbr\x3e\x3cstrong\x3e\x3ca href=\x22https:\/\/github.com\/xd-tayde\/mcanvas\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3egithub\x3c\/a\x3e\x3c\/strong\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch2 id=\x22articleHeader20\x22\x3e致谢\x3c\/h2\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e张鑫旭： \x3ca href=\x22http:\/\/www.zhangxinxu.com\/wordpress\/2012\/05\/getcomputedstyle-js-getpropertyvalue-currentstyle\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e获取元素CSS值之getComputedStyle方法熟悉\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e张鑫旭：\x3ca href=\x22http:\/\/www.zhangxinxu.com\/wordpress\/2012\/06\/css3-transform-matrix-%E7%9F%A9%E9%98%B5\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e理解CSS3 transform中的Matrix(矩阵)\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eAlloyTeam团队的\x3ccode\x3eAlloyFinger\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ehcysunyangd： \x3ca href=\x22https:\/\/juejin.im\/post\/5916851444d904006c5538f8\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e从矩阵与空间操作的关系理解CSS3的transform\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/www.360doc.com\/content\/14\/1112\/00\/202378_424428214.shtml\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e线性代数的理解 学完再看觉得自己弱爆了\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>HTML5中手势原理分析与数学知识的实践</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000010511484">https://segmentfault.com/a/1190000010511484</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/ucl5gdwezzo/" target="_blank">https://alili.tech/archive/ucl5gdwezzo/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>