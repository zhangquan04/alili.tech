<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="mobx——rudex的简单替代品"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>mobx——rudex的简单替代品 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/bcbr5lb7cj5/",
				"appid": "1613049289050283", 
				"title": "mobx——rudex的简单替代品 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-29T02:30:10"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/ud2tx9iukb/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/udt573c7g6/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fbcbr5lb7cj5%2f&text=mobx%e2%80%94%e2%80%94rudex%e7%9a%84%e7%ae%80%e5%8d%95%e6%9b%bf%e4%bb%a3%e5%93%81"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fbcbr5lb7cj5%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fbcbr5lb7cj5%2f&text=mobx%e2%80%94%e2%80%94rudex%e7%9a%84%e7%ae%80%e5%8d%95%e6%9b%bf%e4%bb%a3%e5%93%81"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fbcbr5lb7cj5%2f&title=mobx%e2%80%94%e2%80%94rudex%e7%9a%84%e7%ae%80%e5%8d%95%e6%9b%bf%e4%bb%a3%e5%93%81"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fbcbr5lb7cj5%2f&is_video=false&description=mobx%e2%80%94%e2%80%94rudex%e7%9a%84%e7%ae%80%e5%8d%95%e6%9b%bf%e4%bb%a3%e5%93%81"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=mobx%e2%80%94%e2%80%94rudex%e7%9a%84%e7%ae%80%e5%8d%95%e6%9b%bf%e4%bb%a3%e5%93%81&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fbcbr5lb7cj5%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fbcbr5lb7cj5%2f&title=mobx%e2%80%94%e2%80%94rudex%e7%9a%84%e7%ae%80%e5%8d%95%e6%9b%bf%e4%bb%a3%e5%93%81"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fbcbr5lb7cj5%2f&title=mobx%e2%80%94%e2%80%94rudex%e7%9a%84%e7%ae%80%e5%8d%95%e6%9b%bf%e4%bb%a3%e5%93%81"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fbcbr5lb7cj5%2f&title=mobx%e2%80%94%e2%80%94rudex%e7%9a%84%e7%ae%80%e5%8d%95%e6%9b%bf%e4%bb%a3%e5%93%81"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fbcbr5lb7cj5%2f&title=mobx%e2%80%94%e2%80%94rudex%e7%9a%84%e7%ae%80%e5%8d%95%e6%9b%bf%e4%bb%a3%e5%93%81"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">mobx——rudex的简单替代品</h1><div class="meta"><div class="postdate"><time datetime="2019-01-29" itemprop="datePublished">2019-01-29</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch2 id=\x22articleHeader0\x22\x3emobx 能干什么\x3c\/h2\x3e\n\x3cp\x3e使用 react 写小型应用，数据、业务逻辑和视图的模块划分不是很细是没有问题的。在这个阶段，引入任何状态管理库，都算是奢侈的。但是随着页面逻辑的复杂度提升，在中大型应用中，数据、业务逻辑和视图，如果不能很好的划分，就很有可能出现维护难、性能低下的问题。\x3c\/p\x3e\n\x3cp\x3e业内比较成熟的解决方案有 redux，但是 redux 使用过程中，给我的感觉是太复杂和繁琐。那么为什么不简单一点呢？mobx 的核心理念是 简单、可扩展的状态管理库。这可能正是你想要的。\x3c\/p\x3e\n\x3cp\x3ereact 关注的状态(state)到视图(view)的问题。而 mobx 关注的是状态仓库（store）到的状态(state)的问题。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e核心的概念1\x3c\/h2\x3e\n\x3cp\x3emobx 最最核心的概念只有2个。 \x3ccode\x3e@observable\x3c\/code\x3e 和 \x3ccode\x3e@observer\x3c\/code\x3e ，它们分别对应的是被观察者和观察者。这是大家常见的观察者模式，不过这里使用了，ES7 中的 \x3ca href=\x22http:\/\/es6.ruanyifeng.com\/#docs\/decorator\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e装饰器\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3e使用 \x3ccode\x3e@observable\x3c\/code\x3e 可以观察类的值。\x3c\/p\x3e\n\x3cp\x3e这里使用 \x3ccode\x3e@observable\x3c\/code\x3e 将 Store 的 \x3ccode\x3etodos\x3c\/code\x3e 变为一个被观察的值。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3eobservable\x3c\/h3\x3e\n\x3cp\x3e\x3cstrong\x3e仓库\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 这里引入的是 mobx\nimport {observable} from \x27mobx\x27;\n\nclass Store {\n  @observable todos = [{\n    title: \x26quot;todo标题\x26quot;,\n    done: false,\n  }];\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里引入的是 mobx\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e {observable} \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27mobx\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eStore\x3c\/span\x3e \x3c\/span\x3e{\n  @observable todos = [{\n    \x3cspan class=\x22hljs-attr\x22\x3etitle\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22todo标题\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3edone\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n  }];\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3eobserver\x3c\/h3\x3e\n\x3cp\x3e\x3cstrong\x3e mobx 组件\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e然后再使用 \x3ccode\x3e@observer\x3c\/code\x3e ，将组件变为观察者，响应 \x3ccode\x3etodos\x3c\/code\x3e 状态变化。\x3cbr\x3e当状态变化时，组件也会做相应的更新。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 这里引入的是 mobx-react\nimport {observer} from \x27mobx-react\x27;\n\n@observer\nclass TodoBox extends Component  {\n  render() {\n    return (\n      \x3cul\x3e\n        {this.props.store.todos.map(todo =\x3e \x3cli\x3e{todo.title}\x3c\/li\x3e)}\n      \x3c\/ul\x3e\n    )\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里引入的是 mobx-react\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e {observer} \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27mobx-react\x27\x3c\/span\x3e;\n\n@observer\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eTodoBox\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e  \x3c\/span\x3e{\n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eul\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        {this.props.store.todos.map(todo =\x26gt; \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e\x26gt;\x3c\/span\x3e{todo.title}\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e\x26gt;\x3c\/span\x3e)}\n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eul\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n    )\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e完整的 demo 如下。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import React, {Component} from \x27react\x27;\nimport { render } from \x27react-dom\x27;\nimport {observable} from \x27mobx\x27;\nimport {observer} from \x27mobx-react\x27;\n\n\/\/ 最简单的 mobx 就是一个观察者模式\n\nclass Store {\n  \/\/ 被观察者\n  @observable todos = [{\n    title: \x26quot;完成 Mobx 翻译\x26quot;,\n    done: false,\n  }];\n}\n\n\/\/ 观察者\n@observer\nclass TodoBox extends Component  {\n  render() {\n    return (\n      \x3cul\x3e\n        {this.props.store.todos.map(todo =\x3e \x3cli\x3e{todo.title}\x3c\/li\x3e)}\n      \x3c\/ul\x3e\n    )\n  }\n}\n\n\nconst store = new Store();\n\nrender(\n  \x3cTodoBox store={store} \/\x3e,\n  document.getElementById(\x27root\x27)\n);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e React, {Component} \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { render } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react-dom\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e {observable} \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27mobx\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e {observer} \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27mobx-react\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 最简单的 mobx 就是一个观察者模式\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eStore\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 被观察者\x3c\/span\x3e\n  @observable todos = [{\n    \x3cspan class=\x22hljs-attr\x22\x3etitle\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22完成 Mobx 翻译\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3edone\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n  }];\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 观察者\x3c\/span\x3e\n@observer\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eTodoBox\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e  \x3c\/span\x3e{\n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eul\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        {this.props.store.todos.map(todo =\x26gt; \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e\x26gt;\x3c\/span\x3e{todo.title}\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e\x26gt;\x3c\/span\x3e)}\n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eul\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n    )\n  }\n}\n\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e store = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Store();\n\nrender(\n  \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eTodoBox\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3estore\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{store}\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e,\n  document.getElementById(\x27root\x27)\n);\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e通过以上的简单的例子，展现了 mobx 分离数据、视图的能力。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e核心概念2\x3c\/h2\x3e\n\x3cp\x3e这一小节要介绍的两个概念虽然也是核心概念，但是是可选的。\x3c\/p\x3e\n\x3cp\x3e前面例子，只讲了状态的读取，那么状态应该如何写入呢？\x3c\/p\x3e\n\x3cp\x3e答案是直接写入！\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22@observer\nclass TodoBox extends Component  {\n  render() {\n    return (\n      \x3cdiv\x3e\n        \x3cul\x3e\n          {this.props.store.todos.map(\n            (todo,index) =\x3e \x3cli key={index}\x3e{todo.title}\x3c\/li\x3e\n          )}\n        \x3c\/ul\x3e\n        \x3cdiv\x3e\n          \x3cinput type=\x26quot;button\x26quot; onClick={() =\x3e {\n            \/\/ 直接修改仓库中的状态值\n            this.props.store.todos[0].title = \x26quot;修改后的todo标题\x26quot;\n          \x22}}\x22 value=\x26quot;点我\x26quot;\/\x3e\n        \x3c\/div\x3e\n      \x3c\/div\x3e\n    )\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e@observer\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eTodoBox\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e  \x3c\/span\x3e{\n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eul\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n          {this.props.store.todos.map(\n            (todo,index) =\x26gt; \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ekey\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{index}\x3c\/span\x3e\x26gt;\x3c\/span\x3e{todo.title}\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n          )}\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eul\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n          \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3einput\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22button\x22\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eonClick\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n            \/\/ 直接修改仓库中的状态值\n            this.props.store.todos[0].title = \x22修改后的todo标题\x22\n          \x22}}\x22 value=\x22点我\x22\/\x26gt;\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    )\n  }\n}\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e细心的朋友一定发现了奇怪的地方，react 官方说过 \x3ccode\x3eprops\x3c\/code\x3e 值不能直接修改，但是引入 mobx 后 \x3ccode\x3eprops\x3c\/code\x3e 可以直接修改了，这太奇怪了！\x3c\/p\x3e\n\x3cp\x3e解决办法就是 mobx 的下一个概念 \x3ccode\x3eaction\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3eactions\x3c\/h3\x3e\n\x3cp\x3e首先在 Store 中，定义一个 action。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Store {\n  @observable todos = [{\n    title: \x26quot;todo标题\x26quot;,\n    done: false,\n  }];\n  @action changeTodoTitle({index,title}){\n    this.todos[index].title = title\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eStore\x3c\/span\x3e \x3c\/span\x3e{\n  @observable todos = [{\n    \x3cspan class=\x22hljs-attr\x22\x3etitle\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22todo标题\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3edone\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n  }];\n  @action changeTodoTitle({index,title}){\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.todos[index].title = title\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在 Component 中调用，这样通过 action 的方法，就避免了直接修改 \x3ccode\x3eprops\x3c\/code\x3e 的问题。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cinput type=\x26quot;button\x26quot; onClick={() =\x3e {\n  this.props.store.changeTodoTitle({index:0,title:\x26quot;修改后的todo标题\x26quot;});\n\x22}}\x22 value=\x26quot;点我\x26quot;\/\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x26lt;input type=\x3cspan class=\x22hljs-string\x22\x3e\x22button\x22\x3c\/span\x3e onClick={() =\x26gt; {\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.store.changeTodoTitle({\x3cspan class=\x22hljs-attr\x22\x3eindex\x3c\/span\x3e:\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,\x3cspan class=\x22hljs-attr\x22\x3etitle\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x22修改后的todo标题\x22\x3c\/span\x3e});\n\x22}}\x22 value=\x3cspan class=\x22hljs-string\x22\x3e\x22点我\x22\x3c\/span\x3e\/\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可以通过引入 mobx 定义的严格模式，强制使用 action 来修改状态。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import {useStrict} from \x27mobx\x27;\n\nuseStrict(true);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e {useStrict} \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27mobx\x27\x3c\/span\x3e;\n\nuseStrict(\x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3ecomputed values\x3c\/h3\x3e\n\x3cp\x3e在有些时候，state 并不一定是我们需要的最终数据。例如，所有的 todo 都放在 store.todos 中，而已经完成的 todos 的值(store.unfinishedTodos)，可以由 store.todos 衍生而来。\x3c\/p\x3e\n\x3cp\x3e对此，mobx 提供了 \x3ccode\x3ecomputed\x3c\/code\x3e 装饰器，用于获取由基础 state 衍生出来的值。如果基础值没有变，获取衍生值时就会走缓存，这样就不会引起虚拟 DOM 的重新渲染。\x3c\/p\x3e\n\x3cp\x3e通过 \x3ccode\x3e@computed\x3c\/code\x3e \x2b \x3ccode\x3egetter\x3c\/code\x3e 函数来定义衍生值（computed values）。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import { computed } from \x27mobx\x27;\n\nclass Store {\n  @observable todos = [{\n    title: \x26quot;todo标题\x26quot;,\n    done: false,\n  },{\n    title: \x26quot;已经完成 todo 的标题\x26quot;,\n    done: true,\n  }];\n\n  @action changeTodoTitle({index,title}){\n    this.todos[index].title = title\n  }\n\n  @computed get finishedTodos () {\n    return  this.todos.filter((todo) =\x3e todo.done)\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { computed } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27mobx\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eStore\x3c\/span\x3e \x3c\/span\x3e{\n  @observable todos = [{\n    \x3cspan class=\x22hljs-attr\x22\x3etitle\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22todo标题\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3edone\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n  },{\n    \x3cspan class=\x22hljs-attr\x22\x3etitle\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22已经完成 todo 的标题\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3edone\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n  }];\n\n  @action changeTodoTitle({index,title}){\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.todos[index].title = title\n  }\n\n  @computed get finishedTodos () {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.todos.filter(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3etodo\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e todo.done)\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3emobx 有一套机制，如果衍生值（computed values）所依赖的基础状态（state）没有发生改变，获取衍生值时，不会重新计算，而是走的缓存。因此 mobx 不会引起过度渲染，从而保障了性能。\x3c\/p\x3e\n\x3cp\x3e当渲染的值为 finishedTodos ，点击修改标题，不会在控制台打印 \x22render\x22;\x3cbr\x3e换成 todos，就会打印 \x22render\x22.\x3cbr\x3e这是由于已完成的 todos 值没有改变，所以不会重新计算，而是走的缓存。因此不会调用 render 方法。\x3c\/p\x3e\n\x3cp\x3e完整 demo 如下\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import React, {Component} from \x27react\x27;\nimport { render } from \x27react-dom\x27;\nimport {observable, action, computed,useStrict} from \x27mobx\x27;\nimport {observer} from \x27mobx-react\x27;\n\nuseStrict(true);\n\n\nclass Store {\n  @observable todos = [{\n    title: \x26quot;todo标题\x26quot;,\n    done: false,\n  },{\n    title: \x26quot;已经完成 todo 的标题\x26quot;,\n    done: true,\n  }];\n\n  @action changeTodoTitle({index,title}){\n    this.todos[index].title = title\n  }\n\n  @computed get unfinishedTodos () {\n    return  this.todos.filter((todo) =\x3e todo.done)\n  }\n}\n\n\n@observer\nclass TodoBox extends Component  {\n\n  render() {\n    console.log(\x27render\x27);\n    return (\n      \x3cdiv\x3e\n        \x3cul\x3e\n          { \/* 把 unfinishedTodos 换成 todos，点击修改标题就会在控制台打印 \x26quot;render\x26quot;.*\/ }\n          {this.props.store.unfinishedTodos.map(\n            (todo,index) =\x3e \x3cli key={index}\x3e{todo.title}\x3c\/li\x3e\n          )}\n        \x3c\/ul\x3e\n        \x3cdiv\x3e\n          \x3cinput type=\x26quot;button\x26quot; onClick={() =\x3e {\n            this.props.store.changeTodoTitle({index:0,title:\x26quot;修改后的todo标题\x26quot;});\n          \x22}}\x22 value=\x26quot;修改标题\x26quot;\/\x3e\n        \x3c\/div\x3e\n      \x3c\/div\x3e\n    )\n  }\n}\n\nconst store = new Store();\n\nrender(\n  \x3cTodoBox store={store} \/\x3e,\n  document.getElementById(\x27root\x27)\n);\n\n\n\n\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e React, {Component} \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { render } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react-dom\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e {observable, action, computed,useStrict} \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27mobx\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e {observer} \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27mobx-react\x27\x3c\/span\x3e;\n\nuseStrict(\x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e);\n\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eStore\x3c\/span\x3e \x3c\/span\x3e{\n  @observable todos = [{\n    \x3cspan class=\x22hljs-attr\x22\x3etitle\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22todo标题\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3edone\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n  },{\n    \x3cspan class=\x22hljs-attr\x22\x3etitle\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22已经完成 todo 的标题\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3edone\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n  }];\n\n  @action changeTodoTitle({index,title}){\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.todos[index].title = title\n  }\n\n  @computed get unfinishedTodos () {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.todos.filter(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3etodo\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e todo.done)\n  }\n}\n\n\n@observer\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eTodoBox\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e  \x3c\/span\x3e{\n\n  render() {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27render\x27\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x26lt;div\x26gt;\n        \x26lt;ul\x26gt;\n          { \/* 把 unfinishedTodos 换成 todos，点击修改标题就会在控制台打印 \x22render\x22.*\/ }\n          {this.props.store.unfinishedTodos.map(\n            (todo,index) =\x26gt; \x26lt;li key={index}\x26gt;{todo.title}\x26lt;\/li\x26gt;\n          )}\n        \x26lt;\/ul\x26gt;\n        \x26lt;div\x26gt;\n          \x26lt;input type=\x22button\x22 onClick={() =\x26gt; {\n            this.props.store.changeTodoTitle({index:0,title:\x22修改后的todo标题\x22});\n          \x22}}\x22 value=\x22修改标题\x22\/\x26gt;\n        \x26lt;\/div\x26gt;\n      \x26lt;\/div\x26gt;\n    )\n  }\n}\n\nconst store = new Store();\n\nrender(\n  \x26lt;TodoBox store={store} \/\x26gt;,\n  document.getElementById(\x27root\x27)\n);\n\n\n\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3e小结\x3c\/h2\x3e\n\x3cp\x3e翻译了官网的一段文章，就拿过来做小结了。\x3c\/p\x3e\n\x3cp\x3emobx 是一个的简单、可扩展的状态管理库。它背后的哲学非常简单：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22应用程序 state 是最基础的数据。任何可以从 state 中衍生出来的数据，都应该自动的被衍生出。\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs pf\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e应用程序 \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e 是最基础的数据。任何可以从 \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e 中衍生出来的数据，都应该自动的被衍生出。\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22http:\/\/oi9t94i28.bkt.clouddn.com\/mobx.png\x22 src=\x22https:\/\/static.alili.techhttp:\/\/oi9t94i28.bkt.clouddn.com\/mobx.png\x22 alt=\x22img\x22 title=\x22img\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3eactions\x3c\/strong\x3e 是唯一能够改变 state 的方法。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3estate\x3c\/strong\x3e 是最基础的数据，它不应该包含冗余的和派生的数据。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3ecomputed values\x3c\/strong\x3e 派生值是通过纯函数从 state 中派生而来的。当派生值依赖的状态发生变化了，Mobx 将会自动更新派生值。如果依赖的状态没有改变，mobx 会做优化处理。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3ereactions\x3c\/strong\x3e 也是派生数据，是从 state 中派生而来的。它的副作用是自动更新 UI。（注：mobx 有一个 reaction 接口，当 state 改变时，就会调用它的回调。UI 是通过 reaction 更新的。）\x3c\/p\x3e\n\x3cp\x3eReact 和 MobX 是非常强大的组合。React 提供了将应用状态映射为可渲染的组件树的机制。MobX 提供存储和更新应用状态的机制，供 React 使用。\x3c\/p\x3e\n\x3cp\x3eReact 和 MobX 提供了开发过程中常见问题的解决方案。 React 通过使用虚拟 DOM，减少了对浏览器 DOM 的操作。MobX 通过使用了响应式虚拟依赖状态图(reactive virtual dependency state graph) ，提供了应用程序状态与 React 组件同步的机制，这样 state 只会在需要时更新才会更新。（译者注：这段有点难理解，大概的意思是 Mobx 关注的是 store 到 state 的过程，React 关注的是 state 到 view 的过程）。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3e辅助函数\x3c\/h2\x3e\n\x3cp\x3e在实际开发中，需要用到不少 mobx 的辅助函数，这些辅助函数一共 14 个，挑了一些列举如下。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3eautorun\x3c\/strong\x3e\x3cbr\x3eobservable 的值初始化或改变时，自动运行。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3etrasaction\x3c\/strong\x3e\x3cbr\x3e批量改变时，通过 trasaction 包装，只会触发一次 autorun。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3eextendsObservable\x3c\/strong\x3e\x3cbr\x3e对类的属性或实例，进行监听。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3eobservable\x3c\/strong\x3e\x3cbr\x3e对普通对象进行监听。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3emap\x3c\/strong\x3e\x3cbr\x3e使用 asMap 将对象转化为 map。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3eaction-strict\x3c\/strong\x3e\x3cbr\x3e在 mobx.usrStrict(true)时，只能通过 action 触发值的改变。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3ewhen\x3c\/strong\x3e\x3cbr\x3e类似 autorun.\x3c\/p\x3e\n\x3cp\x3emobx.when 第一个参数是一个函数，初始化时也会自动执行。该函数返回一个 boolean 值，当返回值为 true 的时候，才会继续触发第一个函数。当返回值为 flase 时，不再继续监听。这时会执行 mobx.when 的第二个参数，这个参数也是一个函数。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3ereaction\x3c\/strong\x3e\x3cbr\x3e类似 autorun.\x3c\/p\x3e\n\x3cp\x3ereaction 不会在初始化时执行，只会在值改变的时候执行。\x3c\/p\x3e\n\x3cp\x3e该函数有 2 个值，第一个参数是一个函数，返回监听的值.\x3cbr\x3e第二个参数，也是一个函数，会在值改变的时候执行。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3espy\x3c\/strong\x3e\x3cbr\x3e类似 aoturun.\x3c\/p\x3e\n\x3cp\x3e监听所有 mobx 的事件。\x3c\/p\x3e\n\x3cp\x3e包含一个 type ，该值用来区分执行事件的类型。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3ewhyRun\x3c\/strong\x3e\x3cbr\x3e用于调试，打印 autorun 为什么会触发。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>mobx——rudex的简单替代品</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000007938992">https://segmentfault.com/a/1190000007938992</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/bcbr5lb7cj5/" target="_blank">https://alili.tech/archive/bcbr5lb7cj5/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>