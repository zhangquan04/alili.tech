<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="调试器的工作原理（一）：基础篇"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>调试器的工作原理（一）：基础篇 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/wq97qte7wp/",
				"appid": "1613049289050283", 
				"title": "调试器的工作原理（一）：基础篇 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-23T02:30:08"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/0ei5cdilal5c/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/6mbtteujr86/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fwq97qte7wp%2f&text=%e8%b0%83%e8%af%95%e5%99%a8%e7%9a%84%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86%ef%bc%88%e4%b8%80%ef%bc%89%ef%bc%9a%e5%9f%ba%e7%a1%80%e7%af%87"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fwq97qte7wp%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fwq97qte7wp%2f&text=%e8%b0%83%e8%af%95%e5%99%a8%e7%9a%84%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86%ef%bc%88%e4%b8%80%ef%bc%89%ef%bc%9a%e5%9f%ba%e7%a1%80%e7%af%87"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fwq97qte7wp%2f&title=%e8%b0%83%e8%af%95%e5%99%a8%e7%9a%84%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86%ef%bc%88%e4%b8%80%ef%bc%89%ef%bc%9a%e5%9f%ba%e7%a1%80%e7%af%87"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fwq97qte7wp%2f&is_video=false&description=%e8%b0%83%e8%af%95%e5%99%a8%e7%9a%84%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86%ef%bc%88%e4%b8%80%ef%bc%89%ef%bc%9a%e5%9f%ba%e7%a1%80%e7%af%87"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e8%b0%83%e8%af%95%e5%99%a8%e7%9a%84%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86%ef%bc%88%e4%b8%80%ef%bc%89%ef%bc%9a%e5%9f%ba%e7%a1%80%e7%af%87&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fwq97qte7wp%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fwq97qte7wp%2f&title=%e8%b0%83%e8%af%95%e5%99%a8%e7%9a%84%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86%ef%bc%88%e4%b8%80%ef%bc%89%ef%bc%9a%e5%9f%ba%e7%a1%80%e7%af%87"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fwq97qte7wp%2f&title=%e8%b0%83%e8%af%95%e5%99%a8%e7%9a%84%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86%ef%bc%88%e4%b8%80%ef%bc%89%ef%bc%9a%e5%9f%ba%e7%a1%80%e7%af%87"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fwq97qte7wp%2f&title=%e8%b0%83%e8%af%95%e5%99%a8%e7%9a%84%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86%ef%bc%88%e4%b8%80%ef%bc%89%ef%bc%9a%e5%9f%ba%e7%a1%80%e7%af%87"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fwq97qte7wp%2f&title=%e8%b0%83%e8%af%95%e5%99%a8%e7%9a%84%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86%ef%bc%88%e4%b8%80%ef%bc%89%ef%bc%9a%e5%9f%ba%e7%a1%80%e7%af%87"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">调试器的工作原理（一）：基础篇</h1><div class="meta"><div class="postdate"><time datetime="2019-01-23" itemprop="datePublished">2019-01-23</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n            \x3ch1\x3e\x3ca href=\x22#调试器的工作原理一基础篇\x22\x3e\x3c\/a\x3e调试器的工作原理（一）：基础篇\x3c\/h1\x3e\n\x3cp\x3e这是调试器工作原理系列文章的第一篇，我不确定这个系列会有多少篇文章，会涉及多少话题，但我仍会从这篇基础开始。\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22#这一篇会讲什么\x22\x3e\x3c\/a\x3e这一篇会讲什么\x3c\/h3\x3e\n\x3cp\x3e我将为大家展示 Linux 中调试器的主要构成模块 - \x3ccode\x3eptrace\x3c\/code\x3e 系统调用。这篇文章所有代码都是基于 32 位 Ubuntu 操作系统。值得注意的是，尽管这些代码是平台相关的，将它们移植到其它平台应该并不困难。\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22#缘由\x22\x3e\x3c\/a\x3e缘由\x3c\/h3\x3e\n\x3cp\x3e为了理解我们要做什么，让我们先考虑下调试器为了完成调试都需要什么资源。调试器可以开始一个进程并调试这个进程，又或者将自己同某个已经存在的进程关联起来。调试器能够单步执行代码，设定断点并且将程序执行到断点，检查变量的值并追踪堆栈。许多调试器有着更高级的特性，例如在调试器的地址空间内执行表达式或者调用函数，甚至可以在进程执行过程中改变代码并观察效果。\x3c\/p\x3e\n\x3cp\x3e尽管现代的调试器都十分的复杂（我没有检查，但我确信 gdb 的代码行数至少有六位数），但它们的工作的原理却是十分的简单。调试器的基础是操作系统与编译器 \/ 链接器提供的一些基础服务，其余的部分只是\x3ca href=\x22http:\/\/en.wikipedia.org\/wiki\/Small_matter_of_programming\x22\x3e简单的编程\x3c\/a\x3e而已。\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22#linux-的调试---ptrace\x22\x3e\x3c\/a\x3eLinux 的调试 - ptrace\x3c\/h3\x3e\n\x3cp\x3eLinux 调试器中的瑞士军刀便是 \x3ccode\x3eptrace\x3c\/code\x3e 系统调用（使用 man 2 ptrace 命令可以了解更多）。这是一种复杂却强大的工具，可以允许一个进程控制另外一个进程并从内部替换Peek and poke被控制进程的内核镜像的值（Peek and poke 在系统编程中是很知名的叫法，指的是直接读写内存内容）。\x3c\/p\x3e\n\x3cp\x3e接下来会深入分析。\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22#执行进程的代码\x22\x3e\x3c\/a\x3e执行进程的代码\x3c\/h3\x3e\n\x3cp\x3e我将编写一个示例，实现一个在“跟踪”模式下运行的进程。在这个模式下，我们将单步执行进程的代码，就像机器码（汇编代码）被 CPU 执行时一样。我将分段展示、讲解示例代码，在文章的末尾也有完整 c 文件的下载链接，你可以编译、执行或者随心所欲的更改。\x3c\/p\x3e\n\x3cp\x3e更进一步的计划是实现一段代码，这段代码可以创建可执行用户自定义命令的子进程，同时父进程可以跟踪子进程。首先是主函数：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs cpp\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eint\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emain\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(\x3cspan class=\x22hljs-keyword\x22\x3eint\x3c\/span\x3e argc, \x3cspan class=\x22hljs-keyword\x22\x3echar\x3c\/span\x3e** argv)\x3c\/span\x3e\n\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3epid_t\x3c\/span\x3e child_pid;\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (argc \x26lt; \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-built_in\x22\x3efprintf\x3c\/span\x3e(\x3cspan class=\x22hljs-built_in\x22\x3estderr\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22Expected a program name as argument\\n\x22\x3c\/span\x3e);\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e;\n    }\n\n    child_pid = fork();\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (child_pid == \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e)\n        run_target(argv[\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e]);\n    \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (child_pid \x26gt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e)\n        run_debugger(child_pid);\n    \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        perror(\x3cspan class=\x22hljs-string\x22\x3e\x22fork\x22\x3c\/span\x3e);\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e;\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e看起来相当的简单：我们用 \x3ccode\x3efork\x3c\/code\x3e 创建了一个新的子进程（这篇文章假定读者有一定的 Unix\/Linux 编程经验。我假定你知道或至少了解 fork、exec 族函数与 Unix 信号）。if 语句的分支执行子进程（这里称之为 “target”），\x3ccode\x3eelse if\x3c\/code\x3e 的分支执行父进程（这里称之为 “debugger”）。\x3c\/p\x3e\n\x3cp\x3e下面是 target 进程的代码：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs cpp\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3erun_target\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3echar\x3c\/span\x3e* programname)\x3c\/span\x3e\n\x3c\/span\x3e{\n    procmsg(\x3cspan class=\x22hljs-string\x22\x3e\x22target started. will run \x27%s\x27\\n\x22\x3c\/span\x3e, programname);\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/* Allow tracing of this process *\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (ptrace(PTRACE_TRACEME, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) \x26lt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n        perror(\x3cspan class=\x22hljs-string\x22\x3e\x22ptrace\x22\x3c\/span\x3e);\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/* Replace this process\x27s image with the given program *\/\x3c\/span\x3e\n    execl(programname, programname, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e这段代码中最值得注意的是 \x3ccode\x3eptrace\x3c\/code\x3e 调用。在 \x3ccode\x3esys\/ptrace.h\x3c\/code\x3e 中，\x3ccode\x3eptrace\x3c\/code\x3e 是如下定义的：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs crystal\x22\x3elong ptrace(\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eenum\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e__ptrace_request\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3erequest\x3c\/span\x3e, \x3cspan class=\x22hljs-title\x22\x3epid_t\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3epid\x3c\/span\x3e,\x3c\/span\x3e\n                 void *addr, void *data);\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e第一个参数是 \x3ccode\x3e_request_\x3c\/code\x3e，这是许多预定义的 \x3ccode\x3ePTRACE_*\x3c\/code\x3e 常量中的一个。第二个参数为请求分配进程 ID。第三个与第四个参数是地址与数据指针，用于操作内存。上面代码段中的 \x3ccode\x3eptrace\x3c\/code\x3e 调用发起了 \x3ccode\x3ePTRACE_TRACEME\x3c\/code\x3e 请求，这意味着该子进程请求系统内核让其父进程跟踪自己。帮助页面上对于 request 的描述很清楚：\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3e意味着该进程被其父进程跟踪。任何传递给该进程的信号（除了 \x3ccode\x3eSIGKILL\x3c\/code\x3e）都将通过 \x3ccode\x3ewait()\x3c\/code\x3e 方法阻塞该进程并通知其父进程。\x3cstrong\x3e此外，该进程的之后所有调用 \x3ccode\x3eexec()\x3c\/code\x3e 动作都将导致 \x3ccode\x3eSIGTRAP\x3c\/code\x3e 信号发送到此进程上，使得父进程在新的程序执行前得到取得控制权的机会\x3c\/strong\x3e。如果一个进程并不需要它的的父进程跟踪它，那么这个进程不应该发送这个请求。（pid、addr 与 data 暂且不提）\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e我高亮了这个例子中我们需要注意的部分。在 \x3ccode\x3eptrace\x3c\/code\x3e 调用后，\x3ccode\x3erun_target\x3c\/code\x3e 接下来要做的就是通过 \x3ccode\x3eexecl\x3c\/code\x3e 传参并调用。如同高亮部分所说明，这将导致系统内核在 \x3ccode\x3eexecl\x3c\/code\x3e 创建进程前暂时停止，并向父进程发送信号。\x3c\/p\x3e\n\x3cp\x3e是时候看看父进程做什么了。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs applescript\x22\x3evoid run_debugger(pid_t child_pid)\n{\n    int wait_status;\n    unsigned icounter = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n    procmsg(\x3cspan class=\x22hljs-string\x22\x3e\x22debugger started\\n\x22\x3c\/span\x3e);\n\n    \/* Wait \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e child \x3cspan class=\x22hljs-keyword\x22\x3eto\x3c\/span\x3e stop \x3cspan class=\x22hljs-keyword\x22\x3eon\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eits\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3efirst\x3c\/span\x3e instruction *\/\n    wait(\x26amp;wait_status);\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (WIFSTOPPED(wait_status)) {\n        icounter\x2b\x2b;\n        \/* Make \x3cspan class=\x22hljs-keyword\x22\x3ethe\x3c\/span\x3e child execute another instruction *\/\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (ptrace(PTRACE_SINGLESTEP, child_pid, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) \x26lt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n            perror(\x3cspan class=\x22hljs-string\x22\x3e\x22ptrace\x22\x3c\/span\x3e);\n\x3cspan class=\x22hljs-built_in\x22\x3e            return\x3c\/span\x3e;\n        }\n\n        \/* Wait \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e child \x3cspan class=\x22hljs-keyword\x22\x3eto\x3c\/span\x3e stop \x3cspan class=\x22hljs-keyword\x22\x3eon\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eits\x3c\/span\x3e next instruction *\/\n        wait(\x26amp;wait_status);\n    }\n\n    procmsg(\x3cspan class=\x22hljs-string\x22\x3e\x22the child executed %u instructions\\n\x22\x3c\/span\x3e, icounter);\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e如前文所述，一旦子进程调用了 \x3ccode\x3eexec\x3c\/code\x3e，子进程会停止并被发送 \x3ccode\x3eSIGTRAP\x3c\/code\x3e 信号。父进程会等待该过程的发生并在第一个 \x3ccode\x3ewait()\x3c\/code\x3e 处等待。一旦上述事件发生了，\x3ccode\x3ewait()\x3c\/code\x3e 便会返回，由于子进程停止了父进程便会收到信号（如果子进程由于信号的发送停止了，\x3ccode\x3eWIFSTOPPED\x3c\/code\x3e 就会返回 \x3ccode\x3etrue\x3c\/code\x3e）。\x3c\/p\x3e\n\x3cp\x3e父进程接下来的动作就是整篇文章最需要关注的部分了。父进程会将 \x3ccode\x3ePTRACE_SINGLESTEP\x3c\/code\x3e 与子进程 ID 作为参数调用 \x3ccode\x3eptrace\x3c\/code\x3e 方法。这就会告诉操作系统，“请恢复子进程，但在它执行下一条指令前阻塞”。周而复始地，父进程等待子进程阻塞，循环继续。当 \x3ccode\x3ewait()\x3c\/code\x3e 中传出的信号不再是子进程的停止信号时，循环终止。在跟踪器（父进程）运行期间，这将会是被跟踪进程（子进程）传递给跟踪器的终止信号（如果子进程终止 \x3ccode\x3eWIFEXITED\x3c\/code\x3e 将返回 \x3ccode\x3etrue\x3c\/code\x3e）。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eicounter\x3c\/code\x3e 存储了子进程执行指令的次数。这么看来我们小小的例子也完成了些有用的事情 - 在命令行中指定程序，它将执行该程序并记录它从开始到结束所需要的 cpu 指令数量。接下来就让我们这么做吧。\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22#测试\x22\x3e\x3c\/a\x3e测试\x3c\/h3\x3e\n\x3cp\x3e我编译了下面这个简单的程序并利用跟踪器运行它：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs cpp\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3e#\x3cspan class=\x22hljs-meta-keyword\x22\x3einclude\x3c\/span\x3e \x3cspan class=\x22hljs-meta-string\x22\x3e\x26lt;stdio.h\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eint\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emain\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\n\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3eprintf\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22Hello, world!\\n\x22\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n}\n\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e令我惊讶的是，跟踪器花了相当长的时间，并报告整个执行过程共有超过 100,000 条指令执行。仅仅是一条输出语句？什么造成了这种情况？答案很有趣（至少你同我一样痴迷与机器\/汇编语言）。Linux 的 gcc 默认会动态的将程序与 c 的运行时库动态地链接。这就意味着任何程序运行前的第一件事是需要动态库加载器去查找程序运行所需要的共享库。这些代码的数量很大 - 别忘了我们的跟踪器要跟踪每一条指令，不仅仅是主函数的，而是“整个进程中的指令”。\x3c\/p\x3e\n\x3cp\x3e所以当我将测试程序使用静态编译时（通过比较，可执行文件会多出 500 KB 左右的大小，这部分是 C 运行时库的静态链接），跟踪器提示只有大概 7000 条指令被执行。这个数目仍然不小，但是考虑到在主函数执行前 libc 的初始化以及主函数执行后的清除代码，这个数目已经是相当不错了。此外，\x3ccode\x3eprintf\x3c\/code\x3e 也是一个复杂的函数。\x3c\/p\x3e\n\x3cp\x3e仍然不满意的话，我需要的是“可以测试”的东西 - 例如可以完整记录每一个指令运行的程序执行过程。这当然可以通过汇编代码完成。所以我找到了这个版本的 “Hello, world!” 并编译了它。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs x86asm\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3esection\x3c\/span\x3e    .text\n    \x3cspan class=\x22hljs-comment\x22\x3e; The _start symbol must be declared for the linker (ld)\x3c\/span\x3e\n    \x3cspan class=\x22hljs-meta\x22\x3eglobal\x3c\/span\x3e _start\n\x3cspan class=\x22hljs-symbol\x22\x3e\n_start:\x3c\/span\x3e\n\n    \x3cspan class=\x22hljs-comment\x22\x3e; Prepare arguments for the sys_write system call:\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e;   - eax: system call number (sys_write)\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e;   - ebx: file descriptor (stdout)\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e;   - ecx: pointer to string\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e;   - edx: string length\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3emov\x3c\/span\x3e    \x3cspan class=\x22hljs-built_in\x22\x3eedx\x3c\/span\x3e, len\n    \x3cspan class=\x22hljs-keyword\x22\x3emov\x3c\/span\x3e    \x3cspan class=\x22hljs-built_in\x22\x3eecx\x3c\/span\x3e, msg\n    \x3cspan class=\x22hljs-keyword\x22\x3emov\x3c\/span\x3e    \x3cspan class=\x22hljs-built_in\x22\x3eebx\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3emov\x3c\/span\x3e    \x3cspan class=\x22hljs-built_in\x22\x3eeax\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e\n\n    \x3cspan class=\x22hljs-comment\x22\x3e; Execute the sys_write system call\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eint\x3c\/span\x3e    \x3cspan class=\x22hljs-number\x22\x3e0x80\x3c\/span\x3e\n\n    \x3cspan class=\x22hljs-comment\x22\x3e; Execute sys_exit\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3emov\x3c\/span\x3e    \x3cspan class=\x22hljs-built_in\x22\x3eeax\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eint\x3c\/span\x3e    \x3cspan class=\x22hljs-number\x22\x3e0x80\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-meta\x22\x3esection\x3c\/span\x3e   .data\nmsg \x3cspan class=\x22hljs-built_in\x22\x3edb\x3c\/span\x3e    \x3cspan class=\x22hljs-string\x22\x3e\x27Hello, world!\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e0xa\x3c\/span\x3e\nlen \x3cspan class=\x22hljs-built_in\x22\x3eequ\x3c\/span\x3e    $ - msg\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e当然，现在跟踪器提示 7 条指令被执行了，这样一来很容易区分它们。\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22#深入指令流\x22\x3e\x3c\/a\x3e深入指令流\x3c\/h3\x3e\n\x3cp\x3e上面那个汇编语言编写的程序使得我可以向你介绍 \x3ccode\x3eptrace\x3c\/code\x3e 的另外一个强大的用途 - 详细显示被跟踪进程的状态。下面是 \x3ccode\x3erun_debugger\x3c\/code\x3e 函数的另一个版本：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs mipsasm\x22\x3evoid run_debugger(pid_t child_pid)\n{\n    int \x3cspan class=\x22hljs-keyword\x22\x3ewait_status;\n\x3c\/span\x3e    unsigned icounter = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n    procmsg(\x3cspan class=\x22hljs-string\x22\x3e\x22debugger started\\n\x22\x3c\/span\x3e)\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/* Wait for child to stop on its first instruction *\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ewait(\x26amp;wait_status);\n\x3c\/span\x3e\n    while (WIFSTOPPED(\x3cspan class=\x22hljs-keyword\x22\x3ewait_status)) \x3c\/span\x3e{\n        icounter\x2b\x2b\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n        struct user_regs_struct regs\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n        ptrace(PTRACE_GETREGS, child_pid, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, \x26amp;regs)\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n        unsigned \x3cspan class=\x22hljs-keyword\x22\x3einstr \x3c\/span\x3e= ptrace(PTRACE_PEEKTEXT, child_pid, regs.\x3cspan class=\x22hljs-keyword\x22\x3eeip, \x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e)\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n\n        procmsg(\x3cspan class=\x22hljs-string\x22\x3e\x22icounter = %u.  EIP = 0x%08x.  instr = 0x%08x\\n\x22\x3c\/span\x3e,\n                    icounter, regs.\x3cspan class=\x22hljs-keyword\x22\x3eeip, \x3c\/span\x3e\x3cspan class=\x22hljs-keyword\x22\x3einstr);\n\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/* Make the child execute another instruction *\/\x3c\/span\x3e\n        if (ptrace(PTRACE_SINGLESTEP, child_pid, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) \x26lt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n            perror(\x3cspan class=\x22hljs-string\x22\x3e\x22ptrace\x22\x3c\/span\x3e)\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n            return\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n        }\n\n        \x3cspan class=\x22hljs-comment\x22\x3e\/* Wait for child to stop on its next instruction *\/\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ewait(\x26amp;wait_status);\n\x3c\/span\x3e    }\n\n    procmsg(\x3cspan class=\x22hljs-string\x22\x3e\x22the child executed %u instructions\\n\x22\x3c\/span\x3e, icounter)\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e不同仅仅存在于 \x3ccode\x3ewhile\x3c\/code\x3e 循环的开始几行。这个版本里增加了两个新的 \x3ccode\x3eptrace\x3c\/code\x3e 调用。第一条将进程的寄存器值读取进了一个结构体中。 \x3ccode\x3esys\/user.h\x3c\/code\x3e 定义有 \x3ccode\x3euser_regs_struct\x3c\/code\x3e。如果你查看头文件，头部的注释这么写到：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs actionscript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/* 这个文件只为了 GDB 而创建\n   不用详细的阅读.如果你不知道你在干嘛，\n   不要在除了 GDB 以外的任何地方使用此文件  *\/\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e不知道你做何感想，但这让我觉得我们找对地方了。回到例子中，一旦我们在 \x3ccode\x3eregs\x3c\/code\x3e 变量中取得了寄存器的值，我们就可以通过将 \x3ccode\x3ePTRACE_PEEKTEXT\x3c\/code\x3e 作为参数、 \x3ccode\x3eregs.eip\x3c\/code\x3e（x86 上的扩展指令指针）作为地址，调用 \x3ccode\x3eptrace\x3c\/code\x3e ，读取当前进程的当前指令（警告：如同我上面所说，文章很大程度上是平台相关的。我简化了一些设定 - 例如，x86 指令集不需要调整到 4 字节，我的32位 Ubuntu unsigned int 是 4 字节。事实上，许多平台都不需要。从内存中读取指令需要预先安装完整的反汇编器。我们这里没有，但实际的调试器是有的）。下面是新跟踪器所展示出的调试效果：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs lsl\x22\x3e$ simple_tracer traced_helloworld\n[\x3cspan class=\x22hljs-number\x22\x3e5700\x3c\/span\x3e] debugger started\n[\x3cspan class=\x22hljs-number\x22\x3e5701\x3c\/span\x3e] target started. will run \x27traced_helloworld\x27\n[\x3cspan class=\x22hljs-number\x22\x3e5700\x3c\/span\x3e] icounter = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\\.  EIP = \x3cspan class=\x22hljs-number\x22\x3e0x08048080\x3c\/span\x3e\\.  instr = \x3cspan class=\x22hljs-number\x22\x3e0x00000eba\x3c\/span\x3e\n[\x3cspan class=\x22hljs-number\x22\x3e5700\x3c\/span\x3e] icounter = \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e\\.  EIP = \x3cspan class=\x22hljs-number\x22\x3e0x08048085\x3c\/span\x3e\\.  instr = \x3cspan class=\x22hljs-number\x22\x3e0x0490a0b9\x3c\/span\x3e\n[\x3cspan class=\x22hljs-number\x22\x3e5700\x3c\/span\x3e] icounter = \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e\\.  EIP = \x3cspan class=\x22hljs-number\x22\x3e0x0804808a\x3c\/span\x3e.  instr = \x3cspan class=\x22hljs-number\x22\x3e0x000001bb\x3c\/span\x3e\n[\x3cspan class=\x22hljs-number\x22\x3e5700\x3c\/span\x3e] icounter = \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e\\.  EIP = \x3cspan class=\x22hljs-number\x22\x3e0x0804808f\x3c\/span\x3e.  instr = \x3cspan class=\x22hljs-number\x22\x3e0x000004b8\x3c\/span\x3e\n[\x3cspan class=\x22hljs-number\x22\x3e5700\x3c\/span\x3e] icounter = \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e\\.  EIP = \x3cspan class=\x22hljs-number\x22\x3e0x08048094\x3c\/span\x3e\\.  instr = \x3cspan class=\x22hljs-number\x22\x3e0x01b880cd\x3c\/span\x3e\nHello, world!\n[\x3cspan class=\x22hljs-number\x22\x3e5700\x3c\/span\x3e] icounter = \x3cspan class=\x22hljs-number\x22\x3e6\x3c\/span\x3e\\.  EIP = \x3cspan class=\x22hljs-number\x22\x3e0x08048096\x3c\/span\x3e\\.  instr = \x3cspan class=\x22hljs-number\x22\x3e0x000001b8\x3c\/span\x3e\n[\x3cspan class=\x22hljs-number\x22\x3e5700\x3c\/span\x3e] icounter = \x3cspan class=\x22hljs-number\x22\x3e7\x3c\/span\x3e\\.  EIP = \x3cspan class=\x22hljs-number\x22\x3e0x0804809b\x3c\/span\x3e.  instr = \x3cspan class=\x22hljs-number\x22\x3e0x000080cd\x3c\/span\x3e\n[\x3cspan class=\x22hljs-number\x22\x3e5700\x3c\/span\x3e] the child executed \x3cspan class=\x22hljs-number\x22\x3e7\x3c\/span\x3e instructions\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e现在，除了 \x3ccode\x3eicounter\x3c\/code\x3e，我们也可以观察到指令指针与它每一步所指向的指令。怎么来判断这个结果对不对呢？使用 \x3ccode\x3eobjdump -d\x3c\/code\x3e 处理可执行文件：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs mel\x22\x3e$ objdump -d traced_helloworld\n\ntraced_helloworld:     \x3cspan class=\x22hljs-keyword\x22\x3efile\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eformat\x3c\/span\x3e elf32-i386\n\nDisassembly of section .\x3cspan class=\x22hljs-keyword\x22\x3etext\x3c\/span\x3e:\n\n\x3cspan class=\x22hljs-number\x22\x3e08048080\x3c\/span\x3e \x26lt;.\x3cspan class=\x22hljs-keyword\x22\x3etext\x3c\/span\x3e\x26gt;:\n \x3cspan class=\x22hljs-number\x22\x3e8048080\x3c\/span\x3e:     ba \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3ee \x3cspan class=\x22hljs-number\x22\x3e00\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e00\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e00\x3c\/span\x3e          mov    $0xe,%edx\n \x3cspan class=\x22hljs-number\x22\x3e8048085\x3c\/span\x3e:     b9 a0 \x3cspan class=\x22hljs-number\x22\x3e90\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e04\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e08\x3c\/span\x3e          mov    $0x80490a0,%ecx\n \x3cspan class=\x22hljs-number\x22\x3e804808\x3c\/span\x3ea:     bb \x3cspan class=\x22hljs-number\x22\x3e01\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e00\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e00\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e00\x3c\/span\x3e          mov    $0x1,%ebx\n \x3cspan class=\x22hljs-number\x22\x3e804808\x3c\/span\x3ef:     b8 \x3cspan class=\x22hljs-number\x22\x3e04\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e00\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e00\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e00\x3c\/span\x3e          mov    $0x4,%eax\n \x3cspan class=\x22hljs-number\x22\x3e8048094\x3c\/span\x3e:     cd \x3cspan class=\x22hljs-number\x22\x3e80\x3c\/span\x3e                   \x3cspan class=\x22hljs-keyword\x22\x3eint\x3c\/span\x3e    $0x80\n \x3cspan class=\x22hljs-number\x22\x3e8048096\x3c\/span\x3e:     b8 \x3cspan class=\x22hljs-number\x22\x3e01\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e00\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e00\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e00\x3c\/span\x3e          mov    $0x1,%eax\n \x3cspan class=\x22hljs-number\x22\x3e804809\x3c\/span\x3eb:     cd \x3cspan class=\x22hljs-number\x22\x3e80\x3c\/span\x3e                   \x3cspan class=\x22hljs-keyword\x22\x3eint\x3c\/span\x3e    $0x80\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e这个结果和我们跟踪器的结果就很容易比较了。\x3c\/p\x3e\n\x3cp\x3e###　将跟踪器关联到正在运行的进程\x3c\/p\x3e\n\x3cp\x3e如你所知，调试器也能关联到已经运行的进程。现在你应该不会惊讶，\x3ccode\x3eptrace\x3c\/code\x3e 通过以 \x3ccode\x3ePTRACE_ATTACH\x3c\/code\x3e 为参数调用也可以完成这个过程。这里我不会展示示例代码，通过上文的示例代码应该很容易实现这个过程。出于学习目的，这里使用的方法更简便（因为我们在子进程刚开始就可以让它停止）。\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22#代码\x22\x3e\x3c\/a\x3e代码\x3c\/h3\x3e\n\x3cp\x3e上文中的简单的跟踪器（更高级的，可以打印指令的版本）的完整c源代码可以在\x3ca href=\x22https:\/\/github.com\/eliben\/code-for-blog\/blob\/master\/2011\/simple_tracer.c\x22\x3e这里\x3c\/a\x3e找到。它是通过 4.4 版本的 gcc 以 \x3ccode\x3e-Wall -pedantic --std=c99\x3c\/code\x3e 编译的。\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22#结论与计划\x22\x3e\x3c\/a\x3e结论与计划\x3c\/h3\x3e\n\x3cp\x3e诚然，这篇文章并没有涉及很多内容 - 我们距离亲手完成一个实际的调试器还有很长的路要走。但我希望这篇文章至少可以使得调试这件事少一些神秘感。\x3ccode\x3eptrace\x3c\/code\x3e 是功能多样的系统调用，我们目前只展示了其中的一小部分。\x3c\/p\x3e\n\x3cp\x3e单步调试代码很有用，但也只是在一定程度上有用。上面我通过 C 的 “Hello World!” 做了示例。为了执行主函数，可能需要上万行代码来初始化 C 的运行环境。这并不是很方便。最理想的是在 \x3ccode\x3emain\x3c\/code\x3e 函数入口处放置断点并从断点处开始分步执行。为此，在这个系列的下一篇，我打算展示怎么实现断点。\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22#参考\x22\x3e\x3c\/a\x3e参考\x3c\/h3\x3e\n\x3cp\x3e撰写此文时参考了如下文章\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3ca href=\x22http:\/\/www.linuxjournal.com\/article\/6100?page=0,1\x22\x3ePlaying with ptrace, Part I\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22http:\/\/www.alexonlinux.com\/how-debugger-works\x22\x3eHow debugger works\x3c\/a\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3chr\x3e\n\x3cp\x3evia: \x3ca href=\x22http:\/\/eli.thegreenplace.net\/2011\/01\/23\/how-debuggers-work-part-1\x22\x3ehttp:\/\/eli.thegreenplace.net\/2011\/01\/23\/how-debuggers-work-part-1\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e作者：\x3ca href=\x22http:\/\/eli.thegreenplace.net\/\x22\x3eEli Bendersky\x3c\/a\x3e 译者：\x3ca href=\x22https:\/\/github.com\/YYforymj\x22\x3eYYforymj\x3c\/a\x3e 校对：\x3ca href=\x22https:\/\/github.com\/wxy\x22\x3ewxy\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e本文由 \x3ca href=\x22https:\/\/github.com\/LCTT\/TranslateProject\x22\x3eLCTT\x3c\/a\x3e 原创编译，\x3ca href=\x22https:\/\/linux.cn\/\x22\x3eLinux中国\x3c\/a\x3e 荣誉推出\x3c\/p\x3e\n\n          \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>调试器的工作原理（一）：基础篇</p><h2 id="原文链接">原文链接</h2><p><a href="https://www.zcfy.cc/article/how-debuggers-work-part-1-basics">https://www.zcfy.cc/article/how-debuggers-work-part-1-basics</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/wq97qte7wp/" target="_blank">https://alili.tech/archive/wq97qte7wp/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>