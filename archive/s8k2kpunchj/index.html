<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="Angular Renderer (渲染器)"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>Angular Renderer (渲染器) | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/s8k2kpunchj/",
				"appid": "1613049289050283", 
				"title": "Angular Renderer (渲染器) | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-07T02:30:11"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/husfzcjxvaa/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/gpjoaq9yztd/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fs8k2kpunchj%2f&text=Angular%20Renderer%20%28%e6%b8%b2%e6%9f%93%e5%99%a8%29"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fs8k2kpunchj%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fs8k2kpunchj%2f&text=Angular%20Renderer%20%28%e6%b8%b2%e6%9f%93%e5%99%a8%29"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fs8k2kpunchj%2f&title=Angular%20Renderer%20%28%e6%b8%b2%e6%9f%93%e5%99%a8%29"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fs8k2kpunchj%2f&is_video=false&description=Angular%20Renderer%20%28%e6%b8%b2%e6%9f%93%e5%99%a8%29"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=Angular%20Renderer%20%28%e6%b8%b2%e6%9f%93%e5%99%a8%29&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fs8k2kpunchj%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fs8k2kpunchj%2f&title=Angular%20Renderer%20%28%e6%b8%b2%e6%9f%93%e5%99%a8%29"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fs8k2kpunchj%2f&title=Angular%20Renderer%20%28%e6%b8%b2%e6%9f%93%e5%99%a8%29"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fs8k2kpunchj%2f&title=Angular%20Renderer%20%28%e6%b8%b2%e6%9f%93%e5%99%a8%29"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fs8k2kpunchj%2f&title=Angular%20Renderer%20%28%e6%b8%b2%e6%9f%93%e5%99%a8%29"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">Angular Renderer (渲染器)</h1><div class="meta"><div class="postdate"><time datetime="2019-01-07" itemprop="datePublished">2019-01-07</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e阅读 Angular 6\/RxJS 最新教程，请访问\x3ca href=\x22http:\/\/www.semlinker.com\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e前端修仙之路\x3c\/a\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3eAngular 其中的一个设计目标是使浏览器与 DOM 独立。DOM 是复杂的，因此使组件与它分离，会让我们的应用程序，更容易测试与重构。另外的好处是，由于这种解耦，使得我们的应用能够运行在其它平台 (比如：Node.js、WebWorkers、NativeScript 等)。\x3c\/p\x3e\n\x3cp\x3e为了能够支持跨平台，Angular 通过抽象层封装了不同平台的差异。比如定义了抽象类 Renderer、Renderer2 、抽象类 RootRenderer 等。此外还定义了以下引用类型：ElementRef、TemplateRef、ViewRef 、ComponentRef 和 ViewContainerRef 等。\x3c\/p\x3e\n\x3cp\x3e本文的主要内容是分析 Angular 中 Renderer (渲染器)，不过在进行具体分析前，我们先来介绍一下平台的概念。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e平台\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3e什么是平台\x3c\/h3\x3e\n\x3cp\x3e平台是应用程序运行的环境。它是一组服务，可以用来访问你的应用程序和 Angular 框架本身的内置功能。由于Angular 主要是一个 UI 框架，平台提供的最重要的功能之一就是页面渲染。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e平台和引导应用程序\x3c\/h3\x3e\n\x3cp\x3e在我们开始构建一个自定义渲染器之前，我们来看一下如何设置平台，以及引导应用程序。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import {platformBrowserDynamic} from \x27@angular\/platform-browser-dynamic\x27;\nimport {BrowserModule} from \x27@angular\/platform-browser\x27;\n\n@NgModule({\n  imports: [BrowserModule],\n  bootstrap: [AppCmp]\n})\nclass AppModule {}\n\nplatformBrowserDynamic().bootstrapModule(AppModule);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e {platformBrowserDynamic} \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27@angular\/platform-browser-dynamic\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e {BrowserModule} \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27@angular\/platform-browser\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-meta\x22\x3e@NgModule\x3c\/span\x3e({\n  imports: [BrowserModule],\n  bootstrap: [AppCmp]\n})\n\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e AppModule {}\n\nplatformBrowserDynamic().bootstrapModule(AppModule);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如你所见，引导过程由两部分组成：创建平台和引导模块。在这个例子中，我们导入 BrowserModule 模块，它是浏览器平台的一部分。应用中只能有一个激活的平台，但是我们可以利用它来引导多个模块，如下所示：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const platformRef: PlatformRef = platformBrowserDynamic();\nplatformRef.bootstrapModule(AppModule1);\nplatformRef.bootstrapModule(AppModule2);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e platformRef: PlatformRef = platformBrowserDynamic();\nplatformRef.bootstrapModule(AppModule1);\nplatformRef.bootstrapModule(AppModule2);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e由于应用中只能有一个激活的平台，单例的服务必须在该平台中注册。比如，浏览器只有一个地址栏，对应的服务对象就是单例。此外如何让我们自定义的 UI 界面，能够在浏览器中显示出来呢，这就需要使用 Angular 为我们提供的渲染器。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e渲染器\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e什么是渲染器\x3c\/h3\x3e\n\x3cp\x3e渲染器是 Angular 为我们提供的一种内置服务，用于执行 UI 渲染操作。在浏览器中，渲染是将模型映射到视图的过程。模型的值可以是 JavaScript 中的原始数据类型、对象、数组或其它的数据对象。然而视图可以是页面中的段落、表单、按钮等其他元素，这些页面元素内部使用 \x3ca href=\x22https:\/\/developer.mozilla.org\/zh-CN\/docs\/Web\/API\/Document_Object_Model\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eDOM\x3c\/a\x3e (Document Object Model) 来表示。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3eAngular Renderer\x3c\/h3\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/angular\/angular\/blob\/master\/packages\/core\/src\/render\/api.ts#L112\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eRootRenderer\x3c\/a\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export abstract class RootRenderer {\n  abstract renderComponent(componentType: RenderComponentType): Renderer;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eabstract\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e RootRenderer {\n  \x3cspan class=\x22hljs-keyword\x22\x3eabstract\x3c\/span\x3e renderComponent(componentType: RenderComponentType): Renderer;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/angular\/angular\/blob\/master\/packages\/core\/src\/render\/api.ts#L48\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eRenderer\x3c\/a\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/**\n * @deprecated Use the `Renderer2` instead.\n *\/\nexport abstract class Renderer {\n  abstract createElement(parentElement: any, name: string, \n    debugInfo?: RenderDebugInfo): any;\n  abstract createText(parentElement: any, value: string, \n    debugInfo?: RenderDebugInfo): any;\n  abstract listen(renderElement: any, name: string, callback: Function): Function;\n  abstract listenGlobal(target: string, name: string, callback: Function): Function;\n  abstract setElementProperty(renderElement: any, propertyName: string, propertyValue: \n    any): void;\n  abstract setElementAttribute(renderElement: any, attributeName: string, \n    attributeValue: string): void;\n  \/\/ ...\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * @deprecated Use the `Renderer2` instead.\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eabstract\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e Renderer {\n  \x3cspan class=\x22hljs-keyword\x22\x3eabstract\x3c\/span\x3e createElement(parentElement: \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e, name: \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e, \n    debugInfo?: RenderDebugInfo): \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3eabstract\x3c\/span\x3e createText(parentElement: \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e, value: \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e, \n    debugInfo?: RenderDebugInfo): \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3eabstract\x3c\/span\x3e listen(renderElement: \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e, name: \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e, callback: \x3cspan class=\x22hljs-built_in\x22\x3eFunction\x3c\/span\x3e): \x3cspan class=\x22hljs-built_in\x22\x3eFunction\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3eabstract\x3c\/span\x3e listenGlobal(target: \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e, name: \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e, callback: \x3cspan class=\x22hljs-built_in\x22\x3eFunction\x3c\/span\x3e): \x3cspan class=\x22hljs-built_in\x22\x3eFunction\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3eabstract\x3c\/span\x3e setElementProperty(renderElement: \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e, propertyName: \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e, propertyValue: \n    \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e): \x3cspan class=\x22hljs-built_in\x22\x3evoid\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3eabstract\x3c\/span\x3e setElementAttribute(renderElement: \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e, attributeName: \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e, \n    attributeValue: \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e): \x3cspan class=\x22hljs-built_in\x22\x3evoid\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/angular\/angular\/blob\/master\/packages\/core\/src\/render\/api.ts#L147\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eRenderer2\x3c\/a\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export abstract class Renderer2 {\n  abstract createElement(name: string, namespace?: string|null): any;\n  abstract createComment(value: string): any;\n  abstract createText(value: string): any;\n  abstract setAttribute(el: any, name: string, value: string,\n    namespace?: string|null): void;\n  abstract removeAttribute(el: any, name: string, namespace?: string|null): void;\n  abstract addClass(el: any, name: string): void;\n  abstract removeClass(el: any, name: string): void;\n  abstract setStyle(el: any, style: string, value: any, \n    flags?: RendererStyleFlags2): void;\n  abstract removeStyle(el: any, style: string, flags?: RendererStyleFlags2): void;\n  abstract setProperty(el: any, name: string, value: any): void;\n  abstract setValue(node: any, value: string): void;\n  abstract listen(\n      target: \x27window\x27|\x27document\x27|\x27body\x27|any, eventName: string,\n      callback: (event: any) =\x3e boolean | void): () =\x3e void;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eabstract\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e Renderer2 {\n  \x3cspan class=\x22hljs-keyword\x22\x3eabstract\x3c\/span\x3e createElement(name: \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3enamespace\x3c\/span\x3e?: \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e|\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e): \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3eabstract\x3c\/span\x3e createComment(value: \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e): \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3eabstract\x3c\/span\x3e createText(value: \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e): \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3eabstract\x3c\/span\x3e setAttribute(el: \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e, name: \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e, value: \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-keyword\x22\x3enamespace\x3c\/span\x3e?: \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e|\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e): \x3cspan class=\x22hljs-built_in\x22\x3evoid\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3eabstract\x3c\/span\x3e removeAttribute(el: \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e, name: \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3enamespace\x3c\/span\x3e?: \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e|\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e): \x3cspan class=\x22hljs-built_in\x22\x3evoid\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3eabstract\x3c\/span\x3e addClass(el: \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e, name: \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e): \x3cspan class=\x22hljs-built_in\x22\x3evoid\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3eabstract\x3c\/span\x3e removeClass(el: \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e, name: \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e): \x3cspan class=\x22hljs-built_in\x22\x3evoid\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3eabstract\x3c\/span\x3e setStyle(el: \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e, style: \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e, value: \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e, \n    flags?: RendererStyleFlags2): \x3cspan class=\x22hljs-built_in\x22\x3evoid\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3eabstract\x3c\/span\x3e removeStyle(el: \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e, style: \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e, flags?: RendererStyleFlags2): \x3cspan class=\x22hljs-built_in\x22\x3evoid\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3eabstract\x3c\/span\x3e setProperty(el: \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e, name: \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e, value: \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e): \x3cspan class=\x22hljs-built_in\x22\x3evoid\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3eabstract\x3c\/span\x3e setValue(node: \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e, value: \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e): \x3cspan class=\x22hljs-built_in\x22\x3evoid\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3eabstract\x3c\/span\x3e listen(\n      target: \x3cspan class=\x22hljs-string\x22\x3e\x27window\x27\x3c\/span\x3e|\x3cspan class=\x22hljs-string\x22\x3e\x27document\x27\x3c\/span\x3e|\x3cspan class=\x22hljs-string\x22\x3e\x27body\x27\x3c\/span\x3e|\x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e, eventName: \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e,\n      callback: \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eevent: \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eboolean\x3c\/span\x3e | \x3cspan class=\x22hljs-built_in\x22\x3evoid\x3c\/span\x3e): \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3evoid\x3c\/span\x3e;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e需要注意的是在 Angular 4.x\x2b 版本，我们使用 \x3ccode\x3eRenderer2\x3c\/code\x3e 替代 \x3ccode\x3eRenderer\x3c\/code\x3e。通过观察 Renderer 相关的抽象类 (Renderer、Renderer2)，我们发现抽象类中定义了很多抽象方法，用来创建元素、文本、设置属性、添加样式和设置事件监听等。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e渲染器如何工作\x3c\/h3\x3e\n\x3cp\x3e在实例化一个组件时，Angular 会调用 \x3ccode\x3erenderComponent()\x3c\/code\x3e 方法并将其获取的渲染器与该组件实例相关联。Angular 将会在渲染组件时通过渲染器执行对应相关的操作，比如，创建元素、设置属性、添加样式和订阅事件等。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVRurJ?w=983\x26amp;h=317\x22 src=\x22https:\/\/static.alili.tech\/img\/bVRurJ?w=983\x26amp;h=317\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e使用 Renderer\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22@Component({\n  selector: \x27exe-cmp\x27,\n  template: `\n    \x3ch3\x3eExe Component\x3c\/h3\x3e\n  `\n})\nexport class ExeComponent {\n  constructor(private renderer: Renderer2, elRef: ElementRef) {\n    this.renderer.setProperty(elRef.nativeElement, \x27author\x27, \x27semlinker\x27);\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3e@Component\x3c\/span\x3e({\n  selector: \x3cspan class=\x22hljs-string\x22\x3e\x27exe-cmp\x27\x3c\/span\x3e,\n  template: \x3cspan class=\x22hljs-string\x22\x3e`\n    \x26lt;h3\x26gt;Exe Component\x26lt;\/h3\x26gt;\n  `\x3c\/span\x3e\n})\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e ExeComponent {\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eprivate\x3c\/span\x3e renderer: Renderer2, elRef: ElementRef\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.renderer.setProperty(elRef.nativeElement, \x3cspan class=\x22hljs-string\x22\x3e\x27author\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27semlinker\x27\x3c\/span\x3e);\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上代码中，我们利用构造注入的方式，注入 Renderer2 和 ElementRef 实例。有些读者可能会问，注入的实例对象是怎么生成的。这里我们只是稍微介绍一下相关知识，并不会详细展开。具体代码如下：\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/angular\/angular\/blob\/master\/packages\/core\/src\/view\/provider.ts#L20\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eTokenKey\x3c\/a\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ packages\/core\/src\/view\/util.ts\nconst _tokenKeyCache = new Map\x3cany, string\x3e();\nexport function tokenKey(token: any): string {\n  let key = _tokenKeyCache.get(token);\n  if (!key) {\n    key = stringify(token) \x2b \x27_\x27 \x2b _tokenKeyCache.size;\n    _tokenKeyCache.set(token, key);\n  }\n  return key;\n}\n\n\/\/ packages\/core\/src\/view\/provider.ts\nconst RendererV1TokenKey = tokenKey(RendererV1);\nconst Renderer2TokenKey = tokenKey(Renderer2);\nconst ElementRefTokenKey = tokenKey(ElementRef);\nconst ViewContainerRefTokenKey = tokenKey(ViewContainerRef);\nconst TemplateRefTokenKey = tokenKey(TemplateRef);\nconst ChangeDetectorRefTokenKey = tokenKey(ChangeDetectorRef);\nconst InjectorRefTokenKey = tokenKey(Injector);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ packages\/core\/src\/view\/util.ts\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e _tokenKeyCache = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Map\x26lt;\x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e\x26gt;();\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3etokenKey\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3etoken: \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e\x3c\/span\x3e): \x3cspan class=\x22hljs-title\x22\x3estring\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e key = _tokenKeyCache.get(token);\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!key) {\n    key = stringify(token) \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27_\x27\x3c\/span\x3e \x2b _tokenKeyCache.size;\n    _tokenKeyCache.set(token, key);\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e key;\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ packages\/core\/src\/view\/provider.ts\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e RendererV1TokenKey = tokenKey(RendererV1);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e Renderer2TokenKey = tokenKey(Renderer2);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e ElementRefTokenKey = tokenKey(ElementRef);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e ViewContainerRefTokenKey = tokenKey(ViewContainerRef);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e TemplateRefTokenKey = tokenKey(TemplateRef);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e ChangeDetectorRefTokenKey = tokenKey(ChangeDetectorRef);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e InjectorRefTokenKey = tokenKey(Injector);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/angular\/angular\/blob\/master\/packages\/core\/src\/view\/provider.ts#L343\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eresolveDep()\x3c\/a\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export function resolveDep(\n    view: ViewData, elDef: NodeDef, \n    allowPrivateServices: boolean, depDef: DepDef,\n    notFoundValue: any = Injector.THROW_IF_NOT_FOUND): any {\n  const tokenKey = depDef.tokenKey;\n \/\/ ...\n  while (view) {\n    if (elDef) {\n      switch (tokenKey) {\n        case RendererV1TokenKey: { \/\/ tokenKey(RendererV1)\n          const compView = findCompView(view, elDef, allowPrivateServices);\n          return createRendererV1(compView);\n        }\n        case Renderer2TokenKey: { \/\/ tokenKey(Renderer2)\n          const compView = findCompView(view, elDef, allowPrivateServices);\n          return compView.renderer;\n        }\n        case ElementRefTokenKey: \/\/ tokenKey(ElementRef)\n          return new ElementRef(asElementData(view, elDef.index).renderElement);\n           \/\/ ... 此外还包括：ViewContainerRefTokenKey、TemplateRefTokenKey、\n        \/\/ ChangeDetectorRefTokenKey 等\n      }\n    }\n  }\n  \/\/ ...\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eresolveDep\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\n    view: ViewData, elDef: NodeDef, \n    allowPrivateServices: \x3cspan class=\x22hljs-built_in\x22\x3eboolean\x3c\/span\x3e, depDef: DepDef,\n    notFoundValue: \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e = Injector.THROW_IF_NOT_FOUND\x3c\/span\x3e): \x3cspan class=\x22hljs-title\x22\x3eany\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e tokenKey = depDef.tokenKey;\n \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (view) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (elDef) {\n      \x3cspan class=\x22hljs-keyword\x22\x3eswitch\x3c\/span\x3e (tokenKey) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e RendererV1TokenKey: { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ tokenKey(RendererV1)\x3c\/span\x3e\n          \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e compView = findCompView(view, elDef, allowPrivateServices);\n          \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e createRendererV1(compView);\n        }\n        \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e Renderer2TokenKey: { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ tokenKey(Renderer2)\x3c\/span\x3e\n          \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e compView = findCompView(view, elDef, allowPrivateServices);\n          \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e compView.renderer;\n        }\n        \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e ElementRefTokenKey: \x3cspan class=\x22hljs-comment\x22\x3e\/\/ tokenKey(ElementRef)\x3c\/span\x3e\n          \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e ElementRef(asElementData(view, elDef.index).renderElement);\n           \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ... 此外还包括：ViewContainerRefTokenKey、TemplateRefTokenKey、\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ChangeDetectorRefTokenKey 等\x3c\/span\x3e\n      }\n    }\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e通过以上代码，我们发现当我们在组件类的构造函数中声明相应的依赖对象时，如 Renderer2 和 ElementRef，Angular 内部会调用 \x3ccode\x3eresolveDep()\x3c\/code\x3e 方法，实例化 Token 对应依赖对象。\x3c\/p\x3e\n\x3cp\x3e在大多数情况下，我们开发的 Angular 应用程序是运行在浏览器平台，接下来我们来了解一下该平台下的默认渲染器 - DefaultDomRenderer2。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3eDefaultDomRenderer2\x3c\/h3\x3e\n\x3cp\x3e在浏览器平台下，我们可以通过调用 \x3ccode\x3eDomRendererFactory2\x3c\/code\x3e 工厂，根据不同的视图封装方案，创建对应渲染器。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/angular\/angular\/blob\/master\/packages\/platform-browser\/src\/dom\/dom_renderer.ts#L62\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eDomRendererFactory2\x3c\/a\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ packages\/platform-browser\/src\/dom\/dom_renderer.ts\n@Injectable()\nexport class DomRendererFactory2 implements RendererFactory2 {\n  private rendererByCompId = new Map\x3cstring, Renderer2\x3e();\n  private defaultRenderer: Renderer2;\n\n  constructor(\n    private eventManager: EventManager, \n    private sharedStylesHost: DomSharedStylesHost) {\n    \/\/ 创建默认的DOM渲染器\n    this.defaultRenderer = new DefaultDomRenderer2(eventManager);\n  };\n\n  createRenderer(element: any, type: RendererType2|null): Renderer2 {\n    if (!element || !type) {\n      return this.defaultRenderer;\n    }\n    \/\/ 根据不同的视图封装方案，创建不同的渲染器\n    switch (type.encapsulation) {\n      \/\/ 无 Shadow DOM，但是通过 Angular 提供的样式包装机制来封装组件，\n      \/\/ 使得组件的样式不受外部影响，这是 Angular 的默认设置。\n      case ViewEncapsulation.Emulated: {\n        let renderer = this.rendererByCompId.get(type.id);\n        if (!renderer) {\n          renderer =\n              new EmulatedEncapsulationDomRenderer2(this.eventManager, \n                  this.sharedStylesHost, type);\n          this.rendererByCompId.set(type.id, renderer);\n        }\n        (\x3cEmulatedEncapsulationDomRenderer2\x3erenderer).applyToHost(element);\n        return renderer;\n      }\n      \/\/ 使用原生的 Shadow DOM 特性  \n      case ViewEncapsulation.Native:\n        return new ShadowDomRenderer(this.eventManager, \n          this.sharedStylesHost, element, type);\n      \/\/ 无 Shadow DOM，并且也无样式包装\n      default: {\n        \/\/ ...\n        return this.defaultRenderer;\n      }\n    }\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ packages\/platform-browser\/src\/dom\/dom_renderer.ts\x3c\/span\x3e\n\x3cspan class=\x22hljs-meta\x22\x3e@Injectable\x3c\/span\x3e()\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e DomRendererFactory2 \x3cspan class=\x22hljs-keyword\x22\x3eimplements\x3c\/span\x3e RendererFactory2 {\n  \x3cspan class=\x22hljs-keyword\x22\x3eprivate\x3c\/span\x3e rendererByCompId = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Map\x26lt;\x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e, Renderer2\x26gt;();\n  \x3cspan class=\x22hljs-keyword\x22\x3eprivate\x3c\/span\x3e defaultRenderer: Renderer2;\n\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eprivate\x3c\/span\x3e eventManager: EventManager, \n    \x3cspan class=\x22hljs-keyword\x22\x3eprivate\x3c\/span\x3e sharedStylesHost: DomSharedStylesHost\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建默认的DOM渲染器\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.defaultRenderer = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e DefaultDomRenderer2(eventManager);\n  };\n\n  createRenderer(element: \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e: RendererType2|\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e): Renderer2 {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!element || !\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.defaultRenderer;\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 根据不同的视图封装方案，创建不同的渲染器\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eswitch\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e.encapsulation) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 无 Shadow DOM，但是通过 Angular 提供的样式包装机制来封装组件，\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 使得组件的样式不受外部影响，这是 Angular 的默认设置。\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e ViewEncapsulation.Emulated: {\n        \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e renderer = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.rendererByCompId.get(\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e.id);\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!renderer) {\n          renderer =\n              \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e EmulatedEncapsulationDomRenderer2(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.eventManager, \n                  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.sharedStylesHost, \x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e);\n          \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.rendererByCompId.set(\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e.id, renderer);\n        }\n        (\x26lt;EmulatedEncapsulationDomRenderer2\x26gt;renderer).applyToHost(element);\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e renderer;\n      }\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 使用原生的 Shadow DOM 特性  \x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e ViewEncapsulation.Native:\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e ShadowDomRenderer(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.eventManager, \n          \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.sharedStylesHost, element, \x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e);\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 无 Shadow DOM，并且也无样式包装\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e: {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.defaultRenderer;\n      }\n    }\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面代码中的 \x3ccode\x3eEmulatedEncapsulationDomRenderer2\x3c\/code\x3e 和 \x3ccode\x3eShadowDomRenderer\x3c\/code\x3e 类都继承于 \x3ccode\x3eDefaultDomRenderer2\x3c\/code\x3e 类，接下来我们再来看一下 \x3ca href=\x22https:\/\/github.com\/angular\/angular\/blob\/master\/packages\/platform-browser\/src\/dom\/dom_renderer.ts#L102\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eDefaultDomRenderer2\x3c\/a\x3e 类的内部实现：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class DefaultDomRenderer2 implements Renderer2 {  \n  constructor(private eventManager: EventManager) {}\n\n  \/\/ 省略 Renderer2 抽象类中定义的其它方法\n  createElement(name: string, namespace?: string): any {\n    if (namespace) {\n      return document.createElementNS(NAMESPACE_URIS[namespace], name);\n    }\n    return document.createElement(name);\n  }\n\n  createComment(value: string): any { return document.createComment(value); }\n\n  createText(value: string): any { return document.createTextNode(value); }\n\n  addClass(el: any, name: string): void { el.classList.add(name); }\n\n  setStyle(el: any, style: string, value: any, flags: RendererStyleFlags2): void {\n    if (flags \x26amp; RendererStyleFlags2.DashCase) {\n      el.style.setProperty(\n          style, value, !!(flags \x26amp; RendererStyleFlags2.Important) ? \x27important\x27 : \x27\x27);\n    } else {\n      el.style[style] = value;\n    }\n  }\n\n  listen(\n    target: \x27window\x27|\x27document\x27|\x27body\x27|any, \n    event: string, \n    callback: (event: any) =\x3e boolean):\n      () =\x3e void {\n    checkNoSyntheticProp(event, \x27listener\x27);\n    if (typeof target === \x27string\x27) {\n      return \x3c() =\x3e void\x3ethis.eventManager.addGlobalEventListener(\n          target, event, decoratePreventDefault(callback));\n    }\n    return \x3c() =\x3e void\x3ethis.eventManager.addEventListener(\n          target, event, decoratePreventDefault(callback)) as() =\x3e void;\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e DefaultDomRenderer2 \x3cspan class=\x22hljs-keyword\x22\x3eimplements\x3c\/span\x3e Renderer2 {  \n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eprivate\x3c\/span\x3e eventManager: EventManager\x3c\/span\x3e) {}\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 省略 Renderer2 抽象类中定义的其它方法\x3c\/span\x3e\n  createElement(name: \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3enamespace\x3c\/span\x3e?: \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e): \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3enamespace\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.createElementNS(NAMESPACE_URIS[\x3cspan class=\x22hljs-keyword\x22\x3enamespace\x3c\/span\x3e], name);\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.createElement(name);\n  }\n\n  createComment(value: \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e): \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e { \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.createComment(value); }\n\n  createText(value: \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e): \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e { \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.createTextNode(value); }\n\n  addClass(el: \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e, name: \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e): \x3cspan class=\x22hljs-built_in\x22\x3evoid\x3c\/span\x3e { el.classList.add(name); }\n\n  setStyle(el: \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e, style: \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e, value: \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e, flags: RendererStyleFlags2): \x3cspan class=\x22hljs-built_in\x22\x3evoid\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (flags \x26amp; RendererStyleFlags2.DashCase) {\n      el.style.setProperty(\n          style, value, !!(flags \x26amp; RendererStyleFlags2.Important) ? \x3cspan class=\x22hljs-string\x22\x3e\x27important\x27\x3c\/span\x3e : \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e);\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      el.style[style] = value;\n    }\n  }\n\n  listen(\n    target: \x3cspan class=\x22hljs-string\x22\x3e\x27window\x27\x3c\/span\x3e|\x3cspan class=\x22hljs-string\x22\x3e\x27document\x27\x3c\/span\x3e|\x3cspan class=\x22hljs-string\x22\x3e\x27body\x27\x3c\/span\x3e|\x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e, \n    event: \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e, \n    callback: \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eevent: \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eboolean\x3c\/span\x3e):\n      \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3evoid\x3c\/span\x3e {\n    checkNoSyntheticProp(event, \x3cspan class=\x22hljs-string\x22\x3e\x27listener\x27\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e target === \x3cspan class=\x22hljs-string\x22\x3e\x27string\x27\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x26lt;\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3evoid\x3c\/span\x3e\x26gt;\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.eventManager.addGlobalEventListener(\n          target, event, decoratePreventDefault(callback));\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x26lt;\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3evoid\x3c\/span\x3e\x26gt;\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.eventManager.addEventListener(\n          target, event, decoratePreventDefault(callback)) \x3cspan class=\x22hljs-keyword\x22\x3eas\x3c\/span\x3e() =\x26gt; \x3cspan class=\x22hljs-built_in\x22\x3evoid\x3c\/span\x3e;\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e介绍完 \x3ccode\x3eDomRendererFactory2\x3c\/code\x3e 和 \x3ccode\x3eDefaultDomRenderer2\x3c\/code\x3e 类，最后我们来看一下 Angular 内部如何利用它们。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3eDomRendererFactory2 内部应用\x3c\/h3\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/angular\/angular\/blob\/master\/packages\/platform-browser\/src\/browser.ts#L79\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eBrowserModule\x3c\/a\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ packages\/platform-browser\/src\/browser.ts\n@NgModule({\n  providers: [\n    \/\/ 配置 DomRendererFactory2 和 RendererFactory2 provider\n    DomRendererFactory2,\n    {provide: RendererFactory2, useExisting: DomRendererFactory2},\n    \/\/ ...\n  ],\n  exports: [CommonModule, ApplicationModule]\n})\nexport class BrowserModule {\n  constructor(@Optional() @SkipSelf() parentModule: BrowserModule) {\n    \/\/ 用于判断应用中是否已经导入BrowserModule模块\n    if (parentModule) {\n      throw new Error(\n       `BrowserModule has already been loaded. If you need access to common \n        directives such as NgIf and NgFor from a lazy loaded module, \n        import CommonModule instead.`);\n    }\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ packages\/platform-browser\/src\/browser.ts\x3c\/span\x3e\n\x3cspan class=\x22hljs-meta\x22\x3e@NgModule\x3c\/span\x3e({\n  providers: [\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 配置 DomRendererFactory2 和 RendererFactory2 provider\x3c\/span\x3e\n    DomRendererFactory2,\n    {provide: RendererFactory2, useExisting: DomRendererFactory2},\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n  ],\n  exports: [CommonModule, ApplicationModule]\n})\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e BrowserModule {\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e@Optional(\x3c\/span\x3e) @SkipSelf(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) parentModule: BrowserModule) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 用于判断应用中是否已经导入BrowserModule模块\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (parentModule) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\n       \x3cspan class=\x22hljs-string\x22\x3e`BrowserModule has already been loaded. If you need access to common \n        directives such as NgIf and NgFor from a lazy loaded module, \n        import CommonModule instead.`\x3c\/span\x3e);\n    }\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/angular\/angular\/blob\/master\/packages\/core\/src\/view\/view.ts#L204\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ecreateComponentView()\x3c\/a\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ packages\/core\/src\/view\/view.ts\nexport function createComponentView(\n  parentView: ViewData, \n  nodeDef: NodeDef, \n  viewDef: ViewDefinition, \n  hostElement: any): ViewData {\n  const rendererType = nodeDef.element !.componentRendererType; \/\/ 步骤一\n  let compRenderer: Renderer2;\n  if (!rendererType) { \/\/ 步骤二\n    compRenderer = parentView.root.renderer;\n  } else {\n    compRenderer = parentView.root.rendererFactory\n      .createRenderer(hostElement, rendererType);\n  }\n  \n  return createView(\n    parentView.root, compRenderer, parentView, \n     nodeDef.element !.componentProvider, viewDef);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ packages\/core\/src\/view\/view.ts\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecreateComponentView\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\n  parentView: ViewData, \n  nodeDef: NodeDef, \n  viewDef: ViewDefinition, \n  hostElement: \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e\x3c\/span\x3e): \x3cspan class=\x22hljs-title\x22\x3eViewData\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e rendererType = nodeDef.element !.componentRendererType; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 步骤一\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e compRenderer: Renderer2;\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!rendererType) { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 步骤二\x3c\/span\x3e\n    compRenderer = parentView.root.renderer;\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n    compRenderer = parentView.root.rendererFactory\n      .createRenderer(hostElement, rendererType);\n  }\n  \n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e createView(\n    parentView.root, compRenderer, parentView, \n     nodeDef.element !.componentProvider, viewDef);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cul\x3e\x3cli\x3e步骤一\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e当 Angular 在创建组件视图时，会根据 \x3ccode\x3enodeDef.element\x3c\/code\x3e 对象的 \x3ccode\x3ecomponentRendererType\x3c\/code\x3e 属性值，来创建组件的渲染器。接下来我们先来看一下 \x3ccode\x3eNodeDef\x3c\/code\x3e 、 \x3ccode\x3eElementDef\x3c\/code\x3e 和 \x3ccode\x3eRendererType2\x3c\/code\x3e 接口定义：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ packages\/core\/src\/view\/types.ts\n\/\/ 视图中节点的定义\nexport interface NodeDef {\n  bindingIndex: number;\n  bindings: BindingDef[];\n  bindingFlags: BindingFlags;\n  outputs: OutputDef[];\n  element: ElementDef|null; \/\/ nodeDef.element\n  provider: ProviderDef|null;\n \/\/ ...\n}\n\n\/\/ 元素的定义\nexport interface ElementDef {\n  name: string|null;\n  attrs: [string, string, string][]|null;\n  template: ViewDefinition|null;\n  componentProvider: NodeDef|null;\n  \/\/ 设置组件渲染器的类型\n  componentRendererType: RendererType2|null; \/\/ nodeDef.element.componentRendererType\n  componentView: ViewDefinitionFactory|null;\n  handleEvent: ElementHandleEventFn|null;\n  \/\/ ...\n}\n\n\/\/ packages\/core\/src\/render\/api.ts\n\/\/ RendererType2 接口定义\nexport interface RendererType2 {\n  id: string;\n  encapsulation: ViewEncapsulation; \/\/ Emulated、Native、None\n  styles: (string|any[])[];\n  data: {[kind: string]: any};\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ packages\/core\/src\/view\/types.ts\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 视图中节点的定义\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3einterface\x3c\/span\x3e NodeDef {\n  bindingIndex: \x3cspan class=\x22hljs-built_in\x22\x3enumber\x3c\/span\x3e;\n  bindings: BindingDef[];\n  bindingFlags: BindingFlags;\n  outputs: OutputDef[];\n  element: ElementDef|\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ nodeDef.element\x3c\/span\x3e\n  provider: ProviderDef|\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 元素的定义\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3einterface\x3c\/span\x3e ElementDef {\n  name: \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e|\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n  attrs: [\x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e][]|\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n  template: ViewDefinition|\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n  componentProvider: NodeDef|\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 设置组件渲染器的类型\x3c\/span\x3e\n  componentRendererType: RendererType2|\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ nodeDef.element.componentRendererType\x3c\/span\x3e\n  componentView: ViewDefinitionFactory|\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n  handleEvent: ElementHandleEventFn|\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ packages\/core\/src\/render\/api.ts\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ RendererType2 接口定义\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3einterface\x3c\/span\x3e RendererType2 {\n  id: \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e;\n  encapsulation: ViewEncapsulation; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Emulated、Native、None\x3c\/span\x3e\n  styles: (\x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e|\x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e[])[];\n  data: {[kind: \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e]: \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e};\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cul\x3e\x3cli\x3e步骤二\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e获取 \x3ccode\x3ecomponentRendererType\x3c\/code\x3e 的属性值后，如果该值为 \x3ccode\x3enull\x3c\/code\x3e 的话，则直接使用 \x3ccode\x3eparentView.root\x3c\/code\x3e 属性值对应的  \x3ccode\x3erenderer\x3c\/code\x3e 对象。若该值不为空，则调用 \x3ccode\x3eparentView.root\x3c\/code\x3e 对象的 \x3ccode\x3erendererFactory()\x3c\/code\x3e 方法创建 \x3ccode\x3erenderer\x3c\/code\x3e 对象。\x3c\/p\x3e\n\x3cp\x3e通过上面分析，我们发现不管走哪条分支，我们都需要使用 \x3ccode\x3eparentView.root\x3c\/code\x3e 对象，然而该对象是什么特殊对象？我们发现 \x3ccode\x3eparentView\x3c\/code\x3e 的数据类型是 \x3ccode\x3eViewData\x3c\/code\x3e ，该数据接口定义如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ packages\/core\/src\/view\/types.ts\nexport interface ViewData {\n  def: ViewDefinition;\n  root: RootData;\n  renderer: Renderer2;\n  nodes: {[key: number]: NodeData};\n  state: ViewState;\n  oldValues: any[];\n  disposables: DisposableFn[]|null;\n  \/\/ ...\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ packages\/core\/src\/view\/types.ts\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3einterface\x3c\/span\x3e ViewData {\n  def: ViewDefinition;\n  root: RootData;\n  renderer: Renderer2;\n  nodes: {[key: \x3cspan class=\x22hljs-built_in\x22\x3enumber\x3c\/span\x3e]: NodeData};\n  state: ViewState;\n  oldValues: \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e[];\n  disposables: DisposableFn[]|\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e通过 \x3ccode\x3eViewData\x3c\/code\x3e 的接口定义，我们终于发现了 \x3ccode\x3eparentView.root\x3c\/code\x3e 的属性类型，即 \x3ccode\x3eRootData\x3c\/code\x3e：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ packages\/core\/src\/view\/types.ts\nexport interface RootData {\n  injector: Injector;\n  ngModule: NgModuleRef\x3cany\x3e;\n  projectableNodes: any[][];\n  selectorOrNode: any;\n  renderer: Renderer2;\n  rendererFactory: RendererFactory2;\n  errorHandler: ErrorHandler;\n  sanitizer: Sanitizer;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ packages\/core\/src\/view\/types.ts\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3einterface\x3c\/span\x3e RootData {\n  injector: Injector;\n  ngModule: NgModuleRef\x26lt;\x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e\x26gt;;\n  projectableNodes: \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e[][];\n  selectorOrNode: \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e;\n  renderer: Renderer2;\n  rendererFactory: RendererFactory2;\n  errorHandler: ErrorHandler;\n  sanitizer: Sanitizer;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e那好，现在问题来了：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e什么时候创建 \x3ccode\x3eRootData\x3c\/code\x3e 对象？\x3c\/li\x3e\n\x3cli\x3e怎么创建 \x3ccode\x3eRootData\x3c\/code\x3e 对象？\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch4\x3e什么时候创建 \x3ccode\x3eRootData\x3c\/code\x3e 对象？\x3c\/h4\x3e\n\x3cp\x3e当创建根视图的时候会创建 RootData，在开发环境会调用 \x3ccode\x3edebugCreateRootView()\x3c\/code\x3e 方法创建 \x3ccode\x3eRootView\x3c\/code\x3e，而在生产环境会调用 \x3ccode\x3ecreateProdRootView()\x3c\/code\x3e 方法创建 \x3ccode\x3eRootView\x3c\/code\x3e。简单起见，我们只分析 \x3ccode\x3ecreateProdRootView()\x3c\/code\x3e 方法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function createProdRootView(\n    elInjector: Injector, \n    projectableNodes: any[][], \n    rootSelectorOrNode: string | any,\n    def: ViewDefinition, \n    ngModule: NgModuleRef\x3cany\x3e, \n    context?: any): ViewData {\n  \/** RendererFactory2 Provider 配置\n   *  DomRendererFactory2,\n   *  {provide: RendererFactory2, useExisting: DomRendererFactory2},\n   *\/\n  const rendererFactory: RendererFactory2 = ngModule.injector.get(RendererFactory2);\n      \n  return createRootView(\n      createRootData(elInjector, ngModule, rendererFactory,\n        projectableNodes, rootSelectorOrNode),\n      def, context);\n}\n\n\/\/ 创建根视图\nexport function createRootView(root: RootData, def: ViewDefinition, \n  context?: any): ViewData {\n  \/\/ 创建ViewData对象\n  const view = createView(root, root.renderer, null, null, def);\n  initView(view, context, context);\n  createViewNodes(view);\n  return view;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecreateProdRootView\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\n    elInjector: Injector, \n    projectableNodes: \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e[][], \n    rootSelectorOrNode: \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e | \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e,\n    def: ViewDefinition, \n    ngModule: NgModuleRef\x26lt;\x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e\x26gt;, \n    context?: \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e\x3c\/span\x3e): \x3cspan class=\x22hljs-title\x22\x3eViewData\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/** RendererFactory2 Provider 配置\n   *  DomRendererFactory2,\n   *  {provide: RendererFactory2, useExisting: DomRendererFactory2},\n   *\/\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e rendererFactory: RendererFactory2 = ngModule.injector.get(RendererFactory2);\n      \n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e createRootView(\n      createRootData(elInjector, ngModule, rendererFactory,\n        projectableNodes, rootSelectorOrNode),\n      def, context);\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建根视图\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecreateRootView\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eroot: RootData, def: ViewDefinition, \n  context?: \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e\x3c\/span\x3e): \x3cspan class=\x22hljs-title\x22\x3eViewData\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建ViewData对象\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e view = createView(root, root.renderer, \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e, \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e, def);\n  initView(view, context, context);\n  createViewNodes(view);\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e view;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面代码中，当创建 \x3ccode\x3eRootView\x3c\/code\x3e 的时候，会调用 \x3ccode\x3ecreateRootData()\x3c\/code\x3e 方法创建 \x3ccode\x3eRootData\x3c\/code\x3e 对象。最后一步就是分析 \x3ccode\x3ecreateRootData()\x3c\/code\x3e 方法。\x3c\/p\x3e\n\x3ch4\x3e怎么创建 \x3ccode\x3eRootData\x3c\/code\x3e 对象？\x3c\/h4\x3e\n\x3cp\x3e通过上面分析，我们知道通过 \x3ccode\x3ecreateRootData()\x3c\/code\x3e 方法，来创建 \x3ccode\x3eRootData\x3c\/code\x3e 对象。\x3ccode\x3ecreateRootData()\x3c\/code\x3e 方法具体实现如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function createRootData(\n    elInjector: Injector, \n    ngModule: NgModuleRef\x3cany\x3e, \n    rendererFactory: RendererFactory2,\n    projectableNodes: any[][], \n    rootSelectorOrNode: any): RootData {\n  const sanitizer = ngModule.injector.get(Sanitizer);\n  const errorHandler = ngModule.injector.get(ErrorHandler);\n  \/\/ 创建RootRenderer\n  const renderer = rendererFactory.createRenderer(null, null); \n  return {\n    ngModule,\n    injector: elInjector,\n    projectableNodes,\n    selectorOrNode: rootSelectorOrNode, \n    sanitizer, \n    rendererFactory, \n    renderer,\n    errorHandler\n  };\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecreateRootData\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\n    elInjector: Injector, \n    ngModule: NgModuleRef\x26lt;\x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e\x26gt;, \n    rendererFactory: RendererFactory2,\n    projectableNodes: \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e[][], \n    rootSelectorOrNode: \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e\x3c\/span\x3e): \x3cspan class=\x22hljs-title\x22\x3eRootData\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e sanitizer = ngModule.injector.get(Sanitizer);\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e errorHandler = ngModule.injector.get(ErrorHandler);\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建RootRenderer\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e renderer = rendererFactory.createRenderer(\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e, \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e); \n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n    ngModule,\n    injector: elInjector,\n    projectableNodes,\n    selectorOrNode: rootSelectorOrNode, \n    sanitizer, \n    rendererFactory, \n    renderer,\n    errorHandler\n  };\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e此时浏览器平台下， \x3ccode\x3eRenderer\x3c\/code\x3e 渲染器的相关基础知识已介绍完毕。接下来，我们做一个简单总结：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eAngular 应用程序启动时会创建 RootView (生产环境下通过调用 createProdRootView() 方法)\x3c\/li\x3e\n\x3cli\x3e创建 RootView 的过程中，会创建 RootData 对象，该对象可以通过 ViewData 的 root 属性访问到。基于  RootData 对象，我们可以通过 \x3ccode\x3erenderer\x3c\/code\x3e 访问到默认的渲染器，即 DefaultDomRenderer2 实例，此外也可以通过 \x3ccode\x3erendererFactory\x3c\/code\x3e 访问到 \x3ccode\x3eRendererFactory2\x3c\/code\x3e 实例。\x3c\/li\x3e\n\x3cli\x3e在创建组件视图 (ViewData) 时，会根据 \x3ccode\x3ecomponentRendererType\x3c\/code\x3e 的属性值，来设置组件关联的 \x3ccode\x3erenderer\x3c\/code\x3e 渲染器。\x3c\/li\x3e\n\x3cli\x3e当渲染组件视图的时候，Angular 会利用该组件关联的 \x3ccode\x3erenderer\x3c\/code\x3e 提供的 API，创建该视图中的节点或执行视图的相关操作，比如创建元素 (createElement)、创建文本 (createText)、设置样式 (setStyle) 和 设置事件监听 (listen) 等。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e后面如果有时间的话，我们会介绍如何自定义渲染器，有兴趣的读者，可以先查阅 \x22参考资源\x22 中的链接。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader10\x22\x3e参考资源\x3c\/h2\x3e\n\x3cul\x3e\x3cli\x3e\x3ca href=\x22https:\/\/blog.nrwl.io\/experiments-with-angular-renderers-c5f647d4fd9e\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eExperiments with Angular Renderers\x3c\/a\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>Angular Renderer (渲染器)</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000010326100">https://segmentfault.com/a/1190000010326100</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/s8k2kpunchj/" target="_blank">https://alili.tech/archive/s8k2kpunchj/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>