<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="preact源码学习（2）"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>preact源码学习（2） | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/g5l3ptw8769/",
				"appid": "1613049289050283", 
				"title": "preact源码学习（2） | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-07T02:30:11"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/2s8971jcmjv/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/hsvwrdkx2lb/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fg5l3ptw8769%2f&text=preact%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a0%ef%bc%882%ef%bc%89"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fg5l3ptw8769%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fg5l3ptw8769%2f&text=preact%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a0%ef%bc%882%ef%bc%89"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fg5l3ptw8769%2f&title=preact%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a0%ef%bc%882%ef%bc%89"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fg5l3ptw8769%2f&is_video=false&description=preact%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a0%ef%bc%882%ef%bc%89"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=preact%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a0%ef%bc%882%ef%bc%89&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fg5l3ptw8769%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fg5l3ptw8769%2f&title=preact%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a0%ef%bc%882%ef%bc%89"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fg5l3ptw8769%2f&title=preact%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a0%ef%bc%882%ef%bc%89"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fg5l3ptw8769%2f&title=preact%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a0%ef%bc%882%ef%bc%89"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fg5l3ptw8769%2f&title=preact%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a0%ef%bc%882%ef%bc%89"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">preact源码学习（2）</h1><div class="meta"><div class="postdate"><time datetime="2019-01-07" itemprop="datePublished">2019-01-07</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e本节我们看如何更新组件。在上一节也反复提到renderComponent这个方法了，这节直接从它入手吧。它位于\x3ccode\x3esrc\/vdom\/component.js\x3c\/code\x3e文件中。\x3c\/p\x3e\n\x3cp\x3e从参数来看，我们会惊讶它竟然会有这么多参数，原来我们只看到它有两个参数，第二个为数字。第一个参数不用说，是组件的实例。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export function renderComponent(component, opts, mountAll, isChild) {\n    \/\/如果它是_disable状态，立即返回，\n    if (component._disable) return;\n    \/\/开始取出它前后的props, state,context, base\n    \/\/base是这个组件的render方法生成的虚拟DOM最后转化出来的真实DOM\n    \/\/如果有这个真实DOM，说明它已经mount了，现在是处于更新状态\n    let props = component.props,\n        state = component.state,\n        context = component.context,\n        previousProps = component.prevProps || props,\n        previousState = component.prevState || state,\n        previousContext = component.prevContext || context,\n        isUpdate = component.base,\n        nextBase = component.nextBase,\n        \/\/真实DOM\n        initialBase = isUpdate || nextBase,\n        \/\/这个变早比较难理，它是component的render方法生成的虚拟DOM的type函数再实例化出来的子组件，相当于一个组件又return出另一个组件。通常情况下，组件会return出来的虚拟DOM的type为一个字符串，对应div, p, span这些真实存在的nodeName。而type为函数时，它就是一个组件。\n        initialChildComponent = component._component,\n        skip = false,\n        rendered, inst, cbase;\n\n    \/\/ 如果是更新状态，会经过shouldComponentUpdate，componentWillUpdate钩子\n    if (isUpdate) {\n        component.props = previousProps;\n        component.state = previousState;\n        component.context = previousContext;\n        if (opts!==FORCE_RENDER\n            \x26amp;\x26amp; component.shouldComponentUpdate\n            \x26amp;\x26amp; component.shouldComponentUpdate(props, state, context) === false) {\n            skip = true;\n        }\n        else if (component.componentWillUpdate) {\n            component.componentWillUpdate(props, state, context);\n        }\n        component.props = props;\n        component.state = state;\n        component.context = context;\n    }\n    \/\/GC\n    component.prevProps = component.prevState = component.prevContext = component.nextBase = null;\n    component._dirty = false;\n    \n    if (!skip) {\n        \/\/mount与update都要调用render方法，这时与官方react有点不一样，官方react是没有传参，可能是早期官方文档没有规范render的参数吧。而后来的官方源码上，render是没有参数的。这个参数不应该preact来背。\n        rendered = component.render(props, state, context);\n\n        \/\/ 如果用户定义了getChildContext，那么用它与context生成孩子的context\n        if (component.getChildContext) {\n            context = extend(extend({}, context), component.getChildContext());\n        }\n\n        let childComponent = rendered \x26amp;\x26amp; rendered.nodeName,\n            toUnmount, base;\n        \/\/判定render出来的虚拟DOM是否还是一个组件\n        if (typeof childComponent===\x27function\x27) {\n            \/\/ set up high order component link\n\n            let childProps = getNodeProps(rendered);\n            inst = initialChildComponent;\n            \/\/如果前后两次的子组件的类型都一致，并且key也一样，则用setComponentProps方法更新这个子组件\n            if (inst \x26amp;\x26amp; inst.constructor===childComponent \x26amp;\x26amp; childProps.key==inst.__key) {\n                setComponentProps(inst, childProps, SYNC_RENDER, context, false);\n            }\n            else {\n            \/\/否则要替换原来的组件\n            \/\/toUnmount用来标识一会儿要进行unmount操作\n                toUnmount = inst;\n            \/\/实例化另一个组件\n                component._component = inst = createComponent(childComponent, childProps, context);\n                \/\/刷新真实DOM\n                inst.nextBase = inst.nextBase || nextBase;\n                inst._parentComponent = component;\n                \/\/更新子组件的属性，这里面调用WillRecieveProps钩子\n                setComponentProps(inst, childProps, NO_RENDER, context, false);\n                \/\/异步渲染子组件，这招比较妙，这里你可以看到isChild参数的作用\n                renderComponent(inst, SYNC_RENDER, mountAll, true);\n            }\n           \n            base = inst.base;\n        }\n        else {\n          \/\/如果这次render出来的不是组件，而是普通虚拟DOM，\n            cbase = initialBase;\n\n            \/\/ destroy high order component link\n            toUnmount = initialChildComponent;\n            if (toUnmount) {\n                cbase = component._component = null;\n            }\n\n            if (initialBase || opts===SYNC_RENDER) {\n                if (cbase) cbase._component = null;\n                base = diff(cbase, rendered, context, mountAll || !isUpdate, initialBase \x26amp;\x26amp; initialBase.parentNode, true);\n            }\n        }\n        \/\/如果元素节点不同，并且组件实例也不是一个\n        if (initialBase \x26amp;\x26amp; base!==initialBase \x26amp;\x26amp; inst!==initialChildComponent) {\n            let baseParent = initialBase.parentNode;\n            if (baseParent \x26amp;\x26amp; base!==baseParent) {\n                baseParent.replaceChild(base, initialBase);\n\n                if (!toUnmount) {\n                    initialBase._component = null;\n                    recollectNodeTree(initialBase, false);\n                }\n            }\n        }\n\n        if (toUnmount) {\n            unmountComponent(toUnmount);\n        }\n        \/\/重写真实DOM\n        component.base = base;\n        if (base \x26amp;\x26amp; !isChild) {\n            let componentRef = component,\n                t = component;\n         \/\/由于组件能返回组件，可能经过N次render后才能返回一个能转换成为真实DOM的普通虚拟DOM，这些组件通过_parentComponent链接在一起，它们都是共享同一个真实DOM（base）, 这时我们需要为这些组件都重写base属性\n            while ((t=t._parentComponent)) {\n                (componentRef = t).base = base;\n            }\n            \/\/在真实DOM上保存最初的那个组件与组件的构造器\n            \/\/在真实DOM上保存这么多对象其实是不太好的实现，因为会导致内存泄露，因此才有了recollectNodeTree这个方法\n            base._component = componentRef;\n            base._componentConstructor = componentRef.constructor;\n        }\n    }\n    \/\/如果是异步插入进行组件的单个render或者是ReactDOM.render，这些组件实例都会先放到mounts数组中。\n    if (!isUpdate || mountAll) {\n        mounts.unshift(component);\n    }\n    else if (!skip) {\n         \/\/更新完毕，调用componentDidUpdate，afterUpdate钩子\n        if (component.componentDidUpdate) {\n            component.componentDidUpdate(previousProps, previousState, previousContext);\n        }\n        if (options.afterUpdate){\n           options.afterUpdate(component);\n        }\n    }\n    \/\/调用setState, forceUpdate钩子\n    if (component._renderCallbacks!=null) {\n        while (component._renderCallbacks.length) component._renderCallbacks.pop().call(component);\n    }\n    \/\/执行其他组件的更新或插入，diffLevel为一个全局变量\n    if (!diffLevel \x26amp;\x26amp; !isChild) flushMounts();\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3erenderComponent\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ecomponent, opts, mountAll, isChild\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果它是_disable状态，立即返回，\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (component._disable) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/开始取出它前后的props, state,context, base\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/base是这个组件的render方法生成的虚拟DOM最后转化出来的真实DOM\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果有这个真实DOM，说明它已经mount了，现在是处于更新状态\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e props = component.props,\n        state = component.state,\n        context = component.context,\n        previousProps = component.prevProps || props,\n        previousState = component.prevState || state,\n        previousContext = component.prevContext || context,\n        isUpdate = component.base,\n        nextBase = component.nextBase,\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/真实DOM\x3c\/span\x3e\n        initialBase = isUpdate || nextBase,\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/这个变早比较难理，它是component的render方法生成的虚拟DOM的type函数再实例化出来的子组件，相当于一个组件又return出另一个组件。通常情况下，组件会return出来的虚拟DOM的type为一个字符串，对应div, p, span这些真实存在的nodeName。而type为函数时，它就是一个组件。\x3c\/span\x3e\n        initialChildComponent = component._component,\n        skip = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n        rendered, inst, cbase;\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果是更新状态，会经过shouldComponentUpdate，componentWillUpdate钩子\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isUpdate) {\n        component.props = previousProps;\n        component.state = previousState;\n        component.context = previousContext;\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (opts!==FORCE_RENDER\n            \x26amp;\x26amp; component.shouldComponentUpdate\n            \x26amp;\x26amp; component.shouldComponentUpdate(props, state, context) === \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e) {\n            skip = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n        }\n        \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (component.componentWillUpdate) {\n            component.componentWillUpdate(props, state, context);\n        }\n        component.props = props;\n        component.state = state;\n        component.context = context;\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/GC\x3c\/span\x3e\n    component.prevProps = component.prevState = component.prevContext = component.nextBase = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n    component._dirty = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n    \n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!skip) {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/mount与update都要调用render方法，这时与官方react有点不一样，官方react是没有传参，可能是早期官方文档没有规范render的参数吧。而后来的官方源码上，render是没有参数的。这个参数不应该preact来背。\x3c\/span\x3e\n        rendered = component.render(props, state, context);\n\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果用户定义了getChildContext，那么用它与context生成孩子的context\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (component.getChildContext) {\n            context = extend(extend({}, context), component.getChildContext());\n        }\n\n        \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e childComponent = rendered \x26amp;\x26amp; rendered.nodeName,\n            toUnmount, base;\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/判定render出来的虚拟DOM是否还是一个组件\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e childComponent===\x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e) {\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ set up high order component link\x3c\/span\x3e\n\n            \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e childProps = getNodeProps(rendered);\n            inst = initialChildComponent;\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果前后两次的子组件的类型都一致，并且key也一样，则用setComponentProps方法更新这个子组件\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (inst \x26amp;\x26amp; inst.constructor===childComponent \x26amp;\x26amp; childProps.key==inst.__key) {\n                setComponentProps(inst, childProps, SYNC_RENDER, context, \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e);\n            }\n            \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/否则要替换原来的组件\x3c\/span\x3e\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/toUnmount用来标识一会儿要进行unmount操作\x3c\/span\x3e\n                toUnmount = inst;\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/实例化另一个组件\x3c\/span\x3e\n                component._component = inst = createComponent(childComponent, childProps, context);\n                \x3cspan class=\x22hljs-comment\x22\x3e\/\/刷新真实DOM\x3c\/span\x3e\n                inst.nextBase = inst.nextBase || nextBase;\n                inst._parentComponent = component;\n                \x3cspan class=\x22hljs-comment\x22\x3e\/\/更新子组件的属性，这里面调用WillRecieveProps钩子\x3c\/span\x3e\n                setComponentProps(inst, childProps, NO_RENDER, context, \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e);\n                \x3cspan class=\x22hljs-comment\x22\x3e\/\/异步渲染子组件，这招比较妙，这里你可以看到isChild参数的作用\x3c\/span\x3e\n                renderComponent(inst, SYNC_RENDER, mountAll, \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e);\n            }\n           \n            base = inst.base;\n        }\n        \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果这次render出来的不是组件，而是普通虚拟DOM，\x3c\/span\x3e\n            cbase = initialBase;\n\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ destroy high order component link\x3c\/span\x3e\n            toUnmount = initialChildComponent;\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (toUnmount) {\n                cbase = component._component = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n            }\n\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (initialBase || opts===SYNC_RENDER) {\n                \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (cbase) cbase._component = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n                base = diff(cbase, rendered, context, mountAll || !isUpdate, initialBase \x26amp;\x26amp; initialBase.parentNode, \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e);\n            }\n        }\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果元素节点不同，并且组件实例也不是一个\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (initialBase \x26amp;\x26amp; base!==initialBase \x26amp;\x26amp; inst!==initialChildComponent) {\n            \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e baseParent = initialBase.parentNode;\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (baseParent \x26amp;\x26amp; base!==baseParent) {\n                baseParent.replaceChild(base, initialBase);\n\n                \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!toUnmount) {\n                    initialBase._component = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n                    recollectNodeTree(initialBase, \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e);\n                }\n            }\n        }\n\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (toUnmount) {\n            unmountComponent(toUnmount);\n        }\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/重写真实DOM\x3c\/span\x3e\n        component.base = base;\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (base \x26amp;\x26amp; !isChild) {\n            \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e componentRef = component,\n                t = component;\n         \x3cspan class=\x22hljs-comment\x22\x3e\/\/由于组件能返回组件，可能经过N次render后才能返回一个能转换成为真实DOM的普通虚拟DOM，这些组件通过_parentComponent链接在一起，它们都是共享同一个真实DOM（base）, 这时我们需要为这些组件都重写base属性\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e ((t=t._parentComponent)) {\n                (componentRef = t).base = base;\n            }\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/在真实DOM上保存最初的那个组件与组件的构造器\x3c\/span\x3e\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/在真实DOM上保存这么多对象其实是不太好的实现，因为会导致内存泄露，因此才有了recollectNodeTree这个方法\x3c\/span\x3e\n            base._component = componentRef;\n            base._componentConstructor = componentRef.constructor;\n        }\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果是异步插入进行组件的单个render或者是ReactDOM.render，这些组件实例都会先放到mounts数组中。\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!isUpdate || mountAll) {\n        mounts.unshift(component);\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!skip) {\n         \x3cspan class=\x22hljs-comment\x22\x3e\/\/更新完毕，调用componentDidUpdate，afterUpdate钩子\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (component.componentDidUpdate) {\n            component.componentDidUpdate(previousProps, previousState, previousContext);\n        }\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (options.afterUpdate){\n           options.afterUpdate(component);\n        }\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/调用setState, forceUpdate钩子\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (component._renderCallbacks!=\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (component._renderCallbacks.length) component._renderCallbacks.pop().call(component);\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/执行其他组件的更新或插入，diffLevel为一个全局变量\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!diffLevel \x26amp;\x26amp; !isChild) flushMounts();\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这个函数出现的对象与关系太多了，究竟某某是某某的什么，看下图就知了。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVRxOc?w=1212\x26amp;h=838\x22 src=\x22https:\/\/static.alili.tech\/img\/bVRxOc?w=1212\x26amp;h=838\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e我们需要知道，组件render后可能产生普通虚拟DOM与子组件，而只有普通虚拟DOM才能转化为真实DOM。组件的实例通过\x3ccode\x3e_component\x3c\/code\x3e与\x3ccode\x3e_parentComponent\x3c\/code\x3e联结在一块，方便上下回溯。而实例总是保存着最后转化出来的真实DOM（base, 也叫initialBase）。base上保存着最上面的那个组件实例，也就是_component，此外，为了方便比较，它的构造器也放在DOM节点上。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3erenderComponent\x3c\/strong\x3e这个方法主要处理组件更新时的钩子，及建立父子组件间的联系。\x3c\/p\x3e\n\x3cp\x3e这个方法的参数的起名也很奇葩，如果改成\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22renderComponent(componentInstance, renderModel, isRenderByReactDOM, isRenderChildComponent)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3erenderComponent\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(componentInstance, renderModel, isRenderByReactDOM, isRenderChildComponent)\x3c\/span\x3e\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e则好理解些。显示preact的作者不太想知道其奥秘，因此源码的注释也很少很少。\x3c\/p\x3e\n\x3cp\x3e好了，我们看setComponentProps方法，它在renderComponent用了两次。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/更新已有的子组件实例\nsetComponentProps(inst, childProps, SYNC_RENDER, context, false);\n\/\/新旧子组件的类型不一致，用新组件的实例进行替换\nsetComponentProps(inst, childProps, NO_RENDER, context, false);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/更新已有的子组件实例\x3c\/span\x3e\nsetComponentProps(inst, childProps, SYNC_RENDER, context, \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/新旧子组件的类型不一致，用新组件的实例进行替换\x3c\/span\x3e\nsetComponentProps(inst, childProps, NO_RENDER, context, \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3esetComponentProps的源码\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export function setComponentProps(component, props, opts, context, mountAll) {\n    if (component._disable) return;\n    \/\/_disable状态下阻止用户\n    component._disable = true;\n\n    if ((component.__ref = props.ref)) delete props.ref;\n    if ((component.__key = props.key)) delete props.key;\n\n    if (!component.base || mountAll) {\n    \/\/如果没有插入到DOM树或正在被ReactDOM.render渲染\n        if (component.componentWillMount) component.componentWillMount();\n    }\n    else if (component.componentWillReceiveProps) {\n    \/\/如果是在更新过程中\n        component.componentWillReceiveProps(props, context);\n    }\n    \/\/下面依次设置provProps, props, prevContext, context\n    if (context \x26amp;\x26amp; context!==component.context) {\n        if (!component.prevContext) component.prevContext = component.context;\n        component.context = context;\n    }\n    \n    if (!component.prevProps) component.prevProps = component.props;\n    component.props = props;\n\n    component._disable = false;\n    \/\/=====================\n    if (opts!==NO_RENDER) {\n        if (opts===SYNC_RENDER || options.syncComponentUpdates!==false || !component.base) {\n            renderComponent(component, SYNC_RENDER, mountAll);\n        }\n        else {\n            enqueueRender(component);\n        }\n    }\n\n    if (component.__ref) component.__ref(component);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3esetComponentProps\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ecomponent, props, opts, context, mountAll\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (component._disable) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/_disable状态下阻止用户\x3c\/span\x3e\n    component._disable = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ((component.__ref = props.ref)) \x3cspan class=\x22hljs-keyword\x22\x3edelete\x3c\/span\x3e props.ref;\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ((component.__key = props.key)) \x3cspan class=\x22hljs-keyword\x22\x3edelete\x3c\/span\x3e props.key;\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!component.base || mountAll) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果没有插入到DOM树或正在被ReactDOM.render渲染\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (component.componentWillMount) component.componentWillMount();\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (component.componentWillReceiveProps) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果是在更新过程中\x3c\/span\x3e\n        component.componentWillReceiveProps(props, context);\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/下面依次设置provProps, props, prevContext, context\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (context \x26amp;\x26amp; context!==component.context) {\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!component.prevContext) component.prevContext = component.context;\n        component.context = context;\n    }\n    \n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!component.prevProps) component.prevProps = component.props;\n    component.props = props;\n\n    component._disable = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/=====================\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (opts!==NO_RENDER) {\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (opts===SYNC_RENDER || options.syncComponentUpdates!==\x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e || !component.base) {\n            renderComponent(component, SYNC_RENDER, mountAll);\n        }\n        \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n            enqueueRender(component);\n        }\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (component.__ref) component.__ref(component);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e最后看 createComponent，这是创建一个组件实例。React的组件有三种，经典组件，纯组件，无状态组件，前两种都是类的形式，可以归为一种，最后一种是普通函数。但在\x3ccode\x3esrc\/vdom\/component-recycler.js\x3c\/code\x3e我们看到它们都是\x3ccode\x3enew\x3c\/code\x3e出来的。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export function createComponent(Ctor, props, context) {\n    let list = components[Ctor.name],\n        inst;\n    \/\/类形式的组件\n    if (Ctor.prototype \x26amp;\x26amp; Ctor.prototype.render) {\n        inst = new Ctor(props, context);\n        Component.call(inst, props, context);\n    }else {\/\/无状态组件\n        inst = new Component(props, context);\n        inst.constructor = Ctor;\n        inst.render = doRender;\n    }\n\n    if (list) {\n        for (let i=list.length; i--; ) {\n            if (list[i].constructor===Ctor) {\n                inst.nextBase = list[i].nextBase;\n                list.splice(i, 1);\n                break;\n            }\n        }\n    }\n    return inst;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs maxima\x22\x3e\x3ccode\x3eexport function createComponent(Ctor, \x3cspan class=\x22hljs-built_in\x22\x3eprops\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3econtext\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-built_in\x22\x3elet\x3c\/span\x3e list = \x3cspan class=\x22hljs-built_in\x22\x3ecomponents\x3c\/span\x3e[Ctor.name],\n        inst;\n    \/\/类形式的组件\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (Ctor.prototype \x26amp;\x26amp; Ctor.prototype.render) {\n        inst = \x3cspan class=\x22hljs-built_in\x22\x3enew\x3c\/span\x3e Ctor(\x3cspan class=\x22hljs-built_in\x22\x3eprops\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3econtext\x3c\/span\x3e);\n        Component.call(inst, \x3cspan class=\x22hljs-built_in\x22\x3eprops\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3econtext\x3c\/span\x3e);\n    }\x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\/\/无状态组件\n        inst = \x3cspan class=\x22hljs-built_in\x22\x3enew\x3c\/span\x3e Component(\x3cspan class=\x22hljs-built_in\x22\x3eprops\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3econtext\x3c\/span\x3e);\n        inst.constructor = Ctor;\n        inst.render = doRender;\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (list) {\n        \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3elet\x3c\/span\x3e i=list.\x3cspan class=\x22hljs-built_in\x22\x3elength\x3c\/span\x3e; i--; ) {\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (list[i].constructor===Ctor) {\n                inst.nextBase = list[i].nextBase;\n                list.\x3cspan class=\x22hljs-built_in\x22\x3esplice\x3c\/span\x3e(i, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\n                \x3cspan class=\x22hljs-built_in\x22\x3ebreak\x3c\/span\x3e;\n            }\n        }\n    }\n    \x3cspan class=\x22hljs-built_in\x22\x3ereturn\x3c\/span\x3e inst;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们再看一下doRender,这时恍然大悟，原来preact是统一所有组件以后更新都要通过render方法生成它的普通虚拟DOM或子组件。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function doRender(props, state, context) {\n    return this.constructor(props, context);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3edoRender\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eprops, state, context\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.constructor(props, context);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e此外，preact还通过collectComponent来回收它的真实DOM，然后在createComponent中重复利用。这是它高效的缘由之一。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const components = {};\n\nexport function collectComponent(component) {\n    let name = component.constructor.name;\n    (components[name] || (components[name] = [])).push(component);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs fortran\x22\x3e\x3ccode\x3econst components = {};\n\nexport \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3c\/span\x3e collectComponent(component) {\n    let \x3cspan class=\x22hljs-keyword\x22\x3ename\x3c\/span\x3e = component.constructor.\x3cspan class=\x22hljs-keyword\x22\x3ename\x3c\/span\x3e;\n    (components[\x3cspan class=\x22hljs-keyword\x22\x3ename\x3c\/span\x3e] || (components[\x3cspan class=\x22hljs-keyword\x22\x3ename\x3c\/span\x3e] = [])).push(component);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>preact源码学习（2）</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000010340534">https://segmentfault.com/a/1190000010340534</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/g5l3ptw8769/" target="_blank">https://alili.tech/archive/g5l3ptw8769/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>