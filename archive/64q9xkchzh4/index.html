<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="Ajax知识体系大梳理"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>Ajax知识体系大梳理 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/64q9xkchzh4/",
				"appid": "1613049289050283", 
				"title": "Ajax知识体系大梳理 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-18T02:30:35"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/2tnk4uccj5t/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/ecriucnvxvo/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f64q9xkchzh4%2f&text=Ajax%e7%9f%a5%e8%af%86%e4%bd%93%e7%b3%bb%e5%a4%a7%e6%a2%b3%e7%90%86"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f64q9xkchzh4%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f64q9xkchzh4%2f&text=Ajax%e7%9f%a5%e8%af%86%e4%bd%93%e7%b3%bb%e5%a4%a7%e6%a2%b3%e7%90%86"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f64q9xkchzh4%2f&title=Ajax%e7%9f%a5%e8%af%86%e4%bd%93%e7%b3%bb%e5%a4%a7%e6%a2%b3%e7%90%86"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f64q9xkchzh4%2f&is_video=false&description=Ajax%e7%9f%a5%e8%af%86%e4%bd%93%e7%b3%bb%e5%a4%a7%e6%a2%b3%e7%90%86"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=Ajax%e7%9f%a5%e8%af%86%e4%bd%93%e7%b3%bb%e5%a4%a7%e6%a2%b3%e7%90%86&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f64q9xkchzh4%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f64q9xkchzh4%2f&title=Ajax%e7%9f%a5%e8%af%86%e4%bd%93%e7%b3%bb%e5%a4%a7%e6%a2%b3%e7%90%86"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f64q9xkchzh4%2f&title=Ajax%e7%9f%a5%e8%af%86%e4%bd%93%e7%b3%bb%e5%a4%a7%e6%a2%b3%e7%90%86"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f64q9xkchzh4%2f&title=Ajax%e7%9f%a5%e8%af%86%e4%bd%93%e7%b3%bb%e5%a4%a7%e6%a2%b3%e7%90%86"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f64q9xkchzh4%2f&title=Ajax%e7%9f%a5%e8%af%86%e4%bd%93%e7%b3%bb%e5%a4%a7%e6%a2%b3%e7%90%86"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">Ajax知识体系大梳理</h1><div class="meta"><div class="postdate"><time datetime="2019-01-18" itemprop="datePublished">2019-01-18</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch3 id=\x22articleHeader0\x22\x3e导读\x3c\/h3\x3e\n\x3cp\x3eAjax 全称 Asynchronous JavaScript and XML, 即异步JS与XML. 它最早在IE5中被使用, 然后由Mozilla, Apple, Google推广开来. 典型的代表应用有 Outlook Web Access, 以及 GMail. 现代网页中几乎无ajax不欢. 前后端分离也正是建立在ajax异步通信的基础之上.\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3e浏览器为ajax做了什么\x3c\/h3\x3e\n\x3cp\x3e现代浏览器中, 虽然几乎全部支持ajax, 但它们的技术方案却分为两种:\x3c\/p\x3e\n\x3cp\x3e① 标准浏览器通过 \x3ccode\x3eXMLHttpRequest\x3c\/code\x3e 对象实现了ajax的功能. 只需要通过一行语句便可创建一个用于发送ajax请求的对象.\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var xhr = new XMLHttpRequest();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e xhr = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e XMLHttpRequest();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e② IE浏览器通过 \x3ccode\x3eXMLHttpRequest\x3c\/code\x3e 或者 \x3ccode\x3eActiveXObject\x3c\/code\x3e 对象同样实现了ajax的功能.\x3c\/p\x3e\n\x3ch4\x3eMSXML\x3c\/h4\x3e\n\x3cp\x3e鉴于IE系列各种 \x22神级\x22 表现,  我们先来看看IE浏览器风骚的走位.\x3c\/p\x3e\n\x3cp\x3eIE下的使用环境略显复杂, IE7及更高版本浏览器可以直接使用BOM的 XMLHttpRequest 对象. MSDN传送门: \x3ca href=\x22https:\/\/blogs.msdn.microsoft.com\/ie\/2006\/01\/23\/native-xmlhttprequest-object\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eNative XMLHTTPRequest object\x3c\/a\x3e. IE6及更低版本浏览器只能使用 \x3ccode\x3eActiveXObject\x3c\/code\x3e 对象来创建 XMLHttpRequest 对象实例. 创建时需要指明一个类似\x22Microsoft.XMLHTTP\x22这样的ProgID. 而实际呢, windows系统环境下, 以下ProgID都应该可以创建XMLHTTP对象:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Microsoft.XMLHTTP\nMicrosoft.XMLHTTP.1.0\nMsxml2.ServerXMLHTTP\nMsxml2.ServerXMLHTTP.3.0\nMsxml2.ServerXMLHTTP.4.0\nMsxml2.ServerXMLHTTP.5.0\nMsxml2.ServerXMLHTTP.6.0\nMsxml2.XMLHTTP\nMsxml2.XMLHTTP.3.0\nMsxml2.XMLHTTP.4.0\nMsxml2.XMLHTTP.5.0\nMsxml2.XMLHTTP.6.0\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs css\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3eMicrosoft\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.XMLHTTP\x3c\/span\x3e\n\x3cspan class=\x22hljs-selector-tag\x22\x3eMicrosoft\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.XMLHTTP\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.1\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.0\x3c\/span\x3e\n\x3cspan class=\x22hljs-selector-tag\x22\x3eMsxml2\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.ServerXMLHTTP\x3c\/span\x3e\n\x3cspan class=\x22hljs-selector-tag\x22\x3eMsxml2\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.ServerXMLHTTP\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.3\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.0\x3c\/span\x3e\n\x3cspan class=\x22hljs-selector-tag\x22\x3eMsxml2\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.ServerXMLHTTP\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.4\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.0\x3c\/span\x3e\n\x3cspan class=\x22hljs-selector-tag\x22\x3eMsxml2\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.ServerXMLHTTP\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.5\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.0\x3c\/span\x3e\n\x3cspan class=\x22hljs-selector-tag\x22\x3eMsxml2\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.ServerXMLHTTP\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.6\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.0\x3c\/span\x3e\n\x3cspan class=\x22hljs-selector-tag\x22\x3eMsxml2\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.XMLHTTP\x3c\/span\x3e\n\x3cspan class=\x22hljs-selector-tag\x22\x3eMsxml2\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.XMLHTTP\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.3\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.0\x3c\/span\x3e\n\x3cspan class=\x22hljs-selector-tag\x22\x3eMsxml2\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.XMLHTTP\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.4\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.0\x3c\/span\x3e\n\x3cspan class=\x22hljs-selector-tag\x22\x3eMsxml2\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.XMLHTTP\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.5\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.0\x3c\/span\x3e\n\x3cspan class=\x22hljs-selector-tag\x22\x3eMsxml2\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.XMLHTTP\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.6\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.0\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e简言之, Microsoft.XMLHTTP 已经非常老了, 主要用于提供对历史遗留版本的支持, 不建议使用.对于 MSXML4, 它已被 MSXML6 替代; 而 MSXML5 又是专门针对office办公场景, 在没有安装 Microsoft Office 2003 及更高版本办公软件的情况下, MSXML5 未必可用. 相比之下, MSXML6 具有比 MSXML3 更稳定, 更高性能, 更安全的优势, 同时它也提供了一些 MSXML3 中没有的功能, 比如说 XSD schema. 唯一遗憾的是, MSXML6 只在 vista 系统及以上才是默认支持的; 而 MSXML3 在 Win2k SP4及以上系统就是可用的. 因此一般情况下, MSXML3 可以作为 MSXML6 的优雅降级方案, 我们通过指定 PorgID 为 Msxml2.XMLHTTP 即可自动映射到 Msxml2.XMLHTTP.3.0. 如下所示:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var xhr = new ActiveXObject(\x26quot;Msxml2.XMLHTTP\x26quot;);\/\/ 即MSXML3,等同于如下语句\nvar xhr = new ActiveXObject(\x26quot;MSXML2.XMLHTTP.3.0\x26quot;);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e xhr = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e ActiveXObject(\x3cspan class=\x22hljs-string\x22\x3e\x22Msxml2.XMLHTTP\x22\x3c\/span\x3e);\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 即MSXML3,等同于如下语句\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e xhr = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e ActiveXObject(\x3cspan class=\x22hljs-string\x22\x3e\x22MSXML2.XMLHTTP.3.0\x22\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eMSDN有篇文章专门讲解了各个版本的MSXML. 传送门: \x3ca href=\x22https:\/\/blogs.msdn.microsoft.com\/xmlteam\/2006\/10\/23\/using-the-right-version-of-msxml-in-internet-explorer\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eUsing the right version of MSXML in Internet Explorer\x3c\/a\x3e.\x3c\/p\x3e\n\x3cp\x3e亲测了 IE5, IE5.5, IE6, IE7, IE8, IE9, IE10, IE edge等浏览器, IE5及之后的浏览器均可以通过如下语句获取xhr对象:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var xhr = new ActiveXObject(\x26quot;Msxml2.XMLHTTP\x26quot;);\/\/ 即MSXML3\nvar xhr = new ActiveXObject(\x26quot;Microsoft.XMLHTTP\x26quot;);\/\/ 很老的api,虽然浏览器支持,功能可能不完善,故不建议使用\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e xhr = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e ActiveXObject(\x3cspan class=\x22hljs-string\x22\x3e\x22Msxml2.XMLHTTP\x22\x3c\/span\x3e);\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 即MSXML3\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e xhr = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e ActiveXObject(\x3cspan class=\x22hljs-string\x22\x3e\x22Microsoft.XMLHTTP\x22\x3c\/span\x3e);\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 很老的api,虽然浏览器支持,功能可能不完善,故不建议使用\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上, 思路已经很清晰了, 下面给出个全兼容的方法.\x3c\/p\x3e\n\x3ch4\x3e全平台兼容的XMLHttpRequest对象\x3c\/h4\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function getXHR(){\n  var xhr = null;\n  if(window.XMLHttpRequest) {\n    xhr = new XMLHttpRequest();\n  } else if (window.ActiveXObject) {\n    try {\n      xhr = new ActiveXObject(\x26quot;Msxml2.XMLHTTP\x26quot;);\n    } catch (e) {\n      try {\n        xhr = new ActiveXObject(\x26quot;Microsoft.XMLHTTP\x26quot;);\n      } catch (e) { \n        alert(\x26quot;您的浏览器暂不支持Ajax!\x26quot;);\n      }\n    }\n  }\n  return xhr;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3egetXHR\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e xhr = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.XMLHttpRequest) {\n    xhr = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e XMLHttpRequest();\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.ActiveXObject) {\n    \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n      xhr = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e ActiveXObject(\x3cspan class=\x22hljs-string\x22\x3e\x22Msxml2.XMLHTTP\x22\x3c\/span\x3e);\n    } \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e (e) {\n      \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n        xhr = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e ActiveXObject(\x3cspan class=\x22hljs-string\x22\x3e\x22Microsoft.XMLHTTP\x22\x3c\/span\x3e);\n      } \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e (e) { \n        alert(\x3cspan class=\x22hljs-string\x22\x3e\x22您的浏览器暂不支持Ajax!\x22\x3c\/span\x3e);\n      }\n    }\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e xhr;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3eajax有没有破坏js单线程机制\x3c\/h3\x3e\n\x3cp\x3e对于这个问题, 我们先看下浏览器线程机制. 一般情况下, 浏览器有如下四种线程:\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eGUI渲染线程\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ejavascript引擎线程\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e浏览器事件触发线程\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eHTTP请求线程\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e那么这么多线程, 它们究竟是怎么同js引擎线程交互的呢?\x3c\/p\x3e\n\x3cp\x3e通常, 它们的线程间交互以事件的方式发生, 通过事件回调的方式予以通知. 而事件回调, 又是以先进先出的方式添加到\x3ccode\x3e任务队列\x3c\/code\x3e 的末尾 , 等到js引擎空闲时, \x3ccode\x3e任务队列\x3c\/code\x3e 中排队的任务将会依次被执行. 这些事件回调包括 setTimeout, setInterval, click, ajax异步请求等回调.\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e浏览器中, js引擎线程会循环从 \x3ccode\x3e任务队列\x3c\/code\x3e 中读取事件并且执行, 这种运行机制称作 \x3ccode\x3eEvent Loop\x3c\/code\x3e (事件循环).\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e对于一个ajax请求, js引擎首先生成 \x3ccode\x3eXMLHttpRequest\x3c\/code\x3e 实例对象, open过后再调用send方法. 至此, 所有的语句都是同步执行. 但从send方法内部开始, 浏览器为将要发生的网络请求创建了新的http请求线程, 这个线程独立于js引擎线程, 于是网络请求异步被发送出去了. 另一方面, js引擎并不会等待 ajax 发起的http请求收到结果, 而是直接顺序往下执行.\x3c\/p\x3e\n\x3cp\x3e当ajax请求被服务器响应并且收到response后, 浏览器事件触发线程捕获到了ajax的回调事件 \x3ccode\x3eonreadystatechange\x3c\/code\x3e (当然也可能触发onload, 或者 onerror等等) . 该回调事件并没有被立即执行, 而是被添加到 \x3ccode\x3e任务队列\x3c\/code\x3e 的末尾. 直到js引擎空闲了, \x3ccode\x3e任务队列\x3c\/code\x3e 的任务才被捞出来, 按照添加顺序, 挨个执行, 当然也包括刚刚append到队列末尾的 \x3ccode\x3eonreadystatechange\x3c\/code\x3e 事件.\x3c\/p\x3e\n\x3cp\x3e在 \x3ccode\x3eonreadystatechange\x3c\/code\x3e 事件内部, 有可能对dom进行操作. 此时浏览器便会挂起js引擎线程, 转而执行GUI渲染线程, 进行UI重绘(repaint)或者回流(reflow). 当js引擎重新执行时, GUI渲染线程又会被挂起, GUI更新将被保存起来, 等到js引擎空闲时立即被执行.\x3c\/p\x3e\n\x3cp\x3e以上整个ajax请求过程中, 有涉及到浏览器的4种线程. 其中除了 \x3ccode\x3eGUI渲染线程\x3c\/code\x3e 和 \x3ccode\x3ejs引擎线程\x3c\/code\x3e 是互斥的. 其他线程相互之间, 都是可以并行执行的. 通过这样的一种方式, ajax并没有破坏js的单线程机制.\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3eajax与setTimeout排队问题\x3c\/h3\x3e\n\x3cp\x3e通常, ajax 和 setTimeout 的事件回调都被同等的对待, 按照顺序自动的被添加到 \x3ccode\x3e任务队列\x3c\/code\x3e 的末尾, 等待js引擎空闲时执行. 但请注意, 并非xhr的所有回调执行都滞后于setTImeout的回调. 请看如下代码:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function ajax(url, method){\n  var xhr = getXHR();\n  xhr.onreadystatechange = function(){\n      console.log(\x27xhr.readyState:\x27 \x2b this.readyState);\n  }\n  xhr.onloadstart = function(){\n      console.log(\x27onloadStart\x27);\n  }\n  xhr.onload = function(){\n      console.log(\x27onload\x27);\n  }\n  xhr.open(method, url, true);\n  xhr.setRequestHeader(\x27Cache-Control\x27,3600);\n  xhr.send();\n}\nvar timer = setTimeout(function(){\n  console.log(\x27setTimeout\x27);\n},0);\najax(\x27http:\/\/louiszhai.github.io\/docImages\/ajax01.png\x27,\x27GET\x27);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eajax\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eurl, method\x3c\/span\x3e)\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e xhr = getXHR();\n  xhr.onreadystatechange = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n      \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27xhr.readyState:\x27\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.readyState);\n  }\n  xhr.onloadstart = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n      \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27onloadStart\x27\x3c\/span\x3e);\n  }\n  xhr.onload = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n      \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27onload\x27\x3c\/span\x3e);\n  }\n  xhr.open(method, url, \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e);\n  xhr.setRequestHeader(\x3cspan class=\x22hljs-string\x22\x3e\x27Cache-Control\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e3600\x3c\/span\x3e);\n  xhr.send();\n}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e timer = setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27setTimeout\x27\x3c\/span\x3e);\n},\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\najax(\x3cspan class=\x22hljs-string\x22\x3e\x27http:\/\/louiszhai.github.io\/docImages\/ajax01.png\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27GET\x27\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上述代码执行结果如下图:\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000008697451?w=791\x26amp;h=194\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000008697451?w=791\x26amp;h=194\x22 alt=\x22ajax \x26amp; setTimeout\x22 title=\x22ajax \x26amp; setTimeout\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e由于ajax异步, setTimeout回调本应该最先被执行, 然而实际上, 一次ajax请求, 并非所有的部分都是异步的, 至少\x22readyState==1\x22的 \x3ccode\x3eonreadystatechange\x3c\/code\x3e 回调以及 \x3ccode\x3eonloadstart\x3c\/code\x3e 回调就是同步执行的. 因此它们的输出排在最前面.\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3eXMLHttpRequest 属性解读\x3c\/h3\x3e\n\x3cp\x3e首先在Chrome console下创建一个 XMLHttpRequest 实例对象xhr. 如下所示:\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000008697452?w=800\x26amp;h=364\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000008697452?w=800\x26amp;h=364\x22 alt=\x22XMLHttpRequest\x22 title=\x22XMLHttpRequest\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch4\x3einherit\x3c\/h4\x3e\n\x3cp\x3e试运行以下代码.\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var xhr = new XMLHttpRequest(),\n    i=0;\nfor(var key in xhr){\n    if(xhr.hasOwnProperty(key)){\n       i\x2b\x2b;\n   }\n}\nconsole.log(i);\/\/0\nconsole.log(XMLHttpRequest.prototype.hasOwnProperty(\x27timeout\x27));\/\/true\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e xhr = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e XMLHttpRequest(),\n    i=\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e key \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e xhr){\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(xhr.hasOwnProperty(key)){\n       i\x2b\x2b;\n   }\n}\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(i);\x3cspan class=\x22hljs-comment\x22\x3e\/\/0\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(XMLHttpRequest.prototype.hasOwnProperty(\x3cspan class=\x22hljs-string\x22\x3e\x27timeout\x27\x3c\/span\x3e));\x3cspan class=\x22hljs-comment\x22\x3e\/\/true\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可见,  XMLHttpRequest 实例对象没有自有属性. 实际上, 它的所有属性均来自于 \x3ccode\x3eXMLHttpRequest.prototype\x3c\/code\x3e .\x3c\/p\x3e\n\x3cp\x3e追根溯源, XMLHttpRequest 实例对象具有如下的继承关系. (下面以a\x26lt;\x26lt;b表示a继承b)\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3exhr\x3c\/code\x3e \x26lt;\x26lt; \x3ccode\x3eXMLHttpRequest.prototype\x3c\/code\x3e \x26lt;\x26lt; \x3ccode\x3eXMLHttpRequestEventTarget.prototype\x3c\/code\x3e \x26lt;\x26lt; \x3ccode\x3eEventTarget.prototype\x3c\/code\x3e \x26lt;\x26lt; \x3ccode\x3eObject.prototype\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e由上, xhr也具有Object等原型中的所有方法. 如toString方法.\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22xhr.toString();\/\/\x26quot;[object XMLHttpRequest]\x26quot;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3exhr.toString();\x3cspan class=\x22hljs-comment\x22\x3e\/\/\x22[object XMLHttpRequest]\x22\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e通常, 一个xhr实例对象拥有10个普通属性\x2b9个方法.\x3c\/p\x3e\n\x3ch4\x3ereadyState\x3c\/h4\x3e\n\x3cp\x3e只读属性, readyState属性记录了ajax调用过程中所有可能的状态. 它的取值简单明了, 如下:\x3c\/p\x3e\n\x3ctable\x3e\n\x3cthead\x3e\x3ctr\x3e\n\x3cth\x3ereadyState\x3c\/th\x3e\n\x3cth\x3e对应常量\x3c\/th\x3e\n\x3cth\x3e描述\x3c\/th\x3e\n\x3c\/tr\x3e\x3c\/thead\x3e\n\x3ctbody\x3e\n\x3ctr\x3e\n\x3ctd\x3e0 (未初始化)\x3c\/td\x3e\n\x3ctd\x3exhr.UNSENT\x3c\/td\x3e\n\x3ctd\x3e请求已建立, 但未初始化(此时未调用open方法)\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e1 (初始化)\x3c\/td\x3e\n\x3ctd\x3exhr.OPENED\x3c\/td\x3e\n\x3ctd\x3e请求已建立, 但未发送 (已调用open方法, 但未调用send方法)\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e2 (发送数据)\x3c\/td\x3e\n\x3ctd\x3exhr.HEADERS_RECEIVED\x3c\/td\x3e\n\x3ctd\x3e请求已发送 (send方法已调用, 已收到响应头)\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e3 (数据传送中)\x3c\/td\x3e\n\x3ctd\x3exhr.LOADING\x3c\/td\x3e\n\x3ctd\x3e请求处理中, 因响应内容不全, 这时通过responseBody和responseText获取可能会出现错误\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e4 (完成)\x3c\/td\x3e\n\x3ctd\x3exhr.DONE\x3c\/td\x3e\n\x3ctd\x3e数据接收完毕, 此时可以通过通过responseBody和responseText获取完整的响应数据\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3c\/tbody\x3e\n\x3c\/table\x3e\n\x3cp\x3e注意, readyState 是一个只读属性, 想要改变它的值是不可行的.\x3c\/p\x3e\n\x3ch4\x3eonreadystatechange\x3c\/h4\x3e\n\x3cp\x3eonreadystatechange事件回调方法在readystate状态改变时触发, 在一个收到响应的ajax请求周期中, onreadystatechange 方法会被触发4次. 因此可以在 onreadystatechange 方法中绑定一些事件回调, 比如:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22xhr.onreadystatechange = function(e){\n  if(xhr.readystate==4){\n    var s = xhr.status;\n    if((s \x3e= 200 \x26amp;\x26amp; s \x3c 300) || s == 304){\n      var resp = xhr.responseText;\n      \/\/TODO ...\n    }\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3exhr.onreadystatechange = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ee\x3c\/span\x3e)\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(xhr.readystate==\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e){\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e s = xhr.status;\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e((s \x26gt;= \x3cspan class=\x22hljs-number\x22\x3e200\x3c\/span\x3e \x26amp;\x26amp; s \x26lt; \x3cspan class=\x22hljs-number\x22\x3e300\x3c\/span\x3e) || s == \x3cspan class=\x22hljs-number\x22\x3e304\x3c\/span\x3e){\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e resp = xhr.responseText;\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/TODO ...\x3c\/span\x3e\n    }\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e注意: onreadystatechange回调中默认会传入Event实例, 如下:\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000008697453?w=300\x26amp;h=264\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000008697453?w=300\x26amp;h=264\x22 alt=\x22Event\x22 title=\x22Event\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch4\x3estatus\x3c\/h4\x3e\n\x3cp\x3e只读属性, status表示http请求的状态, 初始值为0. 如果服务器没有显式地指定状态码, 那么status将被设置为默认值, 即200.\x3c\/p\x3e\n\x3ch4\x3estatusText\x3c\/h4\x3e\n\x3cp\x3e只读属性, statusText表示服务器的响应状态信息, 它是一个 UTF-16 的字符串, 请求成功且status==20X时, 返回大写的 \x3ccode\x3eOK\x3c\/code\x3e . 请求失败时返回空字符串. 其他情况下返回相应的状态描述. 比如: 301的 \x3ccode\x3eMoved Permanently\x3c\/code\x3e , 302的 \x3ccode\x3eFound\x3c\/code\x3e , 303的 \x3ccode\x3eSee Other\x3c\/code\x3e , 307 的 \x3ccode\x3eTemporary Redirect\x3c\/code\x3e , 400的 \x3ccode\x3eBad Request\x3c\/code\x3e , 401的 \x3ccode\x3eUnauthorized\x3c\/code\x3e 等等.\x3c\/p\x3e\n\x3ch4\x3eonloadstart\x3c\/h4\x3e\n\x3cp\x3eonloadstart事件回调方法在ajax请求发送之前触发, 触发时机在 \x3ccode\x3ereadyState==1\x3c\/code\x3e 状态之后, \x3ccode\x3ereadyState==2\x3c\/code\x3e 状态之前.\x3c\/p\x3e\n\x3cp\x3eonloadstart方法中默认将传入一个ProgressEvent事件进度对象. 如下:\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000008697454?w=345\x26amp;h=372\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000008697454?w=345\x26amp;h=372\x22 alt=\x22ProgressEvent\x22 title=\x22ProgressEvent\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3eProgressEvent对象具有三个重要的Read only属性.\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3elengthComputable 表示长度是否可计算, 它是一个布尔值, 初始值为false.\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eloaded 表示已加载资源的大小, 如果使用http下载资源, 它仅仅表示已下载内容的大小, 而不包括http headers等. 它是一个无符号长整型, 初始值为0.\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3etotal 表示资源总大小, 如果使用http下载资源, 它仅仅表示内容的总大小, 而不包括http headers等, 它同样是一个无符号长整型, 初始值为0.\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch4\x3eonprogress\x3c\/h4\x3e\n\x3cp\x3eonprogress事件回调方法在 \x3ccode\x3ereadyState==3\x3c\/code\x3e 状态时开始触发, 默认传入 ProgressEvent 对象, 可通过 \x3ccode\x3ee.loaded\/e.total\x3c\/code\x3e 来计算加载资源的进度, 该方法用于获取资源的下载进度.\x3c\/p\x3e\n\x3cp\x3e注意: 该方法适用于 IE10\x2b 及其他现代浏览器.\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22xhr.onprogress = function(e){\n  console.log(\x27progress:\x27, e.loaded\/e.total);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3exhr.onprogress = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ee\x3c\/span\x3e)\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27progress:\x27\x3c\/span\x3e, e.loaded\/e.total);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3eonload\x3c\/h4\x3e\n\x3cp\x3eonload事件回调方法在ajax请求成功后触发, 触发时机在 \x3ccode\x3ereadyState==4\x3c\/code\x3e 状态之后.\x3c\/p\x3e\n\x3cp\x3e想要捕捉到一个ajax异步请求的成功状态, 并且执行回调, 一般下面的语句就足够了:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22xhr.onload = function(){\n  var s = xhr.status;\n  if((s \x3e= 200 \x26amp;\x26amp; s \x3c 300) || s == 304){\n    var resp = xhr.responseText;\n    \/\/TODO ...\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3exhr.onload = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e s = xhr.status;\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e((s \x26gt;= \x3cspan class=\x22hljs-number\x22\x3e200\x3c\/span\x3e \x26amp;\x26amp; s \x26lt; \x3cspan class=\x22hljs-number\x22\x3e300\x3c\/span\x3e) || s == \x3cspan class=\x22hljs-number\x22\x3e304\x3c\/span\x3e){\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e resp = xhr.responseText;\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/TODO ...\x3c\/span\x3e\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3eonloadend\x3c\/h4\x3e\n\x3cp\x3eonloadend事件回调方法在ajax请求完成后触发, 触发时机在 \x3ccode\x3ereadyState==4\x3c\/code\x3e 状态之后(收到响应时) 或者  \x3ccode\x3ereadyState==2\x3c\/code\x3e 状态之后(未收到响应时).\x3c\/p\x3e\n\x3cp\x3eonloadend方法中默认将传入一个ProgressEvent事件进度对象.\x3c\/p\x3e\n\x3ch4\x3etimeout\x3c\/h4\x3e\n\x3cp\x3etimeout属性用于指定ajax的超时时长. 通过它可以灵活地控制ajax请求时间的上限. timeout的值满足如下规则:\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e通常设置为0时不生效.\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e设置为字符串时, 如果字符串中全部为数字, 它会自动将字符串转化为数字, 反之该设置不生效.\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e设置为对象时, 如果该对象能够转化为数字, 那么将设置为转化后的数字.\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22xhr.timeout = 0; \/\/不生效\nxhr.timeout = \x27123\x27; \/\/生效, 值为123\nxhr.timeout = \x27123s\x27; \/\/不生效\nxhr.timeout = [\x27123\x27]; \/\/生效, 值为123\nxhr.timeout = {a:123}; \/\/不生效\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3exhr.timeout = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/不生效\x3c\/span\x3e\nxhr.timeout = \x3cspan class=\x22hljs-string\x22\x3e\x27123\x27\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/生效, 值为123\x3c\/span\x3e\nxhr.timeout = \x3cspan class=\x22hljs-string\x22\x3e\x27123s\x27\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/不生效\x3c\/span\x3e\nxhr.timeout = [\x3cspan class=\x22hljs-string\x22\x3e\x27123\x27\x3c\/span\x3e]; \x3cspan class=\x22hljs-comment\x22\x3e\/\/生效, 值为123\x3c\/span\x3e\nxhr.timeout = {\x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e:\x3cspan class=\x22hljs-number\x22\x3e123\x3c\/span\x3e}; \x3cspan class=\x22hljs-comment\x22\x3e\/\/不生效\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3eontimeout\x3c\/h4\x3e\n\x3cp\x3eontimeout方法在ajax请求超时时触发, 通过它可以在ajax请求超时时做一些后续处理.\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22xhr.ontimeout = function(e) {\n  console.error(\x26quot;请求超时!!!\x26quot;)\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3exhr.ontimeout = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ee\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.error(\x3cspan class=\x22hljs-string\x22\x3e\x22请求超时!!!\x22\x3c\/span\x3e)\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3eresponse responseText\x3c\/h4\x3e\n\x3cp\x3e均为只读属性, response表示服务器的响应内容, 相应的, responseText表示服务器响应内容的文本形式.\x3c\/p\x3e\n\x3ch4\x3eresponseXML\x3c\/h4\x3e\n\x3cp\x3e只读属性, responseXML表示xml形式的响应数据, 缺省为null, 若数据不是有效的xml, 则会报错.\x3c\/p\x3e\n\x3ch4\x3eresponseType\x3c\/h4\x3e\n\x3cp\x3eresponseType表示响应的类型, 缺省为空字符串, 可取 \x3ccode\x3e\x22arraybuffer\x22\x3c\/code\x3e , \x3ccode\x3e\x22blob\x22\x3c\/code\x3e , \x3ccode\x3e\x22document\x22\x3c\/code\x3e , \x3ccode\x3e\x22json\x22\x3c\/code\x3e , and \x3ccode\x3e\x22text\x22\x3c\/code\x3e 共五种类型.\x3c\/p\x3e\n\x3ch4\x3eresponseURL\x3c\/h4\x3e\n\x3cp\x3eresponseURL返回ajax请求最终的URL, 如果请求中存在重定向, 那么responseURL表示重定向之后的URL.\x3c\/p\x3e\n\x3ch4\x3ewithCredentials\x3c\/h4\x3e\n\x3cp\x3ewithCredentials是一个布尔值, 默认为false, 表示跨域请求中不发送cookies等信息. 当它设置为true时, \x3ccode\x3ecookies\x3c\/code\x3e , \x3ccode\x3eauthorization headers\x3c\/code\x3e 或者\x3ccode\x3e TLS客户端证书\x3c\/code\x3e 都可以正常发送和接收. 显然它的值对同域请求没有影响.\x3c\/p\x3e\n\x3cp\x3e注意: 该属性适用于 IE10\x2b, opera12\x2b及其他现代浏览器.\x3c\/p\x3e\n\x3ch4\x3eabort\x3c\/h4\x3e\n\x3cp\x3eabort方法用于取消ajax请求, 取消后, readyState 状态将被设置为\x26nbsp;\x3ccode\x3e0\x3c\/code\x3e\x26nbsp;(\x3ccode\x3eUNSENT\x3c\/code\x3e). 如下, 调用abort 方法后, 请求将被取消.\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000008697455?w=702\x26amp;h=23\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000008697455?w=702\x26amp;h=23\x22 alt=\x22Event\x22 title=\x22Event\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch4\x3egetResponseHeader\x3c\/h4\x3e\n\x3cp\x3egetResponseHeader方法用于获取ajax响应头中指定name的值. 如果response headers中存在相同的name, 那么它们的值将自动以字符串的形式连接在一起.\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22console.log(xhr.getResponseHeader(\x27Content-Type\x27));\/\/\x26quot;text\/html\x26quot;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(xhr.getResponseHeader(\x3cspan class=\x22hljs-string\x22\x3e\x27Content-Type\x27\x3c\/span\x3e));\x3cspan class=\x22hljs-comment\x22\x3e\/\/\x22text\/html\x22\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3egetAllResponseHeaders\x3c\/h4\x3e\n\x3cp\x3egetAllResponseHeaders方法用于获取所有安全的ajax响应头, 响应头以字符串形式返回. 每个HTTP报头名称和值用冒号分隔, 如key:value, 并以rn结束.\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22xhr.onreadystatechange = function() {\n  if(this.readyState == this.HEADERS_RECEIVED) {\n    console.log(this.getAllResponseHeaders());\n  }\n}\n\/\/Content-Type: text\/html\x26quot;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3exhr.onreadystatechange = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.readyState == \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.HEADERS_RECEIVED) {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getAllResponseHeaders());\n  }\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/Content-Type: text\/html\x22\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上,  \x3ccode\x3ereadyState === 2\x3c\/code\x3e 状态时, 就意味着响应头已接受完整. 此时便可以打印出完整的 response headers.\x3c\/p\x3e\n\x3ch4\x3esetRequestHeader\x3c\/h4\x3e\n\x3cp\x3e既然可以获取响应头, 那么自然也可以设置请求头, setRequestHeader就是干这个的. 如下:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/指定请求的type为json格式\nxhr.setRequestHeader(\x26quot;Content-type\x26quot;, \x26quot;application\/json\x26quot;);\n\/\/除此之外, 还可以设置其他的请求头\nxhr.setRequestHeader(\x27x-requested-with\x27, \x27123456\x27);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/指定请求的type为json格式\x3c\/span\x3e\nxhr.setRequestHeader(\x3cspan class=\x22hljs-string\x22\x3e\x22Content-type\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22application\/json\x22\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/除此之外, 还可以设置其他的请求头\x3c\/span\x3e\nxhr.setRequestHeader(\x3cspan class=\x22hljs-string\x22\x3e\x27x-requested-with\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27123456\x27\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3eonerror\x3c\/h4\x3e\n\x3cp\x3eonerror方法用于在ajax请求出错后执行. 通常只在网络出现问题时或者ERR_CONNECTION_RESET时触发(如果请求返回的是407状态码, chrome下也会触发onerror).\x3c\/p\x3e\n\x3ch4\x3eupload\x3c\/h4\x3e\n\x3cp\x3eupload属性默认返回一个 \x3ccode\x3eXMLHttpRequestUpload\x3c\/code\x3e 对象, 用于上传资源. 该对象具有如下方法:\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eonloadstart\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eonprogress\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eonabort\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eonerror\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eonload\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eontimeout\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eonloadend\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e上述方法功能同 xhr 对象中同名方法一致. 其中, onprogress 事件回调方法可用于跟踪资源上传的进度.\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22xhr.upload.onprogress = function(e){\n  var percent = 100 * e.loaded \/ e.total |0;\n  console.log(\x27upload: \x27 \x2b precent \x2b \x27%\x27);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3exhr.upload.onprogress = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ee\x3c\/span\x3e)\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e percent = \x3cspan class=\x22hljs-number\x22\x3e100\x3c\/span\x3e * e.loaded \/ e.total |\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27upload: \x27\x3c\/span\x3e \x2b precent \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27%\x27\x3c\/span\x3e);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3eoverrideMimeType\x3c\/h4\x3e\n\x3cp\x3eoverrideMimeType方法用于强制指定response 的 MIME 类型, 即强制修改response的 \x3ccode\x3eContent-Type\x3c\/code\x3e . 如下, 服务器返回的response的 MIME 类型为 \x3ccode\x3etext\/plain\x3c\/code\x3e .\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000008697456?w=421\x26amp;h=205\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000008697456?w=421\x26amp;h=205\x22 alt=\x22response headers\x22 title=\x22response headers\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22xhr.getResponseHeader(\x27Content-Type\x27);\/\/\x26quot;text\/plain\x26quot;\nxhr.responseXML;\/\/null\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3exhr.getResponseHeader(\x3cspan class=\x22hljs-string\x22\x3e\x27Content-Type\x27\x3c\/span\x3e);\x3cspan class=\x22hljs-comment\x22\x3e\/\/\x22text\/plain\x22\x3c\/span\x3e\nxhr.responseXML;\x3cspan class=\x22hljs-comment\x22\x3e\/\/null\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e通过overrideMimeType方法将response的MIME类型设置为 \x3ccode\x3etext\/xml;charset=utf-8\x3c\/code\x3e , 如下所示:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22xhr.overrideMimeType(\x26quot;text\/xml; charset = utf-8\x26quot;);\nxhr.send();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3exhr.overrideMimeType(\x3cspan class=\x22hljs-string\x22\x3e\x22text\/xml; charset = utf-8\x22\x3c\/span\x3e);\nxhr.send();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e此时虽然 response headers 如上图, 没有变化, 但 \x3ccode\x3eContent-Type\x3c\/code\x3e 已替换为新值.\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22xhr.getResponseHeader(\x27Content-Type\x27);\/\/\x26quot;text\/xml; charset = utf-8\x26quot;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3exhr.getResponseHeader(\x3cspan class=\x22hljs-string\x22\x3e\x27Content-Type\x27\x3c\/span\x3e);\x3cspan class=\x22hljs-comment\x22\x3e\/\/\x22text\/xml; charset = utf-8\x22\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e此时, \x3ccode\x3exhr.responseXML\x3c\/code\x3e 也将返回DOM对象, 如下图.\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000008697457?w=267\x26amp;h=173\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000008697457?w=267\x26amp;h=173\x22 alt=\x22response headers\x22 title=\x22response headers\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3eXHR一级\x3c\/h3\x3e\n\x3cp\x3eXHR1 即 XMLHttpRequest Level 1. XHR1时, xhr对象具有如下缺点:\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e仅支持文本数据传输, 无法传输二进制数据.\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e传输数据时, 没有进度信息提示, 只能提示是否完成.\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e受浏览器 \x3ccode\x3e同源策略\x3c\/code\x3e 限制, 只能请求同域资源.\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e没有超时机制, 不方便掌控ajax请求节奏.\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3eXHR二级\x3c\/h3\x3e\n\x3cp\x3eXHR2 即 XMLHttpRequest Level 2. XHR2针对XHR1的上述缺点做了如下改进:\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e支持二进制数据, 可以上传文件, 可以使用FormData对象管理表单.\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e提供进度提示, 可通过 \x3ccode\x3exhr.upload.onprogress\x3c\/code\x3e 事件回调方法获取传输进度.\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e依然受 \x3ccode\x3e同源策略\x3c\/code\x3e 限制, 这个安全机制不会变. XHR2新提供 \x3ccode\x3eAccess-Control-Allow-Origin\x3c\/code\x3e 等headers, 设置为 \x3ccode\x3e*\x3c\/code\x3e 时表示允许任何域名请求, 从而实现跨域CORS访问(有关CORS详细介绍请耐心往下读).\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e可以设置timeout 及 ontimeout, 方便设置超时时长和超时后续处理.\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e这里就H5新增的FormData对象举个例.\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/可直接创建FormData实例\nvar data = new FormData();\ndata.append(\x26quot;name\x26quot;, \x26quot;louis\x26quot;);\nxhr.send(data);\n\/\/还可以通过传入表单DOM对象来创建FormData实例\nvar form = document.getElementById(\x27form\x27);\nvar data = new FormData(form);\ndata.append(\x26quot;password\x26quot;, \x26quot;123456\x26quot;);\nxhr.send(data);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/可直接创建FormData实例\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e data = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e FormData();\ndata.append(\x3cspan class=\x22hljs-string\x22\x3e\x22name\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22louis\x22\x3c\/span\x3e);\nxhr.send(data);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/还可以通过传入表单DOM对象来创建FormData实例\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e form = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.getElementById(\x3cspan class=\x22hljs-string\x22\x3e\x27form\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e data = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e FormData(form);\ndata.append(\x3cspan class=\x22hljs-string\x22\x3e\x22password\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22123456\x22\x3c\/span\x3e);\nxhr.send(data);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e目前, 主流浏览器基本上都支持XHR2, 除了IE系列需要IE10及更高版本. 因此IE10以下是不支持XHR2的.\x3c\/p\x3e\n\x3cp\x3e那么问题来了, IE7, 8,9的用户怎么办? 很遗憾, 这些用户是比较尴尬的. 对于IE8,9而言, 只有一个阉割版的 \x3ccode\x3eXDomainRequest\x3c\/code\x3e 可用,IE7则没有. 估计IE7用户只能哭晕在厕所了.\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3eXDomainRequest\x3c\/h3\x3e\n\x3cp\x3eXDomainRequest 对象是IE8,9折腾出来的, 用于支持CORS请求非成熟的解决方案. 以至于IE10中直接移除了它, 并重新回到了 XMLHttpRequest 的怀抱.\x3c\/p\x3e\n\x3cp\x3eXDomainRequest 仅可用于发送 \x3ccode\x3eGET \x3c\/code\x3e和 \x3ccode\x3ePOST\x3c\/code\x3e 请求. 如下即创建过程.\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var xdr = new XDomainRequest();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e xdr = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e XDomainRequest();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3exdr具有如下属性:\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3etimeout\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eresponseText\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e如下方法:\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eopen: 只能接收Method,和url两个参数. 只能发送异步请求.\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3esend\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eabort\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e如下事件回调:\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eonprogress\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eontimeout\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eonerror\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eonload\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e除了缺少一些方法外, XDomainRequest 基本上就和 XMLHttpRequest 的使用方式保持一致. \x3c\/p\x3e\n\x3cp\x3e必须要明确的是:\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eXDomainRequest 不支持跨域传输cookie.\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e只能设置请求头的Content-Type字段, 且不能访问响应头信息.\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e$.ajax\x3c\/h3\x3e\n\x3cp\x3e$.ajax是jquery对原生ajax的一次封装. 通过封装ajax, jquery抹平了不同版本浏览器异步http的差异性, 取而代之的是高度统一的api. jquery作为js类库时代的先驱, 对前端发展有着深远的影响. 了解并熟悉其ajax方法, 不可谓不重要.\x3c\/p\x3e\n\x3ch4\x3e参数列表\x3c\/h4\x3e\n\x3cp\x3e$.ajax() 只有一个参数, 该参数为key-value设置对象. 实际上, jq发送的所有ajax请求, 都是通过调用该ajax方法实现的. 它的详细参数如下表:\x3c\/p\x3e\n\x3cdiv class=\x22table-wrap\x22\x3e\x3ctable\x3e\n\x3cthead\x3e\x3ctr\x3e\n\x3cth align=\x22center\x22\x3e序号\x3c\/th\x3e\n\x3cth align=\x22center\x22\x3e参数\x3c\/th\x3e\n\x3cth align=\x22center\x22\x3e类型\x3c\/th\x3e\n\x3cth align=\x22left\x22\x3e描述\x3c\/th\x3e\n\x3c\/tr\x3e\x3c\/thead\x3e\n\x3ctbody\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e1\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cstrong\x3e\x3cem\x3eaccepts\x3c\/em\x3e\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cem\x3ePlainObject\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e用于通知服务器该请求需要接收何种类型的返回结果. 如有必要, 推荐在 \x3ccode\x3e$.ajaxSetup()\x3c\/code\x3e\x26nbsp;方法中设置一次.\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e2\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cstrong\x3e\x3cem\x3easync\x3c\/em\x3e\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cem\x3eBoolean\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e默认为true, 即异步.\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e3\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cstrong\x3e\x3cem\x3ebeforeSend\x3c\/em\x3e\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cem\x3eFunction\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e请求发送前的回调, 默认传入参数jqXHR和settings. 函数内显式返回false将取消本次请求.\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e4\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cstrong\x3e\x3cem\x3ecache\x3c\/em\x3e\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cem\x3eBoolean\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e请求是否开启缓存, 默认为true, 如不需要缓存请设置为false. 不过, dataType为\x22script\x22和\x22jsonp\x22时默认为false.\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e5\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cstrong\x3e\x3cem\x3ecomplete\x3c\/em\x3e\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cem\x3eFunction\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e请求完成后的回调(请求\x3ccode\x3esuccess\x3c\/code\x3e\x26nbsp;和\x26nbsp;\x3ccode\x3eerror\x3c\/code\x3e之后均调用), 默认传入参数jqXHR和textStatus(请求状态, 取值为 \x22success\x22,\x22notmodified\x22,\x22error\x22,\x22timeout\x22,\x22abort\x22,\x22parsererror\x22之一). 从jq1.5开始, complete可以设置为一个包含函数的数组. 如此每个函数将依次被调用.\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e6\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cstrong\x3e\x3cem\x3econtents\x3c\/em\x3e\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cem\x3ePlainObject\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e一个以\x22{字符串\/正则表达式}\x22配对的对象, 根据给定的内容类型, 解析请求的返回结果.\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e7\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cstrong\x3e\x3cem\x3econtentType\x3c\/em\x3e\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cem\x3eString\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e编码类型, 相对应于http请求头域的\x22Content-Type\x22字段. 默认值为\x22application\/x-www-form-urlencoded; charset=UTF-8\x22.\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e8\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cstrong\x3e\x3cem\x3econtext\x3c\/em\x3e\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cem\x3eObject\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e设置ajax回调函数的上下文. 默认上下文为ajax请求传入的参数设置对象. 如设置为document.body, 那么所有ajax回调函数中将以body为上下文.\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e9\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cstrong\x3e\x3cem\x3econverters\x3c\/em\x3e\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cem\x3ePlainObject\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e一个数据类型到数据类型转换器的对象. 默认为 \x3ccode\x3e{\x22* text\x22: window.String, \x22text html\x22: true, \x22text json\x22: jQuery.parseJSON, \x22text xml\x22: jQuery.parseXML}\x3c\/code\x3e . 如设置\x3ccode\x3econverters:{\x22json jsonp\x22: function(msg){\x22}}\x22\x3c\/code\x3e\n\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e10\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cstrong\x3e\x3cem\x3ecrossDomain\x3c\/em\x3e\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cem\x3eBoolean\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e默认同域请求为false, 跨域请求为true.\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e11\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cstrong\x3e\x3cem\x3edata\x3c\/em\x3e\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cem\x3eObject, Array\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e发送到服务器的数据, 默认data为键值对格式对象, 若data为数组则按照\x3ccode\x3etraditional\x3c\/code\x3e参数的值, 自动转化为一个同名的多值查询字符串. 如{a:1,b:2}将转换为\x22\x26amp;a=1\x26amp;b=2\x22.\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e12\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cstrong\x3e\x3cem\x3edataFilter\x3c\/em\x3e\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cem\x3eFunction\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e处理XMLHttpRequest原始响应数据的回调, 默认传入data和type参数, data是Ajax返回的原始数据, type是调用$.ajax时提供的dataType参数\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e13\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cstrong\x3e\x3cem\x3edataType\x3c\/em\x3e\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cem\x3eString\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e预期服务器返回的数据类型, 可设置为\x22xml\x22,\x22html\x22,\x22script\x22,\x22json\x22,\x22jsonp\x22,\x22text\x22之一, 其中设置为\x22xml\x22或\x22text\x22类型时, 数据不会经过处理.\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e14\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cstrong\x3e\x3cem\x3eerror\x3c\/em\x3e\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cem\x3eFunction\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e请求失败时的回调函数, 默认传入jqXHR(jq1.4以前为原生xhr对象),textStatus(请求状态,取值为null,\x22timeout\x22,\x22error\x22,\x22abort\x22 或 \x22parsererror\x22),errorString(错误内容), 当一个HTTP错误发生时, \x3ccode\x3eerrorThrown\x3c\/code\x3e\x26nbsp;接收HTTP状态的文本部分,比如\x22Not Found\x22等. 从jq1.5开始, error可以设置为一个包含函数的数组. 如此每个函数将依次被调用.注意: 跨域脚本和JSONP请求时error不被调用.\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e15\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cstrong\x3e\x3cem\x3eglobal\x3c\/em\x3e\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cem\x3eBoolean\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e表示是否触发全局ajax事件, 默认为true. 设为false将不再触发ajaxStart,ajaxStop,ajaxSend,ajaxError等. 跨站脚本和jsonp请求, 该值自动设置为false.\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e16\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cstrong\x3e\x3cem\x3eheaders\x3c\/em\x3e\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cem\x3ePlainObject\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e设置请求头, 格式为k-v键值对对象. 由于该设置会在beforeSend函数被调用之前生效, 因此可在beforeSend函数内覆盖该对象.\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e17\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cstrong\x3e\x3cem\x3eifModified\x3c\/em\x3e\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cem\x3eBoolean\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e只有上次请求响应改变时, 才允许请求成功. 它使用HTTP包的Last-Modified 头信息判断, 默认为false. 若设置为true, 且数据自从上次请求后没有更改过就会报错.\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e18\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cstrong\x3e\x3cem\x3eisLocal\x3c\/em\x3e\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cem\x3eBoolean\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e运行当前环境设置为\x22本地\x22,默认为false, 若设置为true, 将影响请求发送时的协议.\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e19\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cstrong\x3e\x3cem\x3ejsonp\x3c\/em\x3e\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cem\x3eString\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e显式指定jsonp请求中的回调函数的名称. 如jsonp:cb, jq会将cb代替callback, 以 \x22cb=?\x22传给服务器. 从jq1.5开始, 若设置jsonp:false, 那么需要明确设置jsonpCallback:\x22callbackName\x22.\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e20\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cstrong\x3e\x3cem\x3ejsonpCallback\x3c\/em\x3e\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cem\x3eString,Function\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e为jsonp请求指定一个回调函数名, 以取代jq自动生成的随机函数名. 从jq1.5开始, 可以将该属性设置为一个函数, 函数的返回值就是jsonpCallback的结果.\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e21\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cstrong\x3e\x3cem\x3emimeType\x3c\/em\x3e\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cem\x3eString\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e设置一个MIME类型, 以覆盖xhr的MIM类型(jq1.5新增)\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e22\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cstrong\x3e\x3cem\x3epassword\x3c\/em\x3e\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cem\x3eString\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e设置认证请求中的密码\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e23\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cstrong\x3e\x3cem\x3eprocessData\x3c\/em\x3e\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cem\x3eBoolean\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3ejq的ajax方法默认会将传入的data隐式转换为查询字符串(如\x22\x26amp;a=1\x26amp;b=2\x22), 以配合 默认内容类型 \x22application\/x-www-form-urlencoded\x22, 如果不希望转换请设置为false. angular中想要禁用默认转换, 需要重写transformRequest方法.\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e24\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cstrong\x3e\x3cem\x3escriptCharset\x3c\/em\x3e\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cem\x3eString\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e仅在\x22script\x22请求中使用(如跨域jsonp, dataType为\x22script\x22类型). 显式指定时, 请求中将在script标签上设置\x3ccode\x3echarset\x3c\/code\x3e属性, 可在发现本地和远程编码不一致时使用.\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e25\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cstrong\x3e\x3cem\x3estatusCode\x3c\/em\x3e\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cem\x3ePlainObject\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e一组http状态码和回调函数对应的键值对对象. 该对象以 {404:function(){\x22}}\x22 这种形式表示. 可用于根据不同的http状态码, 执行不同的回调.(jq1.5新增)\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e26\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cstrong\x3e\x3cem\x3etimeout\x3c\/em\x3e\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cem\x3eNumber\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e设置超时时间.\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e27\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cstrong\x3e\x3cem\x3etraditional\x3c\/em\x3e\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cem\x3eBoolean\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e是否按照默认方式序列化data对象, 默认值为false.\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e28\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cstrong\x3e\x3cem\x3etype\x3c\/em\x3e\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cem\x3eString\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e可以设置为8种http method之一, jq中不区分大小写.\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e29\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cstrong\x3e\x3cem\x3eurl\x3c\/em\x3e\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cem\x3eString\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e请求的uri地址.\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e30\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cstrong\x3e\x3cem\x3eusername\x3c\/em\x3e\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cem\x3eString\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e设置认证请求中的用户名\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e31\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cstrong\x3e\x3cem\x3exhr\x3c\/em\x3e\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cem\x3eFunction\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e在回调内创建并返回xhr对象\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e32\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cstrong\x3e\x3cem\x3exhrFields\x3c\/em\x3e\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cem\x3ePlainObject\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e键值对对象, 用于设置原生的xhr对象, 如可用来设置withCredentials:true(jq1.5.1新增)\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3c\/tbody\x3e\n\x3c\/table\x3e\x3c\/div\x3e\n\x3ch4\x3e支持promise\x3c\/h4\x3e\n\x3cp\x3e$.ajax() 方法返回jqXHR对象(jq1.5起), 如果使用的不是XMLHttpRequest对象时, 如jsonp请求, 返回的jqXHR对象将尽可能模拟原生的xhr. 从jq1.5起, 返回的jqXHR对象实现了promise接口, 具有如下新方法.\x3c\/p\x3e\n\x3ctable\x3e\n\x3cthead\x3e\x3ctr\x3e\n\x3cth align=\x22center\x22\x3e新方法\x3c\/th\x3e\n\x3cth align=\x22center\x22\x3e被替代的老方法(jq1.8起弃用)\x3c\/th\x3e\n\x3c\/tr\x3e\x3c\/thead\x3e\n\x3ctbody\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3edone(function(data, textStatus, jqXHR) {})\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cdel\x3esuccess\x3c\/del\x3e\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3efail(function(jqXHR, textStatus, errorThrown) {})\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cdel\x3eerror\x3c\/del\x3e\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3ealways(function(data or jqXHR, textStatus, jqXHR or errorThrown) {})\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cdel\x3ecomplete\x3c\/del\x3e\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3c\/tbody\x3e\n\x3c\/table\x3e\n\x3cp\x3e从jq1.6开始, done, fail, always按照FIFO队列可以分配多个回调.\x3c\/p\x3e\n\x3ch4\x3e使用转换器\x3c\/h4\x3e\n\x3cp\x3e$.ajax() 的转换器可以将支持的数据类型映射到其它数据类型. 如果需要将自定义数据类型映射到已知的类型. 需要使用 \x3ccode\x3econtents\x3c\/code\x3e 选项在响应的 \x22Content-Type\x22 和实际数据类型之间添加一个转换函数.\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22$.ajaxSetup({\n  contents: {\n    myContentType: \/myContentType\/\n  },\n  converters: {\n    \x26quot;myContentType json\x26quot;: function(data) {\n      \/\/TODO something\n      return newData;\n    }\n  }\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e$.ajaxSetup({\n  \x3cspan class=\x22hljs-attr\x22\x3econtents\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-attr\x22\x3emyContentType\x3c\/span\x3e: \x3cspan class=\x22hljs-regexp\x22\x3e\/myContentType\/\x3c\/span\x3e\n  },\n  \x3cspan class=\x22hljs-attr\x22\x3econverters\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-string\x22\x3e\x22myContentType json\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/TODO something\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e newData;\n    }\n  }\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e转换一个支持的类型为自定义类型, 然后再返回. 如 text—\x26gt;myContentType—\x26gt;json.\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22$.ajaxSetup({\n  contents: {\n    myContentType: \/myContentType\/\n  },\n  converters: {\n    \x26quot;text myContentType\x26quot;: true,\n    \x26quot;myContentType json\x26quot;: function(data) {\n      \/\/TODO something\n      return newData;\n    }\n  }\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e$.ajaxSetup({\n  \x3cspan class=\x22hljs-attr\x22\x3econtents\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-attr\x22\x3emyContentType\x3c\/span\x3e: \x3cspan class=\x22hljs-regexp\x22\x3e\/myContentType\/\x3c\/span\x3e\n  },\n  \x3cspan class=\x22hljs-attr\x22\x3econverters\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-string\x22\x3e\x22text myContentType\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-string\x22\x3e\x22myContentType json\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/TODO something\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e newData;\n    }\n  }\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e事件触发顺序\x3c\/h4\x3e\n\x3cp\x3e$.ajax()方法触发的事件纷繁复杂, 有将近20个之多. 为了囊括最多的事件, 这里以一次成功的上传请求为例, 以下是它们的调用顺序(请求出现错误时的顺序, 请自行对应).\x3c\/p\x3e\n\x3ctable\x3e\n\x3cthead\x3e\x3ctr\x3e\n\x3cth align=\x22center\x22\x3e序号\x3c\/th\x3e\n\x3cth align=\x22center\x22\x3e事件名称\x3c\/th\x3e\n\x3cth align=\x22center\x22\x3e是否全局事件\x3c\/th\x3e\n\x3cth align=\x22center\x22\x3e是否能关闭\x3c\/th\x3e\n\x3cth align=\x22center\x22\x3e默认形参\x3c\/th\x3e\n\x3c\/tr\x3e\x3c\/thead\x3e\n\x3ctbody\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e1\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e$.ajaxPrefilter\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e✔️\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e❌\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3efunction(options, originalOptions, jqXHR){}\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e2\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e$(document).ajaxStar\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e✔️\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e✔️\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3efunction(){}(只在当前无激活ajax时触发)\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e3\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3ebeforeSend\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e❌\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e-\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3efunction(jqXHR, settings){}\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e4\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e$(document).ajaxSend\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e✔️\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e✔️\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3efunction(){}\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e5\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3exhr.onloadstart\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e-\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e-\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3eProgressEvent\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e6\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3exhr.upload.onloadstart\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e-\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e-\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3eProgressEvent\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e7\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3exhr.upload.onprogress\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e-\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e-\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3eProgressEvent\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e8\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3exhr.upload.onload\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e-\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e-\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3eProgressEvent\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e9\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3exhr.upload.onloadend\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e-\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e-\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3eProgressEvent\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e10\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3exhr.onprogress\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e-\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e-\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3eProgressEvent\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e11\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3exhr.onload\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e-\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e-\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3eProgressEvent\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e12\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\n\x3cdel\x3esuccess\x3c\/del\x3e(弃用)\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e❌\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e-\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3efunction(data, textStatus, jqXHR){}\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e13\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e$(document).ajaxSuccess\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e✔️\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e✔️\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3efunction(event, jqXHR, options){}\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e14\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\n\x3cdel\x3ecomplete\x3c\/del\x3e(弃用)\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e❌\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e-\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3efunction(jqXHR, textStatus){}\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e15\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e$(document).ajaxComplete\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e✔️\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e✔️\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3efunction(event, jqXHR, textStatus)\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e16\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e$(document).ajaxStop\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e✔️\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e✔️\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3efunction(){}\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e17\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3exhr.onloadend\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e-\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e-\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3eProgressEvent\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3c\/tbody\x3e\n\x3c\/table\x3e\n\x3cp\x3e从jq1.8起, 对于函数 \x3ccode\x3eajaxStart\x3c\/code\x3e, \x3ccode\x3eajaxSend\x3c\/code\x3e, \x3ccode\x3eajaxSuccess\x3c\/code\x3e, \x3ccode\x3eajaxComplete\x3c\/code\x3e, \x3ccode\x3eajaxStop\x3c\/code\x3e , 只能为\x3ccode\x3edocument\x3c\/code\x3e对象绑定事件处理函数, 为其他元素绑定的事件处理函数不会起作用.\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3eAxios\x3c\/h3\x3e\n\x3cp\x3e实际上, 如果你仅仅只是想要一个不错的http库, 相比于庞大臃肿的jquery, 短小精悍的Axios可能更加适合你. 原因如下:\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eAxios支持node, jquery并不支持.\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eAxios基于promise语法, jq3.0才开始全面支持.\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eAxios短小精悍, 更加适合http场景, jquery大而全, 加载较慢.\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3evue作者尤大放弃推荐vue-resource, 转向推荐Axios. 以下为尤大原话.\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cblockquote\x3e\x3cp\x3e\x22最近团队讨论了一下, Ajax 本身跟 Vue 并没有什么需要特别整合的地方, 使用 fetch polyfill 或是 axios、superagent 等等都可以起到同等的效果, vue-resource 提供的价值和其维护成本相比并不划算, 所以决定在不久以后取消对 vue-resource 的官方推荐.\x22\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3eAxios大小仅12k, 目前最新版本号为: \x3ca href=\x22https:\/\/www.npmjs.org\/package\/axios\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000008697458\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000008697458\x22 alt=\x22npm version\x22 title=\x22npm version\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e语法上Axios基本就和promise一样, 在then方法中处理回调, 在catch方法中处理异常. 如下:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22axios.get(\x26quot;https:\/\/api.github.com\/users\/louiszhai\x26quot;)\n  .then(function(response){\n    console.log(response);\n  })\n  .catch(function (error) {\n    console.log(error);\n  });\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3eaxios.get(\x3cspan class=\x22hljs-string\x22\x3e\x22https:\/\/api.github.com\/users\/louiszhai\x22\x3c\/span\x3e)\n  .then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eresponse\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(response);\n  })\n  .catch(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eerror\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(error);\n  });\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e除了get, 它还支持post, delete, head, put, patch, request请求. 具体使用攻略, 请戳这里: \x3ca href=\x22http:\/\/www.bootcdn.cn\/axios\/readme\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eaxios\x3c\/a\x3e .\x3c\/p\x3e\n\x3cp\x3e如需在网页上引入 Axios, 可以链接CDN \x3ca href=\x22http:\/\/www.bootcdn.cn\/axios\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eaxios | Bootstrap中文网开源项目免费 CDN 服务\x3c\/a\x3e 或者将其下载到本地.\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3eFetch\x3c\/h3\x3e\n\x3cp\x3e说到ajax, 就不得不提及fetch, 由于篇幅较长, fetch已从本文中独立出来, 请戳 \x3ca href=\x22http:\/\/louiszhai.github.io\/2016\/11\/02\/fetch\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eFetch进阶指南\x3c\/a\x3e .\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader11\x22\x3eajax跨域请求\x3c\/h3\x3e\n\x3ch4\x3e什么是CORS\x3c\/h4\x3e\n\x3cp\x3eCORS是一个W3C(World Wide Web)标准, 全称是跨域资源共享(Cross-origin resource sharing).它允许浏览器向跨域服务器, 发出异步http请求, 从而克服了ajax受同源策略的限制. 实际上, 浏览器不会拦截不合法的跨域请求, 而是拦截了他们的响应, 因此即使请求不合法, 很多时候, 服务器依然收到了请求.(Chrome和Firefox下https网站不允许发送http异步请求除外)\x3c\/p\x3e\n\x3cp\x3e通常, 一次跨域访问拥有如下流程:\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000008697459?w=600\x26amp;h=443\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000008697459?w=600\x26amp;h=443\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch4\x3e移动端CORS兼容性\x3c\/h4\x3e\n\x3cp\x3e当前几乎所有的桌面浏览器(Internet Explorer 8\x2b, Firefox 3.5\x2b, Safari 4\x2b和 Chrome 3\x2b)都可通过名为跨域资源共享的协议支持ajax跨域调用.\x3c\/p\x3e\n\x3cp\x3e那么移动端兼容性又如何呢? 请看下图:\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000008697460?w=563\x26amp;h=271\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000008697460?w=563\x26amp;h=271\x22 alt=\x22cors-mobile\x22 title=\x22cors-mobile\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e可见, CORS的技术在IOS Safari7.1及Android webview2.3中就早已支持, 即使低版本下webview的canvas在使用跨域的video或图片时会有问题, 也丝毫不影响CORS的在移动端的使用. 至此, 我们就可以放心大胆的去应用CORS了.\x3c\/p\x3e\n\x3ch4\x3eCORS有关的headers\x3c\/h4\x3e\n\x3cp\x3e1) HTTP Response Header(服务器提供):\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eAccess-Control-Allow-Origin: 指定允许哪些源的网页发送请求.\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eAccess-Control-Allow-Credentials: 指定是否允许cookie发送.\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eAccess-Control-Allow-Methods: 指定允许哪些请求方法.\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eAccess-Control-Allow-Headers: 指定允许哪些常规的头域字段, 比如说 Content-Type.\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eAccess-Control-Expose-Headers: 指定允许哪些额外的头域字段, 比如说 X-Custom-Header.\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e该字段可省略. CORS请求时, xhr.getResponseHeader() 方法默认只能获取6个基本字段: \x3ccode\x3eCache-Control\x3c\/code\x3e、\x3ccode\x3eContent-Language\x3c\/code\x3e、\x3ccode\x3eContent-Type\x3c\/code\x3e、\x3ccode\x3eExpires\x3c\/code\x3e、\x3ccode\x3eLast-Modified\x3c\/code\x3e、\x3ccode\x3ePragma\x3c\/code\x3e . 如果需要获取其他字段, 就需要在Access-Control-Expose-Headers 中指定. 如上, 这样xhr.getResponseHeader(\x27X-Custom-Header\x27) 才能返回X-Custom-Header字段的值.(该部分摘自阮一峰老师博客)\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3eAccess-Control-Max-Age: 指定preflight OPTIONS请求的有效期, 单位为秒.\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e2) HTTP Request Header(浏览器OPTIONS请求默认自带):\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eAccess-Control-Request-Method: 告知服务器,浏览器将发送哪种请求, 比如说POST.\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eAccess-Control-Request-Headers: 告知服务器, 浏览器将包含哪些额外的头域字段.\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e3) 以下所有的header name 是被拒绝的:\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eAccept-Charset\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eAccept-Encoding\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eAccess-Control-Request-Headers\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eAccess-Control-Request-Method\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eConnection\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eContent-Length\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eCookie\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eCookie2\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eDate\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eDNT\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eExpect\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eHost\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eKeep-Alive\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eOrigin\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eReferer\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eTE\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eTrailer\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eTransfer-Encoding\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eUpgrade\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eVia\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e包含以\x3ccode\x3eProxy-\x3c\/code\x3e 或 \x3ccode\x3eSec-\x3c\/code\x3e 开头的header name\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch4\x3eCORS请求\x3c\/h4\x3e\n\x3cp\x3eCORS请求分为两种, ① 简单请求; ② 非简单请求.\x3c\/p\x3e\n\x3cp\x3e满足如下两个条件便是简单请求, 反之则为非简单请求.(CORS请求部分摘自阮一峰老师博客)\x3c\/p\x3e\n\x3cp\x3e1) 请求是以下三种之一:\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eHEAD\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eGET\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ePOST\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e2) http头域不超出以下几种字段:\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eAccept\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eAccept-Language\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eContent-Language\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eLast-Event-ID\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eContent-Type字段限三个值 \x3ccode\x3eapplication\/x-www-form-urlencoded\x3c\/code\x3e、\x3ccode\x3emultipart\/form-data\x3c\/code\x3e、\x3ccode\x3etext\/plain\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e对于简单请求, 浏览器将发送一次http请求, 同时在Request头域中增加 \x3ccode\x3eOrigin\x3c\/code\x3e 字段, 用来标示请求发起的源, 服务器根据这个源采取不同的响应策略. 若服务器认为该请求合法, 那么需要往返回的 HTTP Response 中添加 \x3ccode\x3eAccess-Control-*\x3c\/code\x3e 等字段.( \x3ccode\x3eAccess-Control-*\x3c\/code\x3e 相关字段解析请阅读我之前写的\x3ca href=\x22http:\/\/louiszhai.github.io\/2016\/01\/11\/cross-domain\/#CORS__u8DE8_u57DF_u8BBF_u95EE%5D\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eCORS 跨域访问\x3c\/a\x3e )\x3c\/p\x3e\n\x3cp\x3e对于非简单请求, 比如Method为\x3ccode\x3ePOST\x3c\/code\x3e且Content-Type值为 \x3ccode\x3eapplication\/json\x3c\/code\x3e 的请求或者Method为 \x3ccode\x3ePUT\x3c\/code\x3e 或 \x3ccode\x3eDELETE\x3c\/code\x3e 的请求, 浏览器将发送两次http请求. 第一次为preflight预检(Method: OPTIONS),主要验证来源是否合法. 值得注意的是:OPTION请求响应头同样需要包含 \x3ccode\x3eAccess-Control-*\x3c\/code\x3e 字段等. 第二次才是真正的HTTP请求. 所以服务器必须处理OPTIONS应答(通常需要返回20X的状态码, 否则xhr.onerror事件将被触发).\x3c\/p\x3e\n\x3cp\x3e以上请求流程图为:\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000008697461?w=644\x26amp;h=328\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000008697461?w=644\x26amp;h=328\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch4\x3eHTML启用CORS\x3c\/h4\x3e\n\x3cp\x3ehttp-equiv 相当于http的响应头, 它回应给浏览器一些有用的信息,以帮助正确和精确地显示网页内容. 如下html将允许任意域名下的网页跨域访问.\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cmeta http-equiv=\x26quot;Access-Control-Allow-Origin\x26quot; content=\x26quot;*\x26quot;\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22xml hljs\x22\x3e\x3ccode class=\x22html\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3emeta\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ehttp-equiv\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22Access-Control-Allow-Origin\x22\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3econtent\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22*\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e图片启用CORS\x3c\/h4\x3e\n\x3cp\x3e通常, 图片允许跨域访问, 也可以在canvas中使用跨域的图片, 但这样做会污染画布, 一旦画布受污染, 将无法读取其数据. 比如无法调用 toBlob(), toDataURL() 或 getImageData()方法. 浏览器的这种安全机制规避了未经许可的远程服务器图片被滥用的风险.(该部分内容摘自 \x3ca href=\x22https:\/\/developer.mozilla.org\/zh-CN\/docs\/Web\/HTML\/CORS_enabled_image\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e启用了 CORS 的图片 - HTML（超文本标记语言） | MDN\x3c\/a\x3e)\x3c\/p\x3e\n\x3cp\x3e因此如需在canvas中使用跨域的图片资源, 请参考如下apache配置片段(来自\x3ca href=\x22https:\/\/github.com\/h5bp\/server-configs-apache\/blob\/fc379c45f52a09dd41279dbf4e60ae281110a5b0\/src\/.htaccess#L36-L53\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eHTML5 Boilerplate Apache server configs\x3c\/a\x3e).\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cIfModule mod_setenvif.c\x3e\n    \x3cIfModule mod_headers.c\x3e\n        \x3cFilesMatch \x26quot;\\.(cur|gif|ico|jpe?g|png|svgz?|webp)$\x26quot;\x3e\n            SetEnvIf Origin \x26quot;:\x26quot; IS_CORS\n            Header set Access-Control-Allow-Origin \x26quot;*\x26quot; env=IS_CORS\n        \x3c\/FilesMatch\x3e\n    \x3c\/IfModule\x3e\n\x3c\/IfModule\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs apache\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-section\x22\x3e\x26lt;IfModule mod_setenvif.c\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-section\x22\x3e\x26lt;IfModule mod_headers.c\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-section\x22\x3e\x26lt;FilesMatch \x22\\.(cur|gif|ico|jpe?g|png|svgz?|webp)$\x22\x26gt;\x3c\/span\x3e\n            \x3cspan class=\x22hljs-attribute\x22\x3eSetEnvIf\x3c\/span\x3e Origin \x3cspan class=\x22hljs-string\x22\x3e\x22:\x22\x3c\/span\x3e IS_CORS\n            \x3cspan class=\x22hljs-attribute\x22\x3e\x3cspan class=\x22hljs-nomarkup\x22\x3eHeader\x3c\/span\x3e\x3c\/span\x3e set Access-Control-Allow-Origin \x3cspan class=\x22hljs-string\x22\x3e\x22*\x22\x3c\/span\x3e env=IS_CORS\n        \x3cspan class=\x22hljs-section\x22\x3e\x26lt;\/FilesMatch\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-section\x22\x3e\x26lt;\/IfModule\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-section\x22\x3e\x26lt;\/IfModule\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader12\x22\x3eajax文件上传\x3c\/h3\x3e\n\x3cp\x3eajax实现文件上传非常简单, 这里我选取原生js, jq, angular 分别来比较下, 并顺便聊聊使用它们时的注意事项.(ajax文件上传的代码已上传至github, 请戳这里预览效果: \x3ca href=\x22http:\/\/louiszhai.github.io\/res\/ajaxUpload.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eajax 文件上传 demo | louis\x3c\/a\x3e)\x3c\/p\x3e\n\x3cp\x3e1) 为了上传文件, 我们得先选中一个文件. 一个type为file的input框就够了.\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cinput id=\x26quot;input\x26quot; type=\x26quot;file\x26quot;\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22xml hljs\x22\x3e\x3ccode class=\x22html\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3einput\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eid\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22input\x22\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22file\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e2) 然后用FormData对象包裹?选中的文件.\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var input = document.getElementById(\x26quot;input\x26quot;),\n    formData = new FormData();\nformData.append(\x26quot;file\x26quot;,input.files[0]);\/\/key可以随意定义,只要后台能理解就行\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e input = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.getElementById(\x3cspan class=\x22hljs-string\x22\x3e\x22input\x22\x3c\/span\x3e),\n    formData = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e FormData();\nformData.append(\x3cspan class=\x22hljs-string\x22\x3e\x22file\x22\x3c\/span\x3e,input.files[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e]);\x3cspan class=\x22hljs-comment\x22\x3e\/\/key可以随意定义,只要后台能理解就行\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e3) 定义上传的URL, 以及方法. github上我搭建了一个 \x3ca href=\x22https:\/\/github.com\/Louiszhai\/node-webserver\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3enode-webserver\x3c\/a\x3e, 根据需要可以自行克隆下来npm start后便可调试本篇代码.\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var url = \x26quot;http:\/\/localhost:10108\/test\x26quot;,\n    method = \x26quot;POST\x26quot;;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e url = \x3cspan class=\x22hljs-string\x22\x3e\x22http:\/\/localhost:10108\/test\x22\x3c\/span\x3e,\n    method = \x3cspan class=\x22hljs-string\x22\x3e\x22POST\x22\x3c\/span\x3e;\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3ejs文件上传\x3c\/h4\x3e\n\x3cp\x3e4.1) 封装一个用于发送ajax请求的方法.\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function ajax(url, method, data){\n  var xhr = null;\n  if(window.XMLHttpRequest) {\n    xhr = new XMLHttpRequest();\n  } else if (window.ActiveXObject) {\n    try {\n      xhr = new ActiveXObject(\x26quot;Msxml2.XMLHTTP\x26quot;);\n    } catch (e) {\n      try {\n        xhr = new ActiveXObject(\x26quot;Microsoft.XMLHTTP\x26quot;);\n      } catch (e) { \n        alert(\x26quot;您的浏览器暂不支持Ajax!\x26quot;);\n      }\n    }\n  }\n  xhr.onerror = function(e){\n    console.log(e);\n  }\n  xhr.open(method, url);\n  try{\n    setTimeout(function(){\n      xhr.send(data);\n    });\n  }catch(e){\n    console.log(\x27error:\x27,e);\n  }\n  return xhr;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eajax\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eurl, method, data\x3c\/span\x3e)\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e xhr = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.XMLHttpRequest) {\n    xhr = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e XMLHttpRequest();\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.ActiveXObject) {\n    \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n      xhr = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e ActiveXObject(\x3cspan class=\x22hljs-string\x22\x3e\x22Msxml2.XMLHTTP\x22\x3c\/span\x3e);\n    } \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e (e) {\n      \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n        xhr = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e ActiveXObject(\x3cspan class=\x22hljs-string\x22\x3e\x22Microsoft.XMLHTTP\x22\x3c\/span\x3e);\n      } \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e (e) { \n        alert(\x3cspan class=\x22hljs-string\x22\x3e\x22您的浏览器暂不支持Ajax!\x22\x3c\/span\x3e);\n      }\n    }\n  }\n  xhr.onerror = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ee\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(e);\n  }\n  xhr.open(method, url);\n  \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e{\n    setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n      xhr.send(data);\n    });\n  }\x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e(e){\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27error:\x27\x3c\/span\x3e,e);\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e xhr;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e4.2) 上传文件并绑定事件.\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var xhr = ajax(url, method, formData);\nxhr.upload.onprogress = function(e){\n  console.log(\x26quot;upload progress:\x26quot;, e.loaded\/e.total*100 \x2b \x26quot;%\x26quot;);\n};\nxhr.upload.onload = function(){\n  console.log(\x26quot;upload onload.\x26quot;);\n};\nxhr.onload = function(){\n  console.log(\x26quot;onload.\x26quot;);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e xhr = ajax(url, method, formData);\nxhr.upload.onprogress = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ee\x3c\/span\x3e)\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22upload progress:\x22\x3c\/span\x3e, e.loaded\/e.total*\x3cspan class=\x22hljs-number\x22\x3e100\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22%\x22\x3c\/span\x3e);\n};\nxhr.upload.onload = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22upload onload.\x22\x3c\/span\x3e);\n};\nxhr.onload = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22onload.\x22\x3c\/span\x3e);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上传结果如下所示:\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000008697462?w=850\x26amp;h=212\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000008697462?w=850\x26amp;h=212\x22 alt=\x22js file upload\x22 title=\x22js file upload\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch4\x3efetch上传\x3c\/h4\x3e\n\x3cp\x3e5) fetch只要发送一个post请求, 并且body属性设置为formData即可. 遗憾的是, fetch无法跟踪上传的进度信息.\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22fetch(url, {\n  method: method,\n  body: formData\n  }).then(function(res){\n  console.log(res);\n  }).catch(function(e){\n  console.log(e);\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3efetch(url, {\n  \x3cspan class=\x22hljs-attr\x22\x3emethod\x3c\/span\x3e: method,\n  \x3cspan class=\x22hljs-attr\x22\x3ebody\x3c\/span\x3e: formData\n  }).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eres\x3c\/span\x3e)\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(res);\n  }).catch(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ee\x3c\/span\x3e)\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(e);\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3ejquery文件上传\x3c\/h4\x3e\n\x3cp\x3ejq提供了各式各样的上传插件, 其原理都是利用jq自身的ajax方法.\x3c\/p\x3e\n\x3cp\x3e6) jq的ajax提供了xhr属性用于自定义各种事件.\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22$.ajax({\n  type: method,\n  url: url,\n  data: formData,\n  processData : false,\n  contentType : false ,\/\/必须false才会自动加上正确的Content-Type\n  xhr: function(){\n    var xhr = $.ajaxSettings.xhr();\/\/实际上就是return new window.XMLHttpRequest()对象\n    if(xhr.upload) {\n      xhr.upload.addEventListener(\x26quot;progress\x26quot;, function(e){\n        console.log(\x26quot;jq upload progress:\x26quot;, e.loaded\/e.total*100 \x2b \x26quot;%\x26quot;);\n      }, false);\n      xhr.upload.addEventListener(\x26quot;load\x26quot;, function(){\n        console.log(\x26quot;jq upload onload.\x26quot;);\n      });\n      xhr.addEventListener(\x26quot;load\x26quot;, function(){\n        console.log(\x26quot;jq onload.\x26quot;);\n      });\n      return xhr;\n    }\n  }\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e$.ajax({\n  \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e: method,\n  \x3cspan class=\x22hljs-attr\x22\x3eurl\x3c\/span\x3e: url,\n  \x3cspan class=\x22hljs-attr\x22\x3edata\x3c\/span\x3e: formData,\n  \x3cspan class=\x22hljs-attr\x22\x3eprocessData\x3c\/span\x3e : \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3econtentType\x3c\/span\x3e : \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e ,\x3cspan class=\x22hljs-comment\x22\x3e\/\/必须false才会自动加上正确的Content-Type\x3c\/span\x3e\n  xhr: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e xhr = $.ajaxSettings.xhr();\x3cspan class=\x22hljs-comment\x22\x3e\/\/实际上就是return new window.XMLHttpRequest()对象\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(xhr.upload) {\n      xhr.upload.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x22progress\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ee\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22jq upload progress:\x22\x3c\/span\x3e, e.loaded\/e.total*\x3cspan class=\x22hljs-number\x22\x3e100\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22%\x22\x3c\/span\x3e);\n      }, \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e);\n      xhr.upload.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x22load\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22jq upload onload.\x22\x3c\/span\x3e);\n      });\n      xhr.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x22load\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22jq onload.\x22\x3c\/span\x3e);\n      });\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e xhr;\n    }\n  }\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3ejq上传结果如下所示:\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000008697463?w=838\x26amp;h=210\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000008697463?w=838\x26amp;h=210\x22 alt=\x22jq file upload\x22 title=\x22jq file upload\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e有关jq ajax更多的api, 请参考中文文档 \x3ca href=\x22http:\/\/www.jquery123.com\/jQuery.ajax\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ejQuery.ajax() | jQuery API 中文文档\x3c\/a\x3e .\x3c\/p\x3e\n\x3ch4\x3eangular文件上传\x3c\/h4\x3e\n\x3cp\x3e7.1) angular提供了$http方法用于发送http请求, 该方法返回一个promise对象.\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22$http({\n  method: method,\n  url: url,\n  data: formData,\n}).success(function(res) {\n  console.log(res);\n}).error(function(err, status) {\n  console.log(err);\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e$http({\n  \x3cspan class=\x22hljs-attr\x22\x3emethod\x3c\/span\x3e: method,\n  \x3cspan class=\x22hljs-attr\x22\x3eurl\x3c\/span\x3e: url,\n  \x3cspan class=\x22hljs-attr\x22\x3edata\x3c\/span\x3e: formData,\n}).success(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eres\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(res);\n}).error(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eerr, status\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(err);\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eangular文件上传的代码已上传至github, 请戳这里预览效果: \x3ca href=\x22http:\/\/louiszhai.github.io\/res\/angularUpload.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eangular 文件上传 demo | louis\x3c\/a\x3e.\x3c\/p\x3e\n\x3cp\x3e低版本angular中文件上传的功能并不完整,  直到angular1.5.5才在$http中加入了eventHandler和uploadEventHandlers等方法, 使得它支持上传进度信息. 如下:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22$http({\n  method: method,\n  url: url,\n  eventHandlers: {\n    progress: function(c) {\/\/下载进度\n      console.log(\x27Progress -\x3e \x27 \x2b c);\n    }\n  },\n  uploadEventHandlers: {\n    progress: function(e) {\/\/上传进度\n      console.log(\x27UploadProgress -\x3e \x27 \x2b e);\n    }\n  },\n  data: formData,\n}).success(function(res) {\n  console.log(res);\n}).error(function(err, status) {\n  console.log(err);\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e$http({\n  \x3cspan class=\x22hljs-attr\x22\x3emethod\x3c\/span\x3e: method,\n  \x3cspan class=\x22hljs-attr\x22\x3eurl\x3c\/span\x3e: url,\n  \x3cspan class=\x22hljs-attr\x22\x3eeventHandlers\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-attr\x22\x3eprogress\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ec\x3c\/span\x3e) \x3c\/span\x3e{\x3cspan class=\x22hljs-comment\x22\x3e\/\/下载进度\x3c\/span\x3e\n      \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27Progress -\x26gt; \x27\x3c\/span\x3e \x2b c);\n    }\n  },\n  \x3cspan class=\x22hljs-attr\x22\x3euploadEventHandlers\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-attr\x22\x3eprogress\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ee\x3c\/span\x3e) \x3c\/span\x3e{\x3cspan class=\x22hljs-comment\x22\x3e\/\/上传进度\x3c\/span\x3e\n      \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27UploadProgress -\x26gt; \x27\x3c\/span\x3e \x2b e);\n    }\n  },\n  \x3cspan class=\x22hljs-attr\x22\x3edata\x3c\/span\x3e: formData,\n}).success(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eres\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(res);\n}).error(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eerr, status\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(err);\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eangular1.5.5以下低版本中, 请参考成熟的实现方案 \x3ca href=\x22https:\/\/github.com\/nervgh\/angular-file-upload\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eangular-file-upload\x3c\/a\x3e 以及它提供的demo \x3ca href=\x22http:\/\/nervgh.github.io\/pages\/angular-file-upload\/examples\/simple\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eSimple example\x3c\/a\x3e .\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader13\x22\x3eajax请求二进制文件\x3c\/h3\x3e\n\x3ch4\x3eFileReader\x3c\/h4\x3e\n\x3cp\x3e处理二进制文件主要使用的是H5的FileReader.\x3c\/p\x3e\n\x3cp\x3ePC支持性如下:\x3c\/p\x3e\n\x3ctable\x3e\n\x3cthead\x3e\x3ctr\x3e\n\x3cth align=\x22center\x22\x3eIE\x3c\/th\x3e\n\x3cth align=\x22center\x22\x3eEdge\x3c\/th\x3e\n\x3cth align=\x22center\x22\x3eFirefox\x3c\/th\x3e\n\x3cth align=\x22center\x22\x3eChrome\x3c\/th\x3e\n\x3cth align=\x22center\x22\x3eSafari\x3c\/th\x3e\n\x3cth align=\x22center\x22\x3eOpera\x3c\/th\x3e\n\x3c\/tr\x3e\x3c\/thead\x3e\n\x3ctbody\x3e\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e10\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e12\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e3.6\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e6\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e6\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e11.5\x3c\/td\x3e\n\x3c\/tr\x3e\x3c\/tbody\x3e\n\x3c\/table\x3e\n\x3cp\x3eMobile支持性如下:\x3c\/p\x3e\n\x3ctable\x3e\n\x3cthead\x3e\x3ctr\x3e\n\x3cth align=\x22center\x22\x3eIOS Safari\x3c\/th\x3e\n\x3cth align=\x22center\x22\x3eOpera Mini\x3c\/th\x3e\n\x3cth align=\x22center\x22\x3eAndroid Browser\x3c\/th\x3e\n\x3cth align=\x22center\x22\x3eChrome\/Android\x3c\/th\x3e\n\x3cth align=\x22center\x22\x3eUC\/Android\x3c\/th\x3e\n\x3c\/tr\x3e\x3c\/thead\x3e\n\x3ctbody\x3e\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e7.1\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e-\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e4\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e53\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e11\x3c\/td\x3e\n\x3c\/tr\x3e\x3c\/tbody\x3e\n\x3c\/table\x3e\n\x3cp\x3e以下是其API:\x3c\/p\x3e\n\x3ctable\x3e\n\x3cthead\x3e\x3ctr\x3e\n\x3cth align=\x22center\x22\x3e属性\/方法名称\x3c\/th\x3e\n\x3cth align=\x22left\x22\x3e描述\x3c\/th\x3e\n\x3c\/tr\x3e\x3c\/thead\x3e\n\x3ctbody\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e\x3cstrong\x3e\x3cem\x3eerror\x3c\/em\x3e\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e表示读取文件期间发生的错误.\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e\x3cstrong\x3e\x3cem\x3ereadyState\x3c\/em\x3e\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e表示读取文件的状态.默认有三个值:0表示文件还没有加载;1表示文件正在读取;2表示文件读取完成.\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e\x3cstrong\x3e\x3cem\x3eresult\x3c\/em\x3e\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e读取的文件内容.\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e\x3cstrong\x3e\x3cem\x3eabort()\x3c\/em\x3e\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e取消文件读取操作, 此时\x3ccode\x3ereadyState\x3c\/code\x3e属性将置为2.\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e\x3cstrong\x3e\x3cem\x3ereadAsArrayBuffer()\x3c\/em\x3e\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e读取文件(或blob对象)为类型化数组(\x3ca href=\x22http:\/\/blog.csdn.net\/lichwei1983\/article\/details\/43893025\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eArrayBuffer\x3c\/a\x3e),  类型化数组允许开发者以数组下标的方式, 直接操作内存, 由于数据以二进制形式传递, 效率非常高.\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e\x3cem\x3e\x3cdel\x3ereadAsBinaryString()\x3c\/del\x3e\x3c\/em\x3e\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e读取文件(或blob对象)为二进制字符串, 该方法已移出标准api, 请谨慎使用.\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e\x3cstrong\x3e\x3cem\x3ereadAsDataURL()\x3c\/em\x3e\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e读取文件(或blob对象)为base64编码的URL字符串, 与window.URL.createObjectURL方法效果类似.\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e\x3cstrong\x3e\x3cem\x3ereadAsText()\x3c\/em\x3e\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e读取文件(或blob对象)为文本字符串.\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e\x3cstrong\x3e\x3cem\x3eonload()\x3c\/em\x3e\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd align=\x22left\x22\x3e文件读取完成时的事件回调, 默认传入event事件对象. 该回调内, 可通过this.result 或 event.target.result获取读取的文件内容.\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3c\/tbody\x3e\n\x3c\/table\x3e\n\x3ch4\x3eajax请求二进制图片并预览\x3c\/h4\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var xhr = new XMLHttpRequest(),\n    url = \x26quot;http:\/\/louiszhai.github.io\/docImages\/ajax01.png\x26quot;;\nxhr.open(\x26quot;GET\x26quot;, url);\nxhr.responseType = \x26quot;blob\x26quot;;\nxhr.onload = function(){\n  if(this.status == 200){\n    var blob = this.response;\n    var img = document.createElement(\x26quot;img\x26quot;);\n    \/\/方案一\n    img.src = window.URL.createObjectURL(blob);\/\/这里blob依然占据着内存\n    img.onload = function() {\n      window.URL.revokeObjectURL(img.src);\/\/释放内存\n    };\n    \/\/方案二\n    \/*var reader = new FileReader();\n    reader.readAsDataURL(blob);\/\/FileReader将返回base64编码的data-uri对象\n    reader.onload = function(){\n      img.src = this.result;\n    }*\/\n    \/\/方案三\n    \/\/img.src = url;\/\/最简单方法\n    document.body.appendChild(img);\n  }\n}\nxhr.send();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e xhr = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e XMLHttpRequest(),\n    url = \x3cspan class=\x22hljs-string\x22\x3e\x22http:\/\/louiszhai.github.io\/docImages\/ajax01.png\x22\x3c\/span\x3e;\nxhr.open(\x3cspan class=\x22hljs-string\x22\x3e\x22GET\x22\x3c\/span\x3e, url);\nxhr.responseType = \x3cspan class=\x22hljs-string\x22\x3e\x22blob\x22\x3c\/span\x3e;\nxhr.onload = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.status == \x3cspan class=\x22hljs-number\x22\x3e200\x3c\/span\x3e){\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e blob = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.response;\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e img = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.createElement(\x3cspan class=\x22hljs-string\x22\x3e\x22img\x22\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/方案一\x3c\/span\x3e\n    img.src = \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.URL.createObjectURL(blob);\x3cspan class=\x22hljs-comment\x22\x3e\/\/这里blob依然占据着内存\x3c\/span\x3e\n    img.onload = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.URL.revokeObjectURL(img.src);\x3cspan class=\x22hljs-comment\x22\x3e\/\/释放内存\x3c\/span\x3e\n    };\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/方案二\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*var reader = new FileReader();\n    reader.readAsDataURL(blob);\/\/FileReader将返回base64编码的data-uri对象\n    reader.onload = function(){\n      img.src = this.result;\n    }*\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/方案三\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/img.src = url;\/\/最简单方法\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.body.appendChild(img);\n  }\n}\nxhr.send();\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3eajax请求二进制文本并展示\x3c\/h4\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var xhr = new XMLHttpRequest();\nxhr.open(\x26quot;GET\x26quot;,\x26quot;http:\/\/localhost:8080\/Information\/download.jsp?data=node-fetch.js\x26quot;);\nxhr.responseType = \x26quot;blob\x26quot;;\nxhr.onload = function(){\n  if(this.status == 200){\n    var blob = this.response;\n    var reader = new FileReader();\n    reader.readAsBinaryString(blob);\/\/该方法已被移出标准api,建议使用reader.readAsText(blob);\n    reader.onload=function(){\n      document.body.innerHTML = \x26quot;\x3cdiv\x3e\x26quot; \x2b this.result \x2b \x26quot;\x3c\/div\x3e\x26quot;;\n    }\n  }\n}\nxhr.send();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e xhr = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e XMLHttpRequest();\nxhr.open(\x3cspan class=\x22hljs-string\x22\x3e\x22GET\x22\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x22http:\/\/localhost:8080\/Information\/download.jsp?data=node-fetch.js\x22\x3c\/span\x3e);\nxhr.responseType = \x3cspan class=\x22hljs-string\x22\x3e\x22blob\x22\x3c\/span\x3e;\nxhr.onload = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.status == \x3cspan class=\x22hljs-number\x22\x3e200\x3c\/span\x3e){\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e blob = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.response;\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e reader = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e FileReader();\n    reader.readAsBinaryString(blob);\x3cspan class=\x22hljs-comment\x22\x3e\/\/该方法已被移出标准api,建议使用reader.readAsText(blob);\x3c\/span\x3e\n    reader.onload=\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n      \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.body.innerHTML = \x3cspan class=\x22hljs-string\x22\x3e\x22\x26lt;div\x26gt;\x22\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.result \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22\x26lt;\/div\x26gt;\x22\x3c\/span\x3e;\n    }\n  }\n}\nxhr.send();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e有关二进制文件的读取, 请移步这篇博客 \x3ca href=\x22http:\/\/www.cnblogs.com\/jscode\/archive\/2013\/04\/27\/3572239.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eHTML5新特性之文件和二进制数据的操作\x3c\/a\x3e .\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader14\x22\x3e如何等待多个ajax请求完成\x3c\/h3\x3e\n\x3cp\x3e原生js可以使用ES6新增的Promise. ES6的Promise基于 \x3ca href=\x22https:\/\/promisesaplus.com\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ePromises\/A\x2b\x3c\/a\x3e 规范(该部分 \x3ca href=\x22http:\/\/louiszhai.github.io\/2016\/10\/19\/fetch\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eFetch入门指南\x3c\/a\x3e 一文也有提及).\x3c\/p\x3e\n\x3cp\x3e这里先提供一个解析responses的函数.\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function todo(responses){\n  responses.forEach(function(response){\n    response.json().then(function(res){\n      console.log(res);\n    });\n  });\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3etodo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eresponses\x3c\/span\x3e)\x3c\/span\x3e{\n  responses.forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eresponse\x3c\/span\x3e)\x3c\/span\x3e{\n    response.json().then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eres\x3c\/span\x3e)\x3c\/span\x3e{\n      \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(res);\n    });\n  });\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e原生js使用 \x3ccode\x3ePromise.all\x3c\/code\x3e 方法. 如下:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var p1 = fetch(\x26quot;http:\/\/localhost:10108\/test1\x26quot;),\n    p2 = fetch(\x26quot;http:\/\/localhost:10108\/test2\x26quot;);\nPromise.all([p1, p2]).then(function(responses){\n  todo(responses);\n  \/\/TODO do somethings\n});\n\/\/\x26quot;test1\x26quot;\n\/\/\x26quot;test2\x26quot;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e p1 = fetch(\x3cspan class=\x22hljs-string\x22\x3e\x22http:\/\/localhost:10108\/test1\x22\x3c\/span\x3e),\n    p2 = fetch(\x3cspan class=\x22hljs-string\x22\x3e\x22http:\/\/localhost:10108\/test2\x22\x3c\/span\x3e);\n\x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.all([p1, p2]).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eresponses\x3c\/span\x3e)\x3c\/span\x3e{\n  todo(responses);\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/TODO do somethings\x3c\/span\x3e\n});\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/\x22test1\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/\x22test2\x22\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3ejquery可以使用$.when方法. 该方法接受一个或多个Deferred对象作为参数, 只有全部成功才调用resolved状态的回调函数, 但只要其中有一个失败，就调用rejected状态的回调函数. 其实, jq的Deferred是基于 Promises\/A规范实现, 但并非完全遵循. (传送门: \x3ca href=\x22http:\/\/www.css88.com\/archives\/4750\/comment-page-1\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ejQuery 中的 Deferred 和 Promises (2)\x3c\/a\x3e ).\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var p1 = $.ajax(\x26quot;http:\/\/localhost:10108\/test1\x26quot;),\n    p2 = $.ajax(\x26quot;http:\/\/localhost:10108\/test2\x26quot;);\n$.when(p1, p2).then(function(res1, res2){\n  console.log(res1);\/\/[\x26quot;test1\x26quot;, \x26quot;success\x26quot;, Object]\n  console.log(res2);\/\/[\x26quot;test2\x26quot;, \x26quot;success\x26quot;, Object]\n  \/\/TODO do somethings\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e p1 = $.ajax(\x3cspan class=\x22hljs-string\x22\x3e\x22http:\/\/localhost:10108\/test1\x22\x3c\/span\x3e),\n    p2 = $.ajax(\x3cspan class=\x22hljs-string\x22\x3e\x22http:\/\/localhost:10108\/test2\x22\x3c\/span\x3e);\n$.when(p1, p2).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eres1, res2\x3c\/span\x3e)\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(res1);\x3cspan class=\x22hljs-comment\x22\x3e\/\/[\x22test1\x22, \x22success\x22, Object]\x3c\/span\x3e\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(res2);\x3cspan class=\x22hljs-comment\x22\x3e\/\/[\x22test2\x22, \x22success\x22, Object]\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/TODO do somethings\x3c\/span\x3e\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如上, $.when默认返回一个jqXHR对象, 可以直接进行链式调用. then方法的回调中默认传入相应的请求结果, 每个请求结果的都是数组, 数组中依次是responseText, 请求状态, 请求的jqXHR对象.\x3c\/p\x3e\n\x3cp\x3eangular中可以借助 \x3ccode\x3e$q.all()\x3c\/code\x3e 来实现. 别忘了, \x3ccode\x3e$q\x3c\/code\x3e 需要在controller中注入. 此外, \x3ccode\x3e $q\x3c\/code\x3e 相关讲解可参考 \x3ca href=\x22https:\/\/code.angularjs.org\/1.2.6\/docs\/api\/ng.\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eAngularJS: ng.$q\x3c\/a\x3e 或 \x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000000402555\x22\x3eAngular $q service学习笔记\x3c\/a\x3e .\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var p1 = fetch(\x26quot;http:\/\/localhost:10108\/test1\x26quot;),\n    p2 = fetch(\x26quot;http:\/\/localhost:10108\/test2\x26quot;);\n$q.all([p1, p2]).then(function(responses){\n  todo(responses);\n  \/\/TODO do somethings\n});\n\/\/\x26quot;test1\x26quot;\n\/\/\x26quot;test2\x26quot;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e p1 = fetch(\x3cspan class=\x22hljs-string\x22\x3e\x22http:\/\/localhost:10108\/test1\x22\x3c\/span\x3e),\n    p2 = fetch(\x3cspan class=\x22hljs-string\x22\x3e\x22http:\/\/localhost:10108\/test2\x22\x3c\/span\x3e);\n$q.all([p1, p2]).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eresponses\x3c\/span\x3e)\x3c\/span\x3e{\n  todo(responses);\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/TODO do somethings\x3c\/span\x3e\n});\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/\x22test1\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/\x22test2\x22\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3e$q.all()\x3c\/code\x3e 实际上就是对 \x3ccode\x3ePromise.all\x3c\/code\x3e 的封装.\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader15\x22\x3eajax与history的兼容\x3c\/h3\x3e\n\x3cp\x3eajax的一大痛点就是无法支持浏览器前进和后退操作. 因此早期的Gmail 采用 iframe, 来模拟ajax的前进和后退.\x3c\/p\x3e\n\x3cp\x3e如今, H5普及, pjax大行其道. pajax 就是 ajax\x2bhistory.pushState 组合的一种技术. 使用它便可以无刷新通过浏览器前进和后退来改变页面内容.\x3c\/p\x3e\n\x3cp\x3e先看下兼容性.\x3c\/p\x3e\n\x3cdiv class=\x22table-wrap\x22\x3e\x3ctable\x3e\n\x3cthead\x3e\x3ctr\x3e\n\x3cth align=\x22center\x22\x3e \x3c\/th\x3e\n\x3cth align=\x22center\x22\x3eIE\x3c\/th\x3e\n\x3cth align=\x22center\x22\x3eEdge\x3c\/th\x3e\n\x3cth align=\x22center\x22\x3eFirefox\x3c\/th\x3e\n\x3cth align=\x22center\x22\x3eChrome\x3c\/th\x3e\n\x3cth align=\x22center\x22\x3eSafari\x3c\/th\x3e\n\x3cth align=\x22center\x22\x3eOpera\x3c\/th\x3e\n\x3cth align=\x22center\x22\x3eiOS Safari\x3c\/th\x3e\n\x3cth align=\x22center\x22\x3eAndroid Browser\x3c\/th\x3e\n\x3cth align=\x22center\x22\x3eChrome for Android\x3c\/th\x3e\n\x3c\/tr\x3e\x3c\/thead\x3e\n\x3ctbody\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3epushState\/replaceState\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e10\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e12\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e4\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e5\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e6\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e11.5\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e7.1\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e4.3\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e53\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3ehistory.state\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e10\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e \x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e4\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e18\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e6\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e11.5\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e \x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e \x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e \x3c\/td\x3e\n\x3c\/tr\x3e\n\x3c\/tbody\x3e\n\x3c\/table\x3e\x3c\/div\x3e\n\x3cp\x3e可见IE8,9并不能使用 H5的history. 需要使用垫片 \x3ca href=\x22https:\/\/github.com\/devote\/HTML5-History-API\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eHTML5 History API expansion for browsers not supporting pushState, replaceState\x3c\/a\x3e .\x3c\/p\x3e\n\x3ch4\x3epjax\x3c\/h4\x3e\n\x3cp\x3epjax简单易用, 仅需要如下三个api:\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3ehistory.pushState(obj, title, url) 表示往页面history末尾新增一个历史项(history entry), 此时history.length会\x2b1.\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ehistory.replaceState(obj, title, url) 表示替换当前历史项为新的历史项. 此时history.length保持不变.\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ewindow.onpopstate 仅在浏览器前进和后退时触发(history.go(1), history.back() 及location.href=\x22xxx\x22 均会触发), 此时可在history.state中拿到刚刚塞进去的state, 即obj对象(其他数据类型亦可).\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e我们注意到, 首次进入一个页面, 此时 \x3ccode\x3ehistory.length\x3c\/code\x3e 值为1, \x3ccode\x3ehistory.state\x3c\/code\x3e 为空. 如下:\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000008697464?w=391\x26amp;h=125\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000008697464?w=391\x26amp;h=125\x22 alt=\x22history.state\x22 title=\x22history.state\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e1) 为了在onpopstate事件回调中每次都能拿到 \x3ccode\x3ehistory.state\x3c\/code\x3e , 此时需要在页面载入完成后, 自动替换下当前url.\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22history.replaceState(\x26quot;init\x26quot;, title, \x26quot;xxx.html?state=0\x26quot;);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3ehistory.replaceState(\x3cspan class=\x22hljs-string\x22\x3e\x22init\x22\x3c\/span\x3e, title, \x3cspan class=\x22hljs-string\x22\x3e\x22xxx.html?state=0\x22\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e2) 每次发送ajax请求时, 在请求完成后, 调用如下, 从而实现浏览器history往前进.\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22history.pushState(\x26quot;ajax请求相关参数\x26quot;, title, \x26quot;xxx.html?state=标识符\x26quot;);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3ehistory.pushState(\x3cspan class=\x22hljs-string\x22\x3e\x22ajax请求相关参数\x22\x3c\/span\x3e, title, \x3cspan class=\x22hljs-string\x22\x3e\x22xxx.html?state=标识符\x22\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e3) 浏览器前进和后退时, \x3ccode\x3epopstate \x3c\/code\x3e 事件会自动触发, 此时我们手动取出 \x3ccode\x3ehistory.state\x3c\/code\x3e , 构建参数并重新发送ajax请求或者直接取用state值, 从而实现无刷新还原页面.\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22window.addEventListener(\x26quot;popstate\x26quot;, function(e) {\n    var currentState = history.state;\n    \/\/TODO 拼接ajax请求参数并重新发送ajax请求, 从而回到历史页面\n      \/\/TODO 或者从state中拿到关键值直接还原历史页面\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x22popstate\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ee\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e currentState = history.state;\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/TODO 拼接ajax请求参数并重新发送ajax请求, 从而回到历史页面\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/TODO 或者从state中拿到关键值直接还原历史页面\x3c\/span\x3e\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3epopstate \x3c\/code\x3e 事件触发时, 默认会传入 \x3ccode\x3ePopStateEvent\x3c\/code\x3e 事件对象. 该对象具有如下属性.\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000008697465?w=800\x26amp;h=306\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000008697465?w=800\x26amp;h=306\x22 alt=\x22PopStateEvent\x22 title=\x22PopStateEvent\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e如有不懂, 更详细讲解请移步 : \x3ca href=\x22http:\/\/www.zhangxinxu.com\/wordpress\/2013\/06\/html5-history-api-pushstate-replacestate-ajax\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eajax与HTML5 history pushState\/replaceState实例 « 张鑫旭-鑫空间-鑫生活\x3c\/a\x3e .\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader16\x22\x3eajax缓存处理\x3c\/h3\x3e\n\x3cp\x3ejs中的http缓存没有开关, 受制于浏览器http缓存策略. 原生xhr请求中, 可通过如下设置关闭缓存.\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22xhr.setRequestHeader(\x26quot;If-Modified-Since\x26quot;,\x26quot;0\x26quot;);\nxhr.setRequestHeader(\x26quot;Cache-Control\x26quot;,\x26quot;no-cache\x26quot;);\n\/\/或者 URL 参数后加上  \x26quot;?timestamp=\x26quot; \x2b new Date().getTime()\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3exhr.setRequestHeader(\x3cspan class=\x22hljs-string\x22\x3e\x22If-Modified-Since\x22\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x220\x22\x3c\/span\x3e);\nxhr.setRequestHeader(\x3cspan class=\x22hljs-string\x22\x3e\x22Cache-Control\x22\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x22no-cache\x22\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/或者 URL 参数后加上  \x22?timestamp=\x22 \x2b new Date().getTime()\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3ejquery的http缓存是否开启可通过在settings中指定cache.\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22$.ajax({\n  url : \x27url\x27,\n  dataType : \x26quot;xml\x26quot;,\n  cache: true,\/\/true表示缓存开启, false表示缓存不开启\n  success : function(xml, status){    \n  }\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e$.ajax({\n  \x3cspan class=\x22hljs-attr\x22\x3eurl\x3c\/span\x3e : \x3cspan class=\x22hljs-string\x22\x3e\x27url\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3edataType\x3c\/span\x3e : \x3cspan class=\x22hljs-string\x22\x3e\x22xml\x22\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3ecache\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\x3cspan class=\x22hljs-comment\x22\x3e\/\/true表示缓存开启, false表示缓存不开启\x3c\/span\x3e\n  success : \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3exml, status\x3c\/span\x3e)\x3c\/span\x3e{    \n  }\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e同时jquery还可以全局设置是否缓存. 如下将全局关闭ajax缓存.\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22$.ajaxSetup({cache:false});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e$.ajaxSetup({\x3cspan class=\x22hljs-attr\x22\x3ecache\x3c\/span\x3e:\x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e除此之外, 调试过程中出现的浏览器缓存尤为可恶. 建议开启隐私浏览器或者勾选☑️控制台的 \x3ccode\x3eDisable cache\x3c\/code\x3e 选项. (这里以Chrome举例, 其他浏览器类似)\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000008697466?w=900\x26amp;h=70\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000008697466?w=900\x26amp;h=70\x22 alt=\x22PopStateEvent\x22 title=\x22PopStateEvent\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader17\x22\x3eajax的错误处理\x3c\/h3\x3e\n\x3cp\x3e前面已经提过, 通常只要是ajax请求收到了http状态码, 便不会进入到错误捕获里.(Chrome中407响应头除外)\x3c\/p\x3e\n\x3cp\x3e实际上, \x3ccode\x3e$.ajax \x3c\/code\x3e 方法略有区别, jquery的ajax方法还会在类型解析出错时触发error回调. 最常见的便是: dataType设置为json, 但是返回的data并非json格式, 此时 \x3ccode\x3e$.ajax\x3c\/code\x3e 的error回调便会触发.\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader18\x22\x3eajax调试技巧\x3c\/h3\x3e\n\x3cp\x3e有关调试, 如果接口只是做小部分修改. 那么可以使用charles(Mac) 或者fiddler(Windows), 做代理, 将请求的资源替换为本地文件, 或者使用其断点功能, 直接编辑response.\x3c\/p\x3e\n\x3cp\x3e如果是新增接口的调试, 可以本地搭建node服务. 利用hosts文件配置dns \x2b nginx将http请求转发到本地node服务器. 简易的node调试服务器可参考我的 \x3ca href=\x22https:\/\/github.com\/Louiszhai\/node-webserver\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3enode-webserver\x3c\/a\x3e . 如下举一个栗子?:\x3c\/p\x3e\n\x3ch4\x3ehosts\x2bnginx\x2bnode-webserver\x3c\/h4\x3e\n\x3cp\x3e假设我们要调试的是 www.test.com 的GET接口. 以下所有步骤以Mac为例, 其他系统, 请自行搜索?文件路径.\x3c\/p\x3e\n\x3cp\x3e1) hosts配置.\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22sudo vim \/etc\/hosts\n#新增一行 127.0.0.1 www.test.com\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22bash hljs\x22\x3e\x3ccode class=\x22bash\x22\x3esudo vim \/etc\/hosts\n\x3cspan class=\x22hljs-comment\x22\x3e#新增一行 127.0.0.1 www.test.com\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e2) nginx 配置\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22brew install nginx #安装\n#安装成功后进入目标目录\ncd \/usr\/local\/etc\/nginx\/\ncd servers #默认配置入口为nginx.conf.同时servers目录下*.conf文件已自动加入到配置文件列表中\nvim test.conf\n#粘贴如下内容\nserver {\n  listen       80;\n  server_name  www.test.com;\n  index index.html;\n  error_page   500 502 503 504  \/50x.html;\n  location = \/50x.html {\n      root   html;\n  }\n  location \/ {\n    proxy_pass http:\/\/localhost:10108\/;\n    proxy_redirect off;\n    proxy_set_header Host $host;\n    proxy_set_header        X-Read-IP       $remote_addr;\n    proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;\n  }\n}\n#:wq保存并退出\n#启动nginx\nsudo nginx -s reload #如果启动了只需重启即可\nsudo nginx #如果没有启动,便启动之\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22bash hljs\x22\x3e\x3ccode class=\x22bash\x22\x3ebrew install nginx \x3cspan class=\x22hljs-comment\x22\x3e#安装\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e#安装成功后进入目标目录\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3ecd\x3c\/span\x3e \/usr\/\x3cspan class=\x22hljs-built_in\x22\x3elocal\x3c\/span\x3e\/etc\/nginx\/\n\x3cspan class=\x22hljs-built_in\x22\x3ecd\x3c\/span\x3e servers \x3cspan class=\x22hljs-comment\x22\x3e#默认配置入口为nginx.conf.同时servers目录下*.conf文件已自动加入到配置文件列表中\x3c\/span\x3e\nvim test.conf\n\x3cspan class=\x22hljs-comment\x22\x3e#粘贴如下内容\x3c\/span\x3e\nserver {\n  listen       80;\n  server_name  www.test.com;\n  index index.html;\n  error_page   500 502 503 504  \/50x.html;\n  location = \/50x.html {\n      root   html;\n  }\n  location \/ {\n    proxy_pass http:\/\/localhost:10108\/;\n    proxy_redirect off;\n    proxy_set_header Host \x3cspan class=\x22hljs-variable\x22\x3e$host\x3c\/span\x3e;\n    proxy_set_header        X-Read-IP       \x3cspan class=\x22hljs-variable\x22\x3e$remote_addr\x3c\/span\x3e;\n    proxy_set_header        X-Forwarded-For \x3cspan class=\x22hljs-variable\x22\x3e$proxy_add_x_forwarded_for\x3c\/span\x3e;\n  }\n}\n\x3cspan class=\x22hljs-comment\x22\x3e#:wq保存并退出\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e#启动nginx\x3c\/span\x3e\nsudo nginx \x3cspan class=\x22hljs-_\x22\x3e-s\x3c\/span\x3e reload \x3cspan class=\x22hljs-comment\x22\x3e#如果启动了只需重启即可\x3c\/span\x3e\nsudo nginx \x3cspan class=\x22hljs-comment\x22\x3e#如果没有启动,便启动之\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e3) node-webServer 配置\x3c\/p\x3e\n\x3cp\x3e参考 \x3ca href=\x22https:\/\/github.com\/Louiszhai\/node-webserver\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3enode-webserver\x3c\/a\x3e . 启动服务前只需更改index.js, 在第9行后插入如下内容:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x27get\x27: {\n  \x27\/\x27: {\n      getKey : \x27Welcome to Simple Node  WebServer!\x27\n  },\n  \x27接口api\x27: \x27你的response内容\x27\/\/插入的代码                               \n},\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22json hljs\x22\x3e\x3ccode class=\x22json\x22\x3e\x27get\x27: {\n  \x27\/\x27: {\n      getKey : \x27Welcome to Simple Node  WebServer!\x27\n  },\n  \x27接口api\x27: \x27你的response内容\x27\/\/插入的代码                               \n},\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如需在nginx中配置CORS, 请看这里: \x3ca href=\x22http:\/\/mp.weixin.qq.com\/s?__biz=MzI3MTI2NzkxMA==\x26amp;mid=2247484408\x26amp;idx=1\x26amp;sn=5c64dd43ff2060e1c4a22d93e4e887c9\x26amp;scene=1\x26amp;srcid=0901vPdwJR0crm8vJmjboYzI#rd\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eNginx通过CORS实现跨域\x3c\/a\x3e.\x3c\/p\x3e\n\x3ch4\x3e编码问题\x3c\/h4\x3e\n\x3cp\x3eXMLHttpRequest 返回的数据默认的字符编码是utf-8, post方法提交数据默认的字符编码也是utf-8. 若页面编码为gbk等中文编码, 那么就会产生乱码.\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader19\x22\x3e后端接口测试技巧\x3c\/h3\x3e\n\x3cp\x3e通常, 如果后端接口开发OK了, 前端同学需要通过一些手段来确认接口是能正常访问的.\x3c\/p\x3e\n\x3ch4\x3e使用命令测试OPTIONS请求\x3c\/h4\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22curl -I -X OPTIONS -H \x26quot;Origin: http:\/\/example.com\x26quot; http:\/\/localhost:10108\/\n# response\nHTTP\/1.1 200 OK\nX-Powered-By: Express\nContent-Type: text\/json;charset=UTF-8\nAccess-Control-Allow-Credentials: true\nAccess-Control-Allow-Headers: x-requested-with,Content-Type\nAccess-Control-Allow-Methods: GET,POST,PUT,DELETE,OPTIONS\nAccess-Control-Allow-Origin: http:\/\/example.com\nAccess-Control-Max-Age: 3600\nServer: Node WebServer\nWebsite: https:\/\/github.com\/Louiszhai\/node-webserver\nDate: Fri, 21 Oct 2016 09:00:40 GMT\nConnection: keep-alive\nTransfer-Encoding: chunked\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22bash hljs\x22\x3e\x3ccode class=\x22bash\x22\x3ecurl -I -X OPTIONS -H \x3cspan class=\x22hljs-string\x22\x3e\x22Origin: http:\/\/example.com\x22\x3c\/span\x3e http:\/\/localhost:10108\/\n\x3cspan class=\x22hljs-comment\x22\x3e# response\x3c\/span\x3e\nHTTP\/1.1 200 OK\nX-Powered-By: Express\nContent-Type: text\/json;charset=UTF-8\nAccess-Control-Allow-Credentials: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\nAccess-Control-Allow-Headers: x-requested-with,Content-Type\nAccess-Control-Allow-Methods: GET,POST,PUT,DELETE,OPTIONS\nAccess-Control-Allow-Origin: http:\/\/example.com\nAccess-Control-Max-Age: 3600\nServer: Node WebServer\nWebsite: https:\/\/github.com\/Louiszhai\/node-webserver\nDate: Fri, 21 Oct 2016 09:00:40 GMT\nConnection: keep-alive\nTransfer-Encoding: chunked\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上, http状态码为200, 表示允许OPTIONS请求.\x3c\/p\x3e\n\x3cp\x3eGET, POST 请求与GET类似, 其他请求亦然.\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22curl -I -X GET -H \x26quot;Origin: http:\/\/example.com\x26quot; http:\/\/localhost:10108\/\n#HTTP\/1.1 200 OK\ncurl -I -X POST -H \x26quot;Origin: http:\/\/example.com\x26quot; http:\/\/localhost:10108\/test\n#HTTP\/1.1 200 OK\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22bash hljs\x22\x3e\x3ccode class=\x22bash\x22\x3ecurl -I -X GET -H \x3cspan class=\x22hljs-string\x22\x3e\x22Origin: http:\/\/example.com\x22\x3c\/span\x3e http:\/\/localhost:10108\/\n\x3cspan class=\x22hljs-comment\x22\x3e#HTTP\/1.1 200 OK\x3c\/span\x3e\ncurl -I -X POST -H \x3cspan class=\x22hljs-string\x22\x3e\x22Origin: http:\/\/example.com\x22\x3c\/span\x3e http:\/\/localhost:10108\/\x3cspan class=\x22hljs-built_in\x22\x3etest\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e#HTTP\/1.1 200 OK\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3epostman\x3c\/h4\x3e\n\x3cp\x3e除此之外, 我们还可以通过chrome的postman扩展进行测试. 请看postman素洁的界面:\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000008697467?w=1023\x26amp;h=349\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000008697467?w=1023\x26amp;h=349\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3epostman支持所有类型的http请求, 由于其向chrome申请了cookie访问权限及所有http(s)网站的访问权限. 因此可以放心使用它进行各种网站api的测试.\x3c\/p\x3e\n\x3cp\x3e同时, 强烈建议阅读本文的你升级postman的使用技巧, 这里有篇: \x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000005055899\x22\x3e基于Postman的API自动化测试\x3c\/a\x3e , 拿走不谢.\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader20\x22\x3eajax移动端兼容性\x3c\/h3\x3e\n\x3cp\x3e移动端的支持性比较弱, 使用需谨慎. 看表.\x3c\/p\x3e\n\x3ctable\x3e\n\x3cthead\x3e\x3ctr\x3e\n\x3cth align=\x22center\x22\x3e \x3c\/th\x3e\n\x3cth align=\x22center\x22\x3eIOS Safari\x3c\/th\x3e\n\x3cth align=\x22center\x22\x3eOpera Mini\x3c\/th\x3e\n\x3cth align=\x22center\x22\x3eAndroid Browser\x3c\/th\x3e\n\x3cth align=\x22center\x22\x3eAndroid Chrome\x3c\/th\x3e\n\x3cth align=\x22center\x22\x3eAndroid UC\x3c\/th\x3e\n\x3c\/tr\x3e\x3c\/thead\x3e\n\x3ctbody\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3eXMLHttpRequest\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e8.4\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e-\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e4.4.4\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e53\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e11(part)\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3efetch\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e-\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e-\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e52\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e53\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e-\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3c\/tbody\x3e\n\x3c\/table\x3e\n\x3cp\x3e本篇为ajax而生, 通篇介绍 XMLHTTPRequest 相关的知识, 力求简明, 本欲为梳理知识, 为读者答疑解惑, 但因本人理解所限, 难免有所局限, 希望正在阅读的你取其精华去其糟粕. 谢谢.\x3c\/p\x3e\n\x3chr\x3e\n\x3cp\x3e本文就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与留言和评论.\x3c\/p\x3e\n\x3cp\x3e本文作者: \x3ca href=\x22https:\/\/github.com\/Louiszhai\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3elouis\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e本文链接: \x3ca href=\x22http:\/\/louiszhai.github.io\/2016\/11\/02\/ajax\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/louiszhai.github.io\/20...\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e参考文章\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/xhr.spec.whatwg.org\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eXMLHttpRequest Standard\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/www.ruanyifeng.com\/blog\/2012\/09\/xmlhttprequest_level_2.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eXMLHttpRequest Level 2 使用指南 - 阮一峰的网络日志\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000004322487\x22\x3e你真的会使用XMLHttpRequest吗？ - WEB前端路上踩过的坑儿 - SegmentFault\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/www.zhangxinxu.com\/wordpress\/2013\/06\/html5-history-api-pushstate-replacestate-ajax\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eajax与HTML5 history pushState\/replaceState实例 « 张鑫旭-鑫空间-鑫生活\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/www.ruanyifeng.com\/blog\/2016\/04\/cors.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e跨域资源共享 CORS 详解 - 阮一峰的网络日志\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/www.jquery123.com\/jQuery.ajax\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ejQuery.ajax() | jQuery API 中文文档 -- jQuery 中文网\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>Ajax知识体系大梳理</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000008697448">https://segmentfault.com/a/1190000008697448</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/64q9xkchzh4/" target="_blank">https://alili.tech/archive/64q9xkchzh4/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>