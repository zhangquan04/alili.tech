<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="webpack 中的 watch &amp; cache （上）"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>webpack 中的 watch &amp; cache （上） | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/6wanx5muaxy/",
				"appid": "1613049289050283", 
				"title": "webpack 中的 watch &amp; cache （上） | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-28T02:30:09"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/mhif8y5rnv/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/98hq3w0e3ha/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f6wanx5muaxy%2f&text=webpack%20%e4%b8%ad%e7%9a%84%20watch%20%26%20cache%20%ef%bc%88%e4%b8%8a%ef%bc%89"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f6wanx5muaxy%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f6wanx5muaxy%2f&text=webpack%20%e4%b8%ad%e7%9a%84%20watch%20%26%20cache%20%ef%bc%88%e4%b8%8a%ef%bc%89"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f6wanx5muaxy%2f&title=webpack%20%e4%b8%ad%e7%9a%84%20watch%20%26%20cache%20%ef%bc%88%e4%b8%8a%ef%bc%89"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f6wanx5muaxy%2f&is_video=false&description=webpack%20%e4%b8%ad%e7%9a%84%20watch%20%26%20cache%20%ef%bc%88%e4%b8%8a%ef%bc%89"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=webpack%20%e4%b8%ad%e7%9a%84%20watch%20%26%20cache%20%ef%bc%88%e4%b8%8a%ef%bc%89&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f6wanx5muaxy%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f6wanx5muaxy%2f&title=webpack%20%e4%b8%ad%e7%9a%84%20watch%20%26%20cache%20%ef%bc%88%e4%b8%8a%ef%bc%89"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f6wanx5muaxy%2f&title=webpack%20%e4%b8%ad%e7%9a%84%20watch%20%26%20cache%20%ef%bc%88%e4%b8%8a%ef%bc%89"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f6wanx5muaxy%2f&title=webpack%20%e4%b8%ad%e7%9a%84%20watch%20%26%20cache%20%ef%bc%88%e4%b8%8a%ef%bc%89"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f6wanx5muaxy%2f&title=webpack%20%e4%b8%ad%e7%9a%84%20watch%20%26%20cache%20%ef%bc%88%e4%b8%8a%ef%bc%89"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">webpack 中的 watch &amp; cache （上）</h1><div class="meta"><div class="postdate"><time datetime="2019-01-28" itemprop="datePublished">2019-01-28</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e我们在日常使用 \x3ccode\x3ewebpack\x3c\/code\x3e 或者是在以它为基础开发的时候，可能更多的时候关注的是配置以及配置的插件开发。在日常的开发过程中，会发现 \x3ccode\x3ewatch\x3c\/code\x3e 状态下的编译流程有一个规律是，第一次会较为缓慢，后续的编译会很快速，看起来像是有缓存的控制，那么具体内部的缓存流程存在哪些节点呢？下面进行一些探索总结，希望能为日常的插件 \x3ccode\x3eplugin\x3c\/code\x3e、\x3ccode\x3eloader\x3c\/code\x3e 开发起到帮助。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3ewebpack --watch\x3c\/h2\x3e\n\x3cp\x3e对于 cache 使用的入口，其实在我们日常构建中，大多是借助 \x3ccode\x3ewebpack\x3c\/code\x3e 启动一个构建 \x3ccode\x3ewatch 服务\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3e入口\x3c\/h3\x3e\n\x3cp\x3e最普通的相比于 \x3ccode\x3ewebpack\x3c\/code\x3e 不带参数直接执行的方式， \x3ccode\x3ewebpack --watch\x3c\/code\x3e 的执行逻辑存在较为明显的区别。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22webpack\/bin\/webpack.js:\n\nif(options.watch) {\n  var primaryOptions = !Array.isArray(options) ? options : options[0];\n  var watchOptions = primaryOptions.watchOptions || primaryOptions.watch || {};\n  if(watchOptions.stdin) {\n    process.stdin.on(\x27end\x27, function() {\n      process.exit(0); \/\/ eslint-disable-line\n    });\n    process.stdin.resume();\n  }\n  compiler.watch(watchOptions, compilerCallback);\n} else\n  compiler.run(compilerCallback);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3ewebpack\/bin\/webpack.js:\n\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(options.watch) {\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e primaryOptions = !\x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.isArray(options) ? options : options[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e];\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e watchOptions = primaryOptions.watchOptions || primaryOptions.watch || {};\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(watchOptions.stdin) {\n    process.stdin.on(\x3cspan class=\x22hljs-string\x22\x3e\x27end\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n      process.exit(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ eslint-disable-line\x3c\/span\x3e\n    });\n    process.stdin.resume();\n  }\n  compiler.watch(watchOptions, compilerCallback);\n} \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e\n  compiler.run(compilerCallback);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e从执行文件中 \x3ccode\x3ewebpack\/bin\/webpack.js\x3c\/code\x3e 找到 \x3ccode\x3e --watch\x3c\/code\x3e 逻辑，相比于直接 \x3ccode\x3ewebpack\x3c\/code\x3e 不带参数执行对应的是 \x3ccode\x3ecompiler.run\x3c\/code\x3e 方法，\x3ccode\x3e--watch\x3c\/code\x3e 则对应的是 \x3ccode\x3ecompiler.watch\x3c\/code\x3e 方法。\x3c\/p\x3e\n\x3cp\x3e除了 \x3ccode\x3ewebpack --watch\x3c\/code\x3e 调用，这里还可以关联一下在日常使用中很平常的 \x3cstrong\x3e\x3ca href=\x22https:\/\/github.com\/webpack\/webpack-dev-middleware\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ewebpack-dev-middleware\x3c\/a\x3e\x3c\/strong\x3e 模块。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22webpack-dev-middleware\/middleware.js:\n\nif(!options.lazy) {\n  var watching = compiler.watch(options.watchOptions, function(err) {\n    if(err) throw err;\n  });\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3ewebpack-dev-middleware\/middleware.js:\n\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(!options.lazy) {\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e watching = compiler.watch(options.watchOptions, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(err) \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e err;\n  });\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e从代码可以看到，在非 \x3ccode\x3elazy\x3c\/code\x3e（\x3ccode\x3elazy\x3c\/code\x3e 模式指的是根据请求来源情况来直接调用 \x3ccode\x3ecompiler.run\x3c\/code\x3e 进行构建）模式下，实际上也是同样通过 \x3ccode\x3ecompiler.watch\x3c\/code\x3e 方法进行文件的监听编译。印证了前面的\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e大多是借助 \x3ccode\x3ewebpack\x3c\/code\x3e 启动一个构建 \x3ccode\x3ewatch 服务\x3c\/code\x3e\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e更准确的说法是，通过 \x3ccode\x3ecompiler.watch\x3c\/code\x3e 来创建 \x3ccode\x3ewatch\x3c\/code\x3e 服务。\x3c\/p\x3e\n\x3cp\x3e\x3cimg alt=\x22\x22 title=\x22\x22 src=\x22https:\/\/static.alili.techundefined\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/p\x3e\n\x3cp\x3e如图对应上文不同调用方式之间的差异。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3ewatch 编译生命周期\x3c\/h3\x3e\n\x3cp\x3e上面小结的内容，在整个 \x3ccode\x3ewebpack\x3c\/code\x3e 的过程中，是处在完成 \x3ccode\x3ecompiler = webpack(config)\x3c\/code\x3e 函数调用之后，得到一个 \x3ccode\x3eCompiler\x3c\/code\x3e 实例之后，进行正式编译流程之前的节点，详细的编译流程文章推荐 [][]\x3ca href=\x22http:\/\/www.atatech.org\/articles\/67450\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eWebpack 源码（二）—— 如何阅读源码\x3c\/a\x3e、\x3ca href=\x22http:\/\/taobaofed.org\/blog\/2016\/09\/09\/webpack-flow\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e细说 webpack 之流程篇\x3c\/a\x3e ，后续我们也会不断输出一些细节实现的文章。\x3c\/p\x3e\n\x3cp\x3e对于 \x3ccode\x3ewatch\x3c\/code\x3e 这种需要不断进行触发编译的流程的情况，会出现不断重复地经历几个相同流程，可以称之为 watch 的 \x3ccode\x3e生命周期\x3c\/code\x3e，而 cache 的出现和使用同样也融入了在这个\x3ccode\x3e生命周期\x3c\/code\x3e中。\x3c\/p\x3e\n\x3col\x3e\x3cli\x3e\n\x3cp\x3e生成 \x3ccode\x3e Watching\x3c\/code\x3e 实例 \x3ccode\x3ewatching\x3c\/code\x3e，将编译流程控制交给 \x3ccode\x3ewatching\x3c\/code\x3e。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22webpack\/lib\/Compiler.js\n\nCompiler.prototype.watch = function(watchOptions, handler) {\n  this.fileTimestamps = {};\n  this.contextTimestamps = {};\n  var watching = new Watching(this, watchOptions, handler);\n  return watching;\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3ewebpack\/lib\/Compiler.js\n\nCompiler.prototype.watch = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ewatchOptions, handler\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.fileTimestamps = {};\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.contextTimestamps = {};\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e watching = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Watching(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, watchOptions, handler);\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e watching;\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e无论是 \x3ccode\x3ewebpack --watch\x3c\/code\x3e，还是 \x3cstrong\x3e\x3ca href=\x22https:\/\/github.com\/webpack\/webpack-dev-middleware\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ewebpack-dev-middleware\x3c\/a\x3e\x3c\/strong\x3e 模块，都是调用 \x3ccode\x3ecompiler.watch\x3c\/code\x3e 方法进行初始化 \x3ccode\x3ewatch\x3c\/code\x3e 流程，在 \x3ccode\x3eCompiler.prototype.watch\x3c\/code\x3e 逻辑中，与 \x3ccode\x3eCompiler.prototype.run\x3c\/code\x3e \x3cstrong\x3e在方法中完成具体编译流程\x3c\/strong\x3e不同的是，会通过生成 \x3ccode\x3ewatching\x3c\/code\x3e 实例来\x3cstrong\x3e接管具体编译流程\x3c\/strong\x3e。\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\n\x3cp\x3e构造实例，进行第一次编译初始化\x3cbr\x3e\x3ccode\x3ewatching\x3c\/code\x3e 作为 \x3ccode\x3ewatch\x3c\/code\x3e 监听流程中的最上层对象，满足了 \x3ccode\x3ewatch\x3c\/code\x3e 流程在逻辑最上层的各个阶段衔接。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22webpack\/lib\/Compiler.js\n\nfunction Watching(compiler, watchOptions, handler) {\n  this.startTime = null;\n  this.invalid = false;\n  this.error = null;\n  this.stats = null;\n  this.handler = handler;\n  if(typeof watchOptions === \x26quot;number\x26quot;) {\n    this.watchOptions = {\n      aggregateTimeout: watchOptions\n    };\n  } else if(watchOptions \x26amp;\x26amp; typeof watchOptions === \x26quot;object\x26quot;) {\n    this.watchOptions = Object.create(watchOptions);\n  } else {\n    this.watchOptions = {};\n  }\n  this.watchOptions.aggregateTimeout = this.watchOptions.aggregateTimeout || 200;\n  this.compiler = compiler;\n  this.running = true;\n  this.compiler.readRecords(function(err) {\n    if(err) return this._done(err);\n\n    this._go();\n  }.bind(this));\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3ewebpack\/lib\/Compiler.js\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eWatching\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ecompiler, watchOptions, handler\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.startTime = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.invalid = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.error = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.stats = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handler = handler;\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e watchOptions === \x3cspan class=\x22hljs-string\x22\x3e\x22number\x22\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watchOptions = {\n      \x3cspan class=\x22hljs-attr\x22\x3eaggregateTimeout\x3c\/span\x3e: watchOptions\n    };\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(watchOptions \x26amp;\x26amp; \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e watchOptions === \x3cspan class=\x22hljs-string\x22\x3e\x22object\x22\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watchOptions = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.create(watchOptions);\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watchOptions = {};\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watchOptions.aggregateTimeout = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watchOptions.aggregateTimeout || \x3cspan class=\x22hljs-number\x22\x3e200\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.compiler = compiler;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.running = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.compiler.readRecords(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(err) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._done(err);\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._go();\n  }.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e));\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e对于 \x3ccode\x3eWatching\x3c\/code\x3e 构造函数，其实可以分成两个部分\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\n\x3cp\x3e基础属性设置\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3estartTime\x3c\/code\x3e：执行每次编译时(\x3ccode\x3eWatching.prototype._go\x3c\/code\x3e 方法调用)  ，会赋值编译启动时间，在后续文件是否需要再次编译时，作为重要根据之一\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3einvalid\x3c\/code\x3e：表明现在 \x3ccode\x3ewatching \x3c\/code\x3e 的调用状态，例如在 \x3ccode\x3ethis.runing\x3c\/code\x3e 为 true 时，表明运行正常，会赋值该属性为 \x3ccode\x3etrue\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eerror\x3c\/code\x3e：存放编译过程的错误对象，完成每次编译后会回传给 \x3ccode\x3ehandler\x3c\/code\x3e 回调\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3estats \x3c\/code\x3e：存放编译过程中的各个数值，同样也是会在每次编译后会回传给 \x3ccode\x3ehandler\x3c\/code\x3e 回调\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3ehandler\x3c\/code\x3e：指的是，每次编译完执行的回调函数，一个常见的例子是每次编译完在命令行中出现的资源列表就是通过这个函数实现\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3ewatchOptions\x3c\/code\x3e：\x3ccode\x3ewatch\x3c\/code\x3e 调用参数设置，其中 \x3ccode\x3eaggregateTimeout\x3c\/code\x3e 参数代表的是每一次文件（夹）变化后在 \x3ccode\x3eaggregateTimeout\x3c\/code\x3e 值内的变化都会进行合并发送\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3ecompiler\x3c\/code\x3e：生成 \x3ccode\x3ewatching\x3c\/code\x3e 对象的 \x3ccode\x3eCompiler\x3c\/code\x3e 实例\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3erunning\x3c\/code\x3e： \x3ccode\x3ewatching \x3c\/code\x3e实例的运行状态\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e执行初始化编译\x3cbr\x3e从 \x3ccode\x3ethis._go\x3c\/code\x3e 调用开始，就会进入 \x3ccode\x3e编译\x3c\/code\x3e -\x26gt; \x3ccode\x3ewatch监听编译\x3c\/code\x3e -\x26gt; \x3ccode\x3e文件变更触发编译\x3c\/code\x3e -\x26gt;  \x3ccode\x3e编译\x3c\/code\x3e 的循环\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e执行编译\x3cbr\x3e作为执行编译的入口 \x3ccode\x3eWatching.prototype._go\x3c\/code\x3e 函数的结构与 \x3ccode\x3eCompiler.prototype.run\x3c\/code\x3e 的结构类似，都是调用 \x3ccode\x3eCompiler\x3c\/code\x3e 提供的诸如 \x3ccode\x3ethis.compile\x3c\/code\x3e 、this.\x3ccode\x3eemitAssets\x3c\/code\x3e 等方法完成编译过程。\x3cbr\x3e\x3ca href=\x22http:\/\/gw.alicdn.com\/tfs\/TB1pvdmOVXXXXXDapXXXXXXXXXX-1064-488.png\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000008111796?w=1064\x26amp;h=488\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000008111796?w=1064\x26amp;h=488\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/a\x3e\x3cbr\x3e与 \x3ccode\x3erun\x3c\/code\x3e 类似，\x3ccode\x3e_go\x3c\/code\x3e 函数同样会调用 \x3ccode\x3ecompiler.compile\x3c\/code\x3e 方法进行编译，同时在完成 \x3ccode\x3eemitAssets\x3c\/code\x3e (资源输出)、\x3ccode\x3eemitRecords\x3c\/code\x3e (记录输出) 后，也就是完成这一次编译后，会调用 \x3ccode\x3ethis.done\x3c\/code\x3e 方法进行 \x3ccode\x3ewatch\x3c\/code\x3e 循环的最后一步\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e调用文件监听\x3cbr\x3e  在完成编译后，为了在不重复启动编译进程的情况下，文件改动会自动重新编译。会在 \x3ccode\x3eWatching.prototype._done\x3c\/code\x3e 中实时监听文件操作进行编译。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Watching.prototype._done = function(err, compilation) {\n \/\/ 省略部分流程(结束状态值设置、结束事件触发等)\n if(!this.error)\n     this.watch(compilation.fileDependencies, compilation.contextDependencies, compilation.missingDependencies);\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eWatching.prototype._done = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eerr, compilation\x3c\/span\x3e) \x3c\/span\x3e{\n \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 省略部分流程(结束状态值设置、结束事件触发等)\x3c\/span\x3e\n \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(!\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.error)\n     \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watch(compilation.fileDependencies, compilation.contextDependencies, compilation.missingDependencies);\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里在 \x3ccode\x3e_done\x3c\/code\x3e 的最后一个步骤，会调用 \x3ccode\x3eWatching.prototype.watch\x3c\/code\x3e 来进行文件监听：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Watching.prototype.watch = function(files, dirs, missing) {\n this.watcher = this.compiler.watchFileSystem.watch(files, dirs, missing, this.startTime, this.watchOptions, function(err, filesModified, contextModified, missingModified, fileTimestamps, contextTimestamps) {\n     this.watcher = null;\n     if(err) return this.handler(err);\n\n     this.compiler.fileTimestamps = fileTimestamps;\n     this.compiler.contextTimestamps = contextTimestamps;\n     this.invalidate();\n }.bind(this), function() {\n     this.compiler.applyPlugins(\x26quot;invalid\x26quot;);\n }.bind(this));\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eWatching.prototype.watch = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3efiles, dirs, missing\x3c\/span\x3e) \x3c\/span\x3e{\n \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watcher = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.compiler.watchFileSystem.watch(files, dirs, missing, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.startTime, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watchOptions, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eerr, filesModified, contextModified, missingModified, fileTimestamps, contextTimestamps\x3c\/span\x3e) \x3c\/span\x3e{\n     \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watcher = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n     \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(err) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handler(err);\n\n     \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.compiler.fileTimestamps = fileTimestamps;\n     \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.compiler.contextTimestamps = contextTimestamps;\n     \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.invalidate();\n }.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e), \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n     \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.compiler.applyPlugins(\x3cspan class=\x22hljs-string\x22\x3e\x22invalid\x22\x3c\/span\x3e);\n }.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e));\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e\x3ccode\x3eWatching.prototype.watch\x3c\/code\x3e 通过 \x3ccode\x3ecompiler.watchFileSystem\x3c\/code\x3e 的 \x3ccode\x3ewatch\x3c\/code\x3e 方法实现，可以大致看出在文件（夹）变化触发编译后，会执行传递的回调函数，最终会调用 \x3ccode\x3eWatching.prototype.invalidate\x3c\/code\x3e 进行编译触发：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Watching.prototype.invalidate = function() {\n    if(this.watcher) {\n        this.watcher.pause();\n        this.watcher = null;\n    }\n    if(this.running) {\n        this.invalid = true;\n        return false;\n    } else {\n        this._go();\n    }\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eWatching.prototype.invalidate = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watcher) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watcher.pause();\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watcher = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.running) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.invalid = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._go();\n    }\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e到了 \x3ccode\x3eWatching.prototype.invalide\x3c\/code\x3e 这个方法后，又去从 \x3ccode\x3eWatching.prototype._go\x3c\/code\x3e 函数开始进行新一轮的编译，到这里整个 watch 的流程就串起来了。\x3c\/p\x3e\n\x3c\/li\x3e\x3c\/ol\x3e\n\x3cp\x3e在进入 \x3ccode\x3ewatchFileSystem\x3c\/code\x3e 之前，回顾上面的整个流程，\x3ccode\x3ewebpack\x3c\/code\x3e 中的 \x3ccode\x3ewatch\x3c\/code\x3e 流程大致就是 \x3ccode\x3eWatching.prototype._go\x3c\/code\x3e -\x26gt; \x3ccode\x3eWatching.prototype.watch\x3c\/code\x3e -\x26gt; \x3ccode\x3eWatching.prototype.invalidate\x3c\/code\x3e 三个函数循环调用的过程。衔接初始化截图，大致如下图。\x3c\/p\x3e\n\x3cp\x3e\x3cimg alt=\x22\x22 title=\x22\x22 src=\x22https:\/\/static.alili.techundefined\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/p\x3e\n\x3cp\x3e后续主要对 \x3ccode\x3e监听\x3c\/code\x3e 和 \x3ccode\x3e触发\x3c\/code\x3e 两个部分所涉及的一些细节进行深入。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3ewatchFileSystem\x3c\/h3\x3e\n\x3cp\x3e由上面内容看出对于 \x3ccode\x3eWatching.prototype.watch\x3c\/code\x3e 实现文件监听的核心是 \x3ccode\x3ecompiler.watchFileSystem\x3c\/code\x3e 对象的 \x3ccode\x3ewatch\x3c\/code\x3e 方法。 \x3ccode\x3ewatchFileSystem\x3c\/code\x3e 在 \x3ccode\x3ewebpack\x3c\/code\x3e 中通过 \x3ccode\x3eNodeEnvironmentPlugin\x3c\/code\x3e 来进行加载\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22webpack\/lib\/node\/NodeEnvironmentPlugin.js\n\nvar NodeWatchFileSystem = require(\x26quot;.\/NodeWatchFileSystem\x26quot;);\n\nNodeEnvironmentPlugin.prototype.apply = function(compiler) {\n    compiler.inputFileSystem = new NodeJsInputFileSystem();\n    var inputFileSystem = compiler.inputFileSystem = new        CachedInputFileSystem(compiler.inputFileSystem, 60000);\n    compiler.resolvers.normal.fileSystem = compiler.inputFileSystem;\n    compiler.resolvers.context.fileSystem = compiler.inputFileSystem;\n    compiler.resolvers.loader.fileSystem = compiler.inputFileSystem;\n    compiler.outputFileSystem = new NodeOutputFileSystem();\n    compiler.watchFileSystem = new NodeWatchFileSystem(compiler.inputFileSystem);\n    compiler.plugin(\x26quot;run\x26quot;, function(compiler, callback) {\n        if(compiler.inputFileSystem === inputFileSystem)\n            inputFileSystem.purge();\n        callback();\n    });\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3ewebpack\/lib\/node\/NodeEnvironmentPlugin.js\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e NodeWatchFileSystem = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22.\/NodeWatchFileSystem\x22\x3c\/span\x3e);\n\nNodeEnvironmentPlugin.prototype.apply = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ecompiler\x3c\/span\x3e) \x3c\/span\x3e{\n    compiler.inputFileSystem = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e NodeJsInputFileSystem();\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e inputFileSystem = compiler.inputFileSystem = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e        CachedInputFileSystem(compiler.inputFileSystem, \x3cspan class=\x22hljs-number\x22\x3e60000\x3c\/span\x3e);\n    compiler.resolvers.normal.fileSystem = compiler.inputFileSystem;\n    compiler.resolvers.context.fileSystem = compiler.inputFileSystem;\n    compiler.resolvers.loader.fileSystem = compiler.inputFileSystem;\n    compiler.outputFileSystem = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e NodeOutputFileSystem();\n    compiler.watchFileSystem = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e NodeWatchFileSystem(compiler.inputFileSystem);\n    compiler.plugin(\x3cspan class=\x22hljs-string\x22\x3e\x22run\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ecompiler, callback\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(compiler.inputFileSystem === inputFileSystem)\n            inputFileSystem.purge();\n        callback();\n    });\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里会设置很多的 \x3ccode\x3efileSystem\x3c\/code\x3e ，而这样做的好处可以关联到前面的  \x3cstrong\x3e\x3ca href=\x22https:\/\/github.com\/webpack\/webpack-dev-middleware\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ewebpack-dev-middleware\x3c\/a\x3e\x3c\/strong\x3e 模块，在本地调试等对编译性能有较高要求的场景下，需要尽量利用缓存的速度，而  \x3ccode\x3ewebpack-dev-middleware\x3c\/code\x3e  将物理 io 切换成缓存设置，通过修改 \x3ccode\x3efileSystem\x3c\/code\x3e 来实现。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22webpack-dev-middleware\/middleware.js\n\nvar fs = new MemoryFileSystem();\n\n\/\/ the base output path for web and webworker bundles\nvar outputPath;\n\ncompiler.outputFileSystem = fs;\noutputPath = compiler.outputPath;\n    \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3ewebpack-dev-middleware\/middleware.js\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e fs = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e MemoryFileSystem();\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ the base output path for web and webworker bundles\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e outputPath;\n\ncompiler.outputFileSystem = fs;\noutputPath = compiler.outputPath;\n    \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e将 \x3ccode\x3ecompiler\x3c\/code\x3e 的 \x3ccode\x3eoutputFileSystem\x3c\/code\x3e 设置成内存 (\x3ccode\x3eMemoryFileSystem\x3c\/code\x3e) 的方式，将资源编译文件不落地输出，大大提高编译性能。在 \x3ccode\x3ewebpack\x3c\/code\x3e 中存在文件系统的抽象处理，方便一些优秀的文件系统处理模块功能（例如读取缓存、内存读写）接入利用。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000008111797?w=730\x26amp;h=233\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000008111797?w=730\x26amp;h=233\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e例如 \x3ccode\x3ewebpack\x3c\/code\x3e 默认采用的是 \x3ca href=\x22http:\/\/web.npm.alibaba-inc.com\/package\/graceful-fs\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3egraceful-fs\x3c\/a\x3e，本身基于 Node.js 中的 fs 模块进行了许多优化，而 \x3ccode\x3ewebpack-dev-middleware\x3c\/code\x3e 则是采用内存读取的 \x3ca href=\x22http:\/\/web.npm.alibaba-inc.com\/package\/memory-fs\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ememory-fs\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e对照 \x3ccode\x3eNodeEnvironmentPlugin\x3c\/code\x3e 的代码，可以看到 \x3ccode\x3ewatchFileSystem\x3c\/code\x3e 指向的是同目录下的 \x3ccode\x3eNodeWatchFileSystem.js\x3c\/code\x3e 导出的构造函数生成的实例。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22webpack\/lib\/node\/NodeWatchFileSystem.js\n\nvar Watchpack = require(\x26quot;watchpack\x26quot;);\n\nfunction NodeWatchFileSystem(inputFileSystem) {\n    this.inputFileSystem = inputFileSystem;\n    this.watcherOptions = {\n        aggregateTimeout: 0\n    };\n    this.watcher = new Watchpack(this.watcherOptions);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3ewebpack\/lib\/node\/NodeWatchFileSystem.js\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Watchpack = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22watchpack\x22\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eNodeWatchFileSystem\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3einputFileSystem\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.inputFileSystem = inputFileSystem;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watcherOptions = {\n        \x3cspan class=\x22hljs-attr\x22\x3eaggregateTimeout\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n    };\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watcher = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Watchpack(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watcherOptions);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在 \x3ccode\x3eNodeWatchFileSystem.js\x3c\/code\x3e 中的实现再一次的依赖 \x3cstrong\x3e\x3ca href=\x22http:\/\/web.npm.alibaba-inc.com\/package\/watchpack\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ewatchpack\x3c\/a\x3e\x3c\/strong\x3e 完成。通过封装 \x3ccode\x3ewatchpack\x3c\/code\x3e 的监听逻辑，完成绑定相应的文件变更事件，进行上层 \x3ccode\x3ecompiler.invalidate\x3c\/code\x3e 方法调用，触发再次编译流程。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22webpack\/lib\/node\/NodeWatchFileSystem.js\n\nNodeWatchFileSystem.prototype.watch = function watch(files, dirs, missing, startTime, options, callback, callbackUndelayed) {\n    \/\/ 省略异常处理\n  \n    if(callbackUndelayed)\n        this.watcher.once(\x26quot;change\x26quot;, callbackUndelayed);\n\n    this.watcher.once(\x26quot;aggregated\x26quot;, function(changes) {\n        \/\/ 省略具体流程\n        callback(...);\n    }.bind(this));\n      \n      this.watcher.watch(files.concat(missing), dirs, startTime);\n     \/\/ 省略返回\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3ewebpack\/lib\/node\/NodeWatchFileSystem.js\n\nNodeWatchFileSystem.prototype.watch = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ewatch\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3efiles, dirs, missing, startTime, options, callback, callbackUndelayed\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 省略异常处理\x3c\/span\x3e\n  \n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(callbackUndelayed)\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watcher.once(\x3cspan class=\x22hljs-string\x22\x3e\x22change\x22\x3c\/span\x3e, callbackUndelayed);\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watcher.once(\x3cspan class=\x22hljs-string\x22\x3e\x22aggregated\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3echanges\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 省略具体流程\x3c\/span\x3e\n        callback(...);\n    }.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e));\n      \n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watcher.watch(files.concat(missing), dirs, startTime);\n     \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 省略返回\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里的 \x3ccode\x3ecallback\x3c\/code\x3e 就是 \x3ccode\x3eWatching.prototype.watch\x3c\/code\x3e 方法中调用 \x3ccode\x3ethis.compiler.watchFileSystem.watch\x3c\/code\x3e 传递的回调函数，当用户触发了 \x3ccode\x3ewatchpack\x3c\/code\x3e 提供的文件(夹)变化事件，那么就会通过 \x3ccode\x3ecallback\x3c\/code\x3e 回调中 \x3ccode\x3eWatching.prototype.invalidate\x3c\/code\x3e 进行再次编译。在进入 \x3ccode\x3ewatchpack\x3c\/code\x3e 细节之前总结一下 \x3ccode\x3ewatch\x3c\/code\x3e 调用层级。\x3c\/p\x3e\n\x3cp\x3e\x3cimg alt=\x22\x22 title=\x22\x22 src=\x22https:\/\/static.alili.techundefined\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/p\x3e\n\x3cp\x3e在 \x3ccode\x3ewebpack\x3c\/code\x3e 中的 \x3ccode\x3ewatch\x3c\/code\x3e 调用，每一层都叫做 \x3ccode\x3ewatch\x3c\/code\x3e 方法，在每一个 \x3ccode\x3ewatch\x3c\/code\x3e 方法中，都通过逐步对下一层的依赖调用，完成从 \x3ccode\x3ewatching\x3c\/code\x3e 实例与 \x3ccode\x3ewatcher\x3c\/code\x3e 实例的衔接解耦。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e在 \x3ccode\x3ewatching\x3c\/code\x3e 层，完成对重新编译的回调绑定\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e在 \x3ccode\x3ewatchfileSystem\x3c\/code\x3e 层，完成对下层监听文件（夹）触发逻辑之后信息返回的过滤处理，以及对上层回调的调用\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e在 \x3ccode\x3ewatcer\x3c\/code\x3e 层，只负责对文件（夹）的变化的事件监听\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e通过多个层级的划分，解耦逻辑，方便函数进行调整和功能横向扩展。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3ewatchpack 监听\x3c\/h3\x3e\n\x3cp\x3e由上面 \x3ccode\x3eNodeWatchFileSystem.js\x3c\/code\x3e 的代码截断中可以看到，对应的 \x3ccode\x3ewatch\x3c\/code\x3e 方法，核心逻辑是 \x3ccode\x3ewatchpack\x3c\/code\x3e 的实例 \x3ccode\x3ewatcher\x3c\/code\x3e 对应的 \x3ccode\x3ewatch\x3c\/code\x3e 方法。直接找到对应的 \x3ccode\x3eWatchpack.prototype.watch\x3c\/code\x3e 方法\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22watchpack\/lib\/watchpack.js\n\nvar watcherManager = require(\x26quot;.\/watcherManager\x26quot;);\nWatchpack.prototype.watch = function watch(files, directories, startTime) {\n    this.paused = false;\n    \/\/ 省略 old watchers 处理\n  \n    this.fileWatchers = files.map(function(file) {\n        return this._fileWatcher(file, watcherManager.watchFile(file, this.watcherOptions, startTime));\n    }, this);\n    this.dirWatchers = directories.map(function(dir) {\n        return this._dirWatcher(dir, watcherManager.watchDirectory(dir, this.watcherOptions, startTime));\n    }, this);\n\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3ewatchpack\/lib\/watchpack.js\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e watcherManager = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22.\/watcherManager\x22\x3c\/span\x3e);\nWatchpack.prototype.watch = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ewatch\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3efiles, directories, startTime\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.paused = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 省略 old watchers 处理\x3c\/span\x3e\n  \n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.fileWatchers = files.map(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3efile\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._fileWatcher(file, watcherManager.watchFile(file, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watcherOptions, startTime));\n    }, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.dirWatchers = directories.map(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edir\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._dirWatcher(dir, watcherManager.watchDirectory(dir, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watcherOptions, startTime));\n    }, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e衔接上一层在 \x3ccode\x3eNodeWatchFileSystem.js\x3c\/code\x3e 中 \x3ccode\x3ethis.watcher.watch(files.concat(missing), dirs, startTime);\x3c\/code\x3e 的调用，在 \x3ccode\x3ewatchpack\x3c\/code\x3e 实例的 \x3ccode\x3ewatch\x3c\/code\x3e 方法中可以看到会针对 \x3cstrong\x3e文件\x3c\/strong\x3e 、\x3cstrong\x3e文件夹\x3c\/strong\x3e 类型分别调用 \x3ccode\x3ewatcherManager.watchFile\x3c\/code\x3e、\x3ccode\x3ewatcherManager.watchDirectory\x3c\/code\x3e进行监听。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22watchpack\/lib\/watcherManager.js\n\nWatcherManager.prototype.watchFile = function watchFile(p, options, startTime) {\n    var directory = path.dirname(p);\n    return this.getDirectoryWatcher(directory, options).watch(p, startTime);\n};\nWatcherManager.prototype.watchDirectory = function watchDirectory(directory, options, startTime) {\n    return this.getDirectoryWatcher(directory, options).watch(directory, startTime);\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3ewatchpack\/lib\/watcherManager.js\n\nWatcherManager.prototype.watchFile = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ewatchFile\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ep, options, startTime\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e directory = path.dirname(p);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getDirectoryWatcher(directory, options).watch(p, startTime);\n};\nWatcherManager.prototype.watchDirectory = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ewatchDirectory\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edirectory, options, startTime\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getDirectoryWatcher(directory, options).watch(directory, startTime);\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在 \x3ccode\x3ewatcherManager.js\x3c\/code\x3e 文件中的 \x3ccode\x3ewatchFile\x3c\/code\x3e 以及 \x3ccode\x3ewatchDirectory\x3c\/code\x3e 都传递了同类型的参数调用了 \x3ccode\x3ethis.getDirectoryWatcher\x3c\/code\x3e ，并在随后调用了返回实例的 \x3ccode\x3ewatch\x3c\/code\x3e 方法，并将 \x3ccode\x3ewatch\x3c\/code\x3e 方法的返回结果继续往上层 \x3ccode\x3ewatchpack.js\x3c\/code\x3e 的 \x3ccode\x3ethis._fileWatcher\x3c\/code\x3e 与 \x3ccode\x3ethis._dirWatcher\x3c\/code\x3e 方法进行传递。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22watchpack\/lib\/watcherManager.js\n\nWatcherManager.prototype.getDirectoryWatcher = function(directory, options) {\n var DirectoryWatcher = require(\x26quot;.\/DirectoryWatcher\x26quot;);\n options = options || {};\n var key = directory \x2b \x26quot; \x26quot; \x2b JSON.stringify(options);\n if(!this.directoryWatchers[key]) {\n  this.directoryWatchers[key] = new DirectoryWatcher(directory, options);\n  this.directoryWatchers[key].on(\x26quot;closed\x26quot;, function() {\n   delete this.directoryWatchers[key];\n  }.bind(this));\n }\n return this.directoryWatchers[key];\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3ewatchpack\/lib\/watcherManager.js\n\nWatcherManager.prototype.getDirectoryWatcher = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edirectory, options\x3c\/span\x3e) \x3c\/span\x3e{\n \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e DirectoryWatcher = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22.\/DirectoryWatcher\x22\x3c\/span\x3e);\n options = options || {};\n \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e key = directory \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22 \x22\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-built_in\x22\x3eJSON\x3c\/span\x3e.stringify(options);\n \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(!\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.directoryWatchers[key]) {\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.directoryWatchers[key] = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e DirectoryWatcher(directory, options);\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.directoryWatchers[key].on(\x3cspan class=\x22hljs-string\x22\x3e\x22closed\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n   \x3cspan class=\x22hljs-keyword\x22\x3edelete\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.directoryWatchers[key];\n  }.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e));\n }\n \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.directoryWatchers[key];\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e而 \x3ccode\x3egetDirectoryWatcher\x3c\/code\x3e 的具体实现，则是创建一个由 \x3ccode\x3e.\/DirectoryWatcher\x3c\/code\x3e 导出的构造函数所构造出来的实例。这里可以看到以文件夹路径(\x3ccode\x3edirectory\x3c\/code\x3e) 和配置 (\x3ccode\x3eoptions\x3c\/code\x3e)两个属性作为实例的 \x3ccode\x3ekey\x3c\/code\x3e 并且在函数最后，将实例进行返回。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000008111798?w=858\x26amp;h=277\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000008111798?w=858\x26amp;h=277\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e整个逻辑通过 \x3ccode\x3ewatchManager\x3c\/code\x3e 进行底层逻辑创建，通过 \x3ccode\x3e_dirWatcher\x3c\/code\x3e、\x3ccode\x3e_fileWatcher\x3c\/code\x3e 完成对底层逻辑的处理封装。\x3c\/p\x3e\n\x3ch4\x3eDirectoryWatcher 实例创建\x3c\/h4\x3e\n\x3cp\x3e紧接着 \x3ccode\x3ewacthManager\x3c\/code\x3e 的 \x3ccode\x3ewatchFile\x3c\/code\x3e 与 \x3ccode\x3ewatchDirectory\x3c\/code\x3e 中 \x3ccode\x3egetDirectoryWatcher\x3c\/code\x3e 调用完成后，则调用实例的 \x3ccode\x3ewatch\x3c\/code\x3e 方法，逻辑就走到了 \x3ccode\x3eDirectoryWatcher.js\x3c\/code\x3e 文件。关联在 \x3ccode\x3egetDirectoryWatcher\x3c\/code\x3e 的实例生成过程，对应 \x3ccode\x3eDirectoryWatcher\x3c\/code\x3e 的构造函数\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22watchpack\/lib\/DirectoryWatcher.js\n\nvar chokidar = require(\x26quot;chokidar\x26quot;);\n\nfunction DirectoryWatcher(directoryPath, options) {\n    EventEmitter.call(this);\n    this.path = directoryPath;\n    this.files = {};\n    this.directories = {};\n    this.watcher = chokidar.watch(directoryPath, {\n        ignoreInitial: true,\n        persistent: true,\n        followSymlinks: false,\n        depth: 0,\n        atomic: false,\n        alwaysStat: true,\n        ignorePermissionErrors: true,\n        usePolling: options.poll ? true : undefined,\n        interval: typeof options.poll === \x26quot;number\x26quot; ? options.poll : undefined\n    });\n    this.watcher.on(\x26quot;add\x26quot;, this.onFileAdded.bind(this));\n    this.watcher.on(\x26quot;addDir\x26quot;, this.onDirectoryAdded.bind(this));\n    this.watcher.on(\x26quot;change\x26quot;, this.onChange.bind(this));\n    this.watcher.on(\x26quot;unlink\x26quot;, this.onFileUnlinked.bind(this));\n    this.watcher.on(\x26quot;unlinkDir\x26quot;, this.onDirectoryUnlinked.bind(this));\n    this.watcher.on(\x26quot;error\x26quot;, this.onWatcherError.bind(this));\n    this.initialScan = true;\n    this.nestedWatching = false;\n    this.initialScanRemoved = [];\n    this.doInitialScan();\n    this.watchers = {};\n    this.refs = 0;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3ewatchpack\/lib\/DirectoryWatcher.js\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e chokidar = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22chokidar\x22\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eDirectoryWatcher\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edirectoryPath, options\x3c\/span\x3e) \x3c\/span\x3e{\n    EventEmitter.call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.path = directoryPath;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.files = {};\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.directories = {};\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watcher = chokidar.watch(directoryPath, {\n        \x3cspan class=\x22hljs-attr\x22\x3eignoreInitial\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3epersistent\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3efollowSymlinks\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3edepth\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3eatomic\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3ealwaysStat\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3eignorePermissionErrors\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3eusePolling\x3c\/span\x3e: options.poll ? \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e : \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3einterval\x3c\/span\x3e: \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e options.poll === \x3cspan class=\x22hljs-string\x22\x3e\x22number\x22\x3c\/span\x3e ? options.poll : \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e\n    });\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watcher.on(\x3cspan class=\x22hljs-string\x22\x3e\x22add\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.onFileAdded.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e));\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watcher.on(\x3cspan class=\x22hljs-string\x22\x3e\x22addDir\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.onDirectoryAdded.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e));\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watcher.on(\x3cspan class=\x22hljs-string\x22\x3e\x22change\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.onChange.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e));\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watcher.on(\x3cspan class=\x22hljs-string\x22\x3e\x22unlink\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.onFileUnlinked.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e));\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watcher.on(\x3cspan class=\x22hljs-string\x22\x3e\x22unlinkDir\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.onDirectoryUnlinked.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e));\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watcher.on(\x3cspan class=\x22hljs-string\x22\x3e\x22error\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.onWatcherError.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e));\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.initialScan = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.nestedWatching = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.initialScanRemoved = [];\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.doInitialScan();\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watchers = {};\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.refs = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e找到这里，可以看到，监听文件（夹）采用的是 \x3ca href=\x22https:\/\/github.com\/paulmillr\/chokidar\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3echokidar\x3c\/a\x3e 的能力。关联前面的逻辑，可以大致看出，通过  \x3ca href=\x22https:\/\/github.com\/paulmillr\/chokidar\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3echokidar\x3c\/a\x3e 绑定对应 \x3ccode\x3edirectoryPath\x3c\/code\x3e 的目录的 \x3ccode\x3eadd\x3c\/code\x3e、\x3ccode\x3eaddDir\x3c\/code\x3e 、\x3ccode\x3echange\x3c\/code\x3e、\x3ccode\x3eunlink\x3c\/code\x3e 、\x3ccode\x3eunlinkDir\x3c\/code\x3e  的事件，通过对应的事件回调函数来向上层逻辑传递文件（夹）变更信息。\x3c\/p\x3e\n\x3cp\x3e除了 \x3ccode\x3ewatcher\x3c\/code\x3e 对应  \x3ca href=\x22https:\/\/github.com\/paulmillr\/chokidar\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3echokidar\x3c\/a\x3e  对象，这里还有一些辅助的属性来完成监听处理逻辑\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3efiles\x3c\/code\x3e：保存文件改变状态（mtime）\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3edirectories\x3c\/code\x3e：保存文件夹监听状态，以及嵌套文件夹监听实例\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3einitialScan\x3c\/code\x3e：初次文件扫描标识\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3enestedWatching\x3c\/code\x3e：是否存在嵌套文件夹监听\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3einitialScanRemoved\x3c\/code\x3e： 首次查看过程中删除的文件（夹），对在首次查看过程中对已删除文件（夹）的过滤\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3ewatchers\x3c\/code\x3e：以监听路径(\x3ccode\x3efilePath\x3c\/code\x3e) 为 key 的 \x3ccode\x3ewatcher\x3c\/code\x3e 数组为值的 map 对象\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3erefs\x3c\/code\x3e：\x3ccode\x3ewatchers\x3c\/code\x3e 的数量\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e在属性复制完成后，会类似 \x3ccode\x3eCompiler.js\x3c\/code\x3e 中 \x3ccode\x3eWatching\x3c\/code\x3e 实例在实例创建时会进行首次编译一样，会进行首次文件夹的查看\x3ccode\x3e(doInitalScan)\x3c\/code\x3e ，这里会进行初始数据（\x3ccode\x3ethis.files\x3c\/code\x3e、\x3ccode\x3ethis.directories\x3c\/code\x3e）的生成。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22DirectoryWatcher.prototype.doInitialScan = function doInitialScan() {\n    fs.readdir(this.path, function(err, items) {\n        if(err) {\n            this.initialScan = false;\n            return;\n        }\n        async.forEach(items, function(item, callback) {\n            var itemPath = path.join(this.path, item);\n            fs.stat(itemPath, function(err2, stat) {\n                if(!this.initialScan) return;\n                if(err2) {\n                    callback();\n                    return;\n                }\n                if(stat.isFile()) {\n                    if(!this.files[itemPath])\n                        this.setFileTime(itemPath, \x2bstat.mtime, true);\n                } else if(stat.isDirectory()) {\n                    if(!this.directories[itemPath])\n                        this.setDirectory(itemPath, true, true);\n                }\n                callback();\n            }.bind(this));\n        }.bind(this), function() {\n            this.initialScan = false;\n            this.initialScanRemoved = null;\n        }.bind(this));\n    }.bind(this));\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eDirectoryWatcher.prototype.doInitialScan = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3edoInitialScan\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    fs.readdir(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.path, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eerr, items\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(err) {\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.initialScan = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n        }\n        \x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e.forEach(items, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eitem, callback\x3c\/span\x3e) \x3c\/span\x3e{\n            \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e itemPath = path.join(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.path, item);\n            fs.stat(itemPath, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eerr2, stat\x3c\/span\x3e) \x3c\/span\x3e{\n                \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(!\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.initialScan) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n                \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(err2) {\n                    callback();\n                    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n                }\n                \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(stat.isFile()) {\n                    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(!\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.files[itemPath])\n                        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setFileTime(itemPath, \x2bstat.mtime, \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e);\n                } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(stat.isDirectory()) {\n                    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(!\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.directories[itemPath])\n                        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setDirectory(itemPath, \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e, \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e);\n                }\n                callback();\n            }.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e));\n        }.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e), \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.initialScan = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.initialScanRemoved = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n        }.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e));\n    }.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e));\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里是一个 \x3ccode\x3easync.forEach\x3c\/code\x3e 撑起的函数结构，主要对传入 \x3ccode\x3edirectoryPath\x3c\/code\x3e 下的文件（夹）通过 \x3ccode\x3esetFileTime\x3c\/code\x3e、\x3ccode\x3esetDirectory\x3c\/code\x3e 进行 \x3ccode\x3eDirectoryWatcher\x3c\/code\x3e 实例的 \x3ccode\x3efiles\x3c\/code\x3e、\x3ccode\x3edirectories\x3c\/code\x3e 属性赋值。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cp\x3e对于文件情况 (\x3ccode\x3estat.isFile\x3c\/code\x3e 为 \x3ccode\x3etrue\x3c\/code\x3e) ：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22调用 `setFileTime` 函数传入文件最后修改时间（ `stat.mtime`），函数本身分为两个步骤，而这里主要是**存储文件的变更记录**，而另一部则是**变更事件的触发**，在后面的内容也会提到。\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs autohotkey\x22\x3e\x3ccode\x3e调用 `setFileTime` 函数传入文件最后修改时间（ `stat.mtime`），函数本身分为两个步骤，而这里主要是**存储文件的变更记录**，而另一部则是**变更事件的触发**，在后面的内容也会提到。\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22DirectoryWatcher.prototype.setFileTime = function setFileTime(filePath, mtime, initial, type) {\n  var now = Date.now();\n  var old = this.files[filePath];\n  this.files[filePath] = [initial ? Math.min(now, mtime) : now, mtime];\n  \/\/ 省略变更触发\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eDirectoryWatcher.prototype.setFileTime = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3esetFileTime\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3efilePath, mtime, initial, type\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e now = \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e.now();\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e old = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.files[filePath];\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.files[filePath] = [initial ? \x3cspan class=\x22hljs-built_in\x22\x3eMath\x3c\/span\x3e.min(now, mtime) : now, mtime];\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 省略变更触发\x3c\/span\x3e\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里会以数组的形式，存储 \x3ccode\x3e变更流程执行时间点\x3c\/code\x3e、\x3ccode\x3e文件最后修改时间点\x3c\/code\x3e。\x3cbr\x3e一般 \x3ccode\x3esetFileTime\x3c\/code\x3e 的调用的时候，就认为触发了文件触发了变更，进行文件变更记录更新，而对于初始化情况，主要目的是为了初始化数据，并不为变更而调用 \x3ccode\x3esetFileTime\x3c\/code\x3e，所以对于初始化的返回是进行比较 \x3ccode\x3eMath.min(now, mtime)\x3c\/code\x3e 而不是直接返回当前时间。\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e对于文件夹情况（\x3ccode\x3estat.isDirectory\x3c\/code\x3e 为 \x3ccode\x3etrue\x3c\/code\x3e）\x3c\/p\x3e\n\x3cp\x3e调用 \x3ccode\x3esetDirectory\x3c\/code\x3e 来进行子文件夹标记，方便后续进行子文件夹监听的创建：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22DirectoryWatcher.prototype.setDirectory = function setDirectory(directoryPath, exist, initial) {\nvar old = this.directories[directoryPath];\nif(!old) {\n  if(exist) {\nif(this.nestedWatching) {\n  this.createNestedWatcher(directoryPath);\n} else {\n  this.directories[directoryPath] = true;\n}\n  }\n} \n\/\/ 省略文件夹删除事件触发\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eDirectoryWatcher.prototype.setDirectory = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3esetDirectory\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edirectoryPath, exist, initial\x3c\/span\x3e) \x3c\/span\x3e{\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e old = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.directories[directoryPath];\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(!old) {\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(exist) {\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.nestedWatching) {\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.createNestedWatcher(directoryPath);\n} \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.directories[directoryPath] = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n}\n  }\n} \n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 省略文件夹删除事件触发\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在 \x3ccode\x3edoInitalScan\x3c\/code\x3e 的场景下，会判断 \x3ccode\x3enestedWatching\x3c\/code\x3e 的情况，如果为 \x3ccode\x3efalse\x3c\/code\x3e 则赋值 \x3ccode\x3ethis.directories[directoryPath]\x3c\/code\x3e 为 \x3ccode\x3etrue\x3c\/code\x3e，表示文件夹没有创建对应的监听；或者是通过 \x3ccode\x3ethis.createNestedWatcher\x3c\/code\x3e 进行子文件夹监听的创建，最终也会赋值到 \x3ccode\x3ethis.directories[directoryPath]\x3c\/code\x3e 上的则是对应的内嵌 \x3ccode\x3eWatcher\x3c\/code\x3e 实例。而这里的子文件夹的状态在后续也是可能发生变化的。\x3cbr\x3e完成赋值过程后， 会将 \x3ccode\x3ethis.initialScan \x3c\/code\x3e 设置成 \x3ccode\x3efalse\x3c\/code\x3e 表示首次查看结束，设置 \x3ccode\x3e this.initialScanRemoved\x3c\/code\x3e 为 \x3ccode\x3enull\x3c\/code\x3e ，表示在首次查看过程中就删除的文件（夹）的处理也结束。\x3c\/p\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000008111799?w=615\x26amp;h=219\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000008111799?w=615\x26amp;h=219\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e在完成基础  \x3ccode\x3ethis.watcher\x3c\/code\x3e 文件系统监听逻辑（\x3ca href=\x22https:\/\/github.com\/paulmillr\/chokidar\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3echokidar\x3c\/a\x3e ）创建，基础属性 \x3ccode\x3ethis.files\x3c\/code\x3e、\x3ccode\x3ethis.directories\x3c\/code\x3e 初始化后，则完成了整个 \x3ccode\x3eDirectoryWatcher\x3c\/code\x3e 实例的生成。\x3c\/p\x3e\n\x3ch4\x3e搭建监听通道（创建内部 Watcher 实例）\x3c\/h4\x3e\n\x3cp\x3e在 \x3ccode\x3egetDirectoryWatcher\x3c\/code\x3e 完成调用返回 \x3ccode\x3eDirectoryWatcher\x3c\/code\x3e 的实例之后，调用实例的 \x3ccode\x3ewatch\x3c\/code\x3e 方法，传入文件（夹）路径。对最上层 \x3ccode\x3eCompiler\x3c\/code\x3e 传入的 \x3ccode\x3efiles\x3c\/code\x3e、\x3ccode\x3emissings\x3c\/code\x3e 文件，\x3ccode\x3edirs\x3c\/code\x3e 文件夹进行循环调用，进行监听流程。\x3ccode\x3ewatch\x3c\/code\x3e 方法通过三个阶段完成底层到上层的监听信息通道的搭建。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000008111800?w=650\x26amp;h=201\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000008111800?w=650\x26amp;h=201\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\n\x3cp\x3e\x3cstrong\x3e生成 \x3ccode\x3eWatcher\x3c\/code\x3e 实例\x3c\/strong\x3e\x3cbr\x3e第一个部分是针对传入的路径生成对应的 \x3ccode\x3eWatcher\x3c\/code\x3e 实例，最终通过 \x3ccode\x3eWatcherManager\x3c\/code\x3e 的 \x3ccode\x3ewatchFile\x3c\/code\x3e、\x3ccode\x3ewatchDirectory\x3c\/code\x3e 返回到上层 \x3ccode\x3ewatchpack\x3c\/code\x3e 中的 \x3ccode\x3ewatch\x3c\/code\x3e 方法中 \x3ccode\x3ethis._fileWatcher\x3c\/code\x3e 、\x3ccode\x3ethis._dirname\x3c\/code\x3e调用的返回结果，就是这个内部 \x3ccode\x3eWatcher\x3c\/code\x3e 实例。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22watchpack\/lib\/DirectoryWatcher.js\n\nfunction Watcher(directoryWatcher, filePath, startTime) {\n    EventEmitter.call(this);\n    this.directoryWatcher = directoryWatcher;\n    this.path = filePath;\n    this.startTime = startTime \x26amp;\x26amp; \x2bstartTime;\n    this.data = 0;\n}\n\nDirectoryWatcher.prototype.watch = function watch(filePath, startTime) {\n  this.watchers[withoutCase(filePath)] = this.watchers[withoutCase(filePath)] || [];\n  this.refs\x2b\x2b;\n  var watcher = new Watcher(this, filePath, startTime);\n  \n  watcher.on(\x26quot;closed\x26quot;, function() {\n    \/\/ 省略 closed 事件处理\n  }.bind(this));\n  \n  this.watchers[withoutCase(filePath)].push(watcher);\n  \/\/ 省略设置子文件内嵌监听\n  \/\/ 省略已有数据处理\n  return watcher;  \n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3ewatchpack\/lib\/DirectoryWatcher.js\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eWatcher\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edirectoryWatcher, filePath, startTime\x3c\/span\x3e) \x3c\/span\x3e{\n    EventEmitter.call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.directoryWatcher = directoryWatcher;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.path = filePath;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.startTime = startTime \x26amp;\x26amp; \x2bstartTime;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.data = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n}\n\nDirectoryWatcher.prototype.watch = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ewatch\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3efilePath, startTime\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watchers[withoutCase(filePath)] = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watchers[withoutCase(filePath)] || [];\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.refs\x2b\x2b;\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e watcher = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Watcher(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, filePath, startTime);\n  \n  watcher.on(\x3cspan class=\x22hljs-string\x22\x3e\x22closed\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 省略 closed 事件处理\x3c\/span\x3e\n  }.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e));\n  \n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watchers[withoutCase(filePath)].push(watcher);\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 省略设置子文件内嵌监听\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 省略已有数据处理\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e watcher;  \n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里内部 \x3ccode\x3eWatcher\x3c\/code\x3e 实例主要是通过继承 \x3ccode\x3eEventEmitter\x3c\/code\x3e 来实现实例的事件支持，那么传递回上层例如 \x3ccode\x3ewatchpack\x3c\/code\x3e 时，就可以绑定该 \x3ccode\x3eWatcher\x3c\/code\x3e 实例的事件，\x3cstrong\x3e底层的文件改动触发实例的事件，上层对事件处理，通过这个对象建立数据传递的通道，完成监听数据的传递\x3c\/strong\x3e。在完成 \x3ccode\x3ewatcher\x3c\/code\x3e实例创建后，会将实例 \x3ccode\x3epush\x3c\/code\x3e  进 \x3ccode\x3ethis.watchers\x3c\/code\x3e 中以 \x3ccode\x3efilePath\x3c\/code\x3e 为 key 的 \x3ccode\x3ewatcher\x3c\/code\x3e 数组，并将实例返回。\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e\x3cstrong\x3e设置子文件夹内嵌监听\x3c\/strong\x3e\x3cbr\x3e\x3ccode\x3ewatch\x3c\/code\x3e 方法的另一部分，则是进行设置内嵌监听 \x3ccode\x3esetNestedWatching\x3c\/code\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22watchpack\/lib\/DirectoryWatcher.js\n\nDirectoryWatcher.prototype.watch = function watch(filePath, startTime) {\n    \/\/ 省略内部 Watcher 实例生成\n    var data;\n    if(filePath === this.path) {\n        this.setNestedWatching(true);\n    }\n      \/\/ 省略已有数据处理\n};\n\nDirectoryWatcher.prototype.setNestedWatching = function(flag) {\n    if(this.nestedWatching !== !!flag) {\n        this.nestedWatching = !!flag;\n        if(this.nestedWatching) {\n            Object.keys(this.directories).forEach(function(directory) {\n                this.createNestedWatcher(directory);\n            }, this);\n        } else {\n            Object.keys(this.directories).forEach(function(directory) {\n                this.directories[directory].close();\n                this.directories[directory] = true;\n            }, this);\n        }\n    }\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3ewatchpack\/lib\/DirectoryWatcher.js\n\nDirectoryWatcher.prototype.watch = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ewatch\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3efilePath, startTime\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 省略内部 Watcher 实例生成\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e data;\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(filePath === \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.path) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setNestedWatching(\x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e);\n    }\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 省略已有数据处理\x3c\/span\x3e\n};\n\nDirectoryWatcher.prototype.setNestedWatching = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eflag\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.nestedWatching !== !!flag) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.nestedWatching = !!flag;\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.nestedWatching) {\n            \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.keys(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.directories).forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edirectory\x3c\/span\x3e) \x3c\/span\x3e{\n                \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.createNestedWatcher(directory);\n            }, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n            \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.keys(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.directories).forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edirectory\x3c\/span\x3e) \x3c\/span\x3e{\n                \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.directories[directory].close();\n                \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.directories[directory] = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n            }, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n        }\n    }\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在处理 \x3ccode\x3efilePath == this.path\x3c\/code\x3e 的时候，也就是 \x3ccode\x3eDirectoryWatcher.prototype.watch\x3c\/code\x3e 传入的路径与 \x3ccode\x3eDirectory\x3c\/code\x3e 生成实例的路径相同的时候（\x3ccode\x3ewatchManager.js\x3c\/code\x3e 中的 \x3ccode\x3ewatchDirectory\x3c\/code\x3e 方法的调用 \x3ccode\x3ethis.getDirectoryWatcher(directory, options).watch(directory, startTime)\x3c\/code\x3e 满足此条件）会在 \x3ccode\x3ewatch\x3c\/code\x3e 中调用 \x3ccode\x3eDirectoryWatcher.prototype.setNestedWatching\x3c\/code\x3e 进行子文件夹的监听的创建。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22watchpack\/lib\/DirectoryWatcher.js\n\nDirectoryWatcher.prototype.createNestedWatcher = function(directoryPath) {\n  this.directories[directoryPath] = watcherManager.watchDirectory(directoryPath, this.options, 1);\n  this.directories[directoryPath].on(\x26quot;change\x26quot;, function(filePath, mtime) {\n    if(this.watchers[withoutCase(this.path)]) {\n      this.watchers[withoutCase(this.path)].forEach(function(w) {\n        if(w.checkStartTime(mtime, false)) {\n          w.emit(\x26quot;change\x26quot;, filePath, mtime);\n        }\n      });\n    }\n  }.bind(this));\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3ewatchpack\/lib\/DirectoryWatcher.js\n\nDirectoryWatcher.prototype.createNestedWatcher = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edirectoryPath\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.directories[directoryPath] = watcherManager.watchDirectory(directoryPath, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.options, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.directories[directoryPath].on(\x3cspan class=\x22hljs-string\x22\x3e\x22change\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3efilePath, mtime\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watchers[withoutCase(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.path)]) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watchers[withoutCase(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.path)].forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ew\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(w.checkStartTime(mtime, \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e)) {\n          w.emit(\x3cspan class=\x22hljs-string\x22\x3e\x22change\x22\x3c\/span\x3e, filePath, mtime);\n        }\n      });\n    }\n  }.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e));\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e子文件夹的监听同样是通过上层\x3ccode\x3ewatchManager.js\x3c\/code\x3e 中的 \x3ccode\x3ewatchManager.watchDirectory\x3c\/code\x3e 的调用实现，同时这里会多绑定一次 \x3ccode\x3echange\x3c\/code\x3e 事件，实现当子文件夹变化的时候触发父文件夹的 \x3ccode\x3echange\x3c\/code\x3e 事件。\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e\x3cstrong\x3e处理已有数据\x3c\/strong\x3e\x3cbr\x3e在完成 \x3ccode\x3ewatcher\x3c\/code\x3e 实例创建之后，会针对在 \x3ccode\x3ewatch\x3c\/code\x3e \x3cstrong\x3e实例创建过程\x3c\/strong\x3e中发生的文件（夹）变动进行处理，保证文件的变动能完备更新\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22watchpack\/lib\/DirectoryWatcher.js\n\nDirectoryWatcher.prototype.watch = function watch(filePath, startTime) {\n    \/\/ 省略内部 Watcher 实例生成\n    var data;\n      if(filePath === this.path) {\n      \/\/ 省略设置子文件内嵌监听\n      data = false;\n      Object.keys(this.files).forEach(function(file) {\n        var d = this.files[file];\n        if(!data)\n          data = d;\n        else\n          data = [Math.max(data[0], d[0]), Math.max(data[1], d[1])];\n      }, this);\n    } else {\n      data = this.files[filePath];\n    }\n    process.nextTick(function() {\n      if(data) {\n        if(data[0] \x3e startTime)\n          watcher.emit(\x26quot;change\x26quot;, data[1]);\n      } else if(this.initialScan \x26amp;\x26amp; this.initialScanRemoved.indexOf(filePath) \x3e= 0) {\n        watcher.emit(\x26quot;remove\x26quot;);\n      }\n    }.bind(this));\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3ewatchpack\/lib\/DirectoryWatcher.js\n\nDirectoryWatcher.prototype.watch = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ewatch\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3efilePath, startTime\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 省略内部 Watcher 实例生成\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e data;\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(filePath === \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.path) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 省略设置子文件内嵌监听\x3c\/span\x3e\n      data = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n      \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.keys(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.files).forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3efile\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e d = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.files[file];\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(!data)\n          data = d;\n        \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e\n          data = [\x3cspan class=\x22hljs-built_in\x22\x3eMath\x3c\/span\x3e.max(data[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e], d[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e]), \x3cspan class=\x22hljs-built_in\x22\x3eMath\x3c\/span\x3e.max(data[\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e], d[\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e])];\n      }, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      data = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.files[filePath];\n    }\n    process.nextTick(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(data) {\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(data[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e] \x26gt; startTime)\n          watcher.emit(\x3cspan class=\x22hljs-string\x22\x3e\x22change\x22\x3c\/span\x3e, data[\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e]);\n      } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.initialScan \x26amp;\x26amp; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.initialScanRemoved.indexOf(filePath) \x26gt;= \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n        watcher.emit(\x3cspan class=\x22hljs-string\x22\x3e\x22remove\x22\x3c\/span\x3e);\n      }\n    }.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e));\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e处理已有数据也是分成两个步骤\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\n\x3cp\x3e读取数据\x3cbr\x3e   这里对于文件、文件夹的处理，获取数据的方式也不同。\x3cbr\x3e对于监听\x3cstrong\x3e文件夹\x3c\/strong\x3e路径的情况：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Object.keys(this.files).forEach(function(file) {\nvar d = this.files[file];\nif(!data)\n  data = d;\nelse\n  data = [Math.max(data[0], d[0]), Math.max(data[1], d[1])];\n}, this);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.keys(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.files).forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3efile\x3c\/span\x3e) \x3c\/span\x3e{\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e d = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.files[file];\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(!data)\n  data = d;\n\x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e\n  data = [\x3cspan class=\x22hljs-built_in\x22\x3eMath\x3c\/span\x3e.max(data[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e], d[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e]), \x3cspan class=\x22hljs-built_in\x22\x3eMath\x3c\/span\x3e.max(data[\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e], d[\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e])];\n}, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可以从对 \x3ccode\x3ethis.files\x3c\/code\x3e 的循环看出，这里实际上是取到的是该文件夹下所有文件中的\x3ccode\x3e变更流程执行时间点\x3c\/code\x3e、\x3ccode\x3e文件最后修改时间点\x3c\/code\x3e 的最大值。\x3cbr\x3e对于\x3cstrong\x3e单个文件\x3c\/strong\x3e路径的情况：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 data = this.files[filePath];\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e \x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.files[filePath];\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e则是直接取到当前监听文件路径的数据。\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e触发事件\x3cbr\x3e   当数据完成获取后，就进入到 \x3ccode\x3e触发事件\x3c\/code\x3e 的阶段，这个阶段会将前面取到的 \x3ccode\x3e变更流程执行时间点\x3c\/code\x3e 与由 \x3ccode\x3eWatching.prototype._go\x3c\/code\x3e 中设置的编译开始时间 \x3ccode\x3estartTime\x3c\/code\x3e 进行比较：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22process.nextTick(function() {\nif(data) {\n  if(data[0] \x3e startTime)\n watcher.emit(\x26quot;change\x26quot;, data[1]);\n} else if(this.initialScan \x26amp;\x26amp; this.initialScanRemoved.indexOf(filePath) \x3e= 0) {\n  watcher.emit(\x26quot;remove\x26quot;);\n}\n}.bind(this));\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eprocess.nextTick(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(data) {\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(data[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e] \x26gt; startTime)\n watcher.emit(\x3cspan class=\x22hljs-string\x22\x3e\x22change\x22\x3c\/span\x3e, data[\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e]);\n} \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.initialScan \x26amp;\x26amp; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.initialScanRemoved.indexOf(filePath) \x26gt;= \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n  watcher.emit(\x3cspan class=\x22hljs-string\x22\x3e\x22remove\x22\x3c\/span\x3e);\n}\n}.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e));\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当 \x3ccode\x3e变更流程执行时间点\x3c\/code\x3e 比 \x3ccode\x3estartTime\x3c\/code\x3e 时间晚的时候说明，在编译开始后，针对文件夹的情况是文件夹其中的文件发生了变化，对于单个文件的情况，则是该文件发生变化。则触发 \x3ccode\x3echange\x3c\/code\x3e 事件。\x3cbr\x3e这里还会有一个判断是：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22if(this.initialScan \x26amp;\x26amp; this.initialScanRemoved.indexOf(filePath) \x3e= 0) {\n  watcher.emit(\x26quot;remove\x26quot;);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.initialScan \x26amp;\x26amp; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.initialScanRemoved.indexOf(filePath) \x26gt;= \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n  watcher.emit(\x3cspan class=\x22hljs-string\x22\x3e\x22remove\x22\x3c\/span\x3e);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e对于第一个条件 \x3ccode\x3ethis.initialScan\x3c\/code\x3e，上面提到在完成 \x3ccode\x3edoInitialScan\x3c\/code\x3e 完成后会复制为 \x3ccode\x3efalse\x3c\/code\x3e。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e完成赋值过程后， 会将 \x3ccode\x3ethis.initialScan \x3c\/code\x3e 设置成 \x3ccode\x3efalse\x3c\/code\x3e 表示首次查看结束，设置 \x3ccode\x3e this.initialScanRemoved\x3c\/code\x3e 为 \x3ccode\x3enull\x3c\/code\x3e ，表示在首次查看过程中就删除的文件（夹）的处理也结束\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e则这条判断是在 \x3ccode\x3ewatch\x3c\/code\x3e 进行的同时，\x3ccode\x3edoInitialScan\x3c\/code\x3e 也还在进行的时候生效。\x3cbr\x3e对于第二个条件 \x3ccode\x3ethis.initialScanRemoved.indexOf(filePath)\x3c\/code\x3e ，这里主要落脚点在于 \x3ccode\x3einitialScanRemoved\x3c\/code\x3e 对这个数组的操作\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22watchpack\/lib\/DirectoryWatcher.js\n \nthis.watcher.on(\x26quot;unlink\x26quot;, this.onFileUnlinked.bind(this));\nthis.watcher.on(\x26quot;unlinkDir\x26quot;, this.onDirectoryUnlinked.bind(this));\n \nDirectoryWatcher.prototype.onFileUnlinked = function onFileUnlinked(filePath) {\n  \/\/ 省略判断\n  if(this.initialScan) {\n   this.initialScanRemoved.push(filePath);\n  }\n};\n \nDirectoryWatcher.prototype.onDirectoryUnlinked = function onDirectoryUnlinked(directoryPath) {\n  \/\/ 省略判断\n  if(this.initialScan) {\n   this.initialScanRemoved.push(directoryPath);\n  }\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3ewatchpack\/lib\/DirectoryWatcher.js\n \n\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watcher.on(\x3cspan class=\x22hljs-string\x22\x3e\x22unlink\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.onFileUnlinked.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e));\n\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watcher.on(\x3cspan class=\x22hljs-string\x22\x3e\x22unlinkDir\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.onDirectoryUnlinked.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e));\n \nDirectoryWatcher.prototype.onFileUnlinked = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eonFileUnlinked\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3efilePath\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 省略判断\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.initialScan) {\n   \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.initialScanRemoved.push(filePath);\n  }\n};\n \nDirectoryWatcher.prototype.onDirectoryUnlinked = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eonDirectoryUnlinked\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edirectoryPath\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 省略判断\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.initialScan) {\n   \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.initialScanRemoved.push(directoryPath);\n  }\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e从事件绑定中可以看到，当在进行 \x3ccode\x3edoInitialScan\x3c\/code\x3e 过程中，发生了文件（夹）删除的情况，则会将删除的路径 \x3ccode\x3epush\x3c\/code\x3e 到 \x3ccode\x3einitialScanRemoved\x3c\/code\x3e 数组中。\x3cbr\x3e那么整合两个条件，在初始扫描的场景下，监听文件（夹）发生删除的情况时，则触发 \x3ccode\x3eremove\x3c\/code\x3e 事件，避免增加无效的监听。\x3c\/p\x3e\n\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000008111801?w=775\x26amp;h=66\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000008111801?w=775\x26amp;h=66\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e在整个数据监听通道的流程中，都是围绕 \x3ccode\x3eWatcher\x3c\/code\x3e 实例进行开展，通过 \x3ccode\x3eWatcher\x3c\/code\x3e 承上启下衔接上下逻辑的作用。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e触发流程\x3c\/h3\x3e\n\x3cp\x3e在完成了从 \x3ccode\x3eWatchpack.prototype.watch\x3c\/code\x3e -\x26gt; \x3ccode\x3eWatcherManager.prototype.watchFile\x3c\/code\x3e、\x3ccode\x3eWatcherManager.prototype.watchDirectory\x3c\/code\x3e  -\x26gt; \x3ccode\x3eDirectory.prototype.watch\x3c\/code\x3e 这条调用链之后，\x3ccode\x3ewebpack --watch \x3c\/code\x3e 就会等待文件的改动，进行编译的再次触发。\x3c\/p\x3e\n\x3ch4\x3echokidar\x3c\/h4\x3e\n\x3cp\x3e目前 \x3ccode\x3ewatchpack\x3c\/code\x3e 中对文件（夹）的监听通过 \x3ccode\x3echokidar\x3c\/code\x3e 来实现，首先关联的逻辑就是 \x3ccode\x3echokidar\x3c\/code\x3e 的具体调用，关注到 \x3ccode\x3eDirectoryWatcher\x3c\/code\x3e 中调用 \x3ccode\x3echokidar\x3c\/code\x3e 的部分\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22watchpack\/lib\/DirectoryWatcher.js\n\nfunction DirectoryWatcher(directoryPath, options) {\n    EventEmitter.call(this);\n    this.watcher = chokidar.watch(directoryPath, {\n        ignoreInitial: true,\n        persistent: true,\n        followSymlinks: false,\n        depth: 0,\n        atomic: false,\n        alwaysStat: true,\n        ignorePermissionErrors: true,\n        usePolling: options.poll ? true : undefined,\n        interval: typeof options.poll === \x26quot;number\x26quot; ? options.poll : undefined\n    });\n    this.watcher.on(\x26quot;add\x26quot;, this.onFileAdded.bind(this));\n    this.watcher.on(\x26quot;addDir\x26quot;, this.onDirectoryAdded.bind(this));\n    this.watcher.on(\x26quot;change\x26quot;, this.onChange.bind(this));\n    this.watcher.on(\x26quot;unlink\x26quot;, this.onFileUnlinked.bind(this));\n    this.watcher.on(\x26quot;unlinkDir\x26quot;, this.onDirectoryUnlinked.bind(this));\n    this.watcher.on(\x26quot;error\x26quot;, this.onWatcherError.bind(this));\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3ewatchpack\/lib\/DirectoryWatcher.js\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eDirectoryWatcher\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edirectoryPath, options\x3c\/span\x3e) \x3c\/span\x3e{\n    EventEmitter.call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watcher = chokidar.watch(directoryPath, {\n        \x3cspan class=\x22hljs-attr\x22\x3eignoreInitial\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3epersistent\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3efollowSymlinks\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3edepth\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3eatomic\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3ealwaysStat\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3eignorePermissionErrors\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3eusePolling\x3c\/span\x3e: options.poll ? \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e : \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3einterval\x3c\/span\x3e: \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e options.poll === \x3cspan class=\x22hljs-string\x22\x3e\x22number\x22\x3c\/span\x3e ? options.poll : \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e\n    });\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watcher.on(\x3cspan class=\x22hljs-string\x22\x3e\x22add\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.onFileAdded.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e));\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watcher.on(\x3cspan class=\x22hljs-string\x22\x3e\x22addDir\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.onDirectoryAdded.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e));\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watcher.on(\x3cspan class=\x22hljs-string\x22\x3e\x22change\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.onChange.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e));\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watcher.on(\x3cspan class=\x22hljs-string\x22\x3e\x22unlink\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.onFileUnlinked.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e));\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watcher.on(\x3cspan class=\x22hljs-string\x22\x3e\x22unlinkDir\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.onDirectoryUnlinked.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e));\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watcher.on(\x3cspan class=\x22hljs-string\x22\x3e\x22error\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.onWatcherError.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e));\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e首先是 \x3ccode\x3echokidar\x3c\/code\x3e 的初始化，\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eignoreInitial\x3c\/code\x3e：默认为\x3ccode\x3efalse\x3c\/code\x3e， 设置为 \x3ccode\x3etrue\x3c\/code\x3e ，避免在 \x3ccode\x3echokidar\x3c\/code\x3e 自身初始化的过程中触发 \x3ccode\x3eadd\x3c\/code\x3e、\x3ccode\x3eaddDir\x3c\/code\x3e 事件\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3epersistent\x3c\/code\x3e：默认为 \x3ccode\x3etrue\x3c\/code\x3e，设置为 \x3ccode\x3etrue\x3c\/code\x3e，保持文件监听，为 \x3ccode\x3efalse\x3c\/code\x3e 的情况下，会在 \x3ccode\x3eready\x3c\/code\x3e 事件后不再触发事件\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3efollowSymlinks\x3c\/code\x3e：默认为 \x3ccode\x3etrue\x3c\/code\x3e，设置为 \x3ccode\x3efalse\x3c\/code\x3e，对 link 文件不监听真实文件内容的变化\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3edepth\x3c\/code\x3e： 设置为 \x3ccode\x3e0\x3c\/code\x3e ，表明对子文件夹不进行递归监听\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eatomic\x3c\/code\x3e：默认为 \x3ccode\x3efalse\x3c\/code\x3e，设置为 \x3ccode\x3efalse\x3c\/code\x3e，关闭对同一文件删除后 100ms 内重新增加的行为触发 \x3ccode\x3echange\x3c\/code\x3e 事件，而不是 \x3ccode\x3eunlink\x3c\/code\x3e、\x3ccode\x3eadd\x3c\/code\x3e 事件的默认行为\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3ealwaysStat\x3c\/code\x3e：默认为\x3ccode\x3efalse\x3c\/code\x3e，设置为  \x3ccode\x3etrue\x3c\/code\x3e，保持传递 \x3ccode\x3efs.Stats\x3c\/code\x3e，即使可能存在不存在的情况\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eignorePermissionErrors\x3c\/code\x3e：默认为 \x3ccode\x3efalse\x3c\/code\x3e，设置为 \x3ccode\x3etrue\x3c\/code\x3e，忽略权限错误的提示\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eusePolling\x3c\/code\x3e：默认为 \x3ccode\x3efalse\x3c\/code\x3e，根据实际配置来设置，是否开启 \x3ccode\x3epolling\x3c\/code\x3e 轮询模式\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3einterval\x3c\/code\x3e：轮询模式的周期时间，根据实际配置来设置，轮询模式的具体时间\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e其次绑定对应的文件（夹）事件 \x3ccode\x3eadd\x3c\/code\x3e、\x3ccode\x3eaddDir\x3c\/code\x3e、\x3ccode\x3echange\x3c\/code\x3e、\x3ccode\x3eunlink\x3c\/code\x3e、\x3ccode\x3eunlinkDir\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e完成初始化和事件绑定后，通过各个事件的回调函数来进行监听逻辑的触发和向上层传递。\x3c\/p\x3e\n\x3ch4\x3e文件时间精确度数值（\x3ccode\x3eFS_ACCURENCY\x3c\/code\x3e）确定\x3c\/h4\x3e\n\x3cp\x3e根据上面提到的 \x3ccode\x3ethis.watcher.on(\x22change\x22, this.onChange.bind(this));\x3c\/code\x3e  当文件内容发生变化时，进入绑定的 \x3ccode\x3eonChange\x3c\/code\x3e 回调函数\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22watchpack\/lib\/DirectoryWatcher.js\n\nvar FS_ACCURENCY = 10000;\n\nDirectoryWatcher.prototype.onChange = function onChange(filePath, stat) {\n    if(filePath.indexOf(this.path) !== 0) return;\n    if(\/[\\\\\\\/]\/.test(filePath.substr(this.path.length \x2b 1))) return;\n    var mtime = \x2bstat.mtime;\n    if(FS_ACCURENCY \x3e 1 \x26amp;\x26amp; mtime % 1 !== 0)\n        FS_ACCURENCY = 1;\n    else if(FS_ACCURENCY \x3e 10 \x26amp;\x26amp; mtime % 10 !== 0)\n        FS_ACCURENCY = 10;\n    else if(FS_ACCURENCY \x3e 100 \x26amp;\x26amp; mtime % 100 !== 0)\n        FS_ACCURENCY = 100;\n    else if(FS_ACCURENCY \x3e 1000 \x26amp;\x26amp; mtime % 1000 !== 0)\n        FS_ACCURENCY = 1000;\n    else if(FS_ACCURENCY \x3e 2000 \x26amp;\x26amp; mtime % 2000 !== 0)\n        FS_ACCURENCY = 2000;\n    this.setFileTime(filePath, mtime, false, \x26quot;change\x26quot;);\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3ewatchpack\/lib\/DirectoryWatcher.js\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e FS_ACCURENCY = \x3cspan class=\x22hljs-number\x22\x3e10000\x3c\/span\x3e;\n\nDirectoryWatcher.prototype.onChange = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eonChange\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3efilePath, stat\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(filePath.indexOf(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.path) !== \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-regexp\x22\x3e\/[\\\\\\\/]\/\x3c\/span\x3e.test(filePath.substr(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.path.length \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e))) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e mtime = \x2bstat.mtime;\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(FS_ACCURENCY \x26gt; \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e \x26amp;\x26amp; mtime % \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e !== \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e)\n        FS_ACCURENCY = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(FS_ACCURENCY \x26gt; \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e \x26amp;\x26amp; mtime % \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e !== \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e)\n        FS_ACCURENCY = \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(FS_ACCURENCY \x26gt; \x3cspan class=\x22hljs-number\x22\x3e100\x3c\/span\x3e \x26amp;\x26amp; mtime % \x3cspan class=\x22hljs-number\x22\x3e100\x3c\/span\x3e !== \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e)\n        FS_ACCURENCY = \x3cspan class=\x22hljs-number\x22\x3e100\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(FS_ACCURENCY \x26gt; \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e \x26amp;\x26amp; mtime % \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e !== \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e)\n        FS_ACCURENCY = \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(FS_ACCURENCY \x26gt; \x3cspan class=\x22hljs-number\x22\x3e2000\x3c\/span\x3e \x26amp;\x26amp; mtime % \x3cspan class=\x22hljs-number\x22\x3e2000\x3c\/span\x3e !== \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e)\n        FS_ACCURENCY = \x3cspan class=\x22hljs-number\x22\x3e2000\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setFileTime(filePath, mtime, \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22change\x22\x3c\/span\x3e);\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在 \x3ccode\x3eonChange\x3c\/code\x3e 中，除了调用 \x3ccode\x3ethis.setFileTime\x3c\/code\x3e 进行文件变更数据更新、对应 \x3ccode\x3ewatcher\x3c\/code\x3e 实例事件触发之外，还会进行 \x3ccode\x3eFS_ACCURENCY\x3c\/code\x3e 的校准逻辑。可以看到校准的规则是根据文件的修改时间取模的精度来确定值。关于这个变量值，这里从 \x3ca href=\x22https:\/\/github.com\/webpack\/watchpack\/issues\/25\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eissue\x3c\/a\x3e 中找到 \x3ccode\x3ewebpack\x3c\/code\x3e 作者 \x3cstrong\x3esokra\x3c\/strong\x3e 的描述：\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e\x3ccode\x3eFS_ACCURENCY\x3c\/code\x3e\x26nbsp;should\x26nbsp;\x3ca href=\x22https:\/\/github.com\/webpack\/watchpack\/blob\/master\/lib\/DirectoryWatcher.js#L230-L239\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eautomatically adjust\x3c\/a\x3e\x26nbsp;to your file system accuracy\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cblockquote\x3e\x3cp\x3eWith low fs accuracy files could have changed even if mime is equal\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e其中说到，在文件系统数据低精确度的情况，可能出现 \x3ccode\x3emime\x3c\/code\x3e 相同，但也发生了改变的情况。通过在后面的变更判断中通过加入精确值的度量值计算，起到平衡数值的作用（例如\x3ccode\x3evar startTime = this.startTime \x26amp;\x26amp; Math.floor(this.startTime \/ FS_ACCURENCY) * FS_ACCURENCY;\x3c\/code\x3e）。\x3c\/p\x3e\n\x3ch4\x3e\n\x3ccode\x3ewatcher\x3c\/code\x3e 实例事件触发\x3c\/h4\x3e\n\x3cp\x3e之前提到，\x3ccode\x3ewatcher\x3c\/code\x3e 实例是文件变更信息的通道，通过在 \x3ccode\x3ewatcher\x3c\/code\x3e 上的事件绑定，将 \x3ccode\x3echokidar\x3c\/code\x3e 监听到的文件（夹）变更信息，传递到 \x3ccode\x3ewatchpack\x3c\/code\x3e 层的逻辑。进入 \x3ccode\x3ethis.setFileTime\x3c\/code\x3e 后，则进行对应事件的触发\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22watchpack\/lib\/DirectoryWatcher.js\n\nDirectoryWatcher.prototype.setFileTime = function setFileTime(filePath, mtime, initial, type) {\n    var now = Date.now();\n    var old = this.files[filePath];\n    this.files[filePath] = [initial ? Math.min(now, mtime) : now, mtime];\n      \n    if(!old) {\n        if(mtime) {\n            if(this.watchers[withoutCase(filePath)]) {\n               \/\/ 文件事件触发具体逻辑\n            }\n        }\n    } else if(!initial \x26amp;\x26amp; mtime \x26amp;\x26amp; type !== \x26quot;add\x26quot;) {\n      \/\/ 文件事件触发具体逻辑\n    } else if(!initial \x26amp;\x26amp; !mtime) {\n      \/\/ 文件事件触发具体逻辑\n    }\n    if(this.watchers[withoutCase(this.path)]) {\n      \/\/ 文件目录事件触发\n    }\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3ewatchpack\/lib\/DirectoryWatcher.js\n\nDirectoryWatcher.prototype.setFileTime = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3esetFileTime\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3efilePath, mtime, initial, type\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e now = \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e.now();\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e old = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.files[filePath];\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.files[filePath] = [initial ? \x3cspan class=\x22hljs-built_in\x22\x3eMath\x3c\/span\x3e.min(now, mtime) : now, mtime];\n      \n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(!old) {\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(mtime) {\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watchers[withoutCase(filePath)]) {\n               \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 文件事件触发具体逻辑\x3c\/span\x3e\n            }\n        }\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(!initial \x26amp;\x26amp; mtime \x26amp;\x26amp; type !== \x3cspan class=\x22hljs-string\x22\x3e\x22add\x22\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 文件事件触发具体逻辑\x3c\/span\x3e\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(!initial \x26amp;\x26amp; !mtime) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 文件事件触发具体逻辑\x3c\/span\x3e\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watchers[withoutCase(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.path)]) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 文件目录事件触发\x3c\/span\x3e\n    }\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e事件触发分为两个大的阶段，第一个阶段为对于 \x3ccode\x3efilePath\x3c\/code\x3e 文件的事件触发，第二个阶段为对于当前 \x3ccode\x3eDirectoryWatcher\x3c\/code\x3e 对应 \x3ccode\x3epath\x3c\/code\x3e 属性文件夹的事件触发。\x3c\/p\x3e\n\x3cp\x3e1.\x3ccode\x3efilepath\x3c\/code\x3e 文件的事件触发\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22watchpack\/lib\/DirectoryWatcher.js\n\nDirectoryWatcher.prototype.setFileTime = function setFileTime(filePath, mtime, initial, type) {\n    var now = Date.now();\n    var old = this.files[filePath];\n    this.files[filePath] = [initial ? Math.min(now, mtime) : now, mtime];\n    if(!old) {\n        if(mtime) {\n            if(this.watchers[withoutCase(filePath)]) {\n                this.watchers[withoutCase(filePath)].forEach(function(w) {\n                    if(!initial || w.checkStartTime(mtime, initial)) {\n                        w.emit(\x26quot;change\x26quot;, mtime);\n                    }\n                });\n            }\n        }\n    } else if(!initial \x26amp;\x26amp; mtime \x26amp;\x26amp; type !== \x26quot;add\x26quot;) {\n        if(this.watchers[withoutCase(filePath)]) {\n            this.watchers[withoutCase(filePath)].forEach(function(w) {\n                w.emit(\x26quot;change\x26quot;, mtime);\n            });\n        }\n    } else if(!initial \x26amp;\x26amp; !mtime) {\n        if(this.watchers[withoutCase(filePath)]) {\n            this.watchers[withoutCase(filePath)].forEach(function(w) {\n                w.emit(\x26quot;remove\x26quot;);\n            });\n        }\n    }\n  \n      \/\/ 省略文件夹触发\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3ewatchpack\/lib\/DirectoryWatcher.js\n\nDirectoryWatcher.prototype.setFileTime = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3esetFileTime\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3efilePath, mtime, initial, type\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e now = \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e.now();\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e old = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.files[filePath];\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.files[filePath] = [initial ? \x3cspan class=\x22hljs-built_in\x22\x3eMath\x3c\/span\x3e.min(now, mtime) : now, mtime];\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(!old) {\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(mtime) {\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watchers[withoutCase(filePath)]) {\n                \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watchers[withoutCase(filePath)].forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ew\x3c\/span\x3e) \x3c\/span\x3e{\n                    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(!initial || w.checkStartTime(mtime, initial)) {\n                        w.emit(\x3cspan class=\x22hljs-string\x22\x3e\x22change\x22\x3c\/span\x3e, mtime);\n                    }\n                });\n            }\n        }\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(!initial \x26amp;\x26amp; mtime \x26amp;\x26amp; type !== \x3cspan class=\x22hljs-string\x22\x3e\x22add\x22\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watchers[withoutCase(filePath)]) {\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watchers[withoutCase(filePath)].forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ew\x3c\/span\x3e) \x3c\/span\x3e{\n                w.emit(\x3cspan class=\x22hljs-string\x22\x3e\x22change\x22\x3c\/span\x3e, mtime);\n            });\n        }\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(!initial \x26amp;\x26amp; !mtime) {\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watchers[withoutCase(filePath)]) {\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watchers[withoutCase(filePath)].forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ew\x3c\/span\x3e) \x3c\/span\x3e{\n                w.emit(\x3cspan class=\x22hljs-string\x22\x3e\x22remove\x22\x3c\/span\x3e);\n            });\n        }\n    }\n  \n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 省略文件夹触发\x3c\/span\x3e\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e文件事件触发，实际会涉及到三个逻辑，单纯已有文件改变的触发，对应第二个逻辑\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cp\x3e\x3cstrong\x3e对于 \x3ccode\x3efilePath\x3c\/code\x3e 之前没有数据设置的情况 \x3ccode\x3eif(!old)\x3c\/code\x3e \x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22   这里穿插到前面初始化的逻辑，在前面 `doIntialScan` 中 `initial` 的参数为 `true`， 则进入 `checkStartTime` 函数判断\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs autohotkey\x22\x3e\x3ccode\x3e   这里穿插到前面初始化的逻辑，在前面 `doIntialScan` 中 `initial` 的参数为 `true`， 则进入 `checkStartTime` 函数判断\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22watchpack\/lib\/DirectoryWatcher.js\n\nWatcher.prototype.checkStartTime = function checkStartTime(mtime, initial) {\nif(typeof this.startTime !== \x26quot;number\x26quot;) return !initial;\nvar startTime = this.startTime \x26amp;\x26amp; Math.floor(this.startTime \/ FS_ACCURENCY) * FS_ACCURENCY;\nreturn startTime \x3c= mtime;\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3ewatchpack\/lib\/DirectoryWatcher.js\n\nWatcher.prototype.checkStartTime = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3echeckStartTime\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3emtime, initial\x3c\/span\x3e) \x3c\/span\x3e{\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.startTime !== \x3cspan class=\x22hljs-string\x22\x3e\x22number\x22\x3c\/span\x3e) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e !initial;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e startTime = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.startTime \x26amp;\x26amp; \x3cspan class=\x22hljs-built_in\x22\x3eMath\x3c\/span\x3e.floor(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.startTime \/ FS_ACCURENCY) * FS_ACCURENCY;\n\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e startTime \x26lt;= mtime;\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  会去比较编译开始时间 `statrTime` 与文件最后修改时间 `mtime` 来判断是否需要触发事件，`doInitialScan` 场景下，默认 `FS_ACCURENCY` 的值是 `10000` ，意思是在编译前的 10s 范围内的改动都会触发 `change` 事件，那么这样是否会存在初始化时多触发一次编译呢？在上面提到  [issue](https:\/\/github.com\/webpack\/watchpack\/issues\/25) 中，作者同样给出了解释\n   \x3e This may not happen fast enough if you have few files and the files are created unlucky on a timestamp modulo 10s\n\n   \x3e The watching may loop in a unlucky case, but this should not result in a different compilation hash. I. e. the webpack-dev-server doesn\x27t trigger a update if the hash is equal.\n\n   及时触发这样的 `unlucky case`，也只会在 `doInitailScan` 过程中文件内容真正发生变化导致 `hash` 变化的时候再次触发编译更新。\n\n   这条判断同样适用当有新增文件，触发 `add` 事件的情况。\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs markdown\x22\x3e\x3ccode\x3e  会去比较编译开始时间 \x3cspan class=\x22hljs-code\x22\x3e`statrTime`\x3c\/span\x3e 与文件最后修改时间 \x3cspan class=\x22hljs-code\x22\x3e`mtime`\x3c\/span\x3e 来判断是否需要触发事件，\x3cspan class=\x22hljs-code\x22\x3e`doInitialScan`\x3c\/span\x3e 场景下，默认 \x3cspan class=\x22hljs-code\x22\x3e`FS_ACCURENCY`\x3c\/span\x3e 的值是 \x3cspan class=\x22hljs-code\x22\x3e`10000`\x3c\/span\x3e ，意思是在编译前的 10s 范围内的改动都会触发 \x3cspan class=\x22hljs-code\x22\x3e`change`\x3c\/span\x3e 事件，那么这样是否会存在初始化时多触发一次编译呢？在上面提到  [\x3cspan class=\x22hljs-string\x22\x3eissue\x3c\/span\x3e](\x3cspan class=\x22hljs-link\x22\x3ehttps:\/\/github.com\/webpack\/watchpack\/issues\/25\x3c\/span\x3e) 中，作者同样给出了解释\n   \x26gt; This may not happen fast enough if you have few files and the files are created unlucky on a timestamp modulo 10s\n\n   \x26gt; The watching may loop in a unlucky case, but this should not result in a different compilation hash. I. e. the webpack-dev-server doesn\x27t trigger a update if the hash is equal.\n\n   及时触发这样的 \x3cspan class=\x22hljs-code\x22\x3e`unlucky case`\x3c\/span\x3e，也只会在 \x3cspan class=\x22hljs-code\x22\x3e`doInitailScan`\x3c\/span\x3e 过程中文件内容真正发生变化导致 \x3cspan class=\x22hljs-code\x22\x3e`hash`\x3c\/span\x3e 变化的时候再次触发编译更新。\n\n   这条判断同样适用当有新增文件，触发 \x3cspan class=\x22hljs-code\x22\x3e`add`\x3c\/span\x3e 事件的情况。\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e\x3cstrong\x3e对于已有文件变化（非 \x3ccode\x3edoInitial\x3c\/code\x3e 过程中、\x3ccode\x3eadd\x3c\/code\x3e 新增文件事件触发，\x3ccode\x3eif(!initial \x26amp;\x26amp; mtime \x26amp;\x26amp; type !== \x22add\x22)\x3c\/code\x3e）\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  对应这种情况，则直接会触发 `change` 事件\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs autohotkey\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e  对应这种情况，则直接会触发 `change` 事件\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22if(this.watchers[withoutCase(filePath)]) {\n  this.watchers[withoutCase(filePath)].forEach(function(w) {\nw.emit(\x26quot;change\x26quot;, mtime);\n  });\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watchers[withoutCase(filePath)]) {\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watchers[withoutCase(filePath)].forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ew\x3c\/span\x3e) \x3c\/span\x3e{\nw.emit(\x3cspan class=\x22hljs-string\x22\x3e\x22change\x22\x3c\/span\x3e, mtime);\n  });\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22   找到对应文件的监听 `watcher` 触发 `change` 事件，对应上层逻辑逻辑进行响应。\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs autohotkey\x22\x3e\x3ccode\x3e   找到对应文件的监听 `watcher` 触发 `change` 事件，对应上层逻辑逻辑进行响应。\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e\x3cstrong\x3e\x3ccode\x3emtime\x3c\/code\x3e 不存在的情况（文件删除）\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22watchpack\/lib\/DirectoryWatcher.js\n\nthis.watcher.on(\x26quot;unlink\x26quot;, this.onFileUnlinked.bind(this));\nDirectoryWatcher.prototype.onFileUnlinked = function onFileUnlinked(filePath) {\n  \/\/ 省略其他操作\n  this.setFileTime(filePath, null, false, \x26quot;unlink\x26quot;);\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3ewatchpack\/lib\/DirectoryWatcher.js\n\n\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watcher.on(\x3cspan class=\x22hljs-string\x22\x3e\x22unlink\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.onFileUnlinked.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e));\nDirectoryWatcher.prototype.onFileUnlinked = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eonFileUnlinked\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3efilePath\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 省略其他操作\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setFileTime(filePath, \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e, \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22unlink\x22\x3c\/span\x3e);\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 当文件删除触发 `unlink` 事件时，调用 `setFileTime` 时，则会传递 `mtime` 为 `null`。则事件触发逻辑与第二种情况方式相同，只是从 `change` 事件变成了 `remove` 事件。\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs autohotkey\x22\x3e\x3ccode\x3e 当文件删除触发 `unlink` 事件时，调用 `setFileTime` 时，则会传递 `mtime` 为 `null`。则事件触发逻辑与第二种情况方式相同，只是从 `change` 事件变成了 `remove` 事件。\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e2.\x3ccode\x3eDirectoryWatcher\x3c\/code\x3e 对应 \x3ccode\x3epath\x3c\/code\x3e 属性文件夹的事件触发\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22DirectoryWatcher.prototype.setFileTime = function setFileTime(filePath, mtime, initial, type) {\n      \/\/ 省略文件触发\n  \n    if(this.watchers[withoutCase(this.path)]) {\n        this.watchers[withoutCase(this.path)].forEach(function(w) {\n            if(!initial || w.checkStartTime(mtime, initial)) {\n                w.emit(\x26quot;change\x26quot;, filePath, mtime);\n            }\n        });\n    }\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eDirectoryWatcher.prototype.setFileTime = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3esetFileTime\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3efilePath, mtime, initial, type\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 省略文件触发\x3c\/span\x3e\n  \n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watchers[withoutCase(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.path)]) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watchers[withoutCase(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.path)].forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ew\x3c\/span\x3e) \x3c\/span\x3e{\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(!initial || w.checkStartTime(mtime, initial)) {\n                w.emit(\x3cspan class=\x22hljs-string\x22\x3e\x22change\x22\x3c\/span\x3e, filePath, mtime);\n            }\n        });\n    }\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e因为是监听的是文件夹下的文件发生的变化，所以在完成了对应文件事件的触发之后，会进行监听文件夹（路径为实例化 \x3ccode\x3eDirectoryWatcher\x3c\/code\x3e  时传入的 \x3ccode\x3ethis.path\x3c\/code\x3e）的触发，这里除了会将文件的最后修改时间 \x3ccode\x3emtine\x3c\/code\x3e 传递，还会将对应的文件路径 \x3ccode\x3ethis.filePath\x3c\/code\x3e 也当做参数一起传递到绑定的事件回调参数中。\x3c\/p\x3e\n\x3cp\x3e在通过 \x3ccode\x3ewatcher\x3c\/code\x3e 这个继承了 \x3ccode\x3eEventEmitter\x3c\/code\x3e 对象的实例触发事件后，就完成了底层文件（夹）监听触发的功能，紧接着就是上层对象对于 \x3ccode\x3ewatcher\x3c\/code\x3e 实例的事件触发的对应处理，最终关联上 \x3ccode\x3ewebpack\x3c\/code\x3e 的编译启动流程。\x3c\/p\x3e\n\x3ch4\x3e上层响应\x3c\/h4\x3e\n\x3ch5\x3ewatchpack.js\x3c\/h5\x3e\n\x3cp\x3e在上面有提到\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e在 \x3ccode\x3ewatcherManager.js\x3c\/code\x3e 文件中的 \x3ccode\x3ewatchFile\x3c\/code\x3e 以及 \x3ccode\x3ewatchDirectory\x3c\/code\x3e 都传递了同类型的参数调用了 \x3ccode\x3ethis.getDirectoryWatcher\x3c\/code\x3e ，并在随后调用了返回实例的 \x3ccode\x3ewatch\x3c\/code\x3e 方法，并将 \x3ccode\x3ewatch\x3c\/code\x3e 方法的返回继续往上层 \x3ccode\x3ewatchpack.js\x3c\/code\x3e 的 \x3ccode\x3ethis._fileWatcher\x3c\/code\x3e 与 \x3ccode\x3ethis._dirWatcher\x3c\/code\x3e 方法。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e则 \x3ccode\x3ewatch\x3c\/code\x3e 实例的上层响应的第一层在 \x3ccode\x3ewatchpack.js\x3c\/code\x3e 中的 \x3ccode\x3eWatchpack.prototype._fileWatcher\x3c\/code\x3e 、\x3ccode\x3eWatchpack.prototype._dirWatcher\x3c\/code\x3e 中完成，分别针对文件和文件夹的变更处理\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22watchpack\/lib\/watchpack.js\n\nWatchpack.prototype._fileWatcher = function _fileWatcher(file, watcher) {\n    watcher.on(\x26quot;change\x26quot;, this._onChange.bind(this, file));\n    return watcher;\n};\n\nWatchpack.prototype._dirWatcher = function _dirWatcher(item, watcher) {\n    watcher.on(\x26quot;change\x26quot;, function(file, mtime) {\n        this._onChange(item, mtime, file);\n    }.bind(this));\n    return watcher;\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3ewatchpack\/lib\/watchpack.js\n\nWatchpack.prototype._fileWatcher = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e_fileWatcher\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3efile, watcher\x3c\/span\x3e) \x3c\/span\x3e{\n    watcher.on(\x3cspan class=\x22hljs-string\x22\x3e\x22change\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._onChange.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, file));\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e watcher;\n};\n\nWatchpack.prototype._dirWatcher = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e_dirWatcher\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eitem, watcher\x3c\/span\x3e) \x3c\/span\x3e{\n    watcher.on(\x3cspan class=\x22hljs-string\x22\x3e\x22change\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3efile, mtime\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._onChange(item, mtime, file);\n    }.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e));\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e watcher;\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里 \x3ccode\x3e_fileWatcher\x3c\/code\x3e 和 \x3ccode\x3e_dirWatcher\x3c\/code\x3e 对 \x3ccode\x3echange\x3c\/code\x3e 的事件都是将逻辑导向了 \x3ccode\x3eWatchpack.prototype._onChange\x3c\/code\x3e 中\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22watchpack\/lib\/watchpack.js\n\nWatchpack.prototype._onChange = function _onChange(item, mtime, file) {\n    file = file || item;\n    this.mtimes[file] = mtime;\n    if(this.paused) return;\n    this.emit(\x26quot;change\x26quot;, file, mtime);\n    if(this.aggregateTimeout)\n        clearTimeout(this.aggregateTimeout);\n    if(this.aggregatedChanges.indexOf(item) \x3c 0)\n        this.aggregatedChanges.push(item);\n    this.aggregateTimeout = setTimeout(this._onTimeout, this.options.aggregateTimeout);\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3ewatchpack\/lib\/watchpack.js\n\nWatchpack.prototype._onChange = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e_onChange\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eitem, mtime, file\x3c\/span\x3e) \x3c\/span\x3e{\n    file = file || item;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.mtimes[file] = mtime;\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.paused) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.emit(\x3cspan class=\x22hljs-string\x22\x3e\x22change\x22\x3c\/span\x3e, file, mtime);\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.aggregateTimeout)\n        clearTimeout(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.aggregateTimeout);\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.aggregatedChanges.indexOf(item) \x26lt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e)\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.aggregatedChanges.push(item);\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.aggregateTimeout = setTimeout(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._onTimeout, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.options.aggregateTimeout);\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e函数会首先触发 \x3ccode\x3eWatchpack\x3c\/code\x3e 实例的 \x3ccode\x3echange\x3c\/code\x3e 事件，传入触发的文件（夹）的路径，以及最后修改时间，供上层逻辑操作。\x3c\/p\x3e\n\x3cp\x3e然后开始进行 \x3ccode\x3eaggregate\x3c\/code\x3e 逻辑的触发，可以看到这里的大致含义是在文件（夹）发生变更 \x3ccode\x3ethis.aggregateTimeout\x3c\/code\x3e  后，进行 \x3ccode\x3eWatchpack.prototype._onTimeout\x3c\/code\x3e 逻辑，在此之前，会将修改的文件（夹）路径暂存到 \x3ccode\x3eaggregatedChanges\x3c\/code\x3e 数组中\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22watchpack\/lib\/watchpack.js\n\nWatchpack.prototype._onTimeout = function _onTimeout() {\n    this.aggregateTimeout = 0;\n    var changes = this.aggregatedChanges;\n    this.aggregatedChanges = [];\n    this.emit(\x26quot;aggregated\x26quot;, changes);\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3ewatchpack\/lib\/watchpack.js\n\nWatchpack.prototype._onTimeout = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e_onTimeout\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.aggregateTimeout = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e changes = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.aggregatedChanges;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.aggregatedChanges = [];\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.emit(\x3cspan class=\x22hljs-string\x22\x3e\x22aggregated\x22\x3c\/span\x3e, changes);\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e而 \x3ccode\x3eWatchpack.prototype._onTimeout\x3c\/code\x3e 则是当最后一次文件（夹）触发之后没有变更的 200ms 后，通过 \x3ccode\x3ethis.aggregatedChanges\x3c\/code\x3e 将接连不断的变更聚合通过 \x3ccode\x3eaggregated\x3c\/code\x3e 事件传递给上层。\x3c\/p\x3e\n\x3cp\x3e那么对应每一个变更，实际会牵涉触发一次 \x3ccode\x3echange\x3c\/code\x3e 事件，以及关联一次 \x3ccode\x3eaggregated\x3c\/code\x3e 事件，传给给上层，关联实际的编译重新触发逻辑。\x3c\/p\x3e\n\x3ch5\x3eNodeWatchFileSystem.js\x3c\/h5\x3e\n\x3cp\x3e前面提到\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e在 \x3ccode\x3eNodeWatchFileSystem.js\x3c\/code\x3e 中的实现再一次的依赖 \x3cstrong\x3e\x3ca href=\x22http:\/\/web.npm.alibaba-inc.com\/package\/watchpack\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ewatchpack\x3c\/a\x3e\x3c\/strong\x3e 完成。通过封装 \x3ccode\x3ewatchpack\x3c\/code\x3e 的监听逻辑，完成绑定相应的文件变更事件，进行上层 \x3ccode\x3ecompiler.invalidate\x3c\/code\x3e 方法调用，触发再次编译流程。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e那么绑定 \x3ccode\x3ewatchpack\x3c\/code\x3e 实例的事件，来完成这一层的逻辑\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22webpack\/lib\/NodeWatchFileSystem.js\n\nNodeWatchFileSystem.prototype.watch = function watch(files, dirs, missing, startTime, options, callback, callbackUndelayed) {\n    \/\/ 省略参数合法性检测\n  \n    this.watcher = new Watchpack(options);\n\n    if(callbackUndelayed)\n        this.watcher.once(\x26quot;change\x26quot;, callbackUndelayed);\n\n    this.watcher.once(\x26quot;aggregated\x26quot;, function(changes) {\n          \/\/1.\n        if(this.inputFileSystem \x26amp;\x26amp; this.inputFileSystem.purge) {\n            this.inputFileSystem.purge(changes);\n        }\n          \/\/2.\n        var times = this.watcher.getTimes();\n          \/\/3.\n        callback(null, changes.filter(function(file) {\n            return files.indexOf(file) \x3e= 0;\n        }).sort(), changes.filter(function(file) {\n            return dirs.indexOf(file) \x3e= 0;\n        }).sort(), changes.filter(function(file) {\n            return missing.indexOf(file) \x3e= 0;\n        }).sort(), times, times);\n    }.bind(this));\n\n    this.watcher.watch(files.concat(missing), dirs, startTime);\n  \n    \/\/ 省略返回\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3ewebpack\/lib\/NodeWatchFileSystem.js\n\nNodeWatchFileSystem.prototype.watch = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ewatch\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3efiles, dirs, missing, startTime, options, callback, callbackUndelayed\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 省略参数合法性检测\x3c\/span\x3e\n  \n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watcher = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Watchpack(options);\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(callbackUndelayed)\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watcher.once(\x3cspan class=\x22hljs-string\x22\x3e\x22change\x22\x3c\/span\x3e, callbackUndelayed);\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watcher.once(\x3cspan class=\x22hljs-string\x22\x3e\x22aggregated\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3echanges\x3c\/span\x3e) \x3c\/span\x3e{\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/1.\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.inputFileSystem \x26amp;\x26amp; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.inputFileSystem.purge) {\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.inputFileSystem.purge(changes);\n        }\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/2.\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e times = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watcher.getTimes();\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/3.\x3c\/span\x3e\n        callback(\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e, changes.filter(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3efile\x3c\/span\x3e) \x3c\/span\x3e{\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e files.indexOf(file) \x26gt;= \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n        }).sort(), changes.filter(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3efile\x3c\/span\x3e) \x3c\/span\x3e{\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e dirs.indexOf(file) \x26gt;= \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n        }).sort(), changes.filter(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3efile\x3c\/span\x3e) \x3c\/span\x3e{\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e missing.indexOf(file) \x26gt;= \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n        }).sort(), times, times);\n    }.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e));\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.watcher.watch(files.concat(missing), dirs, startTime);\n  \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 省略返回\x3c\/span\x3e\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e与上面 \x3ccode\x3ewatchpack\x3c\/code\x3e 触发事件一致，在 \x3ccode\x3eNodeWatchFileSystem\x3c\/code\x3e 这一层逻辑中，其实对下一层 \x3ccode\x3eWatchpack\x3c\/code\x3e 的就是通过绑定主要的 \x3ccode\x3echange\x3c\/code\x3e、\x3ccode\x3eaggregated\x3c\/code\x3e 事件完成的。\x3c\/p\x3e\n\x3cp\x3e对于 \x3ccode\x3echange\x3c\/code\x3e 事件，会直接传递到上层的 \x3ccode\x3ecallbackUndelayed\x3c\/code\x3e 中\x3c\/p\x3e\n\x3cp\x3e对于 \x3ccode\x3eaggregated\x3c\/code\x3e 事件，\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e首先会调用 \x3ccode\x3ethis.inputFileSystem.purge(changes)\x3c\/code\x3e ，将文件系统中涉及到变更的文件的记录清空。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e其次调用 \x3ccode\x3eWatchpack\x3c\/code\x3e 实例的 \x3ccode\x3egetTimes()\x3c\/code\x3e 方法获取监听文件（夹）的 \x3ccode\x3e变更流程执行时间点\x3c\/code\x3e、\x3ccode\x3e文件最后修改时间点\x3c\/code\x3e 的最大值，便于在后续判断是否需要进行重新编译，例如 \x3ccode\x3ecacheModule.needRebuild(this.fileTimestamps, this.contextTimestamps);\x3c\/code\x3e。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e最后在调用上层回调之前，会将变化的文件（夹）根据监听时传入参数通过挨个过滤的方式进行分发到每个参数中，完成之后，流程就会走到最后一层也是最初调用监听的一层 \x3ccode\x3eCompiler.js\x3c\/code\x3e。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch5\x3eCompiler.js\x3c\/h5\x3e\n\x3cp\x3e在上文中提过\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e\x3ccode\x3eWatching.prototype.watch\x3c\/code\x3e 通过 \x3ccode\x3ecompiler.watchFileSystem\x3c\/code\x3e 的 \x3ccode\x3ewatch\x3c\/code\x3e 方法实现，可以大致看出在变化触发编译后，会执行传递的回调函数，最终会调用 \x3ccode\x3eWatching.prototype.invalidate\x3c\/code\x3e 进行编译触发\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e从调用开始，通过最底层的 \x3ccode\x3echokidar\x3c\/code\x3e 完成文件（夹）监听事件的触发，通过事件传递的方式，又回到调用处，进行重新编译。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000008111802?w=1022\x26amp;h=558\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000008111802?w=1022\x26amp;h=558\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e回顾整个触发流程，纵向 4 个逻辑层级之间进行传递，\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eDirectoryWatcher\x3c\/code\x3e：完成对文件（夹）的监听实现，以及初步监听数据加工\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3ewatchpack\x3c\/code\x3e：完成触发底层逻辑的封装，实现上层逻辑跟触发逻辑解耦\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eNodeWatchFileSystem\x3c\/code\x3e：完成对监听数据业务逻辑处理，进行最后回调处理\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eCompiler\x3c\/code\x3e：完成最终业务响应\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e总结 \x26amp; 衔接\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3ewatch\x3c\/code\x3e 流程利用事件模型，采用多个逻辑层的设计，对复杂的触发流程进行解耦拆分，实现了比较清晰可维护的代码结构。\x3c\/p\x3e\n\x3cp\x3e在完成 \x3ccode\x3ewatch\x3c\/code\x3e 流程，触发重新编译后，与 \x3ccode\x3erun\x3c\/code\x3e 流程相不同的是，\x3ccode\x3ewebpack\x3c\/code\x3e 为了提高编译速度，降低编译的时间消耗与提高编译性能，在重新编译的很多环节中都设置了缓存机制，让二次编译的速度得到大大提高。下一篇文章主要对 cache 的情况进行描述。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>webpack 中的 watch &amp; cache （上）</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000008111793">https://segmentfault.com/a/1190000008111793</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/6wanx5muaxy/" target="_blank">https://alili.tech/archive/6wanx5muaxy/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>