<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="React 状态管理库: Mobx"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>React 状态管理库: Mobx | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/yz5jpugvmg/",
				"appid": "1613049289050283", 
				"title": "React 状态管理库: Mobx | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-09T02:30:12"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/splxyfl3yyn/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/0b5b14ie1va7/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fyz5jpugvmg%2f&text=React%20%e7%8a%b6%e6%80%81%e7%ae%a1%e7%90%86%e5%ba%93%3a%20Mobx"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fyz5jpugvmg%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fyz5jpugvmg%2f&text=React%20%e7%8a%b6%e6%80%81%e7%ae%a1%e7%90%86%e5%ba%93%3a%20Mobx"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fyz5jpugvmg%2f&title=React%20%e7%8a%b6%e6%80%81%e7%ae%a1%e7%90%86%e5%ba%93%3a%20Mobx"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fyz5jpugvmg%2f&is_video=false&description=React%20%e7%8a%b6%e6%80%81%e7%ae%a1%e7%90%86%e5%ba%93%3a%20Mobx"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=React%20%e7%8a%b6%e6%80%81%e7%ae%a1%e7%90%86%e5%ba%93%3a%20Mobx&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fyz5jpugvmg%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fyz5jpugvmg%2f&title=React%20%e7%8a%b6%e6%80%81%e7%ae%a1%e7%90%86%e5%ba%93%3a%20Mobx"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fyz5jpugvmg%2f&title=React%20%e7%8a%b6%e6%80%81%e7%ae%a1%e7%90%86%e5%ba%93%3a%20Mobx"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fyz5jpugvmg%2f&title=React%20%e7%8a%b6%e6%80%81%e7%ae%a1%e7%90%86%e5%ba%93%3a%20Mobx"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fyz5jpugvmg%2f&title=React%20%e7%8a%b6%e6%80%81%e7%ae%a1%e7%90%86%e5%ba%93%3a%20Mobx"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">React 状态管理库: Mobx</h1><div class="meta"><div class="postdate"><time datetime="2019-01-09" itemprop="datePublished">2019-01-09</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3eReact 是一个专注于视图层的库。React 维护了状态到视图的映射关系，开发者只需关心状态即可，由 React 来操控视图。\x3c\/p\x3e\n\x3cp\x3e在小型应用中，单独使用 React 是没什么问题的。但在复杂应用中，容易碰到一些状态管理方面的问题，如：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eReact 只提供了在内部组件修改状态的接口 \x3ccode\x3esetState\x3c\/code\x3e。导致数据、业务逻辑和视图层耦合在组件内部，不利于扩展和维护。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eReact 应用即一颗组件树。兄弟节点，或者不在同一树杈的节点之间的状态同步是非常麻烦。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e关心性能的情况下，需要手动设置 \x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e这时就需要引入状态管理库。现在常用的状态管理库有 Mobx 和 Redux，本文会重点介绍 Mobx，然后会将 Mobx 和 Redux 进行对比，最后展望下未来的 React 状态管理方面趋势。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3eMobx 简介\x3c\/h2\x3e\n\x3cp\x3eMobx 的理念非常简单，可以用一个 demo 就把其核心原理说清楚。Mobx\/MobxReact 中有三个核心概念，\x3ccode\x3eobservable\x3c\/code\x3e、\x3ccode\x3eobserver\x3c\/code\x3e、\x3ccode\x3eaction\x3c\/code\x3e。为了简单起见，本文没有提及 \x3ccode\x3ecomputed\x3c\/code\x3e 等概念。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eobservable\x3c\/code\x3e: 通过 \x3ccode\x3eobservable(state)\x3c\/code\x3e 定义组件的状态，包装后的状态是一个可观察数据（Observable Data）。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eobserver\x3c\/code\x3e: 通过 \x3ccode\x3eobserver(ReactComponent)\x3c\/code\x3e 定义组件。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eaction\x3c\/code\x3e: 通过 \x3ccode\x3eaction\x3c\/code\x3e 来修改状态。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e简化图如下：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVQtuq?w=816\x26amp;h=940\x22 src=\x22https:\/\/static.alili.tech\/img\/bVQtuq?w=816\x26amp;h=940\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e只讲概念还比较模糊，下面给大家举个例子。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/jsfiddle.net\/jhwleo\/1L5jcykr\/9\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e点击运行 https:\/\/jsfiddle.net\/jhwleo\/1L5jcykr\/9\/\x3c\/a\x3e\x3cbutton class=\x22btn btn-xs btn-default ml10 preview\x22 data-url=\x22jhwleo\/1L5jcykr\/9\/\x22 data-typeid=\x220\x22\x3e点击预览\x3c\/button\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 通过 observable 定义组件的状态\nconst user = mobx.observable({\n    name: \x26quot;Jay\x26quot;,\n     age: 22\n})\n\n\/\/ 通过 action 定义如何修改组件的状态\nconst changeName = mobx.action(name =\x3e user.name = name)\nconst changeAge = mobx.action(age =\x3e user.age = age)\n\n\/\/ 通过 observer 定义 ReactComponent 组件。\nconst Hello = mobxReact.observer(class Hello extends React.Component {\n        componentDidMount(){\n            \/\/ 视图层通过事件触发 action\n        changeName(\x27Wang\x27) \/\/ render Wang\n    }\n\n    render() {\n                \/\/ 渲染\n            console.log(\x27render\x27,user.name);\n        return \x3cdiv\x3eHello,{user.name}!\x3c\/div\x3e\n    }\n})\n\nReactDOM.render(\x3cHello \/\x3e, document.getElementById(\x27mount\x27));\n\n\/\/ 非视图层事件触发，外部直接触发 action\nchangeName(\x27Wang2\x27)\/\/ render Wang2\n\/\/ 重点：没有触发重新渲染\n\/\/ 原因：Hello 组件并没有用到 `user.age` 这个可观察数据\nchangeAge(\x2718\x27)  \/\/ no console\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 通过 observable 定义组件的状态\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e user = mobx.observable({\n    \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22Jay\x22\x3c\/span\x3e,\n     \x3cspan class=\x22hljs-attr\x22\x3eage\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e22\x3c\/span\x3e\n})\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 通过 action 定义如何修改组件的状态\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e changeName = mobx.action(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3ename\x3c\/span\x3e =\x26gt;\x3c\/span\x3e user.name = name)\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e changeAge = mobx.action(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eage\x3c\/span\x3e =\x26gt;\x3c\/span\x3e user.age = age)\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 通过 observer 定义 ReactComponent 组件。\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e Hello = mobxReact.observer(\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eHello\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n        componentDidMount(){\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 视图层通过事件触发 action\x3c\/span\x3e\n        changeName(\x3cspan class=\x22hljs-string\x22\x3e\x27Wang\x27\x3c\/span\x3e) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ render Wang\x3c\/span\x3e\n    }\n\n    render() {\n                \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 渲染\x3c\/span\x3e\n            \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27render\x27\x3c\/span\x3e,user.name);\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3eHello,{user.name}!\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n    }\n})\n\nReactDOM.render(\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eHello\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e, document.getElementById(\x27mount\x27));\n\n\/\/ 非视图层事件触发，外部直接触发 action\nchangeName(\x27Wang2\x27)\/\/ render Wang2\n\/\/ 重点：没有触发重新渲染\n\/\/ 原因：Hello 组件并没有用到 `user.age` 这个可观察数据\nchangeAge(\x2718\x27)  \/\/ no console\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e例子看完了，是不是非常简单。\x3c\/p\x3e\n\x3cp\x3e使用 Mobx，组件状态可以在外部定义（也可以在组件内部），因此，数据、业务逻辑可以轻易地和视图层分离，提高应用的可扩展性和可维护性。另外，由于组件状态可以在外部定义，兄弟节点之间的状态同步也非常容易。最后一点， Mobx 知道什么时候应该渲染页面，因此基本不需要手动设置 \x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e 来提高应用性能。\x3c\/p\x3e\n\x3cp\x3e接下来给大家介绍下 Mobx 中 \x3ccode\x3eobservable\x3c\/code\x3e \x3ccode\x3eobserver\x3c\/code\x3e \x3ccode\x3eaction\x3c\/code\x3e 的用法，并会简单介绍一下其原理。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3eobservable\x3c\/h3\x3e\n\x3cp\x3eMobx 如此简单的原因之一，就是使用了\x3cstrong\x3e可观察数据\x3c\/strong\x3e(Observable Data)。简单说，可观察数据就是可以观察到数据的读取、写入，并进行拦截。\x3c\/p\x3e\n\x3cp\x3eMobx 提供了 \x3ccode\x3eobservable\x3c\/code\x3e 接口来定义可观察数据。定义的可观察数据，通常也是组件的状态。该方法接收一个参数，参数可以是原始数据类型、普通 Object、Array、或者 ES6 中的 Map 类型，返回一个 \x3ccode\x3eobservable\x3c\/code\x3e 类型的参数。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Array.isArray(mobx.observable([1,2,3])) === false \/\/ true\nmobx.isObservable(mobx.observable([1,2,3])) === true \/\/ true\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.isArray(mobx.observable([\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e])) === \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\nmobx.isObservable(mobx.observable([\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e])) === \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e注意，数组经过 \x3ccode\x3eobservable\x3c\/code\x3e 包装后，就不是 Array 类型了，而是 Mobx 定义的一个特殊类型 ———— \x3ccode\x3eobservable\x3c\/code\x3e 类型。\x3ccode\x3eobservable\x3c\/code\x3e 类型，可以通过 \x3ccode\x3emobx.isObservable\x3c\/code\x3e 来检查。\x3c\/p\x3e\n\x3cp\x3e虽然数据类型不一样，但是使用方式基本和原来一致(原始数据类型除外)。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const observableArr =  mobx.observable([1,2,3]);\nconst observableObj =  mobx.observable({name: \x27Jay\x27});\nconst observableMap =  mobx.observable(new Map([[\x27name\x27,\x27Wang\x27]]));\n\nconsole.log(observableArr[0])  \/\/ 1\nconsole.log(observableObj.name)  \/\/ Jay\nconsole.log(observableMap.get(\x27name\x27))  \/\/ Wang\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e observableArr =  mobx.observable([\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e]);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e observableObj =  mobx.observable({\x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Jay\x27\x3c\/span\x3e});\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e observableMap =  mobx.observable(\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eMap\x3c\/span\x3e([[\x3cspan class=\x22hljs-string\x22\x3e\x27name\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27Wang\x27\x3c\/span\x3e]]));\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(observableArr[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e])  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 1\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(observableObj.name)  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Jay\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(observableMap.get(\x3cspan class=\x22hljs-string\x22\x3e\x27name\x27\x3c\/span\x3e))  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Wang\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可观察数据类型的原理是，在读取数据时，通过 \x3ccode\x3egetter\x3c\/code\x3e 来拦截，在写入数据时，通过\x3ccode\x3esetter\x3c\/code\x3e 来拦截。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Object.defineProperty(o, key, {\n  get : function(){\n        \/\/ 收集依赖的组件\n    return value;\n  },\n  set : function(newValue){\n        \/\/ 通知依赖的组件更新\n        value = newValue\n  },\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperty(o, key, {\n  \x3cspan class=\x22hljs-attr\x22\x3eget\x3c\/span\x3e : \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 收集依赖的组件\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e value;\n  },\n  \x3cspan class=\x22hljs-attr\x22\x3eset\x3c\/span\x3e : \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3enewValue\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 通知依赖的组件更新\x3c\/span\x3e\n        value = newValue\n  },\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在可观察数据被组件读取时，Mobx 会进行拦截，并记录该组件和可观察数据的依赖关系。在可观察数据被写入时，Mobx 也会进行拦截，并通知依赖它的组件重新渲染。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3eobserver\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3eobserver\x3c\/code\x3e 接收一个 React 组件作为参数，并将其转变成响应式（Reactive）组件。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 普通组件\nconst Hello = mobxReact.observer(class Hello extends React.Component {\n    render() {\n        return \x3cdiv\x3eHello,{user.name}!\x3c\/div\x3e\n    }\n})\n\n\/\/ 函数组件\nconst Hello = mobxReact.observer( () =\x3e (\n    \x3cdiv\x3eHello,{user.name}!\x3c\/div\x3e\n))\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 普通组件\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e Hello = mobxReact.observer(\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eHello\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n    render() {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3eHello,{user.name}!\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n    }\n})\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 函数组件\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e Hello = mobxReact.observer( \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e (\n    \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3eHello,{user.name}!\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n))\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e响应式组件，即当且仅当组件依赖的可观察数据发生改变时，组件才会自动响应，并重新渲染。\x3c\/p\x3e\n\x3cp\x3e在本文最开始的例子中，响应式组件依赖了 \x3ccode\x3euser.name\x3c\/code\x3e，但是没有依赖 \x3ccode\x3euser.age\x3c\/code\x3e。所以当\x3ccode\x3euser.name\x3c\/code\x3e 发现变化时，组件更新。而 \x3ccode\x3euser.age\x3c\/code\x3e 发生变化时，组件没有更新。\x3c\/p\x3e\n\x3cp\x3e这里再详细分析本文中的第一个例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22user.name = \x27Wang2\x27\/\/ render Wang2\n\/\/ 重点：没有触发重新渲染\n\/\/ 原因：Hello 组件并没有用到 `user.age` 这个可观察数据\nuser.age = \x2718\x27  \/\/ no console\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3euser.name = \x3cspan class=\x22hljs-string\x22\x3e\x27Wang2\x27\x3c\/span\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ render Wang2\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 重点：没有触发重新渲染\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 原因：Hello 组件并没有用到 `user.age` 这个可观察数据\x3c\/span\x3e\nuser.age = \x3cspan class=\x22hljs-string\x22\x3e\x2718\x27\x3c\/span\x3e  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ no console\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当可观察数据变化时，Mobx 会调用 \x3ccode\x3eforceUpdate\x3c\/code\x3e 直接更新组件。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/mobxjs\/mobx-react\/blob\/4177daa6685dc6c40a232aeb297f93ee27675bde\/src\/observer.js#L182\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e源码地址\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e而在传统 React 应用中，当状态、属性变化后会先调用 \x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e，该方法会深层对比前后状态和属性是否发生改变，再确定是否更新组件。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e 是很消耗性能的。Mobx 通过可观察数据，精确地知道组件是否需要更新，减少了调用 \x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e 这一步。这是 Mobx 性能好的原因之一。\x3c\/p\x3e\n\x3cp\x3e另外需要注意的是 \x3ccode\x3eobserver\x3c\/code\x3e 并不是 \x3ccode\x3emobx\x3c\/code\x3e 的方法，而是 \x3ccode\x3emobx-react\x3c\/code\x3e 的方法。\x3ccode\x3emobx\x3c\/code\x3e 和 \x3ccode\x3emobx-react\x3c\/code\x3e 关系如同 \x3ccode\x3ereact\x3c\/code\x3e 与 \x3ccode\x3ereact-dom\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3eaction\x3c\/h3\x3e\n\x3cp\x3e在 Mobx 中是可以直接修改可观察数据，来进行更新组件的，但不建议这样做。如果在任何地方都修改可观察数据，将导致页面状态难以管理。\x3c\/p\x3e\n\x3cp\x3e所有对可观察数据地修改，都应该在 \x3ccode\x3eaction\x3c\/code\x3e 中进行。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const changeName = mobx.action(name =\x3e user.name = name)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e changeName = mobx.action(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3ename\x3c\/span\x3e =\x26gt;\x3c\/span\x3e user.name = name)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e使用 Mobx 可以将组件状态定义在组件外部，这样，组件逻辑和组件视图便很容易分离，兄弟组件之间的状态也很容易同步。另外，也不再需要手动使用 \x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e 进行性能优化了。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3eMobx 与 Redux 对比\x3c\/h2\x3e\n\x3cp\x3eMobx 的优势来源于\x3cstrong\x3e可变数据\x3c\/strong\x3e（Mutable Data）和\x3cstrong\x3e可观察数据\x3c\/strong\x3e (Observable Data) 。\x3c\/p\x3e\n\x3cp\x3eRedux 的优势来源于\x3cstrong\x3e不可变数据\x3c\/strong\x3e（Immutable data）。\x3c\/p\x3e\n\x3cp\x3e可观察数据的优势，在前文已经介绍过了。现在再来聊聊可变数据和不可变数据。\x3c\/p\x3e\n\x3cp\x3e顾名思义，可变数据和不可变数据的区别在于，可变数据创建后可以修改，不可变数据创建后不可以修改。\x3c\/p\x3e\n\x3cp\x3e可变数据，可以直接修改，所以操作起来非常简单。这使得使用 mobx 改变状态，变得十分简单。\x3c\/p\x3e\n\x3cp\x3e不可变数据并不一定要用到 Immutable 库。它完全可以是一种约定，只要创建后不修改即可。比如说，Redux 中的 \x3ccode\x3estate\x3c\/code\x3e。每次修改都会重新生成一个 \x3ccode\x3enewState\x3c\/code\x3e ，而不会对原来的值进行改变。所以说 Redux 中的 \x3ccode\x3estate\x3c\/code\x3e 就是不可变数据。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22reducer(state, action) =\x3e newState.  \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3ereducer(state, action) =\x26gt; newState.  \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e不可变数据的优势在于，它可预测，可回溯。示例代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function foo(bar) {\n  let data = { key: \x27value\x27 };\n  bar(data);\n  console.log(data.key); \/\/ 猜猜会打印什么？\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ebar\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e data = { \x3cspan class=\x22hljs-attr\x22\x3ekey\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27value\x27\x3c\/span\x3e };\n  bar(data);\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data.key); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 猜猜会打印什么？\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果是可变数据，\x3ccode\x3edata.key\x3c\/code\x3e 的值可能会在 \x3ccode\x3ebar\x3c\/code\x3e 函数中被改变，所以不能确定会打印什么值。但是如果是不可变数据，那么就可以肯定打印值是什么。这就是不可变数据的优势 ———— 可预测。不可变数据不会随着时间的变化（程序的运行）而发生改变。在需要回溯的时候，直接获取保存的值即可。\x3c\/p\x3e\n\x3cp\x3eMobx 与 Redux 技术选型的本质，是在可变数据与不可变数据之间选择。具体业务场景的技术选型，还需要根据实际情况进行分析，脱离业务场景讨论技术选型是没有意义的。但我个人在状态管理的技术选型上，还是倾向于 Mobx 的。原因是前端与副作用打交道非常频繁，有 Http 请求的副作用，Dom 操作的副作用等等。使用不可变数据，还必须得使用中间件对副作用封装；在 Redux 中修改一次状态，需要经过 Action、Dispatch、Reducer 三个步骤，代码写起来太啰嗦；而前端的程序以中小型程序为主，纯函数带来的可预测性的收益，远不及其带的代码复杂度所需要付出的成本。而 Mobx 使用起来更加简单，更适合现在以业务驱动、快速迭代的开发节奏。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e展望：Mobx 与不可变数据的融合\x3c\/h2\x3e\n\x3cp\x3e不可变数据和可变数据，都是对状态的一种描述。那么有没有一种方案，能将一种状态，同时用可变数据和不可变数据来描述呢？这样就可以同时享有二者的优势了。(注意：当我们说可变数据时，通常它还是可观察数据，后文统一只说可变数据。)\x3c\/p\x3e\n\x3cp\x3e答案是肯定的，它就是 MST(mobx-state-tree) \x3ca href=\x22https:\/\/github.com\/mobxjs\/mobx-state-tree\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/mobxjs\/mob...\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3eMST 是一个状态容器：一种状态，同时包含了可变数据、不可变数据两种不同的形式。\x3c\/p\x3e\n\x3cp\x3e为了让状态可以在可变数据和不可变数据两种形式之间能够高效地相互转化，必须遵循 MST 定义状态的方法。\x3c\/p\x3e\n\x3cp\x3e在 MST 中，定义状态必须先定义它的结构。状态的结构是一颗树(tree)，树是由多层模型(model)组成，model 是由多个节点组成。\x3c\/p\x3e\n\x3cp\x3e在下面的代码中，树只有一层 model，该 model 也只有一个节点：title。title 的类型是事先定好的，在这里是 \x3ccode\x3etypes.string\x3c\/code\x3e。树的结构定义好后，通过 \x3ccode\x3ecreate\x3c\/code\x3e 方法传入数据，就生成树。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import {types} from \x26quot;mobx-state-tree\x26quot;\n\n\/\/ declaring the shape of a node with the type `Todo`\nconst Todo = types.model({\n    title: types.string\n})\n\n\/\/ creating a tree based on the \x26quot;Todo\x26quot; type, with initial data:\nconst coffeeTodo = Todo.create({\n    title: \x26quot;Get coffee\x26quot;\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e {types} \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22mobx-state-tree\x22\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ declaring the shape of a node with the type `Todo`\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e Todo = types.model({\n    \x3cspan class=\x22hljs-attr\x22\x3etitle\x3c\/span\x3e: types.string\n})\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ creating a tree based on the \x22Todo\x22 type, with initial data:\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e coffeeTodo = Todo.create({\n    \x3cspan class=\x22hljs-attr\x22\x3etitle\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22Get coffee\x22\x3c\/span\x3e\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在一些稍微复杂的例子中，树的 model 可以有多层，每层可以有多个节点，有些节点定义的是数据类型（\x3ccode\x3etypes.xxx\x3c\/code\x3e），有些节点直接定义的是数据。下面的示例中，就是定义了一个多层多节点的树。除此之外，注意 \x3ccode\x3etypes.model\x3c\/code\x3e 函数的第一个参数定义的是 model 的名字，第二参数定义的是 model 的所有属性，第三个参数定义的是 action。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import { types, onSnapshot } from \x26quot;mobx-state-tree\x26quot;\n\nconst Todo = types.model(\x26quot;Todo\x26quot;, {\n    title: types.string,\n    done: false\n}, {\n    toggle() {\n        this.done = !this.done\n    }\n})\n\nconst Store = types.model(\x26quot;Store\x26quot;, {\n    todos: types.array(Todo)\n})\n\n\/\/ create an instance from a snapshot\nconst store = Store.create({ todos: [{\n    title: \x26quot;Get coffee\x26quot;\n}]})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { types, onSnapshot } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22mobx-state-tree\x22\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e Todo = types.model(\x3cspan class=\x22hljs-string\x22\x3e\x22Todo\x22\x3c\/span\x3e, {\n    \x3cspan class=\x22hljs-attr\x22\x3etitle\x3c\/span\x3e: types.string,\n    \x3cspan class=\x22hljs-attr\x22\x3edone\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n}, {\n    toggle() {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.done = !\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.done\n    }\n})\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e Store = types.model(\x3cspan class=\x22hljs-string\x22\x3e\x22Store\x22\x3c\/span\x3e, {\n    \x3cspan class=\x22hljs-attr\x22\x3etodos\x3c\/span\x3e: types.array(Todo)\n})\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ create an instance from a snapshot\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e store = Store.create({ \x3cspan class=\x22hljs-attr\x22\x3etodos\x3c\/span\x3e: [{\n    \x3cspan class=\x22hljs-attr\x22\x3etitle\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22Get coffee\x22\x3c\/span\x3e\n}]})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e最关键的来了，请看下面的代码。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ listen to new snapshots\nonSnapshot(store, (snapshot) =\x3e {\n    console.dir(snapshot)\n})\n\n\/\/ invoke action that modifies the tree\nstore.todos[0].toggle()\n\/\/ prints: `{ todos: [{ title: \x26quot;Get coffee\x26quot;, done: true }]}`\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ listen to new snapshots\x3c\/span\x3e\nonSnapshot(store, (snapshot) =\x26gt; {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.dir(snapshot)\n})\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ invoke action that modifies the tree\x3c\/span\x3e\nstore.todos[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e].toggle()\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ prints: `{ todos: [{ title: \x22Get coffee\x22, done: true }]}`\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在上述代码的第一部分，使用 \x3ccode\x3eonSnapshot\x3c\/code\x3e 监听状态的改变。第二部分，调用 \x3ccode\x3estore.todos[0].toggle()\x3c\/code\x3e ，在这个 \x3ccode\x3eaction\x3c\/code\x3e 中通过使用\x3cstrong\x3e可变数据\x3c\/strong\x3e的方式，直接修改了当前的状态。同时在 \x3ccode\x3eonSnapshot\x3c\/code\x3e 生成了一个状态快照。这个状态快照就是状态的\x3cstrong\x3e不可变数据\x3c\/strong\x3e的表现形式。\x3c\/p\x3e\n\x3cp\x3eMST 这么神奇，那么具体怎么用呢？MST 只是一个状态容器，同时包含了可变数据和不可变数据。你可以用 MST 直接搭配 React 使用。可以 MST \x2b Mobx \x2b React 配合着用，还可以 MST \x2b Redux \x2b React 混搭着用。\x3c\/p\x3e\n\x3cp\x3eMST 比较新，业内的实践非常少，如果不是急需，现在还可以先观望一下。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>React 状态管理库: Mobx</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000010084073">https://segmentfault.com/a/1190000010084073</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/yz5jpugvmg/" target="_blank">https://alili.tech/archive/yz5jpugvmg/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>