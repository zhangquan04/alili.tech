<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="Webpack 2 入门"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>Webpack 2 入门 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/msx73unnlto/",
				"appid": "1613049289050283", 
				"title": "Webpack 2 入门 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-28T02:30:09"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/axs4rl6n4jf/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/7v0gtpe75yk/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fmsx73unnlto%2f&text=Webpack%c2%a02%20%e5%85%a5%e9%97%a8"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fmsx73unnlto%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fmsx73unnlto%2f&text=Webpack%c2%a02%20%e5%85%a5%e9%97%a8"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fmsx73unnlto%2f&title=Webpack%c2%a02%20%e5%85%a5%e9%97%a8"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fmsx73unnlto%2f&is_video=false&description=Webpack%c2%a02%20%e5%85%a5%e9%97%a8"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=Webpack%c2%a02%20%e5%85%a5%e9%97%a8&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fmsx73unnlto%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fmsx73unnlto%2f&title=Webpack%c2%a02%20%e5%85%a5%e9%97%a8"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fmsx73unnlto%2f&title=Webpack%c2%a02%20%e5%85%a5%e9%97%a8"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fmsx73unnlto%2f&title=Webpack%c2%a02%20%e5%85%a5%e9%97%a8"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fmsx73unnlto%2f&title=Webpack%c2%a02%20%e5%85%a5%e9%97%a8"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">Webpack 2 入门</h1><div class="meta"><div class="postdate"><time datetime="2019-01-28" itemprop="datePublished">2019-01-28</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n            \x3ch1\x3e\x3ca href=\x22#webpack2-入门\x22\x3e\x3c\/a\x3eWebpack 2 入门\x3c\/h1\x3e\n\x3cp\x3eWebpack 2 \x3ca href=\x22https:\/\/github.com\/webpack\/webpack\/issues\/1545#issuecomment-255446425\x22\x3e一旦文档完成\x3c\/a\x3e，就将结束 Beta 测试期。不过这并不意味着你现在不能开始使用第 2 版，前提是你知道怎么配置它。\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22#webpack-是什么\x22\x3e\x3c\/a\x3eWebpack 是什么\x3c\/h3\x3e\n\x3cp\x3e简单来说，Webpack 是一个 JavaScript 模块打包器。然而，自从它发布以来，它发展成为了你所有的前端代码的管理工具（或许是有意的，或许是社区的意愿）。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/camo.githubusercontent.com\/c5a705703c737acdee08b84e1e9241bea8de6fb8\/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f312a7942743272466a324462636b466c694745304c4579672e706e67\x22\x3e\x3cimg src=\x22https:\/\/p1.ssl.qhimg.com\/t01bee0089f8424fded.png\x22 alt=\x22\x22\x3e\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cem\x3e老式的任务运行器的方式：你的标记、样式和 JavaScript 是分离的。你必须分别管理它们每一个，并且你需要确保每一样都达到产品级\x3c\/em\x3e\x3c\/p\x3e\n\x3cp\x3e任务运行器（task runner），例如 Gulp，可以处理许多不同的预处理器（preprocesser）和转换器（transpiler），但是在所有的情景下，它都需要一个输入源并将其压缩到一个编译好的输出文件中。然而，它是在每个部分的基础上这样做的，而没有考虑到整个系统。这就造成了开发者的负担：找到任务运行器所不能处理的地方，并找到适当的方式将所有这些模块在生产环境中联合在一起。\x3c\/p\x3e\n\x3cp\x3eWebpack 试图通过提出一个大胆的想法来减轻开发者的负担：如果有一部分开发过程可以自动处理依赖关系会怎样？如果我们可以简单地写代码，让构建过程最终只根据需求管理自己会怎样？\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/camo.githubusercontent.com\/16d39d346d31315fe72887338f9b7bc471b31b8a\/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f312a544f46666f483063585463384733595f46366a334a672e706e67\x22\x3e\x3cimg src=\x22https:\/\/p0.ssl.qhimg.com\/t01364d765ae4a82a77.png\x22 alt=\x22\x22\x3e\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cem\x3eWebpack 的方式：如果 Webpack 了解依赖关系，它会仅捆绑我们在生产环境中实际需要的部分\x3c\/em\x3e\x3c\/p\x3e\n\x3cp\x3e如果你过去几年一直参与 web 社区，你已经知道解决问题的首选方法：使用 JavaScript 来构建。而且 Webpack 尝试通过 JavaScript 传递依赖关系使得构建过程更加容易。不过这个设计真正的亮点不是简化代码管理部分，而是管理层由 100% 有效的 JavaScript 实现（具有 Nodejs 特性）。Webpack 能够让你编写有效的 JavaScript，更好更全面地了解系统。\x3c\/p\x3e\n\x3cp\x3e换句话来说：你不需要为 Webpack 写代码。你只需要写项目代码。而且 Webpack 就会持续工作（当然需要一些配置）。\x3c\/p\x3e\n\x3cp\x3e简而言之，如果你曾经遇到过以下任何一种情况：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e载入有问题的依赖项\x3c\/li\x3e\n\x3cli\x3e意外引入一些你不需要在生产中用上的 CSS 样式表和 JS 库，使项目膨胀\x3c\/li\x3e\n\x3cli\x3e意外的两次载入（或三次）库\x3c\/li\x3e\n\x3cli\x3e遇到作用域的问题 —— CSS 和 JavaScript 都会有\x3c\/li\x3e\n\x3cli\x3e寻找一个让你在 JavaScript 中使用 Node\/Bower 模块的构建系统，要么就得依靠一个令人发狂的后端配置才能正确地使用这些模块\x3c\/li\x3e\n\x3cli\x3e需要优化资产（asset）交付，但你担心会弄坏一些东西\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e等等……\x3c\/p\x3e\n\x3cp\x3e那么你可以从 Webpack 中收益了。它通过让 JavaScript 轻松处理你的依赖关系和加载顺序，而不是通过开发者的大脑。最好的部分是，Webpack 甚至可以纯粹在服务器端运行，这意味着你还可以使用 Webpack 构建\x3ca href=\x22https:\/\/www.smashingmagazine.com\/2009\/04\/progressive-enhancement-what-it-is-and-how-to-use-it\/\x22\x3e渐进增强式\x3c\/a\x3e网站。\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22#第一步\x22\x3e\x3c\/a\x3e第一步\x3c\/h3\x3e\n\x3cp\x3e我们将在本教程中使用 \x3ca href=\x22https:\/\/yarnpkg.com\/\x22\x3eYarn\x3c\/a\x3e（运行命令 \x3ccode\x3ebrew install yarn\x3c\/code\x3e） 代替 \x3ccode\x3enpm\x3c\/code\x3e，不过这完全取决于你的喜好，它们做同样的事情。在我们的项目文件夹中，我们将在终端窗口中运行以下代码，将 Webpack 2 添加到我们的全局软件包以及本地项目中：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs lsl\x22\x3eyarn global add webpack@\x3cspan class=\x22hljs-number\x22\x3e2.1\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e.0\x3c\/span\x3e-beta\x3cspan class=\x22hljs-number\x22\x3e.25\x3c\/span\x3e webpack-dev-server@\x3cspan class=\x22hljs-number\x22\x3e2.1\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e.0\x3c\/span\x3e-beta\x3cspan class=\x22hljs-number\x22\x3e.9\x3c\/span\x3e\nyarn add --dev webpack@\x3cspan class=\x22hljs-number\x22\x3e2.1\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e.0\x3c\/span\x3e-beta\x3cspan class=\x22hljs-number\x22\x3e.25\x3c\/span\x3e webpack-dev-server@\x3cspan class=\x22hljs-number\x22\x3e2.1\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e.0\x3c\/span\x3e-beta\x3cspan class=\x22hljs-number\x22\x3e.9\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e我们接着会通过项目根目录的一个 \x3ccode\x3ewebpack.config.js\x3c\/code\x3e 文件来声明 webpack 的配置：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3e\x27use strict\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e webpack = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27webpack\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = {\n  \x3cspan class=\x22hljs-attr\x22\x3econtext\x3c\/span\x3e: __dirname \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27\/src\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3eentry\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-attr\x22\x3eapp\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27.\/app.js\x27\x3c\/span\x3e,\n  },\n  \x3cspan class=\x22hljs-attr\x22\x3eoutput\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-attr\x22\x3epath\x3c\/span\x3e: __dirname \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27\/dist\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3efilename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27[name].bundle.js\x27\x3c\/span\x3e,\n  },\n};\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e注意：此处 \x3ccode\x3e__dirname\x3c\/code\x3e 是指你的项目根目录\x3c\/p\x3e\n\x3cp\x3e记住，Webpack “知道”你的项目发生了什么。它通过阅读你的代码来实现（别担心，它签署了保密协议 :D ）。Webpack 基本上执行以下操作：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e从 \x3ccode\x3econtext\x3c\/code\x3e 文件夹开始……\x3c\/li\x3e\n\x3cli\x3e……它查找 \x3ccode\x3eentry\x3c\/code\x3e 下的文件名……\x3c\/li\x3e\n\x3cli\x3e……并读取其内容。每一个 \x3ccode\x3eimport\x3c\/code\x3e（\x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/JavaScript\/Reference\/Statements\/import\x22\x3eES6\x3c\/a\x3e）或 \x3ccode\x3erequire()\x3c\/code\x3e（Nodejs）的依赖会在它解析代码的时候找到，它会在最终构建的时候打包这些依赖项。然后，它会搜索那些依赖项以及那些依赖项所依赖的依赖项，直到它到达“树”的最底端 —— 只打包它所需要的，没有其它东西。\x3c\/li\x3e\n\x3cli\x3eWebpack 从 \x3ccode\x3econtext\x3c\/code\x3e 文件夹打包所有东西到 \x3ccode\x3eoutput.path\x3c\/code\x3e 文件夹，使用 \x3ccode\x3eoutput.filename\x3c\/code\x3e 命名模板来为其命名（其中 \x3ccode\x3e[name]\x3c\/code\x3e 被替换成来自 \x3ccode\x3eentry\x3c\/code\x3e 的对象的键）。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e所以如果我们的 \x3ccode\x3esrc\/app.js\x3c\/code\x3e 文件看起来像这样（假设我们事先运行了 \x3ccode\x3eyarn add --dev moment\x3c\/code\x3e）：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3e\x27use strict\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e moment \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27moment\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e rightNow = moment().format(\x3cspan class=\x22hljs-string\x22\x3e\x27MMMM Do YYYY, h:mm:ss a\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log( rightNow );\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22October 23rd 2016, 9:30:24 pm\x22\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e我们应该运行：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs stylus\x22\x3ewebpack -\x3cspan class=\x22hljs-selector-tag\x22\x3ep\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e注意：\x3ccode\x3ep\x3c\/code\x3e 标志表示“生产”模式，这会压缩输出文件。\x3c\/p\x3e\n\x3cp\x3e它会输出一个 \x3ccode\x3edist\/app.bundle.js\x3c\/code\x3e，并将当前日期和时间打印到控制台。要注意 Webpack 会自动识别 上面的 \x3ccode\x3e\x27moment\x27\x3c\/code\x3e 指代的是什么（比如说，虽然如果你有一个 \x3ccode\x3emoment.js\x3c\/code\x3e 文件在你的目录，默认情况下 Webpack 会优先考虑你的 \x3ccode\x3emoment\x3c\/code\x3e Node 模块）。\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22#使用多个文件\x22\x3e\x3c\/a\x3e使用多个文件\x3c\/h3\x3e\n\x3cp\x3e你可以通过仅仅修改 \x3ccode\x3eentry\x3c\/code\x3e 对象来指定任意数量的入口（entry）\/输出点（output）。\x3c\/p\x3e\n\x3ch4\x3e\x3ca href=\x22#打包多个文件\x22\x3e\x3c\/a\x3e打包多个文件\x3c\/h4\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3e\x27use strict\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e webpack = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22webpack\x22\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = {\n  \x3cspan class=\x22hljs-attr\x22\x3econtext\x3c\/span\x3e: __dirname \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22\/src\x22\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3eentry\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-attr\x22\x3eapp\x3c\/span\x3e: [\x3cspan class=\x22hljs-string\x22\x3e\x22.\/home.js\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22.\/events.js\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22.\/vendor.js\x22\x3c\/span\x3e],\n  },\n  \x3cspan class=\x22hljs-attr\x22\x3eoutput\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-attr\x22\x3epath\x3c\/span\x3e: __dirname \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22\/dist\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3efilename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22[name].bundle.js\x22\x3c\/span\x3e,\n  },\n};\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e所有文件都会按照数组的顺序一起被打包成一个 \x3ccode\x3edist\/app.bundle.js\x3c\/code\x3e 文件。\x3c\/p\x3e\n\x3ch4\x3e\x3ca href=\x22#输出多个文件\x22\x3e\x3c\/a\x3e输出多个文件\x3c\/h4\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs dts\x22\x3econst webpack = require(\x3cspan class=\x22hljs-string\x22\x3e\x22webpack\x22\x3c\/span\x3e);\n\nmodule.exports = {\n\x3cspan class=\x22hljs-symbol\x22\x3e  context:\x3c\/span\x3e __dirname \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22\/src\x22\x3c\/span\x3e,\n\x3cspan class=\x22hljs-symbol\x22\x3e  entry:\x3c\/span\x3e {\n\x3cspan class=\x22hljs-symbol\x22\x3e    home:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22.\/home.js\x22\x3c\/span\x3e,\n\x3cspan class=\x22hljs-symbol\x22\x3e    events:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22.\/events.js\x22\x3c\/span\x3e,\n\x3cspan class=\x22hljs-symbol\x22\x3e    contact:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22.\/contact.js\x22\x3c\/span\x3e,\n  },\n\x3cspan class=\x22hljs-symbol\x22\x3e  output:\x3c\/span\x3e {\n\x3cspan class=\x22hljs-symbol\x22\x3e    path:\x3c\/span\x3e __dirname \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22\/dist\x22\x3c\/span\x3e,\n\x3cspan class=\x22hljs-symbol\x22\x3e    filename:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22[name].bundle.js\x22\x3c\/span\x3e,\n  },\n};\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e或者，你可以选择打包成多个 JS 文件以便于分割应用的某些模块。这将被打包成 3 个文件：\x3ccode\x3edist\/home.bundle.js\x3c\/code\x3e，\x3ccode\x3edist\/events.bundle.js\x3c\/code\x3e 和 \x3ccode\x3edist\/contact.bundle.js\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch4\x3e\x3ca href=\x22#高级打包自动化\x22\x3e\x3c\/a\x3e高级打包自动化\x3c\/h4\x3e\n\x3cp\x3e如果你将你的应用分割成多个 \x3ccode\x3eoutput\x3c\/code\x3e 输出项（如果你的应用的一部分有大量你不需要预加载的 JS，这会很有用），你可能会重用这些文件的代码，因为它将分别解析每个依赖关系。幸运的是，Webpack 有一个内置的 \x3ccode\x3eCommonsChunk\x3c\/code\x3e 插件来处理这个：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs dts\x22\x3emodule.exports = {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ …\x3c\/span\x3e\n\x3cspan class=\x22hljs-symbol\x22\x3e\n  plugins:\x3c\/span\x3e [\n    new webpack.optimize.CommonsChunkPlugin({\n\x3cspan class=\x22hljs-symbol\x22\x3e      name:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22commons\x22\x3c\/span\x3e,\n\x3cspan class=\x22hljs-symbol\x22\x3e      filename:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22commons.bundle.js\x22\x3c\/span\x3e,\n\x3cspan class=\x22hljs-symbol\x22\x3e      minChunks:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\n    }),\n  ],\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ …\x3c\/span\x3e\n};\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e现在，在你的 \x3ccode\x3eoutput\x3c\/code\x3e 文件中，如果你有任何模块被加载 2 次以上（通过 \x3ccode\x3eminChunks\x3c\/code\x3e 设置），它会把那个模块打包到 \x3ccode\x3ecommon.js\x3c\/code\x3e 文件中，然后你可以将其缓存在客户端。这将生成一个额外的请求头，但是你防止了客户端多次下载同一个库。因此，在很多情景下，这会大大提升速度。\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22#开发\x22\x3e\x3c\/a\x3e开发\x3c\/h3\x3e\n\x3cp\x3eWebpack 实际上有自己的开发服务器，所以无论你是开发一个静态网站还是只是你的网站前端原型，它都是无可挑剔的。要运行那个服务器，只需要添加一个 \x3ccode\x3edevServer\x3c\/code\x3e 对象到 \x3ccode\x3ewebpack.config.js\x3c\/code\x3e：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs dts\x22\x3emodule.exports = {\n\x3cspan class=\x22hljs-symbol\x22\x3e  context:\x3c\/span\x3e __dirname \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22\/src\x22\x3c\/span\x3e,\n\x3cspan class=\x22hljs-symbol\x22\x3e  entry:\x3c\/span\x3e {\n\x3cspan class=\x22hljs-symbol\x22\x3e    app:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22.\/app.js\x22\x3c\/span\x3e,\n  },\n\x3cspan class=\x22hljs-symbol\x22\x3e  output:\x3c\/span\x3e {\n\x3cspan class=\x22hljs-symbol\x22\x3e    filename:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22[name].bundle.js\x22\x3c\/span\x3e,\n\x3cspan class=\x22hljs-symbol\x22\x3e    path:\x3c\/span\x3e __dirname \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22\/dist\/assets\x22\x3c\/span\x3e,\n\x3cspan class=\x22hljs-symbol\x22\x3e    publicPath:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22\/assets\x22\x3c\/span\x3e,            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ New\x3c\/span\x3e\n  },\n\x3cspan class=\x22hljs-symbol\x22\x3e  devServer:\x3c\/span\x3e {\n\x3cspan class=\x22hljs-symbol\x22\x3e    contentBase:\x3c\/span\x3e __dirname \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22\/src\x22\x3c\/span\x3e,  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ New\x3c\/span\x3e\n  },\n};\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e现在创建一个包含以下代码的 \x3ccode\x3esrc\/index.html\x3c\/code\x3e 文件：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3esrc\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22\/assets\/app.bundle.js\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22undefined\x22\x3e\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e……在你的终端中运行：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs axapta\x22\x3ewebpack-dev-\x3cspan class=\x22hljs-keyword\x22\x3eserver\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e你的服务器现在运行在 \x3ccode\x3elocalhost:8080\x3c\/code\x3e。注意 \x3ccode\x3escript\x3c\/code\x3e 标签里面的 \x3ccode\x3e\/assets\x3c\/code\x3e 是怎么匹配到 \x3ccode\x3eoutput.publicPath\x3c\/code\x3e 的 —— 你可以随意更改它的名称（如果你需要一个 CDN 的时候这会很有用）。\x3c\/p\x3e\n\x3cp\x3eWebpack 会热加载所有 JavaScript 更改，而不需要刷新你的浏览器。但是，所有 \x3ccode\x3ewebpack.config.js\x3c\/code\x3e 文件里面的更改都需要重新启动服务器才能生效。\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22#全局访问方法\x22\x3e\x3c\/a\x3e全局访问方法\x3c\/h3\x3e\n\x3cp\x3e需要在全局空间使用你的函数？在 \x3ccode\x3ewebpack.config.js\x3c\/code\x3e 里面简单地设置 \x3ccode\x3eoutput.library\x3c\/code\x3e：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs java\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3emodule\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3eexports\x3c\/span\x3e = {\n  output: {\n    library: \x3cspan class=\x22hljs-string\x22\x3e\x27myClassName\x27\x3c\/span\x3e,\n  }\n};\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e……这会将你打包好的文件附加到一个 \x3ccode\x3ewindow.myClassName\x3c\/code\x3e 实例。因此，使用该命名空间，你可以调用入口文件的可用方法（可以在\x3ca href=\x22https:\/\/webpack.js.org\/concepts\/output\/#output-library\x22\x3e该文档\x3c\/a\x3e中阅读有关此设置的更多信息）。\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22#加载器\x22\x3e\x3c\/a\x3e加载器\x3c\/h3\x3e\n\x3cp\x3e到目前为止，我们所做的一切只涉及 JavaScript。从一开始就使用 JavaScript 是重要的，因为它是 Webpack 唯一支持的语言。事实上我们可以处理几乎所有文件类型，只要我们将其转换成 JavaScript。我们用加载器（loader）来实现这个功能。\x3c\/p\x3e\n\x3cp\x3e加载器可以是 Sass 这样的预处理器，或者是 Babel 这样的转译器。在 NPM 上，它们通常被命名为 \x3ccode\x3e*-loader\x3c\/code\x3e，例如 \x3ccode\x3esass-loader\x3c\/code\x3e 和 \x3ccode\x3ebabel-loader\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch4\x3e\x3ca href=\x22#babel-和es6\x22\x3e\x3c\/a\x3eBabel 和 ES6\x3c\/h4\x3e\n\x3cp\x3e如果我们想在项目中通过 \x3ca href=\x22https:\/\/babeljs.io\/\x22\x3eBabel\x3c\/a\x3e 来使用 ES6，我们首先需要在本地安装合适的加载器：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs armasm\x22\x3e\x3cspan class=\x22hljs-symbol\x22\x3eyarn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eadd \x3c\/span\x3e--dev \x3cspan class=\x22hljs-keyword\x22\x3ebabel-loader \x3c\/span\x3e\x3cspan class=\x22hljs-keyword\x22\x3ebabel-core \x3c\/span\x3e\x3cspan class=\x22hljs-keyword\x22\x3ebabel-preset-es2015\n\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e然后将它添加到 \x3ccode\x3ewebpack.config.js\x3c\/code\x3e，让 Webpack 知道在哪里使用它。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs dts\x22\x3emodule.exports = {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ …\x3c\/span\x3e\n\x3cspan class=\x22hljs-symbol\x22\x3e\n  module:\x3c\/span\x3e {\n\x3cspan class=\x22hljs-symbol\x22\x3e    rules:\x3c\/span\x3e [\n      {\n\x3cspan class=\x22hljs-symbol\x22\x3e        test:\x3c\/span\x3e \/\\.js$\/,\n\x3cspan class=\x22hljs-symbol\x22\x3e        use:\x3c\/span\x3e [{\n\x3cspan class=\x22hljs-symbol\x22\x3e          loader:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22babel-loader\x22\x3c\/span\x3e,\n\x3cspan class=\x22hljs-symbol\x22\x3e          options:\x3c\/span\x3e { presets: [\x3cspan class=\x22hljs-string\x22\x3e\x22es2015\x22\x3c\/span\x3e] }\n        }],\n      },\n\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Loaders for other file types can go here\x3c\/span\x3e\n    ],\n  },\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ …\x3c\/span\x3e\n};\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3eWebpack 1 的用户注意：加载器的核心概念没有任何改变，但是语法改进了。直到官方文档完成之前，这可能不是确切的首选语法。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3e\/\\.js$\/\x3c\/code\x3e 这个正则表达式查找所有以 \x3ccode\x3e.js\x3c\/code\x3e 结尾的待通过 Babel 加载的文件。Webpack 依靠正则检查给予你完全的控制权 —— 它不限制你的文件扩展名或者假定你的代码必须以某种方式组织。例如：也许你的 \x3ccode\x3e\/my_legacy_code\/\x3c\/code\x3e 文件夹下的内容不是用 ES6 写的，所以你可以修改上述的 \x3ccode\x3etest\x3c\/code\x3e 为 \x3ccode\x3e\/^((?!my_legacy_folder).)\\.js$\/\x3c\/code\x3e，这将会排除那个特定的文件夹，不过会用 Babel 处理其余的文件。\x3c\/p\x3e\n\x3ch4\x3e\x3ca href=\x22#css-和-style加载器\x22\x3e\x3c\/a\x3eCSS 和 Style 加载器\x3c\/h4\x3e\n\x3cp\x3e如果我们只想为我们的应用所需加载 CSS，我们也可以这样做。假设我们有一个 \x3ccode\x3eindex.js\x3c\/code\x3e 文件，我们将从那里引入：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs clean\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e styles \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/assets\/stylesheets\/application.css\x27\x3c\/span\x3e;\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e我们会得到以下错误：\x3ccode\x3e你可能需要一个合适的加载器来处理这种类型的文件\x3c\/code\x3e。记住，Webpack 只能识别 JavaScript，所以我们必须安装合适的加载器：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs dockerfile\x22\x3eyarn \x3cspan class=\x22hljs-keyword\x22\x3eadd\x3c\/span\x3e\x3cspan class=\x22bash\x22\x3e --dev css-loader style-loader\n\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e然后添加一条规则到 \x3ccode\x3ewebpack.config.js\x3c\/code\x3e：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs openscad\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3emodule\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eexports\x3c\/span\x3e =\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ …\x3c\/span\x3e\n\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3emodule\x3c\/span\x3e: {\x3c\/span\x3e\n    rules: [\n      {\n        test: \/\\.css$\/,\n        \x3cspan class=\x22hljs-keyword\x22\x3euse\x3c\/span\x3e: [\x3cspan class=\x22hljs-string\x22\x3e\x22style-loader\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22css-loader\x22\x3c\/span\x3e],\n      },\n\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ …\x3c\/span\x3e\n    ],\n  },\n};\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e加载器以数组的逆序处理。这意味着 \x3ccode\x3ecss-loader\x3c\/code\x3e 会比 \x3ccode\x3estyle-loader\x3c\/code\x3e 先执行。\x3c\/p\x3e\n\x3cp\x3e你可能会注意到，即使在生产版本中，这实际上是将你的 CSS 和 JavaScript 打包在一起，\x3ccode\x3estyle-loader\x3c\/code\x3e 手动将你的样式写到 \x3ccode\x3e\x26lt;head\x26gt;\x3c\/code\x3e。乍一看，它可能看起来有点怪异，但你仔细想想就会发现这就慢慢开始变得更加有意义了。你已经节省了一个头部请求 —— 节省了一些连接上的时间。如果你用 JavaScript 来加载你的 DOM，无论如何，这从本质上消除了 \x3ca href=\x22https:\/\/en.wikipedia.org\/wiki\/Flash_of_unstyled_content\x22\x3eFOUC\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3e你还会注意到一个开箱即用的特性 —— Webpack 已经通过将这些文件打包在一起以自动解决你所有的 \x3ccode\x3e@import\x3c\/code\x3e 查询（而不是依靠 CSS 默认的 import 方式，这会导致无谓的头部请求以及资源加载缓慢）。\x3c\/p\x3e\n\x3cp\x3e从你的 JS 加载 CSS 是非常惊人的，因为你现在可以用一种新的强大的方式将你的 CSS 模块化。比如说你要只通过 \x3ccode\x3ebutton.js\x3c\/code\x3e 来加载 \x3ccode\x3ebutton.css\x3c\/code\x3e，这将意味着如果 \x3ccode\x3ebutton.js\x3c\/code\x3e 从来没有真正使用过的话，它的 CSS 就不会膨胀我们的生产版本。如果你坚持面向组件的 CSS 实践，如 SMACSS 或 BEM，你会看到更紧密地结合你的 CSS 和你的标记和 JavaScript 的价值。\x3c\/p\x3e\n\x3ch4\x3e\x3ca href=\x22#css-和-node模块\x22\x3e\x3c\/a\x3eCSS 和 Node 模块\x3c\/h4\x3e\n\x3cp\x3e我们可以使用 Webpack 来利用 Node.js 使用 \x3ccode\x3e~\x3c\/code\x3e 前缀导入 Node 模块的优势。如果我们运行 \x3ccode\x3eyarn add normalize.css\x3c\/code\x3e，我们可以使用：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs css\x22\x3e@\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22~normalize.css\x22\x3c\/span\x3e;\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e……并且充分利用 NPM 来管理我们的第三方样式 —— 版本控制、没有任何副本和粘贴的部分。此外，让 Webpack 为我们打包 CSS 比起使用 CSS 的默认导入方式有明显的优势 —— 节省无谓的头部请求和加载时间。\x3c\/p\x3e\n\x3cp\x3e更新：这一节和下面一节已经更新为准确的用法，不再使用 CSS 模块简单地导入 Node 的模块。感谢 \x3ca href=\x22https:\/\/medium.com\/u\/901a038e32e5\x22\x3eAlbert Fernández\x3c\/a\x3e 的帮助！\x3c\/p\x3e\n\x3ch4\x3e\x3ca href=\x22#css-模块\x22\x3e\x3c\/a\x3eCSS 模块\x3c\/h4\x3e\n\x3cp\x3e你可能听说过 \x3ca href=\x22https:\/\/github.com\/css-modules\/css-modules\x22\x3eCSS 模块\x3c\/a\x3e，它把 CSS 变成了 SS，消除了 CSS 的层叠性（Cascading）。通常它的最适用场景是只有当你使用 JavaScript 构建 DOM 的时候，但实质上，它神奇地将你的 CSS 类放置到加载它的 JavaScript 文件里（\x3ca href=\x22https:\/\/github.com\/css-modules\/css-modules\x22\x3e在这里了解更多\x3c\/a\x3e）。如果你打算使用它，CSS 模块已经与 \x3ccode\x3ecss-loader\x3c\/code\x3e 封装在一起（\x3ccode\x3eyarn add --dev css-loader\x3c\/code\x3e）：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs openscad\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3emodule\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eexports\x3c\/span\x3e =\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ …\x3c\/span\x3e\n\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3emodule\x3c\/span\x3e: {\x3c\/span\x3e\n    rules: [\n      {\n        test: \/\\.css$\/,\n        \x3cspan class=\x22hljs-keyword\x22\x3euse\x3c\/span\x3e: [\n          \x3cspan class=\x22hljs-string\x22\x3e\x22style-loader\x22\x3c\/span\x3e,\n          { loader: \x3cspan class=\x22hljs-string\x22\x3e\x22css-loader\x22\x3c\/span\x3e, options: { modules: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e } }\n        ],\n      },\n\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ …\x3c\/span\x3e\n    ],\n  },\n};\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e注意：对于 \x3ccode\x3ecss-loader\x3c\/code\x3e，我们现在使用扩展对象语法（expanded object syntax）来给它传递一个选项。你可以使用一个更为精简的字符串来取代默认选项，正如我们仍然使用了 \x3ccode\x3estyle-loader\x3c\/code\x3e。\x3c\/p\x3e\n\x3chr\x3e\n\x3cp\x3e值得注意的是，当允许导入 CSS 模块的时候（例如：\x3ccode\x3e@import \x27normalize.css\x27;\x3c\/code\x3e），你完全可以删除掉 \x3ccode\x3e~\x3c\/code\x3e。但是，当你 \x3ccode\x3e@import\x3c\/code\x3e 你自己的 CSS 的时候，你可能会遇到构建错误。如果你遇到“无法找到 ____”的错误，尝试添加一个 \x3ccode\x3eresolve\x3c\/code\x3e 对象到 \x3ccode\x3ewebpack.config.js\x3c\/code\x3e，让 Webpack 更好地理解你的模块加载顺序。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs java\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e path = require(\x3cspan class=\x22hljs-string\x22\x3e\x22path\x22\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-keyword\x22\x3emodule\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3eexports\x3c\/span\x3e = {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/…\x3c\/span\x3e\n\n  resolve: {\n    modules: [path.resolve(__dirname, \x3cspan class=\x22hljs-string\x22\x3e\x22src\x22\x3c\/span\x3e), \x3cspan class=\x22hljs-string\x22\x3e\x22node_modules\x22\x3c\/span\x3e]\n  },\n};\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e我们首先指定源目录，然后指定 \x3ccode\x3enode_modules\x3c\/code\x3e。这样，Webpack 会更好地处理解析，按照既定的顺序（分别用你的源目录和 Node 模块的目录替换 \x3ccode\x3e\x22src\x22\x3c\/code\x3e 和 \x3ccode\x3e\x22node_modules\x22\x3c\/code\x3e），首先查找我们的源目录，然后再查找已安装的 Node 模块。\x3c\/p\x3e\n\x3ch4\x3e\x3ca href=\x22#sass\x22\x3e\x3c\/a\x3eSass\x3c\/h4\x3e\n\x3cp\x3e需要使用 Sass？没问题。安装：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs crmsh\x22\x3eyarn add --dev sass-loader \x3cspan class=\x22hljs-keyword\x22\x3enode\x3c\/span\x3e\x3cspan class=\x22hljs-title\x22\x3e-sass\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e并添加新的规则：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs openscad\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3emodule\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eexports\x3c\/span\x3e =\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ …\x3c\/span\x3e\n\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3emodule\x3c\/span\x3e: {\x3c\/span\x3e\n    rules: [\n      {\n        test: \/\\.(sass|scss)$\/,\n        \x3cspan class=\x22hljs-keyword\x22\x3euse\x3c\/span\x3e: [\n          \x3cspan class=\x22hljs-string\x22\x3e\x22style-loader\x22\x3c\/span\x3e,\n          \x3cspan class=\x22hljs-string\x22\x3e\x22css-loader\x22\x3c\/span\x3e,\n          \x3cspan class=\x22hljs-string\x22\x3e\x22sass-loader\x22\x3c\/span\x3e,\n        ]\n      }\n\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ …\x3c\/span\x3e\n    ],\n  },\n};\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e然后当你的 Javascript 对一个 \x3ccode\x3e.scss\x3c\/code\x3e 或 \x3ccode\x3e.sass\x3c\/code\x3e 文件调用 \x3ccode\x3eimport\x3c\/code\x3e 方法的时候，Webpack 会处理的。\x3c\/p\x3e\n\x3ch4\x3e\x3ca href=\x22#css-独立打包\x22\x3e\x3c\/a\x3eCSS 独立打包\x3c\/h4\x3e\n\x3cp\x3e或许你在处理渐进增强的问题；或许你因为其它原因需要一个单独的 CSS 文件。我们可以通过在我们的配置中用 \x3ccode\x3eextract-text-webpack-plugin\x3c\/code\x3e 替换 \x3ccode\x3estyle-loader\x3c\/code\x3e 而轻易地做到这一点，这不需要更改任何代码。以我们的 \x3ccode\x3eapp.js\x3c\/code\x3e 文件为例：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs clean\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e styles \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/assets\/stylesheets\/application.css\x27\x3c\/span\x3e;\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e让我们安装这个插件到本地（我们需要 2016 年 10 月的测试版本）：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs css\x22\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3eyarn\x3c\/span\x3e \x3cspan class=\x22hljs-selector-tag\x22\x3eadd\x3c\/span\x3e \x3cspan class=\x22hljs-selector-tag\x22\x3e--dev\x3c\/span\x3e \x3cspan class=\x22hljs-selector-tag\x22\x3eextract-text-webpack-plugin\x3c\/span\x3e@\x3cspan class=\x22hljs-keyword\x22\x3e2\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3e0\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3e0\x3c\/span\x3e-\x3cspan class=\x22hljs-keyword\x22\x3ebeta\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3e4\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e并且添加到 \x3ccode\x3ewebpack.config.js\x3c\/code\x3e：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs typescript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e ExtractTextPlugin = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22extract-text-webpack-plugin\x22\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ …\x3c\/span\x3e\n\n  \x3cspan class=\x22hljs-keyword\x22\x3emodule\x3c\/span\x3e: {\n    rules: [\n      {\n        test: \x3cspan class=\x22hljs-regexp\x22\x3e\/\\.css$\/\x3c\/span\x3e,\n        use: [\n          ExtractTextPlugin.extract(\x3cspan class=\x22hljs-string\x22\x3e\x22css\x22\x3c\/span\x3e),\n          { loader: \x3cspan class=\x22hljs-string\x22\x3e\x22css-loader\x22\x3c\/span\x3e, options: { modules: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e } },\n        ],\n      },\n\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ …\x3c\/span\x3e\n    ]\n  },\n  plugins: [\n    \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e ExtractTextPlugin({\n      filename: \x3cspan class=\x22hljs-string\x22\x3e\x22[name].bundle.css\x22\x3c\/span\x3e,\n      allChunks: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n    }),\n  ],\n};\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e现在当运行 \x3ccode\x3ewebpack -p\x3c\/code\x3e 的时候，你的 \x3ccode\x3eoutput\x3c\/code\x3e 目录还会有一个 \x3ccode\x3eapp.bundle.css\x3c\/code\x3e 文件。只需要像往常一样简单地在你的 HTML 中向该文件添加一个 \x3ccode\x3e\x26lt;link\x26gt;\x3c\/code\x3e 标签即可。\x3c\/p\x3e\n\x3ch4\x3e\x3ca href=\x22#html\x22\x3e\x3c\/a\x3eHTML\x3c\/h4\x3e\n\x3cp\x3e正如你可能已经猜到，Webpack 还有一个 \x3ccode\x3e[html-loader][6]\x3c\/code\x3e 插件。但是，当我们用 JavaScript 加载 HTML 时，我们针对不同的场景分成了不同的方法，我无法想出一个单一的例子来为你计划下一步做什么。通常，你需要加载 HTML 以便于在更大的系统（如 \x3ca href=\x22https:\/\/facebook.github.io\/react\/\x22\x3eReact\x3c\/a\x3e、\x3ca href=\x22https:\/\/angularjs.org\/\x22\x3eAngular\x3c\/a\x3e、\x3ca href=\x22http:\/\/vuejs.org\/\x22\x3eVue\x3c\/a\x3e 或 \x3ca href=\x22http:\/\/emberjs.com\/\x22\x3eEmber\x3c\/a\x3e）中使用 JavaScript 风格的标记，如 \x3ca href=\x22https:\/\/jsx.github.io\/\x22\x3eJSX\x3c\/a\x3e、\x3ca href=\x22https:\/\/github.com\/janl\/mustache.js\/\x22\x3eMustache\x3c\/a\x3e 或 \x3ca href=\x22http:\/\/handlebarsjs.com\/\x22\x3eHandlebars\x3c\/a\x3e。或者你可以使用类似 \x3ca href=\x22https:\/\/github.com\/pugjs\/pug-loader\x22\x3ePug\x3c\/a\x3e （以前叫 Jade）或 \x3ca href=\x22https:\/\/github.com\/AlexanderPavlenko\/haml-loader\x22\x3eHaml\x3c\/a\x3e 这样的 HTML 预处理器，抑或你可以直接把同样的 HTML 从你的源代码目录推送到你的构建目录。你怎么做都行。\x3c\/p\x3e\n\x3cp\x3e教程到此为止了：你可以用 Webpack 加载标记，但是进展到这一步的时候，关于你的架构，你将做出自己的决定，我和 Webpack 都无法左右你。不过参考以上的例子以及搜索 NPM 上适用的加载器应该足够你发展下去了。\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22#从模块的角度思考\x22\x3e\x3c\/a\x3e从模块的角度思考\x3c\/h3\x3e\n\x3cp\x3e为了充分使用 Webpack，你必须从模块的角度来思考：细粒度的、可复用的、用于高效处理每一件事的独立的处理程序。这意味着采取这样的方式：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs stylus\x22\x3e└── js\/\n    └── application\x3cspan class=\x22hljs-selector-class\x22\x3e.js\x3c\/span\x3e   \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 300KB of spaghetti code\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e将其转变成这样：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs stylus\x22\x3e└── js\/\n    ├── components\/\n    │   ├── \x3cspan class=\x22hljs-selector-tag\x22\x3ebutton\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.js\x3c\/span\x3e\n    │   ├── calendar\x3cspan class=\x22hljs-selector-class\x22\x3e.js\x3c\/span\x3e\n    │   ├── comment\x3cspan class=\x22hljs-selector-class\x22\x3e.js\x3c\/span\x3e\n    │   ├── modal\x3cspan class=\x22hljs-selector-class\x22\x3e.js\x3c\/span\x3e\n    │   ├── tab\x3cspan class=\x22hljs-selector-class\x22\x3e.js\x3c\/span\x3e\n    │   ├── timer\x3cspan class=\x22hljs-selector-class\x22\x3e.js\x3c\/span\x3e\n    │   ├── \x3cspan class=\x22hljs-selector-tag\x22\x3evideo\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.js\x3c\/span\x3e\n    │   └── wysiwyg\x3cspan class=\x22hljs-selector-class\x22\x3e.js\x3c\/span\x3e\n    │\n    └── application\x3cspan class=\x22hljs-selector-class\x22\x3e.js\x3c\/span\x3e  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ~ 1KB of code; imports from .\/components\/\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e结果呈现了整洁的、可复用的代码。每一个独立的组件通过 \x3ccode\x3eimport\x3c\/code\x3e 来引入自身的依赖，并 \x3ccode\x3eexport\x3c\/code\x3e 它想要暴露给其它模块的部分。结合 Babel 和 ES6，你可以利用 \x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/JavaScript\/Reference\/Classes\x22\x3eJavaScript 类\x3c\/a\x3e 来实现更强大的模块化，而不用考虑它的工作原理。\x3c\/p\x3e\n\x3cp\x3e有关模块的更多信息，请参阅 Preethi Kasreddy \x3ca href=\x22https:\/\/medium.freecodecamp.com\/javascript-modules-a-beginner-s-guide-783f7d7a5fcc\x22\x3e这篇优秀的文章\x3c\/a\x3e。\x3c\/p\x3e\n\x3chr\x3e\n\x3ch3\x3e\x3ca href=\x22#延伸阅读\x22\x3e\x3c\/a\x3e延伸阅读\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/gist.github.com\/sokra\/27b24881210b56bbaff7\x22\x3eWebpack 2 的新特性\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/webpack.js.org\/configuration\/\x22\x3eWebpack 配置文档\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/github.com\/webpack\/webpack\/tree\/master\/examples\x22\x3eWebpack 范例\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/github.com\/kriasoft\/react-starter-kit\x22\x3eReact \x2b Webpack 入门套件\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/github.com\/petehunt\/webpack-howto\x22\x3e怎么使用 Webpack\x3c\/a\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3chr\x3e\n\x3cp\x3evia: \x3ca href=\x22https:\/\/blog.madewithenvy.com\/getting-started-with-webpack-2-ed2b86c68783#.oozfpppao\x22\x3ehttps:\/\/blog.madewithenvy.com\/getting-started-with-webpack-2-ed2b86c68783#.oozfpppao\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e作者：\x3ca href=\x22https:\/\/blog.madewithenvy.com\/@an_ennui\x22\x3eDrew Powers\x3c\/a\x3e 译者：\x3ca href=\x22https:\/\/github.com\/OneNewLife\x22\x3eOneNewLife\x3c\/a\x3e 校对：\x3ca href=\x22https:\/\/github.com\/wxy\x22\x3ewxy\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e本文由 \x3ca href=\x22https:\/\/github.com\/LCTT\/TranslateProject\x22\x3eLCTT\x3c\/a\x3e 原创编译，\x3ca href=\x22https:\/\/linux.cn\/\x22\x3eLinux中国\x3c\/a\x3e 荣誉推出\x3c\/p\x3e\n\n          \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>Webpack 2 入门</p><h2 id="原文链接">原文链接</h2><p><a href="https://www.zcfy.cc/article/getting-started-with-webpack-2">https://www.zcfy.cc/article/getting-started-with-webpack-2</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/msx73unnlto/" target="_blank">https://alili.tech/archive/msx73unnlto/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>