<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="聊聊 React Router v4 的设计思想"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>聊聊 React Router v4 的设计思想 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/296z8axpaic/",
				"appid": "1613049289050283", 
				"title": "聊聊 React Router v4 的设计思想 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-05T02:30:11"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/3e9rnam5hd6/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/lbtanvz2vr/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f296z8axpaic%2f&text=%e8%81%8a%e8%81%8a%20React%20Router%20v4%20%e7%9a%84%e8%ae%be%e8%ae%a1%e6%80%9d%e6%83%b3"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f296z8axpaic%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f296z8axpaic%2f&text=%e8%81%8a%e8%81%8a%20React%20Router%20v4%20%e7%9a%84%e8%ae%be%e8%ae%a1%e6%80%9d%e6%83%b3"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f296z8axpaic%2f&title=%e8%81%8a%e8%81%8a%20React%20Router%20v4%20%e7%9a%84%e8%ae%be%e8%ae%a1%e6%80%9d%e6%83%b3"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f296z8axpaic%2f&is_video=false&description=%e8%81%8a%e8%81%8a%20React%20Router%20v4%20%e7%9a%84%e8%ae%be%e8%ae%a1%e6%80%9d%e6%83%b3"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e8%81%8a%e8%81%8a%20React%20Router%20v4%20%e7%9a%84%e8%ae%be%e8%ae%a1%e6%80%9d%e6%83%b3&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f296z8axpaic%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f296z8axpaic%2f&title=%e8%81%8a%e8%81%8a%20React%20Router%20v4%20%e7%9a%84%e8%ae%be%e8%ae%a1%e6%80%9d%e6%83%b3"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f296z8axpaic%2f&title=%e8%81%8a%e8%81%8a%20React%20Router%20v4%20%e7%9a%84%e8%ae%be%e8%ae%a1%e6%80%9d%e6%83%b3"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f296z8axpaic%2f&title=%e8%81%8a%e8%81%8a%20React%20Router%20v4%20%e7%9a%84%e8%ae%be%e8%ae%a1%e6%80%9d%e6%83%b3"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f296z8axpaic%2f&title=%e8%81%8a%e8%81%8a%20React%20Router%20v4%20%e7%9a%84%e8%ae%be%e8%ae%a1%e6%80%9d%e6%83%b3"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">聊聊 React Router v4 的设计思想</h1><div class="meta"><div class="postdate"><time datetime="2019-01-05" itemprop="datePublished">2019-01-05</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3eReact Router v4 发布已经有几个月了，但好像并没有得到太多人的青睐，大家（包括我们团队自己）还是习惯使用v2、v3版本。这一方面是因为v4版本是一次破坏性的升级，从v2、v3 升级到v4，必需要大量重写原有的路由相关的代码，对于已经稳定的项目，一般是不会轻易尝试这种变更的；另一方面，即使是新项目，很多开发者也依然选择使用v2、v3老版本，因为v4新的设计思想，意味着你必须改变原有的使用路由的思维，才能正确的使用新版本。\x3c\/p\x3e\n\x3cp\x3eReact Router v4 最大的变更，不是API的变更，而是从静态路由到动态路由的变化。什么是静态路由呢？静态路由是一堆在应用运行前就已经定义好的路由配置，应用需要在启动时，加载这些配置，构建出整个应用的路由表，然后当接收到某一请求时，根据请求地址，到应用路由表中找到对应的处理页面或处理方法。不管是前端开发，还是后端开发，只要涉及到路由，大部分情况下，其实我们使用的都是静态路由。例如，React Router v3版本中，我们会配置一个类似下面形式的路由：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cRouter history={browserHistory}\x3e\n  \x3cRoute path=\x27\/\x27 component={App}\x3e\n    \x3cRoute path=\x27about\x27 component={About}\x3e\n    \x3cRoute path=\x27contact\x27 component={Contact}\x3e\n    \/\/ ...\n  \x3c\/Route\x3e\n\x3c\/Router\x3e\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs xml\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eRouter\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ehistory\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{browserHistory}\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eRoute\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3epath\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x27\/\x27\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ecomponent\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{App}\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eRoute\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3epath\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x27about\x27\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ecomponent\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{About}\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eRoute\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3epath\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x27contact\x27\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ecomponent\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{Contact}\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \/\/ ...\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eRoute\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eRouter\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e它的基本工作流程是：Router组件根据所有的子组件Route，生成全局的路由表，路由表中记录了path与UI组件的映射关系，然后Router监听path的变化，当path变化时，根据新的path，找出对应所需的所有UI组件，按一定层级将这些UI组件渲染出来。\x3c\/p\x3e\n\x3cp\x3e对于已经很熟悉静态路由使用方式的开发者来说，上面的工作流程显得很自然，理解起来也毫不费力。既然如此，React Router的作者为什么还要把这一切推翻呢？原因是React Router不是普通的Router，它是“React”的Router。React致力于提供一个高效简洁的组件化方案，组件就是React的核心，在React的设计思想中，一切皆是组件。那么什么是组件呢？组件定义的是界面上一个区域的UI及UI的交互行为，关注点是UI。现在让我们回头来看看上面静态路由的例子，是不是感觉到什么奇怪的地方呢？虽然Route形式上是React组件，但它其实与UI无任何关系，它只是披着React组件的外衣，提供了一条路由配置项而已。我们也可以从Route源码中看出这一点：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const Route = createReactClass({\n  \/\/ 省略无关代码\n\n  \/* istanbul ignore next: sanity check *\/\n  render() {\n    invariant(\n      false,\n      \x27\x3cRoute\x3e elements are for router configuration only and should not be rendered\x27\n    )\n  }\n\n})\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs smali\x22\x3e\x3ccode\x3econst Route = createReactClass({\n  \/\/ 省略无关代码\n\n  \/* istanbul ignore next: sanity\x3cspan class=\x22hljs-built_in\x22\x3e check \x3c\/span\x3e*\/\n  render() {\n    invariant(\n      false,\n      \x27\x26lt;Route\x26gt; elements are for router configuration only\x3cspan class=\x22hljs-built_in\x22\x3e and \x3c\/span\x3eshould\x3cspan class=\x22hljs-built_in\x22\x3e not \x3c\/span\x3ebe rendered\x27\n    )\n  }\n\n})\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eRoute的render方法中，没有做任何UI渲染相关的工作，这确实不是一个正宗的React组件。当然你也可以用React Router的另一种配置路由的方式：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const routes = {\n  path: \x27\/\x27,\n  component: App,\n  childRoutes: [\n    {\n      path: \x27about\x27,\n        component: About,\n    },\n    {\n      path: \x27contact\x27,\n        component: Contact,\n    },\n    \/\/ ...\n  ]\n}\n\n\x3cRouter history={browserHistory} routes={routes} \/\x3e\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs vim\x22\x3e\x3ccode\x3econst routes = {\n  path: \x3cspan class=\x22hljs-string\x22\x3e\x27\/\x27\x3c\/span\x3e,\n  componen\x3cspan class=\x22hljs-variable\x22\x3et:\x3c\/span\x3e App,\n  childRoute\x3cspan class=\x22hljs-variable\x22\x3es:\x3c\/span\x3e [\n    {\n      path: \x3cspan class=\x22hljs-string\x22\x3e\x27about\x27\x3c\/span\x3e,\n        componen\x3cspan class=\x22hljs-variable\x22\x3et:\x3c\/span\x3e About,\n    },\n    {\n      path: \x3cspan class=\x22hljs-string\x22\x3e\x27contact\x27\x3c\/span\x3e,\n        componen\x3cspan class=\x22hljs-variable\x22\x3et:\x3c\/span\x3e Contact,\n    },\n    \/\/ ...\n  ]\n}\n\n\x26lt;Router \x3cspan class=\x22hljs-keyword\x22\x3ehistory\x3c\/span\x3e={browserHistory} routes={routes} \/\x26gt;\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e现在你又可以理直气壮的说，我没有使用Route这个伪组件了，这次和React的设计思想没有冲突了吧？好吧，让我们再来看看其他部分。React Router v3提供了很多类似生命周期方法的API，例如onEnter, onUpdate, and onLeave ，用来为处于不同阶段的路由提供钩子方法。但是，请不要忘了，React组件本身已经有一套很完善的生命周期方法了，如果一个Route就是一个组件，那么我们完全可以直接利用组件的生命周期方法，来作为路由不同阶段的钩子方法。例如，我们可以使用componentDidMount 或 componentWillMount替代onEnter，使用 componentDidUpdate或 componentWillUpdate 替代onUpdate，使用componentWillUnmount替代onLeave。\x3c\/p\x3e\n\x3cp\x3eReact Router v2、v3的问题，是在React组件思想之外，设计了一套API，是一种侵入式的设计。React Router的作者意识到了这个问题，所以在v4中，对React Router 进行了重写，将Route作为普通React组件看待，每个Route也负责UI的渲染工作，让React Router在React的大框架下运转。我们用v4版本实现上面的例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cBrowserRouter\x3e\n  \x3cdiv\x3e\n    \x3cRoute path=\x27\/\x27 component={App} \/\x3e\n    \x3cRoute path={\x27\/about\x27} component={About} \/\x3e\n    \x3cRoute path={\x27\/contact\x27} component={Contact} \/\x3e\n  \x3c\/div\x3e\n\x3c\/BrowserRouter\x3e\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs xml\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eBrowserRouter\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eRoute\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3epath\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x27\/\x27\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ecomponent\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{App}\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eRoute\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3epath\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{\x3c\/span\x3e\x27\/\x3cspan class=\x22hljs-attr\x22\x3eabout\x3c\/span\x3e\x27} \x3cspan class=\x22hljs-attr\x22\x3ecomponent\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{About}\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eRoute\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3epath\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{\x3c\/span\x3e\x27\/\x3cspan class=\x22hljs-attr\x22\x3econtact\x3c\/span\x3e\x27} \x3cspan class=\x22hljs-attr\x22\x3ecomponent\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{Contact}\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eBrowserRouter\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e但从表面上看，并不能很直观地看出Route工作机制的变化。这里做一简单说明：Route的作用不是提供路由配置，而是一个普通的UI组件，不管请求的路径是什么，Route组件总是会被渲染，只不过在Route内部会判断请求路径是否与当前的path匹配，如果匹配，就会把Route component属性指向的组件作为子组件渲染出来，如果不匹配，会渲染一个null。可以从新版Route 的render方法源码中印证这个流程：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Route extends React.Component {\n  \/\/...省略无关代码\n  \n  render() {\n    const { match } = this.state\n    const { children, component, render } = this.props\n    const { history, route, staticContext } = this.context.router\n    const location = this.props.location || route.location\n    const props = { match, location, history, staticContext }\n\n    return (\n      component ? ( \/\/ component prop gets first priority, only called if there\x27s a match\n        match ? React.createElement(component, props) : null\n      ) : render ? ( \/\/ render prop is next, only called if there\x27s a match\n        match ? render(props) : null\n      ) : children ? ( \/\/ children come last, always called\n        typeof children === \x27function\x27 ? (\n          children(props)\n        ) : !Array.isArray(children) || children.length ? ( \/\/ Preact defaults to empty children array\n          React.Children.only(children)\n        ) : (\n          null\n        )\n      ) : (\n        null\n      )\n    )\n  }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eRoute\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/...省略无关代码\x3c\/span\x3e\n  \n  render() {\n    const { \x3cspan class=\x22hljs-keyword\x22\x3ematch\x3c\/span\x3e } = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state\n    const { children, component, render } = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props\n    const { history, route, staticContext } = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.context.router\n    const location = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.location || route.location\n    const props = { \x3cspan class=\x22hljs-keyword\x22\x3ematch\x3c\/span\x3e, location, history, staticContext }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      component ? ( \x3cspan class=\x22hljs-comment\x22\x3e\/\/ component prop gets first priority, only called if there\x27s a match\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ematch\x3c\/span\x3e ? \x3cspan class=\x22hljs-type\x22\x3eReact\x3c\/span\x3e.createElement(component, props) : \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e\n      ) : render ? ( \x3cspan class=\x22hljs-comment\x22\x3e\/\/ render prop is next, only called if there\x27s a match\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ematch\x3c\/span\x3e ? render(props) : \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e\n      ) : children ? ( \x3cspan class=\x22hljs-comment\x22\x3e\/\/ children come last, always called\x3c\/span\x3e\n        typeof children === \x3cspan class=\x22hljs-symbol\x22\x3e\x27functio\x3c\/span\x3en\x27 ? (\n          children(props)\n        ) : !\x3cspan class=\x22hljs-type\x22\x3eArray\x3c\/span\x3e.isArray(children) || children.length ? ( \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Preact defaults to empty children array\x3c\/span\x3e\n          \x3cspan class=\x22hljs-type\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-type\x22\x3eChildren\x3c\/span\x3e.only(children)\n        ) : (\n          \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e\n        )\n      ) : (\n        \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e\n      )\n    )\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这种模式的路由就是动态路由。可见，动态路由发挥作用的时间是在组件渲染时，而不是通过提前配置的方式，在应用刚收到请求时，就已经知道该渲染哪些组件了。\x3c\/p\x3e\n\x3cp\x3e从上面的分析，可以得出动态路由的一个优点是，它会同时负责UI的渲染工作，而不是单纯的路由配置工作。此外，动态路由的另外一个优点是，你可以在任意时间、任意地点自由添加新的Route。例如，在上面的例子中，我想在About组件内定义两个新的路由，可以这么做：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cBrowserRouter\x3e\n  \x3cdiv\x3e\n    \x3cRoute path=\x27\/\x27 component={App} \/\x3e\n    \x3cRoute path={\x27\/about\x27} component={About} \/\x3e\n    \x3cRoute path={\x27\/contact\x27} component={Contact} \/\x3e\n  \x3c\/div\x3e\n\x3c\/BrowserRouter\x3e\n\nconst About = (props) =\x3e (\n  \x3cdiv\x3e\n    \x3cRoute path={`${props.match.url}\/a`} component={AboutA} \/\x3e\n    \x3cRoute path={`${props.match.url}\/b`} component={AboutB} \/\x3e\n  \x3c\/div\x3e\n)\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs xml\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eBrowserRouter\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eRoute\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3epath\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x27\/\x27\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ecomponent\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{App}\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eRoute\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3epath\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{\x3c\/span\x3e\x27\/\x3cspan class=\x22hljs-attr\x22\x3eabout\x3c\/span\x3e\x27} \x3cspan class=\x22hljs-attr\x22\x3ecomponent\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{About}\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eRoute\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3epath\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{\x3c\/span\x3e\x27\/\x3cspan class=\x22hljs-attr\x22\x3econtact\x3c\/span\x3e\x27} \x3cspan class=\x22hljs-attr\x22\x3ecomponent\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{Contact}\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eBrowserRouter\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\nconst About = (props) =\x26gt; (\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eRoute\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3epath\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{\x3c\/span\x3e`${\x3cspan class=\x22hljs-attr\x22\x3eprops.match.url\x3c\/span\x3e}\/\x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e`} \x3cspan class=\x22hljs-attr\x22\x3ecomponent\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{AboutA}\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eRoute\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3epath\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{\x3c\/span\x3e`${\x3cspan class=\x22hljs-attr\x22\x3eprops.match.url\x3c\/span\x3e}\/\x3cspan class=\x22hljs-attr\x22\x3eb\x3c\/span\x3e`} \x3cspan class=\x22hljs-attr\x22\x3ecomponent\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{AboutB}\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n)\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样，当访问 \/about\/a 时，组件AboutA 会被作为About的子组件渲染，当访问 \/about\/b 时，组件AboutB 会作为About的子组件渲染。而且，\/about\/a 和 \/about\/b 我们是直接定义到 About 组件内的，并不需要像静态路由那样做集中配置，充分体现了动态路由的灵活性。\x3c\/p\x3e\n\x3cp\x3e总结一下，虽然React Router v4 重构了路由使用的思想，但却和React的设计思想更加切合，个人认为是一个巨大的进步。使用React Router v4 时，你需要忘掉以前使用静态路由的思维方式，把路由当成普通组件看待，习惯了这个思维转变后，你就会发现React Router v4的魅力所在了。\x3c\/p\x3e\n\x3chr\x3e\n\x3cp\x3e\x3cstrong\x3e欢迎关注我的公众号：老干部的大前端，领取21本大前端精选书籍！\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV4lGT?w=540\x26amp;h=193\x22 src=\x22https:\/\/static.alili.tech\/img\/bV4lGT?w=540\x26amp;h=193\x22 alt=\x223808299627-5a93ba468b59a\x22 title=\x223808299627-5a93ba468b59a\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>聊聊 React Router v4 的设计思想</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000010526243">https://segmentfault.com/a/1190000010526243</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/296z8axpaic/" target="_blank">https://alili.tech/archive/296z8axpaic/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>