<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="React Native 的 ListView 性能问题已解决"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>React Native 的 ListView 性能问题已解决 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/mw9p5lb9qfb/",
				"appid": "1613049289050283", 
				"title": "React Native 的 ListView 性能问题已解决 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-19T02:30:10"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/agx80jkcr9k/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/r8yve5n3vxn/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fmw9p5lb9qfb%2f&text=React%20Native%20%e7%9a%84%20ListView%20%e6%80%a7%e8%83%bd%e9%97%ae%e9%a2%98%e5%b7%b2%e8%a7%a3%e5%86%b3"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fmw9p5lb9qfb%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fmw9p5lb9qfb%2f&text=React%20Native%20%e7%9a%84%20ListView%20%e6%80%a7%e8%83%bd%e9%97%ae%e9%a2%98%e5%b7%b2%e8%a7%a3%e5%86%b3"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fmw9p5lb9qfb%2f&title=React%20Native%20%e7%9a%84%20ListView%20%e6%80%a7%e8%83%bd%e9%97%ae%e9%a2%98%e5%b7%b2%e8%a7%a3%e5%86%b3"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fmw9p5lb9qfb%2f&is_video=false&description=React%20Native%20%e7%9a%84%20ListView%20%e6%80%a7%e8%83%bd%e9%97%ae%e9%a2%98%e5%b7%b2%e8%a7%a3%e5%86%b3"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=React%20Native%20%e7%9a%84%20ListView%20%e6%80%a7%e8%83%bd%e9%97%ae%e9%a2%98%e5%b7%b2%e8%a7%a3%e5%86%b3&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fmw9p5lb9qfb%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fmw9p5lb9qfb%2f&title=React%20Native%20%e7%9a%84%20ListView%20%e6%80%a7%e8%83%bd%e9%97%ae%e9%a2%98%e5%b7%b2%e8%a7%a3%e5%86%b3"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fmw9p5lb9qfb%2f&title=React%20Native%20%e7%9a%84%20ListView%20%e6%80%a7%e8%83%bd%e9%97%ae%e9%a2%98%e5%b7%b2%e8%a7%a3%e5%86%b3"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fmw9p5lb9qfb%2f&title=React%20Native%20%e7%9a%84%20ListView%20%e6%80%a7%e8%83%bd%e9%97%ae%e9%a2%98%e5%b7%b2%e8%a7%a3%e5%86%b3"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fmw9p5lb9qfb%2f&title=React%20Native%20%e7%9a%84%20ListView%20%e6%80%a7%e8%83%bd%e9%97%ae%e9%a2%98%e5%b7%b2%e8%a7%a3%e5%86%b3"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">React Native 的 ListView 性能问题已解决</h1><div class="meta"><div class="postdate"><time datetime="2019-01-19" itemprop="datePublished">2019-01-19</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e长列表或者无限下拉列表是最常见的应用场景之一。RN 提供的 ListView 组件，在长列表这种数据量大的场景下，性能堪忧。而在最新的 0.43 版本中，提供了 FlatList 组件，或许就是你需要的高性能长列表解决方案。它足以应对大多数的长列表场景。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e测试数据\x3c\/h2\x3e\n\x3cp\x3eFlatList 到底行不行，光说不行，先动手测试一下吧。\x3c\/p\x3e\n\x3cp\x3e性能瓶颈主要体现在 Android 这边，所以就用魅族 MX5 测试机，测试无限下拉列表，列表为常见的左文右图的形式。\x3c\/p\x3e\n\x3cp\x3e测试数据如下：\x3c\/p\x3e\n\x3ctable\x3e\n\x3cthead\x3e\x3ctr\x3e\n\x3cth\x3e对比\x3c\/th\x3e\n\x3cth\x3eListView\x3c\/th\x3e\n\x3cth\x3eFlatList\x3c\/th\x3e\n\x3c\/tr\x3e\x3c\/thead\x3e\n\x3ctbody\x3e\n\x3ctr\x3e\n\x3ctd\x3e1000条时内存\x3c\/td\x3e\n\x3ctd\x3e350M\x3c\/td\x3e\n\x3ctd\x3e180M\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e2000条时内存\x3c\/td\x3e\n\x3ctd\x3e\/\x3c\/td\x3e\n\x3ctd\x3e230M\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3ejs-fps\x3c\/td\x3e\n\x3ctd\x3e4~6 fps\x3c\/td\x3e\n\x3ctd\x3e8~20 fps\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3c\/tbody\x3e\n\x3c\/table\x3e\n\x3cp\x3e\x3ccode\x3ejs-pfs\x3c\/code\x3e 类似于游戏的画面渲染的帧率，60 为最高。它用于判断 js 线程的繁忙程度，数值越大说明 js 线程运行状态越好，数值越小说明 js 线程运行状态越差。在快速滑动测试 ListView 的时候， \x3ccode\x3ejs-pfs\x3c\/code\x3e 的值一直在  4~6 范围波动，即使停止滑动，\x3ccode\x3ejs-pfs\x3c\/code\x3e 的值也不能很快恢复正常。而 FlatList 在快速滚动后停止，\x3ccode\x3ejs-pfs\x3c\/code\x3e 能够很快的恢复到正常。\x3c\/p\x3e\n\x3cp\x3e内存方面，ListView 滑动到 1000 条时，已经涨到 350M。这时机器已经卡的不行了，所以没法滑到 2000 条并给出相关数据。而 FlatList 滑到 2000 条时的内存，也比 ListView 1000 条时的内存少不少。说明，FlatList 对内存的控制是很优秀的。\x3c\/p\x3e\n\x3cp\x3e主观体验方面：FlatList 快速滑动至 2000 条的过程中全程体验流畅，没有出现卡顿或肉眼可见的掉帧现象。而ListView 滑动到 200 条开始卡顿，页面滑动变得不顺畅，到 500 条渲染极其缓慢，到 1000 条时已经滑不动了。\x3c\/p\x3e\n\x3cp\x3e通过以上的简单的测试，可以看出，FlatList 已经能够应对简单的无限列表的场景。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e使用方法\x3c\/h2\x3e\n\x3cp\x3eFlatList 有三个核心属性 \x3ccode\x3edata\x3c\/code\x3e \x3ccode\x3erenderItem\x3c\/code\x3e \x3ccode\x3egetItemLayout\x3c\/code\x3e。它继承自 ScrollView 组件，所以拥有 ScrollView 的属性和方法。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e data \x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e和 ListView 不同，它没有特殊的 \x3ccode\x3eDataSource\x3c\/code\x3e 数据类型作为传入参数。它接收的仅仅只是一个 \x3ccode\x3eArray\x26lt;object\x26gt;\x3c\/code\x3e 作为参数。\x3cbr\x3e参数数组中的每一项，需要包含 \x3ccode\x3ekey\x3c\/code\x3e 值作为唯一标示。数据结构如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22[{title: \x27Title Text\x27, key: \x27item1\x27}]\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e[{\x3cspan class=\x22hljs-attr\x22\x3etitle\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Title Text\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-attr\x22\x3ekey\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27item1\x27\x3c\/span\x3e}]\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e renderItem \x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e和 ListView 的 \x3ccode\x3erenderRow\x3c\/code\x3e 类似，它接收一个函数作为参数，该函数返回一个 ReactElement。函数的第一个参数的 \x3ccode\x3eitem\x3c\/code\x3e 是 \x3ccode\x3edata\x3c\/code\x3e属性中的每个列表的数据（ \x3ccode\x3eArray\x26lt;object\x26gt;\x3c\/code\x3e 中的 \x3ccode\x3eobject\x3c\/code\x3e) 。这样就将列表元素和数据结合在一起，生成了列表。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 _renderItem = ({item}) =\x3e (\n   \x3cTouchableOpacity onPress={() =\x3e this._onPress(item)}\x3e\n     \x3cText\x3e{item.title\x22}}\x22\x3c\/Text\x3e\n   \x3cTouchableOpacity\/\x3e\n );\n ...\n \x3cFlatList data={[{title: \x27Title Text\x27, key: \x27item1\x27}]} renderItem={this._renderItem} \/\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e _renderItem = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3e{item}\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e (\n   \x26lt;TouchableOpacity onPress={() =\x26gt; this._onPress(item)}\x26gt;\n     \x26lt;Text\x26gt;{item.title\x22}}\x22\x26lt;\/Text\x26gt;\n   \x26lt;TouchableOpacity\/\x26gt;\n );\n ...\n \x26lt;FlatList data={[{title: \x27Title Text\x27, key: \x27item1\x27}]} renderItem={this._renderItem} \/\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e getItemLayout \x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e可选优化项。但是实际测试中，如果不做该项优化，性能会差很多。所以强烈建议做此项优化！\x3cbr\x3e如果不做该项优化，每个列表都需要事先渲染一次，动态地取得其渲染尺寸，然后再真正地渲染到页面中。\x3c\/p\x3e\n\x3cp\x3e如果预先知道列表中的每一项的高度(ITEM_HEIGHT)和其在父组件中的偏移量(offset)和位置(index)，就能减少一次渲染。这是很关键的性能优化点。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 getItemLayout={(data, index) =\x3e (\n   {length: ITEM_HEIGHT, offset: ITEM_HEIGHT * index, index}\n )}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e getItemLayout={(data, index) =\x26gt; (\n   {\x3cspan class=\x22hljs-attr\x22\x3elength\x3c\/span\x3e: ITEM_HEIGHT, \x3cspan class=\x22hljs-attr\x22\x3eoffset\x3c\/span\x3e: ITEM_HEIGHT * index, index}\n )}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e完整代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 这里使用 getData 获取假数据\n\/\/ 数据结构类似于 [{title: \x27Title Text\x27, key: \x27item1\x27}]\nimport getData from \x27.\/getData\x27;\nimport TopicRow from \x27.\/TopicRow\x27;\n\/\/ 引入 FlatList\nimport FlatList from \x27react-native\/Libraries\/CustomComponents\/Lists\/FlatList\x27;\n\nexport default class Wuba extends Component {\n\n  constructor(props) {\n    super(props);\n    this.state = {\n      listData: getData(),\n    };\n  }\n\n  renderItem({item,index}) {\n    return \x3cTopicRow  {...item} id={item.key} \/\x3e;\n  }\n\n  render() {\n    return (\n      \x3cFlatList\n        data = {this.state.listData}\n        renderItem={this.renderItem}\n        onEndReached={()=\x3e{\n          \/\/ 到达底部，加载更多列表项\n          this.setState({\n            listData: this.state.listData.concat(getData())\n          });\n        \x22}}\x22\n        getItemLayout={(data, index) =\x3e (\n          \/\/ 120 是被渲染 item 的高度 ITEM_HEIGHT。\n          {length: 120, offset: 120 * index, index}\n        )}\n      \/\x3e\n    )\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里使用 getData 获取假数据\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 数据结构类似于 [{title: \x27Title Text\x27, key: \x27item1\x27}]\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e getData \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/getData\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e TopicRow \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/TopicRow\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 引入 FlatList\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e FlatList \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react-native\/Libraries\/CustomComponents\/Lists\/FlatList\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eWuba\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(props) {\n    \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(props);\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = {\n      \x3cspan class=\x22hljs-attr\x22\x3elistData\x3c\/span\x3e: getData(),\n    };\n  }\n\n  renderItem({item,index}) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x26lt;TopicRow  {...item} id={item.key} \/\x26gt;;\n  }\n\n  render() {\n    return (\n      \x26lt;FlatList\n        data = {this.state.listData}\n        renderItem={this.renderItem}\n        onEndReached={()=\x26gt;{\n          \/\/ 到达底部，加载更多列表项\n          this.setState({\n            listData: this.state.listData.concat(getData())\n          });\n        \x22}}\x22\n        getItemLayout={(data, index) =\x26gt; (\n          \/\/ 120 是被渲染 item 的高度 ITEM_HEIGHT。\n          {length: 120, offset: 120 * index, index}\n        )}\n      \/\x26gt;\n    )\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e源码分析\x3c\/h2\x3e\n\x3cp\x3eFlatList 之所以节约内存、渲染快，是因为它只将用户看到的(和即将看到的)部分真正渲染出来了。而用户看不到的地方，渲染的只是空白元素。渲染空白元素相比渲染真正的列表元素需要内存和计算量会大大减少，这就是性能好的原因。\x3c\/p\x3e\n\x3cp\x3eFlatList 将页面分为 4 部分。初始化部分\/上方空白部分\/展现部分\/下方空白部分。初始化部分，在每次都会渲染；当用户滚动时，根据需求动态的调整(上下)空白部分的高度，并将视窗中的列表元素正确渲染出来。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVK9ux?w=628\x26amp;h=862\x22 src=\x22https:\/\/static.alili.tech\/img\/bVK9ux?w=628\x26amp;h=862\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22_usedIndexForKey = false;\nconst lastInitialIndex = this.props.initialNumToRender - 1;\nconst {first, last} = this.state;\n\/\/ 初始化时的 items (10个) ，被正确渲染出来\nthis._pushCells(cells, 0, lastInitialIndex);\n\/\/  first 就是 在视图中(包括要即将在视图)的第一个 item\nif (!disableVirtualization \x26amp;\x26amp; first \x3e lastInitialIndex) {\n  const initBlock = this._getFrameMetricsApprox(lastInitialIndex);\n  const firstSpace = this._getFrameMetricsApprox(first).offset -\n    (initBlock.offset \x2b initBlock.length);\n  \/\/ 从第 11 个 items (除去初始化的 10个 items) 到 first 渲染空白元素\n  cells.push(\n    \x3cView key=\x26quot;$lead_spacer\x26quot; style=\x22{{\x22[!horizontal ? \x27height\x27 : \x27width\x27]: firstSpace\x22}}\x22 \/\x3e\n  );\n}\n\/\/ last 是最后一个在视图(包括要即将在视图)中的元素。\n\/\/ 从 first 到 last ，即用户看到的界面渲染真正的 item\nthis._pushCells(cells, Math.max(lastInitialIndex \x2b 1, first), last);\nif (!this._hasWarned.keys \x26amp;\x26amp; _usedIndexForKey) {\n  console.warn(\n    \x27VirtualizedList: missing keys for items, make sure to specify a key property on each \x27 \x2b\n    \x27item or provide a custom keyExtractor.\x27\n  );\n  this._hasWarned.keys = true;\n}\nif (!disableVirtualization \x26amp;\x26amp; last \x3c itemCount - 1) {\n  const lastFrame = this._getFrameMetricsApprox(last);\n  const end = this.props.getItemLayout ?\n    itemCount - 1 :\n    Math.min(itemCount - 1, this._highestMeasuredFrameIndex);\n  const endFrame = this._getFrameMetricsApprox(end);\n  const tailSpacerLength =\n    (endFrame.offset \x2b endFrame.length) -\n    (lastFrame.offset \x2b lastFrame.length);\n   \/\/ last 之后的元素，渲染空白\n  cells.push(\n    \x3cView key=\x26quot;$tail_spacer\x26quot; style=\x22{{\x22[!horizontal ? \x27height\x27 : \x27width\x27]: tailSpacerLength\x22}}\x22 \/\x3e\n  );\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e_usedIndexForKey = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e lastInitialIndex = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.initialNumToRender - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e {first, last} = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state;\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 初始化时的 items (10个) ，被正确渲染出来\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._pushCells(cells, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, lastInitialIndex);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/  first 就是 在视图中(包括要即将在视图)的第一个 item\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!disableVirtualization \x26amp;\x26amp; first \x26gt; lastInitialIndex) {\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e initBlock = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._getFrameMetricsApprox(lastInitialIndex);\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e firstSpace = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._getFrameMetricsApprox(first).offset -\n    (initBlock.offset \x2b initBlock.length);\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 从第 11 个 items (除去初始化的 10个 items) 到 first 渲染空白元素\x3c\/span\x3e\n  cells.push(\n    \x26lt;View key=\x22$lead_spacer\x22 style=\x22{{\x22[!horizontal ? \x27height\x27 : \x27width\x27]: firstSpace\x22}}\x22 \/\x26gt;\n  );\n}\n\/\/ last 是最后一个在视图(包括要即将在视图)中的元素。\n\/\/ 从 first 到 last ，即用户看到的界面渲染真正的 item\nthis._pushCells(cells, Math.max(lastInitialIndex \x2b 1, first), last);\nif (!this._hasWarned.keys \x26amp;\x26amp; _usedIndexForKey) {\n  console.warn(\n    \x27VirtualizedList: missing keys for items, make sure to specify a key property on each \x27 \x2b\n    \x27item or provide a custom keyExtractor.\x27\n  );\n  this._hasWarned.keys = true;\n}\nif (!disableVirtualization \x26amp;\x26amp; last \x26lt; itemCount - 1) {\n  const lastFrame = this._getFrameMetricsApprox(last);\n  const end = this.props.getItemLayout ?\n    itemCount - 1 :\n    Math.min(itemCount - 1, this._highestMeasuredFrameIndex);\n  const endFrame = this._getFrameMetricsApprox(end);\n  const tailSpacerLength =\n    (endFrame.offset \x2b endFrame.length) -\n    (lastFrame.offset \x2b lastFrame.length);\n   \/\/ last 之后的元素，渲染空白\n  cells.push(\n    \x26lt;View key=\x22$tail_spacer\x22 style=\x22{{\x22[!horizontal ? \x27height\x27 : \x27width\x27]: tailSpacerLength\x22}}\x22 \/\x26gt;\n  );\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e既然要使用空白元素去代替实际的列表元素，就需要预先知道实际展现元素的高度(或宽度)和相对位置。如果不知道，就需要先渲染出实际展现元素，在获取完展现元素的高度和相对位置后，再用相同（累计）高度空白元素去代替实际的列表元素。\x3ccode\x3e_onCellLayout\x3c\/code\x3e 就是用于动态计算元素高度的方法，如果事先知道元素的高度和位置，就可以使用上面提到的 \x3ccode\x3egetItemLayout\x3c\/code\x3e 方法，就能跳过 \x3ccode\x3e_onCellLayout\x3c\/code\x3e 这一步，获得更好的性能。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22return (\n    \/\/ _onCellLayout 就是这里的 _onLayout\n    \/\/ 先渲染一次展现元素，通过 onLayout 获取其尺寸等信息\n  \x3cView onLayout={this._onLayout}\x3e\n    {element}\n  \x3c\/View\x3e\n);\n...\n  _onCellLayout = (e, cellKey, index) =\x3e {\n    \/\/ 展现元素尺寸等相关计算\n    const layout = e.nativeEvent.layout;\n    const next = {\n      offset: this._selectOffset(layout),\n      length: this._selectLength(layout),\n      index,\n      inLayout: true,\n    };\n    const curr = this._frames[cellKey];\n    if (!curr ||\n      next.offset !== curr.offset ||\n      next.length !== curr.length ||\n      index !== curr.index\n    ) {\n      this._totalCellLength \x2b= next.length - (curr ? curr.length : 0);\n      this._totalCellsMeasured \x2b= (curr ? 0 : 1);\n      this._averageCellLength = this._totalCellLength \/ this._totalCellsMeasured;\n      this._frames[cellKey] = next;\n      this._highestMeasuredFrameIndex = Math.max(this._highestMeasuredFrameIndex, index);\n      \/\/ 重新渲染一次。最终会调用一次上面分析的源码\n      this._updateCellsToRenderBatcher.schedule();\n    }\n  };\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ _onCellLayout 就是这里的 _onLayout\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 先渲染一次展现元素，通过 onLayout 获取其尺寸等信息\x3c\/span\x3e\n  \x26lt;View onLayout={\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._onLayout}\x26gt;\n    {element}\n  \x26lt;\x3cspan class=\x22hljs-regexp\x22\x3e\/View\x26gt;\n);\n...\n  _onCellLayout = (e, cellKey, index) =\x26gt; {\n    \/\x3c\/span\x3e\x3cspan class=\x22hljs-regexp\x22\x3e\/ 展现元素尺寸等相关计算\n    const layout = e.nativeEvent.layout;\n    const next = {\n      offset: this._selectOffset(layout),\n      length: this._selectLength(layout),\n      index,\n      inLayout: true,\n    };\n    const curr = this._frames[cellKey];\n    if (!curr ||\n      next.offset !== curr.offset ||\n      next.length !== curr.length ||\n      index !== curr.index\n    ) {\n      this._totalCellLength \x2b= next.length - (curr ? curr.length : 0);\n      this._totalCellsMeasured \x2b= (curr ? 0 : 1);\n      this._averageCellLength = this._totalCellLength \/\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._totalCellsMeasured;\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._frames[cellKey] = next;\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._highestMeasuredFrameIndex = \x3cspan class=\x22hljs-built_in\x22\x3eMath\x3c\/span\x3e.max(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._highestMeasuredFrameIndex, index);\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 重新渲染一次。最终会调用一次上面分析的源码\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._updateCellsToRenderBatcher.schedule();\n    }\n  };\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e简单分析 FlatList 的源码后，后发现它并没有和 native 端复用逻辑。而且如果有些机器性能极差，渲染过慢，那些假的列表——空白元素就会被用户看到！\x3c\/p\x3e\n\x3cp\x3e那么为什么要基于 RN 的 ScrollView 组件进行性能优化，而不直接使用 Android 或 iOS 提供的列表组件呢？\x3c\/p\x3e\n\x3cp\x3e最简单回答就是：太难了！\x3c\/p\x3e\n\x3cp\x3e由于本人对 RN 底层原理实现只有简单理解。只能引用 Facebook 大神的解释，起一个抛砖引玉的作用。\x3c\/p\x3e\n\x3cp\x3e以 iOS 的 \x3ccode\x3eUITableView\x3c\/code\x3e 为例，所有即将在视窗中呈现的元素都必须同步渲染。这意味着如果渲染过程超过 16ms，就会掉帧。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3eIn UITableView, when an element comes on screen, you have to synchronously render it. This means that you\x27ve got less than 16ms to do it. If you don\x27t, then you drop one or multiple frames.\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e但是问题是，从 RN render 到真正调用 native 代码这个过程本身是\x3cstrong\x3e异步\x3c\/strong\x3e的，过程中消耗的时间也并不能保证在 16ms 以内。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3eThe problem is in the RN render -\x26gt; shadow -\x26gt; yoga -\x26gt; native loop. You have at least three runloop jumps (dispatch_async(dispatch_get_main_queue(), ...) as well as background thread work, which all work against the required goal.\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e那么解决方案就是，在一些需要高性能的场景下，让 RN 能够\x3cstrong\x3e同步\x3c\/strong\x3e的调用 native 代码。这个答案或许就是 ListView 性能问题的终极解决方案。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3eWe are actually starting to experiment more and more with synchronous method calls for other modules, which would allow us to build a native list component that could call \x3ccode\x3erenderItem\x3c\/code\x3e on demand and choose whether to make the call synchronously on the UI thread if it\x27s hi-pri (including the JS, react, and yoga\/layout calcs), or on a background thread if it\x27s a low-pri pre-render further off-screen. This native list component might also be able to do proper recycling and other optimizations.\x3c\/p\x3e\x3c\/blockquote\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>React Native 的 ListView 性能问题已解决</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000008589705">https://segmentfault.com/a/1190000008589705</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/mw9p5lb9qfb/" target="_blank">https://alili.tech/archive/mw9p5lb9qfb/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>