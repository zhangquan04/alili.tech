<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="koa-router 源码浅析"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>koa-router 源码浅析 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/j60tyttzo9d/",
				"appid": "1613049289050283", 
				"title": "koa-router 源码浅析 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-01T02:30:10"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/ekkut3yf8b/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/xupzg5qj5e/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fj60tyttzo9d%2f&text=koa-router%20%e6%ba%90%e7%a0%81%e6%b5%85%e6%9e%90"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fj60tyttzo9d%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fj60tyttzo9d%2f&text=koa-router%20%e6%ba%90%e7%a0%81%e6%b5%85%e6%9e%90"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fj60tyttzo9d%2f&title=koa-router%20%e6%ba%90%e7%a0%81%e6%b5%85%e6%9e%90"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fj60tyttzo9d%2f&is_video=false&description=koa-router%20%e6%ba%90%e7%a0%81%e6%b5%85%e6%9e%90"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=koa-router%20%e6%ba%90%e7%a0%81%e6%b5%85%e6%9e%90&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fj60tyttzo9d%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fj60tyttzo9d%2f&title=koa-router%20%e6%ba%90%e7%a0%81%e6%b5%85%e6%9e%90"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fj60tyttzo9d%2f&title=koa-router%20%e6%ba%90%e7%a0%81%e6%b5%85%e6%9e%90"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fj60tyttzo9d%2f&title=koa-router%20%e6%ba%90%e7%a0%81%e6%b5%85%e6%9e%90"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fj60tyttzo9d%2f&title=koa-router%20%e6%ba%90%e7%a0%81%e6%b5%85%e6%9e%90"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">koa-router 源码浅析</h1><div class="meta"><div class="postdate"><time datetime="2019-02-01" itemprop="datePublished">2019-02-01</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch2 id=\x22articleHeader0\x22\x3e代码结构\x3c\/h2\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000007468236?w=1425\x26amp;h=1772\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000007468236?w=1425\x26amp;h=1772\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e执行流程\x3c\/h2\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000007468237?w=1212\x26amp;h=483\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000007468237?w=1212\x26amp;h=483\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e上面两张图主要将\x3ccode\x3ekoa-router\x3c\/code\x3e的整体代码结构和大概的执行流程画了出来，画的不够具体。那下面主要讲\x3ccode\x3ekoa-router\x3c\/code\x3e中的几处的关键代码解读一下。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e读代码首先要找到入口文件，那几乎所有的\x3ccode\x3enode\x3c\/code\x3e模块的入口文件都会在\x3ccode\x3epackage.json\x3c\/code\x3e文件中的\x3ccode\x3emain\x3c\/code\x3e属性指明了。\x3ccode\x3ekoa-router\x3c\/code\x3e的入口文件就是\x3ccode\x3elib\/router.js\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e第三方模块\x3c\/h2\x3e\n\x3cp\x3e首先先讲几个第三方的node模块了解一下，因为后面的代码讲解中会用到，不去看具体实现，只要知道其功能就行：  \x3cbr\x3e\x3cstrong\x3e\x3ca href=\x22https:\/\/github.com\/koajs\/compose\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ekoa-compose:\x3c\/a\x3e\x3c\/strong\x3e  \x3cbr\x3e提供给它一个中间件数组， 返回一个顺序执行所有中间件的执行函数。 \x3cbr\x3e\x3cstrong\x3e\x3ca href=\x22https:\/\/github.com\/jshttp\/methods\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3emethods\x3c\/a\x3e：\x3c\/strong\x3e  \x3cbr\x3enode中支持的http动词，就是http.METHODS，可以在终端输出看看。  \x3cbr\x3e\x3cstrong\x3e\x3ca href=\x22https:\/\/github.com\/pillarjs\/path-to-regexp\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3epath-to-regexp\x3c\/a\x3e：\x3c\/strong\x3e  \x3cbr\x3e将路径字符串转换成强大的正则表达式，还可以输出路径参数。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3eRouter \x26amp; Layer\x3c\/h2\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000007468238?w=295\x26amp;h=264\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000007468238?w=295\x26amp;h=264\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eRouter\x3c\/code\x3e 和 \x3ccode\x3eLayer\x3c\/code\x3e 分别是两个构造函数，分别在\x3ccode\x3erouter.js\x3c\/code\x3e 和 \x3ccode\x3elayer.js\x3c\/code\x3e中，\x3ccode\x3ekoa-router\x3c\/code\x3e的所有代码也就在这两个文件中，可以知道它的代码量并不是很多。  \x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3eRouter: 创建管理整个路由模块的实例\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Router(opts) {\n  if (!(this instanceof Router)) {\n    return new Router(opts);\n  }\n\n  this.opts = opts || {};\n  this.methods = this.opts.methods || [\n    \x27HEAD\x27,\n    \x27OPTIONS\x27,\n    \x27GET\x27,\n    \x27PUT\x27,\n    \x27PATCH\x27,\n    \x27POST\x27,\n    \x27DELETE\x27\n  ];\n\n  this.params = {};\n  this.stack = [];\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eRouter\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eopts\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e Router)) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Router(opts);\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.opts = opts || {};\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.methods = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.opts.methods || [\n    \x3cspan class=\x22hljs-string\x22\x3e\x27HEAD\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-string\x22\x3e\x27OPTIONS\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-string\x22\x3e\x27GET\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-string\x22\x3e\x27PUT\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-string\x22\x3e\x27PATCH\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-string\x22\x3e\x27POST\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-string\x22\x3e\x27DELETE\x27\x3c\/span\x3e\n  ];\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.params = {};\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.stack = [];\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e首先是\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22if (!(this instanceof Router)) {\n  return new Router(opts);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e Router)) {\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Router(opts);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这是常用的\x3ccode\x3e去new\x3c\/code\x3e的方式，所以我们可以在引入koa-router时：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const router = require(\x27koa-router\x27)()\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e router = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27koa-router\x27\x3c\/span\x3e)()\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e而不用：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const router = new require(\x27koa-router\x27)() \/\/ 这样也是没问题的\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e router = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27koa-router\x27\x3c\/span\x3e)() \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这样也是没问题的\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3ethis.methods:\x3c\/strong\x3e  \x3cbr\x3e在后面要讲的\x3ccode\x3eallowedMethods\x3c\/code\x3e方法中要用到的，目的是响应\x3ccode\x3eoptions\x3c\/code\x3e请求和请求出错的处理。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3ethis.params:\x3c\/strong\x3e   \x3cbr\x3e全局的路由参数处理的中间件组成的对象。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3ethis.stack:\x3c\/strong\x3e  \x3cbr\x3e其实就是各个路由(Layer)实例组成的数组。每次处理请求时都需要循环这个数组找到匹配的路由。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3eLayer: 创建各个路由实例\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Layer(path, methods, middleware, opts) {\n  ...\n\n  this.stack = Array.isArray(middleware) ? middleware : [middleware];\n\n  \/\/ 为给后面的allowedMthods处理\n  methods.forEach(function(method) {\n    var l = this.methods.push(method.toUpperCase());\n    if (this.methods[l-1] === \x27GET\x27) {\n      \/\/ 如果是get请求，则支持head请求\n      this.methods.unshift(\x27HEAD\x27);\n    }\n  }, this);\n\n  \/\/ 确保路由的每个中间件都是函数\n  this.stack.forEach(function(fn) {\n    var type = (typeof fn);\n    if (type !== \x27function\x27) {\n      throw new Error(\n        methods.toString() \x2b \x26quot; `\x26quot; \x2b (this.opts.name || path) \x2b\x26quot;`: `middleware` \x26quot;\n        \x2b \x26quot;must be a function, not `\x26quot; \x2b type \x2b \x26quot;`\x26quot;\n      );\n    }\n  }, this);\n  this.path = path;\n  \/\/ 利用path-to-rege模块生产的路径的正则表达式\n  this.regexp = pathToRegExp(path, this.paramNames, this.opts);\n\n  ...\n};\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eLayer\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3epath, methods, middleware, opts\x3c\/span\x3e) \x3c\/span\x3e{\n  ...\n\n  this.stack = \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.isArray(middleware) ? middleware : [middleware];\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 为给后面的allowedMthods处理\x3c\/span\x3e\n  methods.forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3emethod\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e l = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.methods.push(method.toUpperCase());\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.methods[l\x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e] === \x3cspan class=\x22hljs-string\x22\x3e\x27GET\x27\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果是get请求，则支持head请求\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.methods.unshift(\x3cspan class=\x22hljs-string\x22\x3e\x27HEAD\x27\x3c\/span\x3e);\n    }\n  }, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 确保路由的每个中间件都是函数\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.stack.forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3efn\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e type = (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e fn);\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (type !== \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\n        methods.toString() \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22 `\x22\x3c\/span\x3e \x2b (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.opts.name || path) \x2b\x3cspan class=\x22hljs-string\x22\x3e\x22`: `middleware` \x22\x3c\/span\x3e\n        \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22must be a function, not `\x22\x3c\/span\x3e \x2b type \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22`\x22\x3c\/span\x3e\n      );\n    }\n  }, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.path = path;\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 利用path-to-rege模块生产的路径的正则表达式\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.regexp = pathToRegExp(path, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.paramNames, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.opts);\n\n  ...\n};\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里的\x3ccode\x3ethis.stack\x3c\/code\x3e和\x3ccode\x3eRouter\x3c\/code\x3e中的不同，这里的是路由所有的中间件的数组。（一个路由可以有多个中间件）\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3erouter.register()\x3c\/h2\x3e\n\x3cp\x3e\x3cstrong\x3e作用：注册路由\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e从上一篇的代码结构图中可以看出，\x3ccode\x3eRouter\x3c\/code\x3e的几个实例方法都直接或简介地调用了\x3ccode\x3eregister\x3c\/code\x3e方法，可见，它应该是比较核心的函数, 代码不长，我们一行行看一下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Router.prototype.register = function (path, methods, middleware, opts) {\n  opts = opts || {};\n  var router = this;\n\n  \/\/ 全部路由\n  var stack = this.stack;\n\n  \/\/ 说明路由的path是支持数组的\n  \/\/ 如果是数组的话，需要递归调用register来注册路由\n  \/\/ 因为一个path对应一个路由\n  if (Array.isArray(path)) {\n    path.forEach(function (p) {\n      router.register.call(router, p, methods, middleware, opts);\n    });\n\n    return this;\n  }\n\n  \/\/ 创建路由，路由就是Layer的实例\n  \/\/ mthods 是路由处理的http方法\n  \/\/ 最后一个参数对象最终是传给Layer模块中的path-to-regexp模块接口调用的\n  var route = new Layer(path, methods, middleware, {\n    end: opts.end === false ? opts.end : true,\n    name: opts.name,\n    sensitive: opts.sensitive || this.opts.sensitive || false,\n    strict: opts.strict || this.opts.strict || false,\n    prefix: opts.prefix || this.opts.prefix || \x26quot;\x26quot;,\n    ignoreCaptures: opts.ignoreCaptures\n  });\n\n  \/\/ 处理路径前缀\n  if (this.opts.prefix) {\n    route.setPrefix(this.opts.prefix);\n  }\n\n  \/\/ 将全局的路由参数添加到每个路由中\n  Object.keys(this.params).forEach(function (param) {\n    route.param(param, this.params[param]);\n  }, this);\n\n  \/\/ 往路由数组中添加新创建的路由\n  stack.push(route);\n\n  return route;\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eRouter.prototype.register = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3epath, methods, middleware, opts\x3c\/span\x3e) \x3c\/span\x3e{\n  opts = opts || {};\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e router = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 全部路由\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e stack = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.stack;\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 说明路由的path是支持数组的\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果是数组的话，需要递归调用register来注册路由\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 因为一个path对应一个路由\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.isArray(path)) {\n    path.forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ep\x3c\/span\x3e) \x3c\/span\x3e{\n      router.register.call(router, p, methods, middleware, opts);\n    });\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建路由，路由就是Layer的实例\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ mthods 是路由处理的http方法\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 最后一个参数对象最终是传给Layer模块中的path-to-regexp模块接口调用的\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e route = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Layer(path, methods, middleware, {\n    \x3cspan class=\x22hljs-attr\x22\x3eend\x3c\/span\x3e: opts.end === \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e ? opts.end : \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: opts.name,\n    \x3cspan class=\x22hljs-attr\x22\x3esensitive\x3c\/span\x3e: opts.sensitive || \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.opts.sensitive || \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3estrict\x3c\/span\x3e: opts.strict || \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.opts.strict || \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3eprefix\x3c\/span\x3e: opts.prefix || \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.opts.prefix || \x3cspan class=\x22hljs-string\x22\x3e\x22\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3eignoreCaptures\x3c\/span\x3e: opts.ignoreCaptures\n  });\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 处理路径前缀\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.opts.prefix) {\n    route.setPrefix(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.opts.prefix);\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将全局的路由参数添加到每个路由中\x3c\/span\x3e\n  \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.keys(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.params).forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eparam\x3c\/span\x3e) \x3c\/span\x3e{\n    route.param(param, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.params[param]);\n  }, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 往路由数组中添加新创建的路由\x3c\/span\x3e\n  stack.push(route);\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e route;\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3erouter.verb()\x3c\/h2\x3e\n\x3cp\x3e\x3cstrong\x3everb =\x26gt; get|put|post|patch|delete\x3c\/strong\x3e   \x3cbr\x3e\x3cstrong\x3e作用：注册路由\x3c\/strong\x3e  \x3c\/p\x3e\n\x3cp\x3e这是\x3ccode\x3ekoa-router\x3c\/code\x3e提供的直接注册相应http方法的路由，但最终还是会调用\x3ccode\x3eregister\x3c\/code\x3e方法如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22router.get(\x27\/user\x27, function(ctx, next){...})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3erouter.get(\x3cspan class=\x22hljs-string\x22\x3e\x27\/user\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ectx, next\x3c\/span\x3e)\x3c\/span\x3e{...})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e和下面利用\x3ccode\x3eregister\x3c\/code\x3e方法等价：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22router.register(\x27\/user\x27, [\x27get\x27], [function(ctx, next){...}])\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3erouter.register(\x3cspan class=\x22hljs-string\x22\x3e\x27\/user\x27\x3c\/span\x3e, [\x3cspan class=\x22hljs-string\x22\x3e\x27get\x27\x3c\/span\x3e], [\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ectx, next\x3c\/span\x3e)\x3c\/span\x3e{...}])\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可以看到直接使用\x3ccode\x3erouter.verb\x3c\/code\x3e注册路由会方便很多。来看看代码：  \x3cbr\x3e你会发现\x3ccode\x3erouter.js\x3c\/code\x3e的代码里并没有\x3ccode\x3eRouter.prototype.get\x3c\/code\x3e的代码出现，原因是它还依赖了上面提到的\x3ccode\x3emethods\x3c\/code\x3e模块来实现。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 这里的methods就是上面的methods模块提供的数组\nmethods.forEach(function (method) {\n  Router.prototype[method] = function (name, path, middleware) {\n    var middleware;\n\n    \/\/ 这段代码做了两件事：\n    \/\/ 1.name 参数是可选的，所以要做一些参数置换的处理\n    \/\/ 2.将所有路由中间件合并成一个数组\n    if (typeof path === \x27string\x27 || path instanceof RegExp) {\n      middleware = Array.prototype.slice.call(arguments, 2);\n    } else {\n      middleware = Array.prototype.slice.call(arguments, 1);\n      path = name;\n      name = null;\n    }\n\n    \/\/ 调用register方法\n    this.register(path, [method], middleware, {\n      name: name\n    });\n\n    return this;\n  };\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里的methods就是上面的methods模块提供的数组\x3c\/span\x3e\nmethods.forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3emethod\x3c\/span\x3e) \x3c\/span\x3e{\n  Router.prototype[method] = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ename, path, middleware\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e middleware;\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这段代码做了两件事：\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 1.name 参数是可选的，所以要做一些参数置换的处理\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 2.将所有路由中间件合并成一个数组\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e path === \x3cspan class=\x22hljs-string\x22\x3e\x27string\x27\x3c\/span\x3e || path \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eRegExp\x3c\/span\x3e) {\n      middleware = \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.prototype.slice.call(\x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e);\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      middleware = \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.prototype.slice.call(\x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\n      path = name;\n      name = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 调用register方法\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.register(path, [method], middleware, {\n      \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: name\n    });\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n  };\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3erouter.routes()\x3c\/h2\x3e\n\x3cp\x3e\x3cstrong\x3e作用：启动路由\x3c\/strong\x3e  \x3c\/p\x3e\n\x3cp\x3e这是在koa中配置路由的重要一步：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var router = require(\x27koa-router\x27)();\n...\napp.use(router.routes())\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e router = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27koa-router\x27\x3c\/span\x3e)();\n...\napp.use(router.routes())\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e就这样，\x3ccode\x3ekoa-router\x3c\/code\x3e就启动了，所以我们也一定会很好奇这个\x3ccode\x3eroutes\x3c\/code\x3e函数到底做了什么,但可以肯定\x3ccode\x3erouter.routes()\x3c\/code\x3e返回了一个中间件函数。\x3cbr\x3e函数体长了一点，简化一下看下整体轮廓：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Router.prototype.routes = Router.prototype.middleware = function () {\n  var router = this;\n  var dispatch = function dispatch(ctx, next) {\n    ...\n  }\n  dispatch.router = this;\n  return dispatch;\n};\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eRouter.prototype.routes = Router.prototype.middleware = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e router = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e dispatch = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3edispatch\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ectx, next\x3c\/span\x3e) \x3c\/span\x3e{\n    ...\n  }\n  dispatch.router = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e dispatch;\n};\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里形成了一个闭包，在\x3ccode\x3eroutes\x3c\/code\x3e函数内部返回了一个\x3ccode\x3edispatch\x3c\/code\x3e函数作为中间件。  \x3cbr\x3e接下来看下\x3ccode\x3edispatch\x3c\/code\x3e函数的实现：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var dispatch = function dispatch(ctx, next) {\n    var path = router.opts.routerPath || ctx.routerPath || ctx.path;\n\n    \/\/ router.match函数内部遍历所有路由（this.stach）,\n    \/\/ 根据路径和请求方法找到对应的路由\n    \/\/ 返回的matched对象为： \n    \/* \n      var matched = {\n        path: [], \/\/ 保存了path匹配的路由数组\n        pathAndMethod: [], \/\/ 保存了path和methods都匹配的路由数组\n        route: false \/\/ 是否有对应的路由\n      };\n    *\/\n    var matched = router.match(path, ctx.method);\n    var layerChain, layer, i;\n    if (ctx.matched) {\n      ctx.matched.push.apply(ctx.matched, matched.path);\n    } else {\n      ctx.matched = matched.path;\n    }\n\n    \/\/ 如果没有对应的路由，则直接进入下一个中间件\n    if (!matched.route) return next();\n\n    \/\/ 找到正确的路由的path\n    var mostSpecificPath = matched.pathAndMethod[matched.pathAndMethod.length - 1].path;\n    ctx._matchedRoute = mostSpecificPath;\n\n    \/\/ 使用reduce方法将路由的所有中间件形成一条链\n    layerChain = matched.pathAndMethod.reduce(function(memo, layer) {\n\n      \/\/ 在每个路由的中间件执行之前，根据参数不同，设置 ctx.captures 和 ctx.params\n      \/\/ 这就是为什么我们可以直接在中间件函数中直接使用 ctx.params 来读取路由参数信息了\n      memo.push(function(ctx, next) {\n\n        \/\/ 返回路由的参数的key \n        ctx.captures = layer.captures(path, ctx.captures);\n\n        \/\/ 返回参数的key和对应的value组成的对象\n        ctx.params = layer.params(path, ctx.captures, ctx.params);\n\n        \/\/ 执行下一个中间件\n        return next();\n      });\n\n      \/\/ 将上面另外加的中间件和已有的路由中间件合并到一起\n      \/\/ 所以最终 layerChain 将会是一个中间件的数组\n      return memo.concat(layer.stack);\n    }, []);\n\n    \/\/ 最后调用上面提到的 compose 模块提供的方法，返回将 layerChain (中间件的数组) \n    \/\/ 顺序执行所有中间件的执行函数， 并立即执行。\n    return compose(layerChain)(ctx, next);\n  };\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e dispatch = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3edispatch\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ectx, next\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e path = router.opts.routerPath || ctx.routerPath || ctx.path;\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ router.match函数内部遍历所有路由（this.stach）,\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 根据路径和请求方法找到对应的路由\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 返回的matched对象为： \x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/* \n      var matched = {\n        path: [], \/\/ 保存了path匹配的路由数组\n        pathAndMethod: [], \/\/ 保存了path和methods都匹配的路由数组\n        route: false \/\/ 是否有对应的路由\n      };\n    *\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e matched = router.match(path, ctx.method);\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e layerChain, layer, i;\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (ctx.matched) {\n      ctx.matched.push.apply(ctx.matched, matched.path);\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      ctx.matched = matched.path;\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果没有对应的路由，则直接进入下一个中间件\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!matched.route) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e next();\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 找到正确的路由的path\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e mostSpecificPath = matched.pathAndMethod[matched.pathAndMethod.length - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e].path;\n    ctx._matchedRoute = mostSpecificPath;\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 使用reduce方法将路由的所有中间件形成一条链\x3c\/span\x3e\n    layerChain = matched.pathAndMethod.reduce(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ememo, layer\x3c\/span\x3e) \x3c\/span\x3e{\n\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 在每个路由的中间件执行之前，根据参数不同，设置 ctx.captures 和 ctx.params\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这就是为什么我们可以直接在中间件函数中直接使用 ctx.params 来读取路由参数信息了\x3c\/span\x3e\n      memo.push(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ectx, next\x3c\/span\x3e) \x3c\/span\x3e{\n\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 返回路由的参数的key \x3c\/span\x3e\n        ctx.captures = layer.captures(path, ctx.captures);\n\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 返回参数的key和对应的value组成的对象\x3c\/span\x3e\n        ctx.params = layer.params(path, ctx.captures, ctx.params);\n\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 执行下一个中间件\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e next();\n      });\n\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将上面另外加的中间件和已有的路由中间件合并到一起\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 所以最终 layerChain 将会是一个中间件的数组\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e memo.concat(layer.stack);\n    }, []);\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 最后调用上面提到的 compose 模块提供的方法，返回将 layerChain (中间件的数组) \x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 顺序执行所有中间件的执行函数， 并立即执行。\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e compose(layerChain)(ctx, next);\n  };\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3erouter.allowMethods()\x3c\/h2\x3e\n\x3cp\x3e\x3cstrong\x3e作用： 当请求出错时的处理逻辑\x3c\/strong\x3e  \x3c\/p\x3e\n\x3cp\x3e同样也是koa中配置路由的中一步：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var router = require(\x27koa-router\x27)();\n...\napp.use(router.routes())\napp.use(router.allowMethods())\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e router = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27koa-router\x27\x3c\/span\x3e)();\n...\napp.use(router.routes())\napp.use(router.allowMethods())\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可以看出，该方法也是闭包内返回了中间件函数。我们将代码简化一下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Router.prototype.allowedMethods = function (options) {\n  options = options || {};\n  var implemented = this.methods;\n  return function allowedMethods(ctx, next) {\n    return next().then(function() {\n      var allowed = {};\n\n      if (!ctx.status || ctx.status === 404) {\n        ...\n\n        if (!~implemented.indexOf(ctx.method)) {\n          if (options.throw) {\n            ...\n          } else {\n            ctx.status = 501;\n            ctx.set(\x27Allow\x27, allowedArr);\n          }\n        } else if (allowedArr.length) {\n          if (ctx.method === \x27OPTIONS\x27) {\n            ctx.status = 204;\n            ctx.set(\x27Allow\x27, allowedArr);\n          } else if (!allowed[ctx.method]) {\n            if (options.throw) {\n              ...\n            } else {\n              ctx.status = 405;\n              ctx.set(\x27Allow\x27, allowedArr);\n            }\n          }\n        }\n      }\n    });\n  };\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eRouter.prototype.allowedMethods = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eoptions\x3c\/span\x3e) \x3c\/span\x3e{\n  options = options || {};\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e implemented = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.methods;\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eallowedMethods\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ectx, next\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e next().then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e allowed = {};\n\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!ctx.status || ctx.status === \x3cspan class=\x22hljs-number\x22\x3e404\x3c\/span\x3e) {\n        ...\n\n        if (!~implemented.indexOf(ctx.method)) {\n          \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (options.throw) {\n            ...\n          } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n            ctx.status = \x3cspan class=\x22hljs-number\x22\x3e501\x3c\/span\x3e;\n            ctx.set(\x3cspan class=\x22hljs-string\x22\x3e\x27Allow\x27\x3c\/span\x3e, allowedArr);\n          }\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (allowedArr.length) {\n          \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (ctx.method === \x3cspan class=\x22hljs-string\x22\x3e\x27OPTIONS\x27\x3c\/span\x3e) {\n            ctx.status = \x3cspan class=\x22hljs-number\x22\x3e204\x3c\/span\x3e;\n            ctx.set(\x3cspan class=\x22hljs-string\x22\x3e\x27Allow\x27\x3c\/span\x3e, allowedArr);\n          } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!allowed[ctx.method]) {\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (options.throw) {\n              ...\n            } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n              ctx.status = \x3cspan class=\x22hljs-number\x22\x3e405\x3c\/span\x3e;\n              ctx.set(\x3cspan class=\x22hljs-string\x22\x3e\x27Allow\x27\x3c\/span\x3e, allowedArr);\n            }\n          }\n        }\n      }\n    });\n  };\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e眼尖的同学可能会看到一些\x3ccode\x3ehttp code\x3c\/code\x3e ： \x3ccode\x3e404\x3c\/code\x3e, \x3ccode\x3e501\x3c\/code\x3e, \x3ccode\x3e204\x3c\/code\x3e, \x3ccode\x3e405\x3c\/code\x3e    \x3cbr\x3e那这个函数其实就是当所有中间件函数执行完了，并且请求出错了进行相应的处理：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e如果请求的方法koa-router不支持并且没有设置\x3ccode\x3ethrow\x3c\/code\x3e选项，则返回 \x3ccode\x3e501(未实现)\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e如果是\x3ccode\x3eoptions\x3c\/code\x3e请求，则返回 \x3ccode\x3e204(无内容)\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e如果请求的方法支持但没有设置\x3ccode\x3ethrow\x3c\/code\x3e选项，则返回 \x3ccode\x3e405(不允许此方法 )\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3e总结\x3c\/h2\x3e\n\x3cp\x3e粗略浅析了这么些，能大概知道了koa-router的工作原理。笔者能力有限，有错误还请指出。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>koa-router 源码浅析</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000007468233">https://segmentfault.com/a/1190000007468233</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/j60tyttzo9d/" target="_blank">https://alili.tech/archive/j60tyttzo9d/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>