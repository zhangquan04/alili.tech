<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="理解Javascript之执行上下文(Execution Context)"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>理解Javascript之执行上下文(Execution Context) | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/383eptildsh/",
				"appid": "1613049289050283", 
				"title": "理解Javascript之执行上下文(Execution Context) | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-11T02:30:08"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/vyutywhpps/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/di9f4c5ln58/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f383eptildsh%2f&text=%e7%90%86%e8%a7%a3Javascript%e4%b9%8b%e6%89%a7%e8%a1%8c%e4%b8%8a%e4%b8%8b%e6%96%87%28Execution%20Context%29"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f383eptildsh%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f383eptildsh%2f&text=%e7%90%86%e8%a7%a3Javascript%e4%b9%8b%e6%89%a7%e8%a1%8c%e4%b8%8a%e4%b8%8b%e6%96%87%28Execution%20Context%29"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f383eptildsh%2f&title=%e7%90%86%e8%a7%a3Javascript%e4%b9%8b%e6%89%a7%e8%a1%8c%e4%b8%8a%e4%b8%8b%e6%96%87%28Execution%20Context%29"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f383eptildsh%2f&is_video=false&description=%e7%90%86%e8%a7%a3Javascript%e4%b9%8b%e6%89%a7%e8%a1%8c%e4%b8%8a%e4%b8%8b%e6%96%87%28Execution%20Context%29"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e7%90%86%e8%a7%a3Javascript%e4%b9%8b%e6%89%a7%e8%a1%8c%e4%b8%8a%e4%b8%8b%e6%96%87%28Execution%20Context%29&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f383eptildsh%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f383eptildsh%2f&title=%e7%90%86%e8%a7%a3Javascript%e4%b9%8b%e6%89%a7%e8%a1%8c%e4%b8%8a%e4%b8%8b%e6%96%87%28Execution%20Context%29"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f383eptildsh%2f&title=%e7%90%86%e8%a7%a3Javascript%e4%b9%8b%e6%89%a7%e8%a1%8c%e4%b8%8a%e4%b8%8b%e6%96%87%28Execution%20Context%29"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f383eptildsh%2f&title=%e7%90%86%e8%a7%a3Javascript%e4%b9%8b%e6%89%a7%e8%a1%8c%e4%b8%8a%e4%b8%8b%e6%96%87%28Execution%20Context%29"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f383eptildsh%2f&title=%e7%90%86%e8%a7%a3Javascript%e4%b9%8b%e6%89%a7%e8%a1%8c%e4%b8%8a%e4%b8%8b%e6%96%87%28Execution%20Context%29"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">理解Javascript之执行上下文(Execution Context)</h1><div class="meta"><div class="postdate"><time datetime="2019-01-11" itemprop="datePublished">2019-01-11</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e\x3cstrong\x3e1\x26gt;什么是执行上下文\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3eJavascript中代码的运行环境分为以下三种：\x3cbr\x3e全局级别的代码 - 这个是默认的代码运行环境，一旦代码被载入，引擎最先进入的就是这个环境。\x3cbr\x3e函数级别的代码 - 当执行一个函数时，运行函数体中的代码。\x3cbr\x3eEval的代码 - 在Eval函数内运行的代码。\x3cbr\x3ejavascript是一个单线程语言，这意味着在浏览器中同时只能做一件事情。当javascript解释器初始执行代码，它首先默认进入全局上下文。每次调用一个函数将会创建一个新的执行上下文。 \x3cbr\x3e每次新创建的一个执行上下文会被添加到作用域链的顶部，有时也称为执行或调用栈。浏览器总是运行位于作用域链顶部的当前执行上下文。一旦完成，当前执行上下文将从栈顶被移除并且将控制权归还给之前的执行上下文。\x3c\/p\x3e\n\x3cp\x3e不同执行上下文之间的变量命名冲突通过攀爬作用域链解决，从局部直到全局。这意味着具有相同名称的局部变量在作用域链中有更高的优先级。 \x3cbr\x3e简单的说，每次你试图访问函数执行上下文中的变量时，查找进程总是从自己的变量对象开始。如果在自己的变量对象中没发现要查找的变量，继续搜索作用域链。它将攀爬作用域链检查每一个执行上下文的变量对象，寻找和变量名称匹配的值。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e2\x26gt;执行上下文的建立过程\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e我们现在已经知道，每当调用一个函数时，一个新的执行上下文就会被创建出来。然而，在javascript引擎内部，这个上下文的创建过程具体分为两个阶段:\x3cbr\x3e建立阶段(发生在当调用一个函数时，但是在执行函数体内的具体代码以前)\x3cbr\x3e建立变量，函数，arguments对象，参数\x3cbr\x3e建立作用域链\x3cbr\x3e确定this的值\x3cbr\x3e代码执行阶段:\x3cbr\x3e变量赋值，函数引用，执行其它代码\x3cbr\x3e实际上，可以把执行上下文看做一个对象，其下包含了以上3个属性：\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3eexecutionContextObj = {    variableObject: { \/* 函数中的arguments对象, 参数,\x3cbr\x3e内部的变量以及函数声明 \x3cem\x3e\/ },    scopeChain: { \/\x3c\/em\x3e variableObject\x3cbr\x3e以及所有父执行上下文中的variableObject *\/ },    this: {}  }\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e\x3cstrong\x3e3\x26gt;建立阶段以及代码执行阶段的详细分析\x3c\/strong\x3e\x3cbr\x3e确 切地说，执行上下文对象（上述的executionContextObj）是在函数被调用时，但是在函数体被真正执行以前所创建的。函数被调用时，就是我 上述所描述的两个阶段中的第一个阶段 - 建立阶段。这个时刻，引擎会检查函数中的参数，声明的变量以及内部函数，然后基于这些信息建立执行上下文对象 （executionContextObj）。在这个阶段，variableObject对象，作用域链，以及this所指向的对象都会被确定。\x3cbr\x3e上述第一个阶段的具体过程如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x221.找到当前上下文中的调用函数的代码\n2.在执行被调用的函数体中的代码以前，开始创建执行上下文\n3.进入第一个阶段-建立阶段:\n    建立variableObject对象:\n        建立arguments对象，检查当前上下文中的参数，建立该对象下的属性以及属性值\n        检查当前上下文中的函数声明：\n        每找到一个函数声明，就在variableObject下面用函数名建立一个属性，属性值就是指向该函数在内存中的地址的一个引用\n        如果上述函数名已经存在于variableObject下，那么对应的属性值会被新的引用所覆盖。\n        检查当前上下文中的变量声明：\n        每找到一个变量的声明，就在variableObject下，用变量名建立一个属性，属性值为undefined。\n        如果该变量名已经存在于variableObject属性中，直接跳过(防止指向函数的属性的值被变量属性覆盖为undefined)，原属性值不会被修改。\n    初始化作用域链\n    确定上下文中this的指向对象\n4.代码执行阶段:\n    执行函数体中的代码，一行一行地运行代码，给variableObject中的变量属性赋值。\n    下面来看个具体的代码示例:\n    function foo(i) {\n       var a = \x27hello\x27;\n       var b = function privateB() {\n    \n       };\n       function c() {\n    \n       }\n    }\n    \n    foo(22);\n    在调用foo(22)的时候，建立阶段如下:\n            fooExecutionContext = {\n       variableObject: {\n           arguments: {\n               0: 22,\n               length: 1\n           },\n           i: 22,\n           c: pointer to function c()\n           a: undefined,\n           b: undefined\n       },\n       scopeChain: { ... },\n       this: { ... }\n    }\n    由此可见，在建立阶段，除了arguments，函数的声明，以及参数被赋予了具体的属性值，其它的变量属性默认的都是undefined。一旦上述建立阶段结束，引擎就会进入代码执行阶段，这个阶段完成后，上述执行上下文对象如下:\n        fooExecutionContext = {\n   variableObject: {\n       arguments: {\n           0: 22,\n           length: 1\n       },\n       i: 22,\n       c: pointer to function c()\n       a: \x27hello\x27,\n       b: pointer to function privateB()\n   },\n   scopeChain: { ... },\n   this: { ... }\n}\n我们看到，只有在代码执行阶段，变量属性才会被赋予具体的值。\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-number\x22\x3e1.\x3c\/span\x3e找到当前上下文中的调用函数的代码\n\x3cspan class=\x22hljs-number\x22\x3e2.\x3c\/span\x3e在执行被调用的函数体中的代码以前，开始创建执行上下文\n\x3cspan class=\x22hljs-number\x22\x3e3.\x3c\/span\x3e进入第一个阶段-建立阶段:\n    建立variableObject对象:\n        建立\x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e对象，检查当前上下文中的参数，建立该对象下的属性以及属性值\n        检查当前上下文中的函数声明：\n        每找到一个函数声明，就在variableObject下面用函数名建立一个属性，属性值就是指向该函数在内存中的地址的一个引用\n        如果上述函数名已经存在于variableObject下，那么对应的属性值会被新的引用所覆盖。\n        检查当前上下文中的变量声明：\n        每找到一个变量的声明，就在variableObject下，用变量名建立一个属性，属性值为\x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e。\n        如果该变量名已经存在于variableObject属性中，直接跳过(防止指向函数的属性的值被变量属性覆盖为\x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e)，原属性值不会被修改。\n    初始化作用域链\n    确定上下文中\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e的指向对象\n\x3cspan class=\x22hljs-number\x22\x3e4.\x3c\/span\x3e代码执行阶段:\n    执行函数体中的代码，一行一行地运行代码，给variableObject中的变量属性赋值。\n    下面来看个具体的代码示例:\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ei\x3c\/span\x3e) \x3c\/span\x3e{\n       \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e a = \x3cspan class=\x22hljs-string\x22\x3e\x27hello\x27\x3c\/span\x3e;\n       \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e b = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eprivateB\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \n       };\n       \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ec\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \n       }\n    }\n    \n    foo(\x3cspan class=\x22hljs-number\x22\x3e22\x3c\/span\x3e);\n    在调用foo(\x3cspan class=\x22hljs-number\x22\x3e22\x3c\/span\x3e)的时候，建立阶段如下:\n            fooExecutionContext = {\n       \x3cspan class=\x22hljs-attr\x22\x3evariableObject\x3c\/span\x3e: {\n           \x3cspan class=\x22hljs-attr\x22\x3earguments\x3c\/span\x3e: {\n               \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e22\x3c\/span\x3e,\n               \x3cspan class=\x22hljs-attr\x22\x3elength\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n           },\n           \x3cspan class=\x22hljs-attr\x22\x3ei\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e22\x3c\/span\x3e,\n           \x3cspan class=\x22hljs-attr\x22\x3ec\x3c\/span\x3e: pointer to \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ec\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\n           \x3cspan class=\x22hljs-title\x22\x3ea\x3c\/span\x3e: \x3cspan class=\x22hljs-title\x22\x3eundefined\x3c\/span\x3e,\n           \x3cspan class=\x22hljs-title\x22\x3eb\x3c\/span\x3e: \x3cspan class=\x22hljs-title\x22\x3eundefined\x3c\/span\x3e\n       },\n       \x3cspan class=\x22hljs-title\x22\x3escopeChain\x3c\/span\x3e: \x3c\/span\x3e{ ... },\n       \x3cspan class=\x22hljs-attr\x22\x3ethis\x3c\/span\x3e: { ... }\n    }\n    由此可见，在建立阶段，除了\x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e，函数的声明，以及参数被赋予了具体的属性值，其它的变量属性默认的都是\x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e。一旦上述建立阶段结束，引擎就会进入代码执行阶段，这个阶段完成后，上述执行上下文对象如下:\n        fooExecutionContext = {\n   \x3cspan class=\x22hljs-attr\x22\x3evariableObject\x3c\/span\x3e: {\n       \x3cspan class=\x22hljs-attr\x22\x3earguments\x3c\/span\x3e: {\n           \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e22\x3c\/span\x3e,\n           \x3cspan class=\x22hljs-attr\x22\x3elength\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n       },\n       \x3cspan class=\x22hljs-attr\x22\x3ei\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e22\x3c\/span\x3e,\n       \x3cspan class=\x22hljs-attr\x22\x3ec\x3c\/span\x3e: pointer to \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ec\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\n       \x3cspan class=\x22hljs-title\x22\x3ea\x3c\/span\x3e: \x27\x3cspan class=\x22hljs-title\x22\x3ehello\x3c\/span\x3e\x27,\n       \x3cspan class=\x22hljs-title\x22\x3eb\x3c\/span\x3e: \x3cspan class=\x22hljs-title\x22\x3epointer\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eto\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eprivateB\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\n   },\n   \x3cspan class=\x22hljs-title\x22\x3escopeChain\x3c\/span\x3e: \x3c\/span\x3e{ ... },\n   \x3cspan class=\x22hljs-attr\x22\x3ethis\x3c\/span\x3e: { ... }\n}\n我们看到，只有在代码执行阶段，变量属性才会被赋予具体的值。\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e4\x26gt;局部变量作用域提升的缘由\x3c\/strong\x3e\x3cbr\x3e在网上一直看到这样的总结： 在函数中声明的变量以及函数，其作用域提升到函数顶部，换句话说，就是一进入函数体，就可以访问到其中声明的变量以及函数。这是对的，但是知道其中的缘由吗？相信你通过上述的解释应该也有所明白了。不过在这边再分析一下。看下面一段代码:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function() {\n\n   console.log(typeof foo); \/\/ function pointer\n   console.log(typeof bar); \/\/ undefined\n\n   var foo = \x27hello\x27,\n       bar = function() {\n           return \x27world\x27;\n       };\n\n   function foo() {\n       return \x27hello\x27;\n   }\n\n}());\n上述代码定义了一个匿名函数，并且通过()运算符强制理解执行。那么我们知道这个时候就会有个执行上下文被创建，我们看到例子中马上可以访问foo以及bar变量，并且通过typeof输出foo为一个函数引用，bar为undefined。\n为什么我们可以在声明foo变量以前就可以访问到foo呢？\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n\n   \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e foo); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ function pointer\x3c\/span\x3e\n   \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e bar); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ undefined\x3c\/span\x3e\n\n   \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e foo = \x3cspan class=\x22hljs-string\x22\x3e\x27hello\x27\x3c\/span\x3e,\n       bar = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n           \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27world\x27\x3c\/span\x3e;\n       };\n\n   \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n       \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27hello\x27\x3c\/span\x3e;\n   }\n\n}());\n上述代码定义了一个匿名函数，并且通过()运算符强制理解执行。那么我们知道这个时候就会有个执行上下文被创建，我们看到例子中马上可以访问foo以及bar变量，并且通过\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e输出foo为一个函数引用，bar为\x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e。\n为什么我们可以在声明foo变量以前就可以访问到foo呢？\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e因 为在上下文的建立阶段，先是处理arguments, 参数，接着是函数的声明，最后是变量的声明。那么，发现foo函数的声明后，就会在variableObject下面建立一个foo属性，其值是一个指向 函数的引用。当处理变量声明的时候，发现有var foo的声明，但是variableObject已经具有了foo属性，所以直接跳过。当进入代码执行阶段的时候，就可以通过访问到foo属性了，因为它 已经就存在，并且是一个函数引用。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22为什么bar是undefined呢？   \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e为什么bar是\x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e呢？   \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e因为bar是变量的声明，在建立阶段的时候，被赋予的默认的值为undefined。由于它只要在代码执行阶段才会被赋予具体的值，所以，当调用typeof(bar)的时候输出的值为undefined。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>理解Javascript之执行上下文(Execution Context)</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000009919936">https://segmentfault.com/a/1190000009919936</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/383eptildsh/" target="_blank">https://alili.tech/archive/383eptildsh/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>