<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="React 组件设计和分解思考"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>React 组件设计和分解思考 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/acpj1otkbul/",
				"appid": "1613049289050283", 
				"title": "React 组件设计和分解思考 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-11T02:30:07"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/1980255ddhki/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/7dqldu9id15/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2facpj1otkbul%2f&text=React%20%e7%bb%84%e4%bb%b6%e8%ae%be%e8%ae%a1%e5%92%8c%e5%88%86%e8%a7%a3%e6%80%9d%e8%80%83"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2facpj1otkbul%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2facpj1otkbul%2f&text=React%20%e7%bb%84%e4%bb%b6%e8%ae%be%e8%ae%a1%e5%92%8c%e5%88%86%e8%a7%a3%e6%80%9d%e8%80%83"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2facpj1otkbul%2f&title=React%20%e7%bb%84%e4%bb%b6%e8%ae%be%e8%ae%a1%e5%92%8c%e5%88%86%e8%a7%a3%e6%80%9d%e8%80%83"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2facpj1otkbul%2f&is_video=false&description=React%20%e7%bb%84%e4%bb%b6%e8%ae%be%e8%ae%a1%e5%92%8c%e5%88%86%e8%a7%a3%e6%80%9d%e8%80%83"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=React%20%e7%bb%84%e4%bb%b6%e8%ae%be%e8%ae%a1%e5%92%8c%e5%88%86%e8%a7%a3%e6%80%9d%e8%80%83&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2facpj1otkbul%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2facpj1otkbul%2f&title=React%20%e7%bb%84%e4%bb%b6%e8%ae%be%e8%ae%a1%e5%92%8c%e5%88%86%e8%a7%a3%e6%80%9d%e8%80%83"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2facpj1otkbul%2f&title=React%20%e7%bb%84%e4%bb%b6%e8%ae%be%e8%ae%a1%e5%92%8c%e5%88%86%e8%a7%a3%e6%80%9d%e8%80%83"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2facpj1otkbul%2f&title=React%20%e7%bb%84%e4%bb%b6%e8%ae%be%e8%ae%a1%e5%92%8c%e5%88%86%e8%a7%a3%e6%80%9d%e8%80%83"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2facpj1otkbul%2f&title=React%20%e7%bb%84%e4%bb%b6%e8%ae%be%e8%ae%a1%e5%92%8c%e5%88%86%e8%a7%a3%e6%80%9d%e8%80%83"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">React 组件设计和分解思考</h1><div class="meta"><div class="postdate"><time datetime="2019-01-11" itemprop="datePublished">2019-01-11</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e之前分享过几篇关于React技术栈的文章：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/www.jianshu.com\/p\/49029b49f2b4\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e做出Uber移动网页版还不够 极致性能打造才见真章\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/www.jianshu.com\/p\/7a56ac1de2a8\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e解析Twitter前端架构 学习复杂场景数据设计\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/www.jianshu.com\/p\/83c86dd0802d\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eReact Conf 2017 干货总结1: React \x2b ES next = ♥\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/www.jianshu.com\/p\/cde3cf7e2760\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eReact\x2bRedux打造“NEWS EARLY”单页应用 一个项目理解最前沿技术栈真谛\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/www.jianshu.com\/p\/8e28be0e7ab1\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e一个react\x2bredux工程实例\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e......\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e今天再来同大家讨论 React 组件设计的一个有趣话题：\x3cstrong\x3e分解 React 组件的几种进阶方法。\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3eReact 组件魔力无穷，同时灵活性超强。我们可以在组件的设计上，玩转出很多花样。但是保证组件的\x3ca href=\x22https:\/\/en.wikipedia.org\/wiki\/Single_responsibility_principle\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eSingle responsibility principle: 单一原则\x3c\/a\x3e非常重要，它可以使得我们的组件更简单、更方便维护，更重要的是使得组件更加具有复用性。\x3c\/p\x3e\n\x3cp\x3e但是，如何对一个功能复杂且臃肿的 React 组件进行分解，也许并不是一件简单的事情。本文由浅入深，介绍三个分解 React 组件的方法。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e切割 render() 方法\x3c\/h2\x3e\n\x3cp\x3e这是一个最容易想到的方法：当一个组件渲染了很多元素时，就需要尝试分离这些元素的渲染逻辑。最迅速的方式就是切割 render() 方法为多个 sub-render 方法。\x3c\/p\x3e\n\x3cp\x3e看下面的例子会更加直观：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Panel extends React.Component {\n  renderHeading() {\n    \/\/ ...\n  }\n\n  renderBody() {\n    \/\/ ...\n  }\n\n  render() {\n    return (\n      \x3cdiv\x3e\n        {this.renderHeading()}\n        {this.renderBody()}\n      \x3c\/div\x3e\n    );\n  }\n  \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePanel\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  renderHeading() {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n  }\n\n  renderBody() {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n  }\n\n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x26lt;div\x26gt;\n        {\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.renderHeading()}\n        {\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.renderBody()}\n      \x26lt;\/div\x26gt;\n    );\n  }\n  \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e细心的读者很快就能发现，\x3cstrong\x3e其实这并没有分解组件本身，\x3c\/strong\x3e该 Panel 组件仍然保持有原先的 state, props, 以及 class methods。\x3c\/p\x3e\n\x3cp\x3e如何真正地做到减少复杂度呢？我们需要创建一些子组件。此时，采用最新版 React 支持并推荐的函数式组件／无状态组件一定会是一个很好的尝试：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const PanelHeader = (props) =\x3e (\n  \/\/ ...\n);\n\nconst PanelBody = (props) =\x3e (\n  \/\/ ...\n);\n\nclass Panel extends React.Component {\n  render() {\n    return (\n      \x3cdiv\x3e\n        \/\/ Nice and explicit about which props are used\n        \x3cPanelHeader title={this.props.title}\/\x3e\n        \x3cPanelBody content={this.props.content}\/\x3e\n      \x3c\/div\x3e\n    );\n   }\n }\n \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3econst \x3cspan class=\x22hljs-type\x22\x3ePanelHeader\x3c\/span\x3e = (props) =\x26gt; (\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n);\n\nconst \x3cspan class=\x22hljs-type\x22\x3ePanelBody\x3c\/span\x3e = (props) =\x26gt; (\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n);\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePanel\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x26lt;div\x26gt;\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Nice and explicit about which props are used\x3c\/span\x3e\n        \x26lt;\x3cspan class=\x22hljs-type\x22\x3ePanelHeader\x3c\/span\x3e title={\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.title}\/\x26gt;\n        \x26lt;\x3cspan class=\x22hljs-type\x22\x3ePanelBody\x3c\/span\x3e content={\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.content}\/\x26gt;\n      \x26lt;\/div\x26gt;\n    );\n   }\n }\n \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e同之前的方式相比，这个微妙的改进是革命性的。我们新建了两个单元组件：PanelHeader 和 PanelBody。这样带来了测试的便利，我们可以直接分离测试不同的组件。同时，借助于 React 新的算法引擎 \x3ca href=\x22https:\/\/github.com\/acdlite\/react-fiber-architecture\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eReact Fiber，\x3c\/a\x3e两个单元组件在渲染的效率上，乐观地预计会有较大幅度的提升。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e模版化组件\x3c\/h2\x3e\n\x3cp\x3e回到问题的起点，为什么一个组件会变的臃肿而复杂呢？其一是渲染元素较多且嵌套，另外就是组件内部变化较多，或者存在多种 configurations 的情况。\x3c\/p\x3e\n\x3cp\x3e此时，我们便可以将组件改造为模版：父组件类似一个模版，只专注于各种 configurations。\x3c\/p\x3e\n\x3cp\x3e还是要举例来说，这样理解起来更加清晰。\x3c\/p\x3e\n\x3cp\x3e比如我们有一个 Comment 组件，这个组件存在多种行为或事件。同时组件所展现的信息根据用户的身份不同而有所变化：用户是否是此 comment 的作者，此 comment 是否被正确保存，各种权限不同等等都会引起这个组件的不同展示行为。这时候，与其把所有的逻辑混淆在一起，也许更好的做法是利用 React 可以传递 React element 的特性，我们将 React element 进行组件间传递，这样就更加像一个模版：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class CommentTemplate extends React.Component {\n  static propTypes = {\n    \/\/ Declare slots as type node\n    metadata: PropTypes.node,\n    actions: PropTypes.node,\n  };\n  \n  render() {\n    return (\n      \x3cdiv\x3e\n        \x3cCommentHeading\x3e\n          \x3cAvatar user={...}\/\x3e\n          \n          \/\/ Slot for metadata\n          \x3cspan\x3e{this.props.metadata}\x3c\/span\x3e\n          \n        \x3c\/CommentHeading\x3e\n    \n        \x3cCommentBody\/\x3e\n        \n        \x3cCommentFooter\x3e\n          \x3cTimestamp time={...}\/\x3e\n          \n          \/\/ Slot for actions\n          \x3cspan\x3e{this.props.actions}\x3c\/span\x3e\n          \n        \x3c\/CommentFooter\x3e\n      \x3c\/div\x3e\n      ...\n      \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs nimrod\x22\x3e\x3ccode\x3eclass \x3cspan class=\x22hljs-type\x22\x3eCommentTemplate\x3c\/span\x3e extends \x3cspan class=\x22hljs-type\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-type\x22\x3eComponent\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3estatic\x3c\/span\x3e propTypes = {\n    \/\/ \x3cspan class=\x22hljs-type\x22\x3eDeclare\x3c\/span\x3e slots \x3cspan class=\x22hljs-keyword\x22\x3eas\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e node\n    metadata: \x3cspan class=\x22hljs-type\x22\x3ePropTypes\x3c\/span\x3e.node,\n    actions: \x3cspan class=\x22hljs-type\x22\x3ePropTypes\x3c\/span\x3e.node,\n  };\n  \n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x26lt;\x3cspan class=\x22hljs-keyword\x22\x3ediv\x3c\/span\x3e\x26gt;\n        \x26lt;\x3cspan class=\x22hljs-type\x22\x3eCommentHeading\x3c\/span\x3e\x26gt;\n          \x26lt;\x3cspan class=\x22hljs-type\x22\x3eAvatar\x3c\/span\x3e user=\x3cspan class=\x22hljs-meta\x22\x3e{...}\x3c\/span\x3e\/\x26gt;\n          \n          \/\/ \x3cspan class=\x22hljs-type\x22\x3eSlot\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e metadata\n          \x26lt;span\x26gt;{this.props.metadata}\x26lt;\/span\x26gt;\n          \n        \x26lt;\/\x3cspan class=\x22hljs-type\x22\x3eCommentHeading\x3c\/span\x3e\x26gt;\n    \n        \x26lt;\x3cspan class=\x22hljs-type\x22\x3eCommentBody\x3c\/span\x3e\/\x26gt;\n        \n        \x26lt;\x3cspan class=\x22hljs-type\x22\x3eCommentFooter\x3c\/span\x3e\x26gt;\n          \x26lt;\x3cspan class=\x22hljs-type\x22\x3eTimestamp\x3c\/span\x3e time=\x3cspan class=\x22hljs-meta\x22\x3e{...}\x3c\/span\x3e\/\x26gt;\n          \n          \/\/ \x3cspan class=\x22hljs-type\x22\x3eSlot\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e actions\n          \x26lt;span\x26gt;{this.props.actions}\x26lt;\/span\x26gt;\n          \n        \x26lt;\/\x3cspan class=\x22hljs-type\x22\x3eCommentFooter\x3c\/span\x3e\x26gt;\n      \x26lt;\/\x3cspan class=\x22hljs-keyword\x22\x3ediv\x3c\/span\x3e\x26gt;\n      ...\n      \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e此时，我们真正的 Comment 组件组织为：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Comment extends React.Component {\n  render() {\n    const metadata = this.props.publishTime ?\n      \x3cPublishTime time={this.props.publishTime} \/\x3e :\n      \x3cspan\x3eSaving...\x3c\/span\x3e;\n    \n    const actions = [];\n    if (this.props.isSignedIn) {\n      actions.push(\x3cLikeAction \/\x3e);\n      actions.push(\x3cReplyAction \/\x3e);\n    }\n    if (this.props.isAuthor) {\n      actions.push(\x3cDeleteAction \/\x3e);\n    }\n    \n    return \x3cCommentTemplate metadata={metadata} actions={actions} \/\x3e;\n  }\n  \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComment\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  render() {\n    const metadata = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.publishTime ?\n      \x26lt;\x3cspan class=\x22hljs-type\x22\x3ePublishTime\x3c\/span\x3e time={\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.publishTime} \/\x26gt; :\n      \x26lt;span\x26gt;\x3cspan class=\x22hljs-type\x22\x3eSaving\x3c\/span\x3e...\x26lt;\/span\x26gt;;\n    \n    const actions = [];\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.isSignedIn) {\n      actions.push(\x26lt;\x3cspan class=\x22hljs-type\x22\x3eLikeAction\x3c\/span\x3e \/\x26gt;);\n      actions.push(\x26lt;\x3cspan class=\x22hljs-type\x22\x3eReplyAction\x3c\/span\x3e \/\x26gt;);\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.isAuthor) {\n      actions.push(\x26lt;\x3cspan class=\x22hljs-type\x22\x3eDeleteAction\x3c\/span\x3e \/\x26gt;);\n    }\n    \n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x26lt;\x3cspan class=\x22hljs-type\x22\x3eCommentTemplate\x3c\/span\x3e metadata={metadata} actions={actions} \/\x26gt;;\n  }\n  \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3emetadata 和 actions 其实就是在特定情况下需要渲染的 React element。\x3c\/p\x3e\n\x3cp\x3e比如，如果 this.props.publishTime 存在，metadata 就是 \x26lt;PublishTime time={this.props.publishTime} \/\x26gt;；反正则为 \x26lt;span\x26gt;Saving...\x26lt;\/span\x26gt;。\x3c\/p\x3e\n\x3cp\x3e如果用户已经登陆，则需要渲染（即actions值为） \x26lt;LikeAction \/\x26gt; 和 \x26lt;ReplyAction \/\x26gt;，如果是作者本身，需要渲染的内容就要加入 \x26lt;DeleteAction \/\x26gt;。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e高阶组件\x3c\/h2\x3e\n\x3cp\x3e在实际开发当中，组件经常会被其他需求所污染。\x3c\/p\x3e\n\x3cp\x3e比如，我们想统计页面中所有链接的点击信息。在链接点击时，发送统计请求，同时包含此页面 document 的 id 值。常见的做法是在 Document 组件的生命周期函数 componentDidMount 和 componentWillUnmount 增加代码逻辑：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Document extends React.Component {\n  componentDidMount() {\n    ReactDOM.findDOMNode(this).addEventListener(\x27click\x27, this.onClick);\n  }\n  \n  componentWillUnmount() {\n    ReactDOM.findDOMNode(this).removeEventListener(\x27click\x27, this.onClick);\n  }\n  \n  onClick = (e) =\x3e {\n    if (e.target.tagName === \x27A\x27) { \/\/ Naive check for \x3ca\x3e elements\n      sendAnalytics(\x27link clicked\x27, {\n        documentId: this.props.documentId \/\/ Specific information to be sent\n      });\n    }\n  };\n  \n  render() {\n    \/\/ ...\n    \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eDocument\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  componentDidMount() {\n    \x3cspan class=\x22hljs-type\x22\x3eReactDOM\x3c\/span\x3e.findDOMNode(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e).addEventListener(\x3cspan class=\x22hljs-symbol\x22\x3e\x27clic\x3c\/span\x3ek\x27, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.onClick);\n  }\n  \n  componentWillUnmount() {\n    \x3cspan class=\x22hljs-type\x22\x3eReactDOM\x3c\/span\x3e.findDOMNode(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e).removeEventListener(\x3cspan class=\x22hljs-symbol\x22\x3e\x27clic\x3c\/span\x3ek\x27, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.onClick);\n  }\n  \n  onClick = (e) =\x26gt; {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (e.target.tagName === \x27\x3cspan class=\x22hljs-type\x22\x3eA\x3c\/span\x3e\x27) { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Naive check for \x26lt;a\x26gt; elements\x3c\/span\x3e\n      sendAnalytics(\x3cspan class=\x22hljs-symbol\x22\x3e\x27link\x3c\/span\x3e clicked\x27, {\n        documentId: \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.documentId \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Specific information to be sent\x3c\/span\x3e\n      });\n    }\n  };\n  \n  render() {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n    \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这么做的几个问题在于：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e相关组件 Document 除了自身的主要逻辑：显示主页面之外，多了其他统计逻辑；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e如果 Document 组件的生命周期函数中，还存在其他逻辑，那么这个组件就会变的更加含糊不合理；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e统计逻辑代码无法复用；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e组件重构、维护都会变的更加困难。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e为了解决这个问题，我们提出了高阶组件这个概念：\x3ca href=\x22https:\/\/facebook.github.io\/react\/docs\/higher-order-components.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e higher-order components (HOCs)\x3c\/a\x3e。不去晦涩地解释这个名词，我们来直接看看使用高阶组件如何来重构上面的代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function withLinkAnalytics(mapPropsToData, WrappedComponent) {\n  class LinkAnalyticsWrapper extends React.Component {\n    componentDidMount() {\n      ReactDOM.findDOMNode(this).addEventListener(\x27click\x27, this.onClick);\n    }\n\n    componentWillUnmount() {\n      ReactDOM.findDOMNode(this).removeEventListener(\x27click\x27, this.onClick);\n    }\n\n    onClick = (e) =\x3e {\n      if (e.target.tagName === \x27A\x27) { \/\/ Naive check for \x3ca\x3e elements\n        const data = mapPropsToData ? mapPropsToData(this.props) : {};\n        sendAnalytics(\x27link clicked\x27, data);\n      }\n    };\n    \n    render() {\n      \/\/ Simply render the WrappedComponent with all props\n      return \x3cWrappedComponent {...this.props} \/\x3e;\n    }\n  }\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3efunction withLinkAnalytics(mapPropsToData, \x3cspan class=\x22hljs-type\x22\x3eWrappedComponent\x3c\/span\x3e) {\n  \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eLinkAnalyticsWrapper\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n    componentDidMount() {\n      \x3cspan class=\x22hljs-type\x22\x3eReactDOM\x3c\/span\x3e.findDOMNode(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e).addEventListener(\x3cspan class=\x22hljs-symbol\x22\x3e\x27clic\x3c\/span\x3ek\x27, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.onClick);\n    }\n\n    componentWillUnmount() {\n      \x3cspan class=\x22hljs-type\x22\x3eReactDOM\x3c\/span\x3e.findDOMNode(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e).removeEventListener(\x3cspan class=\x22hljs-symbol\x22\x3e\x27clic\x3c\/span\x3ek\x27, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.onClick);\n    }\n\n    onClick = (e) =\x26gt; {\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (e.target.tagName === \x27\x3cspan class=\x22hljs-type\x22\x3eA\x3c\/span\x3e\x27) { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Naive check for \x26lt;a\x26gt; elements\x3c\/span\x3e\n        const data = mapPropsToData ? mapPropsToData(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props) : {};\n        sendAnalytics(\x3cspan class=\x22hljs-symbol\x22\x3e\x27link\x3c\/span\x3e clicked\x27, data);\n      }\n    };\n    \n    render() {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Simply render the WrappedComponent with all props\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x26lt;\x3cspan class=\x22hljs-type\x22\x3eWrappedComponent\x3c\/span\x3e {...\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props} \/\x26gt;;\n    }\n  }\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e需要注意的是，withLinkAnalytics 函数并不会去改变 WrappedComponent 组件本身，更不会去改变 WrappedComponent 组件的行为。而是返回了一个被包裹的新组件。实际用法为：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Document extends React.Component {\n  render() {\n    \/\/ ...\n  }\n}\n\nexport default withLinkAnalytics((props) =\x3e ({\n  documentId: props.documentId\n}), Document);\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eDocument\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  render() {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n  }\n}\n\nexport \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e withLinkAnalytics((props) =\x26gt; ({\n  documentId: props.documentId\n}), \x3cspan class=\x22hljs-type\x22\x3eDocument\x3c\/span\x3e);\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样一来，Document 组件仍然只需关心自己该关心的部分，而 withLinkAnalytics 赋予了复用统计逻辑的能力。\x3c\/p\x3e\n\x3cp\x3e高阶组件的存在，完美展示了 React 天生的复合（compositional）能力，在 React 社区当中，react-redux，styled-components，react-intl 等都普遍采用了这个方式。值得一提的是，\x3ca href=\x22https:\/\/github.com\/acdlite\/recompose\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3erecompose\x3c\/a\x3e 类库又利用高阶组件，并发扬光大，做到了“脑洞大开”的事情。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e总结\x3c\/h2\x3e\n\x3cp\x3eReact 及其周边社区的崛起，让函数式编程风靡一时，受到追捧。其中关于 decomposing 和 composing 的思想，我认为非常值得学习。同时，对开发设计的一个建议是，不要犹豫将你的组件拆分的更小、更单一，因为这样能换来强健和复用。\x3c\/p\x3e\n\x3cp\x3e本文意译了\x3ca href=\x22https:\/\/medium.com\/dailyjs\/techniques-for-decomposing-react-components-e8a1081ef5da\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eDavid Tang的：Techniques for decomposing React components一文。\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3eHappy Coding!\x3c\/p\x3e\n\x3cp\x3ePS: 作者\x3ca href=\x22https:\/\/github.com\/HOUCe\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eGithub仓库\x3c\/a\x3e，欢迎通过代码各种形式交流。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>React 组件设计和分解思考</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000009952681">https://segmentfault.com/a/1190000009952681</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/acpj1otkbul/" target="_blank">https://alili.tech/archive/acpj1otkbul/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>