<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="从 Node 到 Go：一个粗略的比较"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>从 Node 到 Go：一个粗略的比较 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/dmbc9wijdz9/",
				"appid": "1613049289050283", 
				"title": "从 Node 到 Go：一个粗略的比较 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-22T02:30:07"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/h2biv5qw44l/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/t9ppv5ukm8h/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fdmbc9wijdz9%2f&text=%e4%bb%8e%20Node%20%e5%88%b0%20Go%ef%bc%9a%e4%b8%80%e4%b8%aa%e7%b2%97%e7%95%a5%e7%9a%84%e6%af%94%e8%be%83"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fdmbc9wijdz9%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fdmbc9wijdz9%2f&text=%e4%bb%8e%20Node%20%e5%88%b0%20Go%ef%bc%9a%e4%b8%80%e4%b8%aa%e7%b2%97%e7%95%a5%e7%9a%84%e6%af%94%e8%be%83"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fdmbc9wijdz9%2f&title=%e4%bb%8e%20Node%20%e5%88%b0%20Go%ef%bc%9a%e4%b8%80%e4%b8%aa%e7%b2%97%e7%95%a5%e7%9a%84%e6%af%94%e8%be%83"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fdmbc9wijdz9%2f&is_video=false&description=%e4%bb%8e%20Node%20%e5%88%b0%20Go%ef%bc%9a%e4%b8%80%e4%b8%aa%e7%b2%97%e7%95%a5%e7%9a%84%e6%af%94%e8%be%83"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e4%bb%8e%20Node%20%e5%88%b0%20Go%ef%bc%9a%e4%b8%80%e4%b8%aa%e7%b2%97%e7%95%a5%e7%9a%84%e6%af%94%e8%be%83&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fdmbc9wijdz9%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fdmbc9wijdz9%2f&title=%e4%bb%8e%20Node%20%e5%88%b0%20Go%ef%bc%9a%e4%b8%80%e4%b8%aa%e7%b2%97%e7%95%a5%e7%9a%84%e6%af%94%e8%be%83"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fdmbc9wijdz9%2f&title=%e4%bb%8e%20Node%20%e5%88%b0%20Go%ef%bc%9a%e4%b8%80%e4%b8%aa%e7%b2%97%e7%95%a5%e7%9a%84%e6%af%94%e8%be%83"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fdmbc9wijdz9%2f&title=%e4%bb%8e%20Node%20%e5%88%b0%20Go%ef%bc%9a%e4%b8%80%e4%b8%aa%e7%b2%97%e7%95%a5%e7%9a%84%e6%af%94%e8%be%83"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fdmbc9wijdz9%2f&title=%e4%bb%8e%20Node%20%e5%88%b0%20Go%ef%bc%9a%e4%b8%80%e4%b8%aa%e7%b2%97%e7%95%a5%e7%9a%84%e6%af%94%e8%be%83"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">从 Node 到 Go：一个粗略的比较</h1><div class="meta"><div class="postdate"><time datetime="2019-01-22" itemprop="datePublished">2019-01-22</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n            \x3ch1\x3e\x3ca href=\x22#从-node-到-go一个粗略的比较\x22\x3e\x3c\/a\x3e从 Node 到 Go：一个粗略的比较\x3c\/h1\x3e\n\x3cp\x3e在 XO 公司，我们最初使用 Node 和 Ruby 构建相互连接的服务系统。我们享受 Node 带来的明显性能优势，以及可以访问已有的大型软件包仓库。我们也可以轻松地在公司内部发布并复用已有的插件和模块。极大地提高了开发效率，使得我们可以快速编写出可拓展的和可靠的应用。而且，庞大的 Node 社区使我们的工程师向开源软件贡献更加容易（比如 \x3ca href=\x22https:\/\/medium.com\/xo-tech\/bunnybus-building-a-data-transit-system-b9647f6283e5#.l64fdvfys\x22\x3eBunnyBus\x3c\/a\x3e 和 \x3ca href=\x22https:\/\/medium.com\/xo-tech\/introducing-felicity-7b6d0b734ce#.hmloiiyx8\x22\x3eFelicity\x3c\/a\x3e）。\x3c\/p\x3e\n\x3cp\x3e虽然我在大学时期和刚刚工作的一些时间在使用更严谨的编译语言，比如 C\x2b\x2b 和 C#，而后来我开始使用 JavaScript。我很喜欢它的自由和灵活，但是我最近开始怀念静态和结构化的语言，因为当时有一个同事让我对 Go 语言产生了兴趣。\x3c\/p\x3e\n\x3cp\x3e我从写 JavaScript 到写 Go，我发现两种语言有很多相似之处。两者学习起来都很快并且易于上手，都具有充满表现力的语法，并且在开发者社区中都有很多工作机会。没有完美的编程语言，所以你应该总是选择一个适合手头项目的语言。在这篇文章中，我将要说明这两种语言深层次上的关键区别，希望能鼓励没有用过 Go 语言的用户可以有机会使用 Go 。\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22#大体上的差异\x22\x3e\x3c\/a\x3e大体上的差异\x3c\/h3\x3e\n\x3cp\x3e在深入细节之前，我们应该先了解一下两种语言之间的重要区别。\x3c\/p\x3e\n\x3cp\x3eGo，或称 Golang，是 Google 在 2007 年创建的自由开源编程语言。它以快速和简单为设计目标。Go 被直接编译成机器码，这就是它速度的来源。使用编译语言调试是相当容易的，因为你可以在早期捕获大量错误。Go 也是一种强类型的语言，它有助于数据完整，并可以在编译时查找类型错误。\x3c\/p\x3e\n\x3cp\x3e另一方面，JavaScript 是一种弱类型语言。除了忽略验证数据的类型和真值判断陷阱所带来的额外负担之外，使用弱类型语言也有自己的好处。比起使用接口interfaces和范型generics，柯里化currying和可变的形参个数flexible arity让函数变得更加灵活。JavaScript 在运行时进行解释，这可能导致错误处理和调试的问题。Node 是一款基于 Google V8 虚拟机的 JavaScript 运行库，这使它成为一个轻量和快速的 Web 开发平台。\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22#语法\x22\x3e\x3c\/a\x3e语法\x3c\/h3\x3e\n\x3cp\x3e作为原来的 JavaScript 开发者，Go 简单和直观的语法很吸引我。由于两种语言的语法可以说都是从 C 语言演变而来的，所以它们的语法有很多相同之处。Go 被普遍认为是一种“容易学习的语言”。那是因为它的对开发者友好的工具、精简的语法和固守惯例（LCTT 译注：惯例优先）。\x3c\/p\x3e\n\x3cp\x3eGo 包含大量有助于简化开发的内置特性。你可以用标准 Go 构建工具把你的程序用 \x3ccode\x3ego build\x3c\/code\x3e 命令编译成二进制可执行文件。使用内置的测试套件进行测试只需要运行 \x3ccode\x3ego test\x3c\/code\x3e 即可。 诸如原生支持的并发等特性甚至在语言层面上提供。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/golang.org\/doc\/faq\x22\x3eGoogle 的 Go 开发者\x3c\/a\x3e认为，现在的编程太复杂了，太多的“记账一样，重复劳动和文书工作”。这就是为什么 Go 的语法被设计得如此简单和干净，以减少混乱、提高效率和增强可读性。它还鼓励开发人员编写明确的、易于理解的代码。Go 只有 \x3ca href=\x22https:\/\/golang.org\/ref\/spec#Keywords\x22\x3e25 个保留关键字\x3c\/a\x3e和一种循环（\x3ccode\x3efor\x3c\/code\x3e 循环），而不像 JavaScript 有 \x3ca href=\x22https:\/\/www.w3schools.com\/js\/js_reserved.asp\x22\x3e大约 84 个关键字\x3c\/a\x3e（包括保留关键字字、对象、属性和方法）。\x3c\/p\x3e\n\x3cp\x3e为了说明语法的一些差异和相似之处，我们来看几个例子：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e标点符号： Go 去除了所有多余的符号以提高效率和可读性。尽管 JavaScript 中需要符号的地方也不多（参见： \x3ca href=\x22https:\/\/en.wikipedia.org\/wiki\/Lisp_%28programming_language%29\x22\x3eLisp\x3c\/a\x3e），而且经常是可选的，但我更加喜欢 Go 的简单。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\/\/ JavaScript 的逗号和分号 for (var i = 0; i \x26lt; 10; i\x2b\x2b) { console.log(i); }\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs mipsasm\x22\x3e\n    *\x3cspan class=\x22hljs-keyword\x22\x3eJavaScript \x3c\/span\x3e中的标点*\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e\/\/ Go 使用最少数量标点\nfor i := 0; i \x26lt; 10; i\x2b\x2b {\n    fmt.Println(i)\n}\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs\x22\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e\x3cem\x3eGo 中的标点\x3c\/em\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs markdown\x22\x3e\n\x3cspan class=\x22hljs-bullet\x22\x3e*   \x3c\/span\x3e赋值：由于 Go 是强类型语言，所以你在初始化变量时可以使用 \x3cspan class=\x22hljs-code\x22\x3e`:=`\x3c\/span\x3e 操作符来进行类型推断，以避免[\x3cspan class=\x22hljs-string\x22\x3e重复声明\x3c\/span\x3e](\x3cspan class=\x22hljs-link\x22\x3ehttps:\/\/golang.org\/doc\/faq#principles\x3c\/span\x3e)，而 JavaScript 则在运行时声明类型。\n\n\n\/\/ JavaScript 赋值 var foo = \x22bar\x22;\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs clean\x22\x3e*JavaScript 中的赋值*\n\n```\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e\/\/ Go 的赋值\nvar foo string \/\/不使用类型推导\nfoo = \x22bar\x22\nfoo := \x22bar\x22 \/\/使用类型推导\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs\x22\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e\x3cem\x3eGo 的赋值\x3c\/em\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs coffeescript\x22\x3e\n*   导出：在 JavaScript 中，你必须从某个模块中显式地导出。 在 Go 中，任何大写的函数将被默认导出。\n\n\nconst Bar = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {}; \x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = { Bar }\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs clean\x22\x3e*JavaScript 中的导出*\n\n```\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e\/\/ Go 中的导出\npackage foo \/\/ 定义包名\nfunc Bar (s string) string {\n    \/\/ Bar 将被导出\n}\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs\x22\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e\x3cem\x3eGo 中的导出\x3c\/em\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs clean\x22\x3e\n*   导入：在 JavaScript 中 `required` 库是导入依赖项和模块所必需的，而 Go 则利用原生的 `\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e` 关键字通过包的路径导入模块。另一个区别是，与 Node 的中央 NPM 存储库不同，Go 使用 URL 作为路径来导入非标准库的包，这是为了从包的源码仓库直接克隆依赖。\n\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Javascript 的导入 var foo = require(\x27foo\x27); foo.bar();\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs clean\x22\x3e*JavaScript 的导入*\n\n```\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e\/\/ Go 的导入\nimport (\n    \x22fmt\x22 \/\/ Go 的标准库部分\n    \x22github.com\/foo\/foo\x22 \/\/ 直接从仓库导入\n)\nfoo.Bar()\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs\x22\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e\x3cem\x3eGo 的导入\x3c\/em\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs ada\x22\x3e\n*   返回值：通过 Go 的多值返回特性可以优雅地传递和处理返回值和错误，并且通过传递引用减少了不正确的值传递。在 JavaScript 中需要通过一个对象或者数组来返回多个值。\n\n\n\/\/ Javascript - 返回多值 \x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e() { \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3e{a:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, b: \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e}; } const { a, b } = foo();\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs clean\x22\x3e*JavaScript 的返回*\n\n```\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e\/\/ Go - 返回多值\nfunc foo() (int, int) {\n    return 1, 2\n}\na, b := foo()\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs\x22\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e\x3cem\x3eGo 的返回\x3c\/em\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs awk\x22\x3e\n*   错误处理：Go 推荐在错误出现的地方捕获它们，而不是像 Node 一样在回调中让错误冒泡。\n\n\n\x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e Node 的错误处理 foo(\x3cspan class=\x22hljs-string\x22\x3e\x27bar\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(err, data) { \x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e 处理错误 }\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs clean\x22\x3e*JavaScript 的错误处理*\n\n```\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e\/\/Go 的错误处理\nfoo, err := bar()\nif err != nil {\n    \/\/ 用 defer、 panic、 recover 或 log.fatal 等等处理错误.\n}\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs\x22\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e\x3cem\x3eGo  的错误处理\x3c\/em\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs actionscript\x22\x3e\n*   可变参数函数：Go 和 JavaScript 的函数都支持传入不定数量的参数。\n\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(\x3cspan class=\x22hljs-rest_arg\x22\x3e...args\x3c\/span\x3e)\x3c\/span\x3e \x3c\/span\x3e{ console.log(args.length); } foo(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 0 foo(1, 2, 3); \/\/ 3\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs clean\x22\x3e*JavaScript 中的可变参数函数*\n\n```\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3efunc foo (args ...int) {\n    fmt.Println(len(args))\n}\nfunc main() {\n    foo() \/\/ 0\n    foo(1,2,3) \/\/ 3\n}\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs\x22\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e\x3cem\x3eGo 中的可变参数函数\x3c\/em\x3e\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs markdown\x22\x3e\n\x3cspan class=\x22hljs-section\x22\x3e### [](#社区)社区\x3c\/span\x3e\n\n当比较 Go 和 Node 提供的编程范式哪种更方便时，两边都有不同的拥护者。Node 在软件包数量和社区的大小上完全胜过了 Go。Node 包管理器（NPM），是世界上最大的软件仓库，拥有[\x3cspan class=\x22hljs-string\x22\x3e超过 410,000 个软件包，每天以 555 个新软件包的惊人速度增长\x3c\/span\x3e](\x3cspan class=\x22hljs-link\x22\x3ehttp:\/\/www.modulecounts.com\/\x3c\/span\x3e)。这个数字可能看起来令人吃惊（确实是），但是需要注意的是，这些包许多是重复的，且质量不足以用在生产环境。 相比之下，Go 大约有 13 万个包。\n\n[\x3cspan class=\x22hljs-string\x22\x3e![\x3c\/span\x3e](\x3cspan class=\x22hljs-link\x22\x3ehttps:\/\/camo.githubusercontent.com\/a6ec6ab081114541a68ee04a0939a9c668f8c96b\/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f302a306f556e56564b7875557276564733462e\x3c\/span\x3e)](\x3cspan class=\x22hljs-link\x22\x3ehttps:\/\/camo.githubusercontent.com\/a6ec6ab081114541a68ee04a0939a9c668f8c96b\/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f302a306f556e56564b7875557276564733462e\x3c\/span\x3e)\n\n\x3cspan class=\x22hljs-emphasis\x22\x3e_Node 和 Go 包的数量_\x3c\/span\x3e\n\n尽管 Node 和 Go 岁数相仿，但 JavaScript 使用更加广泛，并拥有巨大的开发者和开源社区。因为 Node 是为所有人开发的，并在开始的时候就带有一个强壮的包管理器，而 Go 是特地为 Google 开发的。下面的[\x3cspan class=\x22hljs-string\x22\x3eSpectrum 排行榜\x3c\/span\x3e](\x3cspan class=\x22hljs-link\x22\x3ehttp:\/\/spectrum.ieee.org\/static\/interactive-the-top-programming-languages-2016\x3c\/span\x3e)显示了当前流行的的顶尖 Web 开发语言。\n\n[\x3cspan class=\x22hljs-string\x22\x3e![\x3c\/span\x3e](\x3cspan class=\x22hljs-link\x22\x3ehttps:\/\/camo.githubusercontent.com\/d812496b1c3e1f37265de6960515aa1a2ecc9e02\/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f302a6f32536d6e556f36377865614662595a2e\x3c\/span\x3e)](\x3cspan class=\x22hljs-link\x22\x3ehttps:\/\/camo.githubusercontent.com\/d812496b1c3e1f37265de6960515aa1a2ecc9e02\/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f302a6f32536d6e556f36377865614662595a2e\x3c\/span\x3e)\n\n\x3cspan class=\x22hljs-emphasis\x22\x3e_Web 开发语言排行榜前 7 名_\x3c\/span\x3e\n\nJavaScript 的受欢迎程度近年来似乎保持相对稳定，而 [\x3cspan class=\x22hljs-string\x22\x3eGo 一直在保持上升趋势\x3c\/span\x3e](\x3cspan class=\x22hljs-link\x22\x3ehttp:\/\/www.tiobe.com\/tiobe-index\/\x3c\/span\x3e)。\n\n[\x3cspan class=\x22hljs-string\x22\x3e![\x3c\/span\x3e](\x3cspan class=\x22hljs-link\x22\x3ehttps:\/\/camo.githubusercontent.com\/c718290606b012f8aefa378901580690145c8595\/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f302a7a583559673377684c637a705369665f2e\x3c\/span\x3e)](\x3cspan class=\x22hljs-link\x22\x3ehttps:\/\/camo.githubusercontent.com\/c718290606b012f8aefa378901580690145c8595\/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f302a7a583559673377684c637a705369665f2e\x3c\/span\x3e)\n\n\x3cspan class=\x22hljs-emphasis\x22\x3e_编程语言趋势_\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-section\x22\x3e### [](#性能)性能\x3c\/span\x3e\n\n如果你的主要关注点是速度呢？当今似乎人们比以前更重视性能的优化。用户不喜欢等待信息。 事实上，如果网页的加载时间超过 3 秒，[\x3cspan class=\x22hljs-string\x22\x3e40％ 的用户会放弃访问您的网站\x3c\/span\x3e](\x3cspan class=\x22hljs-link\x22\x3ehttps:\/\/hostingfacts.com\/internet-facts-stats-2016\/\x3c\/span\x3e)。\n\n因为它的非阻塞异步 I\/O，Node 经常被认为是高性能的语言。另外，正如我之前提到的，Node 运行在针对动态语言进行了优化的 Google V8 引擎上。而 Go 的设计也考虑到速度。[\x3cspan class=\x22hljs-string\x22\x3eGoogle 的开发者们\x3c\/span\x3e](\x3cspan class=\x22hljs-link\x22\x3ehttps:\/\/golang.org\/doc\/faq\x3c\/span\x3e)通过建立了一个“充满表现力而轻量级的类型系统；并发和垃圾回收机制；强制地指定依赖版本等等”，达成了这一目标。\n\n我运行了一些测试来比较 Node 和 Go 之间的性能。这些测试注重于语言提供的初级能力。如果我准备测试例如 HTTP 请求或者 CPU 密集型运算，我会使用 Go 语言级别的并发工具（goroutines\/channels）。但是我更注重于各个语言提供的基本特性（参见 [\x3cspan class=\x22hljs-string\x22\x3e三种并发方法\x3c\/span\x3e](\x3cspan class=\x22hljs-link\x22\x3ehttps:\/\/medium.com\/xo-tech\/concurrency-in-three-flavors-51ed709876fb#.khvqrttxa\x3c\/span\x3e) 了解关于 goroutines 和 channels 的更多知识）。\n\n我在基准测试中也加入了 Python，所以无论如何我们对 Node 和 Go 的结果都很满意。\n\n\x3cspan class=\x22hljs-section\x22\x3e#### [](#循环算术)循环\/算术\x3c\/span\x3e\n\n迭代十亿项并把它们相加：\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3evar r = 0;\nfor (var c = 0; c \x26lt; 1000000000; c\x2b\x2b) {\n    r \x2b= c;\n}\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs nginx\x22\x3e\n\x3cspan class=\x22hljs-attribute\x22\x3e_Node_\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3epackage main\nfunc main() {\n    var r int\n    for c := 0; c \x26lt; 1000000000; c\x2b\x2b {\n        r \x2b= c\n    }\n}\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs nginx\x22\x3e\n\x3cspan class=\x22hljs-attribute\x22\x3e_Go_\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3esum(xrange(1000000000))\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs markdown\x22\x3e\n\x3cspan class=\x22hljs-emphasis\x22\x3e_Python_\x3c\/span\x3e\n\n[\x3cspan class=\x22hljs-string\x22\x3e![\x3c\/span\x3e](\x3cspan class=\x22hljs-link\x22\x3ehttps:\/\/camo.githubusercontent.com\/c6a452ff225288a0dafbb910068599c24364ca03\/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313630302f312a35753051396e6d706b637370326c747a6d4c4f3643512e706e67\x3c\/span\x3e)](\x3cspan class=\x22hljs-link\x22\x3ehttps:\/\/camo.githubusercontent.com\/c6a452ff225288a0dafbb910068599c24364ca03\/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313630302f312a35753051396e6d706b637370326c747a6d4c4f3643512e706e67\x3c\/span\x3e)\n\n\x3cspan class=\x22hljs-emphasis\x22\x3e_结果_\x3c\/span\x3e\n\n这里的输家无疑是 Python，花了超过 7 秒的 CPU 时间。而 Node 和 Go 都相当高效，分别用了 900 ms 和 408 ms。\n\n\x3cspan class=\x22hljs-emphasis\x22\x3e_修正：由于一些评论表明 Python 的性能还可以提高。我更新了结果来反映这些变化。同时，使用 PyPy 大大地提高了性能。当使用 Python 3.6.1 和 PyPy 3.5.7 运行时，性能提升到 1.234 秒，但仍然不及 Go 和 Node 。_\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-section\x22\x3e#### [](#io)I\/O\x3c\/span\x3e\n\n遍历一百万个数字并将其写入一个文件。\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3evar fs = require(\x27fs\x27);\nvar wstream = fs.createWriteStream(\x27node\x27);\x3c\/p\x3e\n\x3cp\x3efor (var c = 0; c \x26lt; 1000000; \x2b\x2bc) {\n  wstream.write(c.toString());\n}\nwstream.end();\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs nginx\x22\x3e\n\x3cspan class=\x22hljs-attribute\x22\x3e_Node_\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3epackage main\x3c\/p\x3e\n\x3cp\x3eimport (\n    \x22bufio\x22\n    \x22os\x22\n    \x22strconv\x22\n)\x3c\/p\x3e\n\x3cp\x3efunc main() {\n    file, _ := os.Create(\x22go\x22)\n    b := bufio.NewWriter(file)\n    for c := 0; c \x26lt; 1000000; c\x2b\x2b {\n        num := strconv.Itoa(c)\n        b.WriteString(num)\n    }\n    file.Close()\n}\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs nginx\x22\x3e\n\x3cspan class=\x22hljs-attribute\x22\x3e_Go_\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3ewith open(\x22python\x22, \x22a\x22) as text_file:\n    for i in range(1000000):\n        text_file.write(str(i))\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs crmsh\x22\x3e\n_Python_\n\n[![](https:\/\/camo.githubusercontent.com\/\x3cspan class=\x22hljs-number\x22\x3e157\x3c\/span\x3ec3c1a4b6c77c2e1d33208d55f701c0fc03b3e\/\x3cspan class=\x22hljs-number\x22\x3e68747470733\x3c\/span\x3ea2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313630302f312a67485a6f575635774959526d5931386568706a6e55512e706e67)](https:\/\/camo.githubusercontent.com\/\x3cspan class=\x22hljs-number\x22\x3e157\x3c\/span\x3ec3c1a4b6c77c2e1d33208d55f701c0fc03b3e\/\x3cspan class=\x22hljs-number\x22\x3e68747470733\x3c\/span\x3ea2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313630302f312a67485a6f575635774959526d5931386568706a6e55512e706e67)\n\n_结果_\n\nPython 以 \x3cspan class=\x22hljs-number\x22\x3e7.82\x3c\/span\x3e 秒再次排名第三。 这次测试中，\x3cspan class=\x22hljs-keyword\x22\x3eNode\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e和 Go\x3c\/span\x3e 之间的差距很大，\x3cspan class=\x22hljs-keyword\x22\x3eNode\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e花费大约 1\x3c\/span\x3e.\x3cspan class=\x22hljs-number\x22\x3e172\x3c\/span\x3e 秒，Go 花费了 \x3cspan class=\x22hljs-number\x22\x3e213\x3c\/span\x3e 毫秒。真正令人印象深刻的是，Go 大部分的处理时间花费在编译上。如果我们将代码编译，以二进制运行，这个 I\/O 测试仅花费 \x3cspan class=\x22hljs-number\x22\x3e78\x3c\/span\x3e 毫秒——要比 \x3cspan class=\x22hljs-keyword\x22\x3eNode\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e快 15\x3c\/span\x3e 倍。\n\n_修正：修改了 Go 代码以实现缓存 I\/O。_\n\n\x3cspan class=\x22hljs-comment\x22\x3e#### [](#冒泡排序)冒泡排序\x3c\/span\x3e\n\n将含有十个元素的数组排序一千万次。\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3efunction bubbleSort(input) {\n    var n = input.length;\n    var swapped = true;\n    while (swapped) {\n        swapped = false;\n        for (var i = 0; i \x26lt; n; i\x2b\x2b) {\n            if (input[i - 1] \x26gt; input [i]) {\n                [input[i], input[i - 1]] = [input[i - 1], input[i]];\n                swapped = true;\n            }\n        }\n    }\n}\x3c\/p\x3e\n\x3cp\x3efor (var c = 0; c \x26lt; 1000000; c\x2b\x2b) {\n    const toBeSorted = [1, 3, 2, 4, 8, 6, 7, 2, 3, 0];\n    bubbleSort(toBeSorted);\n}\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs nginx\x22\x3e\n\x3cspan class=\x22hljs-attribute\x22\x3e_Node_\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3epackage main\x3c\/p\x3e\n\x3cp\x3evar toBeSorted [10]int = [10]int{1, 3, 2, 4, 8, 6, 7, 2, 3, 0}\x3c\/p\x3e\n\x3cp\x3efunc bubbleSort(input [10]int) {\n    n := len(input)\n    swapped := true\n    for swapped {\n        swapped = false\n        for i := 1; i \x26lt; n; i\x2b\x2b {\n            if input[i-1] \x26gt; input[i] {\n                input[i], input[i-1] = input[i-1], input[i]\n                swapped = true\n            }\n        }\n    }\n}\x3c\/p\x3e\n\x3cp\x3efunc main() {\n    for c := 0; c \x26lt; 1000000; c\x2b\x2b {\n        bubbleSort(toBeSorted)\n    }\n}\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs nginx\x22\x3e\n\x3cspan class=\x22hljs-attribute\x22\x3e_Go_\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3edef bubbleSort(input):\n    length = len(input)\n    swapped = True\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs stylus\x22\x3ewhile swapped:\n    swapped = False\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e \x3cspan class=\x22hljs-selector-tag\x22\x3ei\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e range(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,length):\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e \x3cspan class=\x22hljs-selector-tag\x22\x3einput\x3c\/span\x3e[\x3cspan class=\x22hljs-selector-tag\x22\x3ei\x3c\/span\x3e - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e] \x26gt; \x3cspan class=\x22hljs-selector-tag\x22\x3einput\x3c\/span\x3e[i]:\n            \x3cspan class=\x22hljs-selector-tag\x22\x3einput\x3c\/span\x3e[i], \x3cspan class=\x22hljs-selector-tag\x22\x3einput\x3c\/span\x3e[\x3cspan class=\x22hljs-selector-tag\x22\x3ei\x3c\/span\x3e - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e] = \x3cspan class=\x22hljs-selector-tag\x22\x3einput\x3c\/span\x3e[\x3cspan class=\x22hljs-selector-tag\x22\x3ei\x3c\/span\x3e - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e], \x3cspan class=\x22hljs-selector-tag\x22\x3einput\x3c\/span\x3e[i]\n            swapped = True\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3efor i in range(1000000):\n    toBeSorted = [1, 3, 2, 4, 8, 6, 7, 2, 3, 0]\n    bubbleSort(toBeSorted)\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3e`\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cem\x3ePython\x3c\/em\x3e\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/camo.githubusercontent.com\/f453110a18b065b4994cfd23b7eb3c0bafa4e2c7\/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f312a305f322d692d477751306c306e3830704543484555512e706e67\x22\x3e\x3cimg src=\x22\x22 alt=\x22\x22\x3e\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e_结果_\x3c\/p\x3e\n\x3cp\x3e像刚才一样，Python 的表现是最差的，大约花费 15 秒完成了任务。 Go 完成任务的速度是 Node 的 16 倍。\x3c\/p\x3e\n\x3ch4\x3e\x3ca href=\x22#判决\x22\x3e\x3c\/a\x3e判决\x3c\/h4\x3e\n\x3cp\x3eGo 无疑是这三个测试中的赢家，而 Node 大部分表现都很出色。Python 也表现不错。要清楚，性能不是选择编程语言需要考虑的全部内容。如果您的应用不需要处理大量数据，那么 Node 和 Go 之间的性能差异可能是微不足道的。 有关性能的一些其他比较，请参阅以下内容：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/jaxbot.me\/articles\/node-vs-go-2014\x22\x3eNode Vs. Go\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/hashnode.com\/post\/comparison-nodejs-php-c-go-python-and-ruby-cio352ydg000ym253frmfnt70\x22\x3eMultiple Language Performance Test\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/benchmarksgame.alioth.debian.org\/u64q\/compare.php?lang=go\x26amp;amp;amp;amp;amp;amp;amp;amp;amp;amp;amp;amp;lang2=node\x22\x3eBenchmarks Game\x3c\/a\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3\x3e\x3ca href=\x22#结论\x22\x3e\x3c\/a\x3e结论\x3c\/h3\x3e\n\x3cp\x3e这个帖子不是为了证明一种语言比另一种语言更好。由于各种原因，每种编程语言都在软件开发社区中占有一席之地。 我的意图是强调 Go 和 Node 之间的差异，并且促进展示一种新的 Web 开发语言。 在为一个项目选择语言时，有各种因素需要考虑，比如开发人员的熟悉程度、花费和实用性。 我鼓励在决定哪种语言适合您时进行一次彻底的底层分析。\x3c\/p\x3e\n\x3cp\x3e正如我们所看到的，Go 有如下的优点：接近底层语言的性能，简单的语法和相对简单的学习曲线使它成为构建可拓展和安全的 Web 应用的理想选择。随着 Go 的使用率和社区活动的快速增长，它将会成为现代网络开发中的重要角色。话虽如此，我相信如果 Node 被正确地实现，它正在向正确的方向努力，仍然是一种强大而有用的语言。它具有大量的追随者和活跃的社区，使其成为一个简单的平台，可以让 Web 应用在任何时候启动和运行。\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22#资料\x22\x3e\x3c\/a\x3e资料\x3c\/h3\x3e\n\x3cp\x3e如果你对学习 Go 语言感兴趣，可以参阅下面的资源：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/golang.org\/doc\/#learning\x22\x3eGolang 网站\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/github.com\/golang\/go\/wiki\/Learn\x22\x3eGolang Wiki\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/www.reddit.com\/r\/golang\/\x22\x3eGolang Subreddit\x3c\/a\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3chr\x3e\n\x3cp\x3evia: \x3ca href=\x22https:\/\/medium.com\/xo-tech\/from-node-to-go-a-high-level-comparison-56c8b717324a#.byltlz535\x22\x3ehttps:\/\/medium.com\/xo-tech\/from-node-to-go-a-high-level-comparison-56c8b717324a#.byltlz535\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e作者：\x3ca href=\x22https:\/\/medium.com\/@johnstamatakos?source=post_header_lockup\x22\x3eJohn Stamatakos\x3c\/a\x3e 译者：\x3ca href=\x22https:\/\/github.com\/trnhoe\x22\x3etrnhoe\x3c\/a\x3e 校对：\x3ca href=\x22https:\/\/github.com\/wxy\x22\x3ewxy\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e本文由 \x3ca href=\x22https:\/\/github.com\/LCTT\/TranslateProject\x22\x3eLCTT\x3c\/a\x3e 原创编译，\x3ca href=\x22https:\/\/linux.cn\/\x22\x3eLinux中国\x3c\/a\x3e 荣誉推出\x3c\/p\x3e\n\n          \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>从 Node 到 Go：一个粗略的比较</p><h2 id="原文链接">原文链接</h2><p><a href="https://www.zcfy.cc/article/from-node-to-go-a-high-level-comparison">https://www.zcfy.cc/article/from-node-to-go-a-high-level-comparison</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/dmbc9wijdz9/" target="_blank">https://alili.tech/archive/dmbc9wijdz9/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>