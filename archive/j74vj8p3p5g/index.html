<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="vue源码解析－插件入侵机制"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>vue源码解析－插件入侵机制 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/j74vj8p3p5g/",
				"appid": "1613049289050283", 
				"title": "vue源码解析－插件入侵机制 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-12T02:30:24"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/wljwdquo3e/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/wkeos96quta/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fj74vj8p3p5g%2f&text=vue%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90%ef%bc%8d%e6%8f%92%e4%bb%b6%e5%85%a5%e4%be%b5%e6%9c%ba%e5%88%b6"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fj74vj8p3p5g%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fj74vj8p3p5g%2f&text=vue%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90%ef%bc%8d%e6%8f%92%e4%bb%b6%e5%85%a5%e4%be%b5%e6%9c%ba%e5%88%b6"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fj74vj8p3p5g%2f&title=vue%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90%ef%bc%8d%e6%8f%92%e4%bb%b6%e5%85%a5%e4%be%b5%e6%9c%ba%e5%88%b6"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fj74vj8p3p5g%2f&is_video=false&description=vue%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90%ef%bc%8d%e6%8f%92%e4%bb%b6%e5%85%a5%e4%be%b5%e6%9c%ba%e5%88%b6"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=vue%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90%ef%bc%8d%e6%8f%92%e4%bb%b6%e5%85%a5%e4%be%b5%e6%9c%ba%e5%88%b6&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fj74vj8p3p5g%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fj74vj8p3p5g%2f&title=vue%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90%ef%bc%8d%e6%8f%92%e4%bb%b6%e5%85%a5%e4%be%b5%e6%9c%ba%e5%88%b6"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fj74vj8p3p5g%2f&title=vue%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90%ef%bc%8d%e6%8f%92%e4%bb%b6%e5%85%a5%e4%be%b5%e6%9c%ba%e5%88%b6"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fj74vj8p3p5g%2f&title=vue%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90%ef%bc%8d%e6%8f%92%e4%bb%b6%e5%85%a5%e4%be%b5%e6%9c%ba%e5%88%b6"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fj74vj8p3p5g%2f&title=vue%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90%ef%bc%8d%e6%8f%92%e4%bb%b6%e5%85%a5%e4%be%b5%e6%9c%ba%e5%88%b6"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">vue源码解析－插件入侵机制</h1><div class="meta"><div class="postdate"><time datetime="2019-01-12" itemprop="datePublished">2019-01-12</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e插件：聪明的程序员往往希望能更高(tou)效(lan)的完成指定的工作，插件就是按照一定的封装方式，暴露接口。让我们利用这些接口更快捷的实现功能。升职加薪。每个框架都提供了插件的扩展机制。这是框架可扩展性必不可少的一个部分。插件机制越简单。对于框架的生态的发展大有好处。jquery提供了$.fn.extend,angular有对应的依赖注入，module机制。既然vue那么精美，能迅速火起来。插件这部分的可扩展性必须顶级。这里接下来我们看看vue插件的入侵机制。\x3cbr\x3e   说到插件。我们最多使用的一个方法。无非就是 Vue.use(MyPlugin, { someOption: true });\x3cbr\x3e这么说的话，这个方法应该是所有插件入侵vue的起点。没错。那么我们来看看这个方法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Vue.use = function (plugin) {\n    \/* istanbul ignore if *\/\n    if (plugin.installed) {\n      return\/\/假如插件已经初始化过就不再继续。避免插件重复入侵\n    }\n    \/\/ additional parameters\n    var args = toArray(arguments, 1);\/\/获取插件的配置参数\n    args.unshift(this);\n    if (typeof plugin.install === \x27function\x27) {\n      plugin.install.apply(plugin, args);／／调用的是插件的install方法；\n    } else if (typeof plugin === \x27function\x27) {\n      plugin.apply(null, args);\/\/若插件本省就是一个函数。则直接调用该函数\n    }\n    plugin.installed = true;\n    return this\n  };\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stata\x22\x3e\x3ccode\x3eVue.\x3cspan class=\x22hljs-keyword\x22\x3euse\x3c\/span\x3e = function (\x3cspan class=\x22hljs-keyword\x22\x3eplugin\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/* istanbul ignore if *\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3eplugin\x3c\/span\x3e.installed) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/假如插件已经初始化过就不再继续。避免插件重复入侵\x3c\/span\x3e\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ additional parameters\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eargs\x3c\/span\x3e = toArray(arguments, 1);\x3cspan class=\x22hljs-comment\x22\x3e\/\/获取插件的配置参数\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eargs\x3c\/span\x3e.unshift(this);\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eplugin\x3c\/span\x3e.install === \x27function\x27) {\n      \x3cspan class=\x22hljs-keyword\x22\x3eplugin\x3c\/span\x3e.install.apply(\x3cspan class=\x22hljs-keyword\x22\x3eplugin\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3eargs\x3c\/span\x3e);／／调用的是插件的install方法；\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eplugin\x3c\/span\x3e === \x27function\x27) {\n      \x3cspan class=\x22hljs-keyword\x22\x3eplugin\x3c\/span\x3e.apply(null, \x3cspan class=\x22hljs-keyword\x22\x3eargs\x3c\/span\x3e);\x3cspan class=\x22hljs-comment\x22\x3e\/\/若插件本省就是一个函数。则直接调用该函数\x3c\/span\x3e\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3eplugin\x3c\/span\x3e.installed = true;\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e this\n  };\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eVue.use这个方法让我们知道来。插件入侵的起点是调用插件自身的install函数。那么不同的插件入侵的机制有些时候很不一样。我们可以知道。这个不一样肯定发生在install函数中。我们来看看官方的install函数中的一些方式：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22MyPlugin.install = function (Vue, options) {\n  \/\/ 1. 添加全局方法或属性\n  Vue.myGlobalMethod = function () {\n    \/\/ 逻辑...\n  }\n  \/\/ 2. 添加全局资源\n  Vue.directive(\x27my-directive\x27, {\n    bind (el, binding, vnode, oldVnode) {\n      \/\/ 逻辑...\n    }\n    ...\n  })\n  \/\/ 3. 注入组件\n  Vue.mixin({\n    created: function () {\n      \/\/ 逻辑...\n    }\n    ...\n  })\n  \/\/ 4. 添加实例方法\n  Vue.prototype.$myMethod = function (options) {\n    \/\/ 逻辑...\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs php\x22\x3e\x3ccode\x3eMyPlugin.install = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(Vue, options)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 1. 添加全局方法或属性\x3c\/span\x3e\n  Vue.myGlobalMethod = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 逻辑...\x3c\/span\x3e\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 2. 添加全局资源\x3c\/span\x3e\n  Vue.directive(\x3cspan class=\x22hljs-string\x22\x3e\x27my-directive\x27\x3c\/span\x3e, {\n    bind (el, binding, vnode, oldVnode) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 逻辑...\x3c\/span\x3e\n    }\n    ...\n  })\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 3. 注入组件\x3c\/span\x3e\n  Vue.mixin({\n    created: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 逻辑...\x3c\/span\x3e\n    }\n    ...\n  })\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 4. 添加实例方法\x3c\/span\x3e\n  Vue.prototype.$myMethod = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(options)\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 逻辑...\x3c\/span\x3e\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们按官网推荐的四种例子。来看看每种方法对应的源码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x221:Vue.myGlobalMethod = function () {\n    \/\/ 逻辑...\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e:Vue.myGlobalMethod = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 逻辑...\x3c\/span\x3e\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e类似jquery中的jquery.myGlobalMethod或则$.myGlobalMethod简单来说就是给Vue这个全局对象添加一些工具方法。可以供全局快捷调用。我们这里就略过了\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x222: \/\/ 2. 添加全局资源\n  Vue.directive(\x27my-directive\x27, {\n    bind (el, binding, vnode, oldVnode) {\n      \/\/ 逻辑...\n    }\n    ...\n  })\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs clean\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e: \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 2. 添加全局资源\x3c\/span\x3e\n  Vue.directive(\x3cspan class=\x22hljs-string\x22\x3e\x27my-directive\x27\x3c\/span\x3e, {\n    bind (el, binding, vnode, oldVnode) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 逻辑...\x3c\/span\x3e\n    }\n    ...\n  })\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eVue.directive，Vue.filter，Vue.component等价。当全局使用这些api时。会在vue上把这些指令过滤器组件等放在相应的属性数组里。形如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Vue.options = {\n    components: {\n      \n    },\n    directives: {},\n    filters: {},\n    _base: Vue\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs vim\x22\x3e\x3ccode\x3eVue.\x3cspan class=\x22hljs-keyword\x22\x3eoptions\x3c\/span\x3e = {\n    component\x3cspan class=\x22hljs-variable\x22\x3es:\x3c\/span\x3e {\n      \n    },\n    directive\x3cspan class=\x22hljs-variable\x22\x3es:\x3c\/span\x3e {},\n    \x3cspan class=\x22hljs-built_in\x22\x3efilter\x3c\/span\x3e\x3cspan class=\x22hljs-variable\x22\x3es:\x3c\/span\x3e {},\n    _base: Vue\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e因为他挂在全局的vue中。在vue初始化。调用init方法时。会执行：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\/\/策略合并核心函数。可以仔细去看看\n        options || {},\n        vm\n      );\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs ruby\x22\x3e\x3ccode\x3e vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e策略合并核心函数。可以仔细去看看\n        options \x3cspan class=\x22hljs-params\x22\x3e||\x3c\/span\x3e {},\n        vm\n      );\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3evue在创建实例时。会把vue对象上的options的对象中的属性提取出来和传入的options做合并。这里涉及到合并策略。以后会专门讲一下。这里只要知道。vue每个配置相都有自己的合并规则。mergeOptions会根据合并的类目去选择对应的合并规则。这里的component.directive.filter根据合并规则。Vue对象上的全局的这些属性会被放在实例的__proto__上。\x3cbr\x3e同样的。相应的子组件。可以回过头去看一下组件那一章。在render创建子组件的时候。代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function createComponent (\n  Ctor,\n  data,\n  context,\n  children,\n  tag\n) {\n  if (isUndef(Ctor)) {\n    return\n  }\n\n  var baseCtor = context.$options._base;\n\n  \/\/ plain options object: turn it into a constructor\n  if (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor);\n  }\n\n  \/\/ if at this stage it\x27s not a constructor or an async component factory,\n  \/\/ reject.\n  if (typeof Ctor !== \x27function\x27) {\n    {\n      warn((\x26quot;Invalid Component definition: \x26quot; \x2b (String(Ctor))), context);\n    }\n    return\n  }\n\n  \/\/ async component\n  if (isUndef(Ctor.cid)) {\n    Ctor = resolveAsyncComponent(Ctor, baseCtor, context);\n    if (Ctor === undefined) {\n      \/\/ return nothing if this is indeed an async component\n      \/\/ wait for the callback to trigger parent update.\n      return\n    }\n  }\n\n  \/\/ resolve constructor options in case global mixins are applied after\n  \/\/ component constructor creation\n  resolveConstructorOptions(Ctor);\/\/核心：这里会再次合并一下vue上的全局的一些指令或则组件或则过滤器到组件的构造函数上\n\n  data = data || {};\n\n  \/\/ transform component v-model data into props \x26amp; events\n  if (isDef(data.model)) {\n    transformModel(Ctor.options, data);\n  }\n\n  \/\/ extract props\n  var propsData = extractPropsFromVNodeData(data, Ctor, tag);\n\n  \/\/ functional component\n  if (isTrue(Ctor.options.functional)) {\n    return createFunctionalComponent(Ctor, propsData, data, context, children)\n  }\n\n  \/\/ extract listeners, since these needs to be treated as\n  \/\/ child component listeners instead of DOM listeners\n  var listeners = data.on;\n  \/\/ replace with listeners with .native modifier\n  data.on = data.nativeOn;\n\n  if (isTrue(Ctor.options.abstract)) {\n    \/\/ abstract components do not keep anything\n    \/\/ other than props \x26amp; listeners\n    data = {};\n  }\n\n  \/\/ merge component management hooks onto the placeholder node\n  mergeHooks(data);\n\n  \/\/ return a placeholder vnode\n  var name = Ctor.options.name || tag;\n  var vnode = new VNode(\n    (\x26quot;vue-component-\x26quot; \x2b (Ctor.cid) \x2b (name ? (\x26quot;-\x26quot; \x2b name) : \x27\x27)),\n    data, undefined, undefined, undefined, context,\n    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }\n  );\n  return vnode\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lasso\x22\x3e\x3ccode\x3efunction createComponent (\n  Ctor,\n  \x3cspan class=\x22hljs-built_in\x22\x3edata\x3c\/span\x3e,\n  context,\n  children,\n  \x3cspan class=\x22hljs-built_in\x22\x3etag\x3c\/span\x3e\n) {\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isUndef(Ctor)) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n  }\n\n  \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e baseCtor = context.$options._base;\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ plain options object: turn it into a constructor\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor);\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ if at this stage it\x27s not a constructor or an async component factory,\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ reject.\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (typeof Ctor !== \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e) {\n    {\n      warn((\x3cspan class=\x22hljs-string\x22\x3e\x22Invalid Component definition: \x22\x3c\/span\x3e \x2b (\x3cspan class=\x22hljs-built_in\x22\x3eString\x3c\/span\x3e(Ctor))), context);\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ async component\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isUndef(Ctor.cid)) {\n    Ctor = resolveAsyncComponent(Ctor, baseCtor, context);\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (Ctor === undefined) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ return nothing if this is indeed an async component\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ wait for the callback to trigger parent update.\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n    }\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ resolve constructor options in case global mixins are applied after\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ component constructor creation\x3c\/span\x3e\n  resolveConstructorOptions(Ctor);\x3cspan class=\x22hljs-comment\x22\x3e\/\/核心：这里会再次合并一下vue上的全局的一些指令或则组件或则过滤器到组件的构造函数上\x3c\/span\x3e\n\n  \x3cspan class=\x22hljs-built_in\x22\x3edata\x3c\/span\x3e = \x3cspan class=\x22hljs-built_in\x22\x3edata\x3c\/span\x3e || {};\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ transform component v-model data into props \x26amp; events\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isDef(\x3cspan class=\x22hljs-built_in\x22\x3edata\x3c\/span\x3e.model)) {\n    transformModel(Ctor.options, \x3cspan class=\x22hljs-built_in\x22\x3edata\x3c\/span\x3e);\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ extract props\x3c\/span\x3e\n  \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e propsData = extractPropsFromVNodeData(\x3cspan class=\x22hljs-built_in\x22\x3edata\x3c\/span\x3e, Ctor, \x3cspan class=\x22hljs-built_in\x22\x3etag\x3c\/span\x3e);\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ functional component\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isTrue(Ctor.options.functional)) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e createFunctionalComponent(Ctor, propsData, \x3cspan class=\x22hljs-built_in\x22\x3edata\x3c\/span\x3e, context, children)\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ extract listeners, since these needs to be treated as\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ child component listeners instead of DOM listeners\x3c\/span\x3e\n  \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e listeners = \x3cspan class=\x22hljs-built_in\x22\x3edata\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3eon\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ replace with listeners with .native modifier\x3c\/span\x3e\n  \x3cspan class=\x22hljs-built_in\x22\x3edata\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3eon\x3c\/span\x3e = \x3cspan class=\x22hljs-built_in\x22\x3edata\x3c\/span\x3e.nativeOn;\n\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isTrue(Ctor.options.abstract)) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ abstract components do not keep anything\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ other than props \x26amp; listeners\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3edata\x3c\/span\x3e = {};\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ merge component management hooks onto the placeholder node\x3c\/span\x3e\n  mergeHooks(\x3cspan class=\x22hljs-built_in\x22\x3edata\x3c\/span\x3e);\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ return a placeholder vnode\x3c\/span\x3e\n  \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e name = Ctor.options.name || \x3cspan class=\x22hljs-built_in\x22\x3etag\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e vnode = \x3cspan class=\x22hljs-literal\x22\x3enew\x3c\/span\x3e VNode(\n    (\x3cspan class=\x22hljs-string\x22\x3e\x22vue-component-\x22\x3c\/span\x3e \x2b (Ctor.cid) \x2b (name ? (\x3cspan class=\x22hljs-string\x22\x3e\x22-\x22\x3c\/span\x3e \x2b name) : \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e)),\n    \x3cspan class=\x22hljs-built_in\x22\x3edata\x3c\/span\x3e, undefined, undefined, undefined, context,\n    { Ctor: Ctor, propsData: propsData, listeners: listeners, \x3cspan class=\x22hljs-built_in\x22\x3etag\x3c\/span\x3e: \x3cspan class=\x22hljs-built_in\x22\x3etag\x3c\/span\x3e, children: children }\n  );\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e vnode\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e最后在内部组件初始化时。vue会调用\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function initInternalComponent (vm, options) {\n  var opts = vm.$options = Object.create(vm.constructor.options);\/\/这里还是把构造函数的options放在了$options上供后续使用\n  \/\/ doing this because it\x27s faster than dynamic enumeration.\n  opts.parent = options.parent;\n  opts.propsData = options.propsData;\n  opts._parentVnode = options._parentVnode;\n  opts._parentListeners = options._parentListeners;\n  opts._renderChildren = options._renderChildren;\n  opts._componentTag = options._componentTag;\n  opts._parentElm = options._parentElm;\n  opts._refElm = options._refElm;\n  if (options.render) {\n    opts.render = options.render;\n    opts.staticRenderFns = options.staticRenderFns;\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs gradle\x22\x3e\x3ccode\x3efunction initInternalComponent (vm, \x3cspan class=\x22hljs-keyword\x22\x3eoptions\x3c\/span\x3e) {\n  var opts = vm.$\x3cspan class=\x22hljs-keyword\x22\x3eoptions\x3c\/span\x3e = Object.create(vm.constructor.\x3cspan class=\x22hljs-keyword\x22\x3eoptions\x3c\/span\x3e);\x3cspan class=\x22hljs-comment\x22\x3e\/\/这里还是把构造函数的options放在了$options上供后续使用\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ doing this because it\x27s faster than dynamic enumeration.\x3c\/span\x3e\n  opts.parent = \x3cspan class=\x22hljs-keyword\x22\x3eoptions\x3c\/span\x3e.parent;\n  opts.propsData = \x3cspan class=\x22hljs-keyword\x22\x3eoptions\x3c\/span\x3e.propsData;\n  opts._parentVnode = \x3cspan class=\x22hljs-keyword\x22\x3eoptions\x3c\/span\x3e._parentVnode;\n  opts._parentListeners = \x3cspan class=\x22hljs-keyword\x22\x3eoptions\x3c\/span\x3e._parentListeners;\n  opts._renderChildren = \x3cspan class=\x22hljs-keyword\x22\x3eoptions\x3c\/span\x3e._renderChildren;\n  opts._componentTag = \x3cspan class=\x22hljs-keyword\x22\x3eoptions\x3c\/span\x3e._componentTag;\n  opts._parentElm = \x3cspan class=\x22hljs-keyword\x22\x3eoptions\x3c\/span\x3e._parentElm;\n  opts._refElm = \x3cspan class=\x22hljs-keyword\x22\x3eoptions\x3c\/span\x3e._refElm;\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3eoptions\x3c\/span\x3e.render) {\n    opts.render = \x3cspan class=\x22hljs-keyword\x22\x3eoptions\x3c\/span\x3e.render;\n    opts.staticRenderFns = \x3cspan class=\x22hljs-keyword\x22\x3eoptions\x3c\/span\x3e.staticRenderFns;\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e总的来说。如果是全局的指令过滤器时。vue统一把他放在根构造方法上。根实例初始化时。通过策略合并合并到$options中。而子组件稍微绕了一下。最终也是放在$options的原型上。很连贯啊。这样只要是全局的组件。指令过滤器。每个子组件都可以继承使用。达到了插件的效果。\x3c\/p\x3e\n\x3cp\x3e3:下面来看看mixin方法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Vue.mixin({\n    created: function () {\n      \/\/ 逻辑...\n    }\n    ...\n  })\n\n\nVue.mixin = function (mixin) {\n    this.options = mergeOptions(this.options, mixin);\n  };\n\n\n\/\/这里还是不可避免要看看mergeOptions函数：\nfunction mergeOptions (\n  parent,\n  child,\n  vm\n) {\n  {\n    checkComponents(child);\n  }\n\n  if (typeof child === \x27function\x27) {\n    child = child.options;\n  }\n\n  normalizeProps(child);\n  normalizeDirectives(child);\n  var extendsFrom = child.extends;\n  if (extendsFrom) {\n    parent = mergeOptions(parent, extendsFrom, vm);\n  }\n  if (child.mixins) {\n    for (var i = 0, l = child.mixins.length; i \x3c l; i\x2b\x2b) {\n      parent = mergeOptions(parent, child.mixins[i], vm);\n    }\n  }\n  var options = {};\n  var key;\n  for (key in parent) {\n    mergeField(key);\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key);\n    }\n  }\n  function mergeField (key) {\n    var strat = strats[key] || defaultStrat;\n    options[key] = strat(parent[key], child[key], vm, key);\n  }\n  return options\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs qml\x22\x3e\x3ccode\x3eVue.mixin({\n    \x3cspan class=\x22hljs-attribute\x22\x3ecreated\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 逻辑...\x3c\/span\x3e\n    }\n    ...\n  })\n\n\nVue.mixin = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3emixin\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.options = mergeOptions(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.options, mixin);\n  };\n\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/这里还是不可避免要看看mergeOptions函数：\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emergeOptions\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\n  parent,\n  child,\n  vm\n\x3c\/span\x3e) \x3c\/span\x3e{\n  {\n    checkComponents(child);\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e child === \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e) {\n    child = child.options;\n  }\n\n  normalizeProps(child);\n  normalizeDirectives(child);\n  \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e extendsFrom = child.extends;\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (extendsFrom) {\n    \x3cspan class=\x22hljs-built_in\x22\x3eparent\x3c\/span\x3e = mergeOptions(\x3cspan class=\x22hljs-built_in\x22\x3eparent\x3c\/span\x3e, extendsFrom, vm);\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (child.mixins) {\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, l = child.mixins.length; i \x26lt; l; i\x2b\x2b) {\n      \x3cspan class=\x22hljs-built_in\x22\x3eparent\x3c\/span\x3e = mergeOptions(\x3cspan class=\x22hljs-built_in\x22\x3eparent\x3c\/span\x3e, child.mixins[i], vm);\n    }\n  }\n  \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e options = {};\n  \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e key;\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (key \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eparent\x3c\/span\x3e) {\n    mergeField(key);\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (key \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e child) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!hasOwn(\x3cspan class=\x22hljs-built_in\x22\x3eparent\x3c\/span\x3e, key)) {\n      mergeField(key);\n    }\n  }\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emergeField\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ekey\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e strat = strats[key] || defaultStrat;\n    options[key] = strat(\x3cspan class=\x22hljs-built_in\x22\x3eparent\x3c\/span\x3e[key], child[key], vm, key);\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e options\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e分两种情况吧：\x3c\/p\x3e\n\x3cp\x3ea:全局注册时即vue.mixin时。直接调用合并。直接便利mixin中的项目。分别调用相应合并策略。合并到构造函数的options中。影响后面所有的子组件\x3c\/p\x3e\n\x3cp\x3eb:局部注册时。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22if (child.mixins) {\n    for (var i = 0, l = child.mixins.length; i \x3c l; i\x2b\x2b) {\n      parent = mergeOptions(parent, child.mixins[i], vm);\n    }\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs php\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (child.mixins) {\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, l = child.mixins.length; i \x26lt; l; i\x2b\x2b) {\n      \x3cspan class=\x22hljs-keyword\x22\x3eparent\x3c\/span\x3e = mergeOptions(\x3cspan class=\x22hljs-keyword\x22\x3eparent\x3c\/span\x3e, child.mixins[i], vm);\n    }\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e则会去递归的调用合并策略把该合并的项目合并结束为止；\x3c\/p\x3e\n\x3cp\x3evue.mixin就相当于是一个传入的额外的配置项目，会让vue重新按照规则合并一次，成功入侵vue\x3c\/p\x3e\n\x3cp\x3e4:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 4. 添加实例方法\n  Vue.prototype.$myMethod = function (options) {\n    \/\/ 逻辑...\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs php\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 4. 添加实例方法\x3c\/span\x3e\n  Vue.prototype.$myMethod = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(options)\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 逻辑...\x3c\/span\x3e\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这个方法就很明显了。在vue的原型上挂载方法。vue的实例自然而然就能继承。子组件在创建的时候。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Sub.prototype = Object.create(Super.prototype);\n    Sub.prototype.constructor = Sub;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs elm\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-type\x22\x3eSub\x3c\/span\x3e.proto\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e = \x3cspan class=\x22hljs-type\x22\x3eObject\x3c\/span\x3e.create(\x3cspan class=\x22hljs-type\x22\x3eSuper\x3c\/span\x3e.prototype);\n    \x3cspan class=\x22hljs-type\x22\x3eSub\x3c\/span\x3e.proto\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e.constructor = \x3cspan class=\x22hljs-type\x22\x3eSub\x3c\/span\x3e;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e将原型指向根构造函数Vue的prototype；自然而然就会有Vue的原型上的所有属性和方法。。\x3c\/p\x3e\n\x3cp\x3e以上就是vue比较常用的插件侵入方法。哈哈。下次再说。告辞\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>vue源码解析－插件入侵机制</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000009811112">https://segmentfault.com/a/1190000009811112</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/j74vj8p3p5g/" target="_blank">https://alili.tech/archive/j74vj8p3p5g/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>