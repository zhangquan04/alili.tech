<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="加深对 JavaScript This 的理解"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>加深对 JavaScript This 的理解 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/y5pbv9508k/",
				"appid": "1613049289050283", 
				"title": "加深对 JavaScript This 的理解 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-08T02:30:11"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/oq8xf0a0f18/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/iza3ho5n2q/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fy5pbv9508k%2f&text=%e5%8a%a0%e6%b7%b1%e5%af%b9%20JavaScript%20This%20%e7%9a%84%e7%90%86%e8%a7%a3"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fy5pbv9508k%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fy5pbv9508k%2f&text=%e5%8a%a0%e6%b7%b1%e5%af%b9%20JavaScript%20This%20%e7%9a%84%e7%90%86%e8%a7%a3"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fy5pbv9508k%2f&title=%e5%8a%a0%e6%b7%b1%e5%af%b9%20JavaScript%20This%20%e7%9a%84%e7%90%86%e8%a7%a3"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fy5pbv9508k%2f&is_video=false&description=%e5%8a%a0%e6%b7%b1%e5%af%b9%20JavaScript%20This%20%e7%9a%84%e7%90%86%e8%a7%a3"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e5%8a%a0%e6%b7%b1%e5%af%b9%20JavaScript%20This%20%e7%9a%84%e7%90%86%e8%a7%a3&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fy5pbv9508k%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fy5pbv9508k%2f&title=%e5%8a%a0%e6%b7%b1%e5%af%b9%20JavaScript%20This%20%e7%9a%84%e7%90%86%e8%a7%a3"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fy5pbv9508k%2f&title=%e5%8a%a0%e6%b7%b1%e5%af%b9%20JavaScript%20This%20%e7%9a%84%e7%90%86%e8%a7%a3"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fy5pbv9508k%2f&title=%e5%8a%a0%e6%b7%b1%e5%af%b9%20JavaScript%20This%20%e7%9a%84%e7%90%86%e8%a7%a3"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fy5pbv9508k%2f&title=%e5%8a%a0%e6%b7%b1%e5%af%b9%20JavaScript%20This%20%e7%9a%84%e7%90%86%e8%a7%a3"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">加深对 JavaScript This 的理解</h1><div class="meta"><div class="postdate"><time datetime="2019-01-08" itemprop="datePublished">2019-01-08</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e\x3cp\x3e欢迎来我的博客阅读：\x3ca href=\x22http:\/\/huang-jerryc.com\/2017\/07\/15\/understand-this-of-javascript\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e《加深对 JavaScript This 的理解》\x3c\/a\x3e\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e我相信你已经看过很多关于 JavaScript 的 \x3ccode\x3ethis\x3c\/code\x3e  的谈论了，既然你点进来了，不妨继续看下去，看是否能帮你加深对 \x3ccode\x3ethis\x3c\/code\x3e 的理解。\x3c\/p\x3e\n\x3cp\x3e最近在看 \x3ca href=\x22https:\/\/github.com\/getify\/You-Dont-Know-JS\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e《You Dont Know JS》\x3c\/a\x3e 这本书，不得感叹，就算用了 JS 很多年的老前端来看这本书，我觉得还是会有不少的收获。\x3c\/p\x3e\n\x3cp\x3e其中关于 \x3ccode\x3ethis\x3c\/code\x3e 的讲解，更是加深了我对 \x3ccode\x3ethis\x3c\/code\x3e 的理解，故整理知识点，再加上自身的理解，以自己的语言来描述。\x3cbr\x3e对读者来说，算是二手知识，这本书是开源的，可以到本书的 Github 项目地址学习一手的知识。\x3c\/p\x3e\n\x3cp\x3e首先有一句大家都明白的话，我还是要强调一遍：\x3cbr\x3e\x3cstrong\x3e「\x3ccode\x3ethis\x3c\/code\x3e 是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。」\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e这句话很重要，这是理解 \x3ccode\x3ethis\x3c\/code\x3e 原理的基础。\x3cbr\x3e而在讲解 \x3ccode\x3ethis\x3c\/code\x3e 之前，先要理解一下作用域的相关概念。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader0\x22\x3e「词法作用域」与「动态作用域」\x3c\/h1\x3e\n\x3cp\x3e通常来说，作用域一共有两种主要的工作模型。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e词法作用域\x3c\/li\x3e\n\x3cli\x3e动态作用域\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e词法作用域是大多数编程语言所采用的模式，而动态作用域仍有一些编程语言在用，例如 Bash 脚本。\x3cbr\x3e而 JavaScript 就是采用的词法作用域，也就是在编程阶段，作用域就已经明确下来了。\x3c\/p\x3e\n\x3cp\x3e思考下面代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function foo(){\n  console.log(a);   \/\/ 输出 2\n}\n\nfunction bar(){\n  let a = 3;\n  foo();\n}\n\nlet a = 2;\n\nbar()\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(a);   \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出 2\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ebar\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e a = \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e;\n  foo();\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e a = \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e;\n\nbar()\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e因为 JavaScript 所用的是词法作用域，自然 \x3ccode\x3efoo()\x3c\/code\x3e 声明的阶段，就已经确定了变量 \x3ccode\x3ea\x3c\/code\x3e 的作用域了。\x3c\/p\x3e\n\x3cp\x3e倘若，JavaScript 是采用的动态作用域，\x3ccode\x3efoo()\x3c\/code\x3e 中打印的将是 \x3ccode\x3e3\x3c\/code\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function foo(){\n  console.log(a);   \/\/ 输出 3 （不是 2）\n}\n\nfunction bar(){\n  let a = 3;\n  foo();\n}\n\nlet a = 2;\n\nbar()\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(a);   \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出 3 （不是 2）\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ebar\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e a = \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e;\n  foo();\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e a = \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e;\n\nbar()\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e而 JavaScript 的 \x3ccode\x3ethis\x3c\/code\x3e 机制跟动态作用域很相似，是在运行时在被调用的地方动态绑定的。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader1\x22\x3ethis 的四种绑定规则\x3c\/h1\x3e\n\x3cp\x3e在 JavaScript 中，影响 this 指向的绑定规则有四种：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e默认绑定\x3c\/li\x3e\n\x3cli\x3e隐式绑定\x3c\/li\x3e\n\x3cli\x3e显式绑定\x3c\/li\x3e\n\x3cli\x3enew 绑定\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e默认绑定\x3c\/h2\x3e\n\x3cp\x3e这是最直接的一种方式，就是不加任何的修饰符直接调用函数，如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function foo() {\n  console.log(this.a)   \/\/ 输出 a\n}\n\nvar a = 2;  \/\/  变量声明到全局对象中\n\nfoo();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a)   \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出 a\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e a = \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e;  \x3cspan class=\x22hljs-comment\x22\x3e\/\/  变量声明到全局对象中\x3c\/span\x3e\n\nfoo();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e使用 \x3ccode\x3evar\x3c\/code\x3e 声明的变量 \x3ccode\x3ea\x3c\/code\x3e，被绑定到全局对象中，如果是浏览器，则是在 \x3ccode\x3ewindow\x3c\/code\x3e 对象。\x3cbr\x3e\x3ccode\x3efoo()\x3c\/code\x3e 调用时，引用了默认绑定，\x3ccode\x3ethis\x3c\/code\x3e 指向了全局对象。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e隐式绑定\x3c\/h2\x3e\n\x3cp\x3e这种情况会发生在调用位置存在「上下文对象」的情况，如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function foo() {\n  console.log(this.a);\n}\n\nlet obj1 = {\n  a: 1,\n  foo,\n};\n\nlet obj2 = {\n  a: 2,\n  foo,\n}\n\nobj1.foo();   \/\/ 输出 1\nobj2.foo();   \/\/ 输出 2\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a);\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e obj1 = {\n  \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\n  foo,\n};\n\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e obj2 = {\n  \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\n  foo,\n}\n\nobj1.foo();   \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出 1\x3c\/span\x3e\nobj2.foo();   \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出 2\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当函数调用的时候，拥有上下文对象的时候，\x3ccode\x3ethis\x3c\/code\x3e 会被绑定到该上下文对象。\x3cbr\x3e正如上面的代码，\x3cbr\x3e\x3ccode\x3eobj1.foo()\x3c\/code\x3e 被调用时，\x3ccode\x3ethis\x3c\/code\x3e 绑定到了 \x3ccode\x3eobj1\x3c\/code\x3e, \x3cbr\x3e而 \x3ccode\x3eobj2.foo()\x3c\/code\x3e 被调用时，\x3ccode\x3ethis\x3c\/code\x3e 绑定到了 \x3ccode\x3eobj2\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e显式绑定\x3c\/h2\x3e\n\x3cp\x3e这种就是使用 \x3ccode\x3eFunction.prototype\x3c\/code\x3e 中的三个方法 \x3ccode\x3ecall()\x3c\/code\x3e, \x3ccode\x3eapply()\x3c\/code\x3e, \x3ccode\x3ebind()\x3c\/code\x3e 了。\x3cbr\x3e这三个函数，都可以改变函数的 \x3ccode\x3ethis\x3c\/code\x3e 指向到指定的对象，\x3cbr\x3e不同之处在于，\x3ccode\x3ecall()\x3c\/code\x3e 和 \x3ccode\x3eapply()\x3c\/code\x3e 是立即执行函数，并且接受的参数的形式不同：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3ccode\x3ecall(this, arg1, arg2, ...)\x3c\/code\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ccode\x3eapply(this, [arg1, arg2, ...])\x3c\/code\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e而 \x3ccode\x3ebind()\x3c\/code\x3e 则是创建一个新的包装函数，并且返回，而不是立刻执行。\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\x3ccode\x3ebind(this, arg1, arg2, ...)\x3c\/code\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e\x3ccode\x3eapply()\x3c\/code\x3e 接收参数的形式，有助于函数嵌套函数的时候，把 \x3ccode\x3earguments\x3c\/code\x3e 变量传递到下一层函数中。\x3c\/p\x3e\n\x3cp\x3e思考下面代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function foo() {\n  console.log(this.a);  \/\/ 输出 1\n  bar.apply({a: 2}, arguments);\n}\n\nfunction bar(b) {\n  console.log(this.a \x2b b);  \/\/ 输出 5\n}\n\nvar a = 1;\nfoo(3);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a);  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出 1\x3c\/span\x3e\n  bar.apply({\x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e}, \x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e);\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ebar\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eb\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a \x2b b);  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出 5\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e a = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\nfoo(\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面代码中， \x3ccode\x3efoo()\x3c\/code\x3e 内部的 \x3ccode\x3ethis\x3c\/code\x3e 遵循默认绑定规则，绑定到全局变量中。\x3cbr\x3e而 \x3ccode\x3ebar()\x3c\/code\x3e 在调用的时候，调用了 \x3ccode\x3eapply()\x3c\/code\x3e 函数，把 \x3ccode\x3ethis\x3c\/code\x3e 绑定到了一个新的对象中 \x3ccode\x3e{a: 2}\x3c\/code\x3e，而且原封不动的接收 \x3ccode\x3efoo()\x3c\/code\x3e 接收的函数。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3enew 绑定\x3c\/h2\x3e\n\x3cp\x3e最后一种，则是使用 \x3ccode\x3enew\x3c\/code\x3e 操作符会产生 \x3ccode\x3ethis\x3c\/code\x3e 的绑定。\x3cbr\x3e在理解 \x3ccode\x3enew\x3c\/code\x3e 操作符对 \x3ccode\x3ethis\x3c\/code\x3e 的影响，首先要理解 \x3ccode\x3enew\x3c\/code\x3e 的原理。\x3cbr\x3e在 JavaScript 中，\x3ccode\x3enew\x3c\/code\x3e 操作符并不像其他面向对象的语言一样，而是一种模拟出来的机制。\x3cbr\x3e在 JavaScript 中，所有的函数都可以被 \x3ccode\x3enew\x3c\/code\x3e 调用，这时候这个函数一般会被称为「构造函数」，实际上并不存在所谓「构造函数」，更确切的理解应该是对于函数的「构造调用」。\x3c\/p\x3e\n\x3cp\x3e使用 \x3ccode\x3enew\x3c\/code\x3e 来调用函数，会自动执行下面操作：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e创建一个全新的对象。\x3c\/li\x3e\n\x3cli\x3e这个新对象会被执行 [[Prototype]] 连接。\x3c\/li\x3e\n\x3cli\x3e这个新对象会绑定到函数调用的 this。\x3c\/li\x3e\n\x3cli\x3e如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e所以如果 \x3ccode\x3enew\x3c\/code\x3e 是一个函数的话，会是这样子的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function New(Constructor, ...args){\n    let obj = {};   \/\/ 创建一个新对象\n    Object.setPrototypeOf(obj, Constructor.prototype);  \/\/ 连接新对象与函数的原型\n    return Constructor.apply(obj, args) || obj;   \/\/ 执行函数，改变 this 指向新的对象\n}\n\nfunction Foo(a){\n    this.a = a;\n}\n\nNew(Foo, 1);  \/\/ Foo { a: 1 }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eNew\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eConstructor, ...args\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e obj = {};   \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建一个新对象\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.setPrototypeOf(obj, Constructor.prototype);  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 连接新对象与函数的原型\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e Constructor.apply(obj, args) || obj;   \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 执行函数，改变 this 指向新的对象\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eFoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ea\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a = a;\n}\n\nNew(Foo, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Foo { a: 1 }\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e所以，在使用 \x3ccode\x3enew\x3c\/code\x3e 来调用函数时候，我们会构造一个新对象并把它绑定到函数调用中的 \x3ccode\x3ethis\x3c\/code\x3e 上。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader6\x22\x3e优先级\x3c\/h1\x3e\n\x3cp\x3e如果一个位置发生了多条改变 this 的规则，那么优先级是如何的呢？\x3c\/p\x3e\n\x3cp\x3e看几段代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 显式绑定 \x3e 隐式绑定\nfunction foo() {\n    console.log(this.a);\n}\n\nlet obj1 = {\n    a: 2,\n    foo,\n}\n\nobj1.foo();     \/\/ 输出 2\nobj1.foo.call({a: 1});      \/\/ 输出 1\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 显式绑定 \x26gt; 隐式绑定\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a);\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e obj1 = {\n    \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\n    foo,\n}\n\nobj1.foo();     \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出 2\x3c\/span\x3e\nobj1.foo.call({\x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e});      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出 1\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这说明「显式绑定」的优先级大于「隐式绑定」\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ new 绑定 \x3e 显式绑定\nfunction foo(a) {\n    this.a = a;\n}\n\nlet obj1 = {};\n\nlet bar = foo.bind(obj1);\nbar(2);\nconsole.log(obj1); \/\/ 输出 {a:2}\n\nlet obj2 = new bar(3);\nconsole.log(obj1); \/\/ 输出 {a:2}\nconsole.log(obj2); \/\/ 输出 foo { a: 3 }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ new 绑定 \x26gt; 显式绑定\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ea\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a = a;\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e obj1 = {};\n\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e bar = foo.bind(obj1);\nbar(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e);\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(obj1); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出 {a:2}\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e obj2 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e bar(\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e);\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(obj1); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出 {a:2}\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(obj2); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出 foo { a: 3 }\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这说明「new 绑定」的优先级大于「显式绑定」\x3cbr\x3e而「默认绑定」，毫无疑问是优先级最低的。\x3cbr\x3e所以优先级顺序为：\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e「new 绑定」 \x26gt; 「显式绑定」 \x26gt; 「隐式绑定」 \x26gt; 「默认绑定。」\x3c\/strong\x3e\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader7\x22\x3e所以，this 到底是什么\x3c\/h1\x3e\n\x3cp\x3e\x3ccode\x3ethis\x3c\/code\x3e 并不是在编写的时候绑定的，而是在运行时绑定的。它的上下文取决于函数调用时的各种条件。\x3cbr\x3e\x3ccode\x3ethis\x3c\/code\x3e 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。\x3cbr\x3e当一个函数被调用时，会创建一个「执行上下文」，这个上下文会包含函数在哪里被调用（调用栈）、函数的调用方式、传入的参数等信息。\x3ccode\x3ethis\x3c\/code\x3e 就是这个记录的一个属性，会在函数执行的过程中用到。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader8\x22\x3e参考\x3c\/h1\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/getify\/You-Dont-Know-JS\/blob\/master\/this%20\x26amp;%20object%20prototypes\/README.md#you-dont-know-js-this--object-prototypes\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e《You Dont Know JS》- this \x26amp; Object Prototypes\x3c\/a\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>加深对 JavaScript This 的理解</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000010202788">https://segmentfault.com/a/1190000010202788</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/y5pbv9508k/" target="_blank">https://alili.tech/archive/y5pbv9508k/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>