<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="也谈JavaScript数组去重"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>也谈JavaScript数组去重 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/vda4333rfwn/",
				"appid": "1613049289050283", 
				"title": "也谈JavaScript数组去重 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-28T02:30:09"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/l1443vraki8/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/9pvtwgjarlq/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fvda4333rfwn%2f&text=%e4%b9%9f%e8%b0%88JavaScript%e6%95%b0%e7%bb%84%e5%8e%bb%e9%87%8d"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fvda4333rfwn%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fvda4333rfwn%2f&text=%e4%b9%9f%e8%b0%88JavaScript%e6%95%b0%e7%bb%84%e5%8e%bb%e9%87%8d"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fvda4333rfwn%2f&title=%e4%b9%9f%e8%b0%88JavaScript%e6%95%b0%e7%bb%84%e5%8e%bb%e9%87%8d"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fvda4333rfwn%2f&is_video=false&description=%e4%b9%9f%e8%b0%88JavaScript%e6%95%b0%e7%bb%84%e5%8e%bb%e9%87%8d"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e4%b9%9f%e8%b0%88JavaScript%e6%95%b0%e7%bb%84%e5%8e%bb%e9%87%8d&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fvda4333rfwn%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fvda4333rfwn%2f&title=%e4%b9%9f%e8%b0%88JavaScript%e6%95%b0%e7%bb%84%e5%8e%bb%e9%87%8d"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fvda4333rfwn%2f&title=%e4%b9%9f%e8%b0%88JavaScript%e6%95%b0%e7%bb%84%e5%8e%bb%e9%87%8d"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fvda4333rfwn%2f&title=%e4%b9%9f%e8%b0%88JavaScript%e6%95%b0%e7%bb%84%e5%8e%bb%e9%87%8d"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fvda4333rfwn%2f&title=%e4%b9%9f%e8%b0%88JavaScript%e6%95%b0%e7%bb%84%e5%8e%bb%e9%87%8d"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">也谈JavaScript数组去重</h1><div class="meta"><div class="postdate"><time datetime="2019-01-28" itemprop="datePublished">2019-01-28</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e\x3cp\x3e本文同时发布于个人博客\x3ca href=\x22https:\/\/www.toobug.net\/article\/array_unique_in_javascript.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/www.toobug.net\/articl...\x3c\/a\x3e\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3eJavaScript的数组去重是一个老生常谈的话题了。随便搜一搜就能找到非常多不同版本的解法。\x3c\/p\x3e\n\x3cp\x3e昨天在微博上看到一篇文章，也写数组去重，主要推崇的方法是将利用数组元素当作对象key来去重。我在微博转发了“用对象key去重不是个好办法…”然后作者问什么才是推荐的方法。\x3c\/p\x3e\n\x3cp\x3e细想一下，这样一个看似简单的需求，如果要做到完备，涉及的知识和需要注意的地方着实不少，于是诞生此文。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e定义重复（相等）\x3c\/h2\x3e\n\x3cp\x3e要去重，首先得定义，什么叫作“重复”，即具体到代码而言，两个数据在什么情况下可以算是相等的。这并不是一个很容易的问题。\x3c\/p\x3e\n\x3cp\x3e对于原始值而言，我们很容易想到\x3ccode\x3e1\x3c\/code\x3e和\x3ccode\x3e1\x3c\/code\x3e是相等的，\x3ccode\x3e\x271\x27\x3c\/code\x3e和\x3ccode\x3e\x271\x27\x3c\/code\x3e也是相等的。那么，\x3ccode\x3e1\x3c\/code\x3e和\x3ccode\x3e\x271\x27\x3c\/code\x3e是相等的么？\x3c\/p\x3e\n\x3cp\x3e如果这个问题还好说，只要回答“是”或者“不是”即可。那么下面这些情况就没那么容易了。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3eNaN\x3c\/h3\x3e\n\x3cp\x3e初看\x3ccode\x3eNaN\x3c\/code\x3e时，很容易把它当成和\x3ccode\x3enull\x3c\/code\x3e、\x3ccode\x3eundefined\x3c\/code\x3e一样的独立数据类型。但其实，它是数字类型。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ number\nconsole.log(typeof NaN);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ number\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3eNaN\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e根据规范，比较运算中只要有一个值为NaN，则比较结果为\x3ccode\x3efalse\x3c\/code\x3e，所以会有下面这些看起来略蛋疼的结论：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 全都是false\n0 \x3c NaN;\n0 \x3e NaN;\n0 == NaN;\n0 === NaN;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 全都是false\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e \x26lt; \x3cspan class=\x22hljs-literal\x22\x3eNaN\x3c\/span\x3e;\n\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e \x26gt; \x3cspan class=\x22hljs-literal\x22\x3eNaN\x3c\/span\x3e;\n\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e == \x3cspan class=\x22hljs-literal\x22\x3eNaN\x3c\/span\x3e;\n\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e === \x3cspan class=\x22hljs-literal\x22\x3eNaN\x3c\/span\x3e;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以最后一个表达式\x3ccode\x3e0 === NaN\x3c\/code\x3e为例，在规范中有明确规定（\x3ca href=\x22http:\/\/www.ecma-international.org\/ecma-262\/6.0\/#sec-strict-equality-comparison\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/www.ecma-international...\x3c\/a\x3e）：\x3c\/p\x3e\n\x3cblockquote\x3e\x3col\x3e\x3cli\x3e\n\x3cp\x3eIf Type(x) is Number, then\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3eIf x is NaN, return false.\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eIf y is NaN, return false.\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eIf x is the same Number value as y, return true.\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eIf x is \x2b0 and y is −0, return true.\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eIf x is −0 and y is \x2b0, return true.\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eReturn false.\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3c\/li\x3e\x3c\/ol\x3e\x3c\/blockquote\x3e\n\x3cp\x3e这意味着任何涉及到\x3ccode\x3eNaN\x3c\/code\x3e的情况都不能简单地使用比较运算来判定是否相等。比较科学的方法只能是使用\x3ccode\x3eisNaN()\x3c\/code\x3e：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var a = NaN;\nvar b = NaN;\n\n\/\/ true\nconsole.log(isNaN(a) \x26amp;\x26amp; isNaN(b));\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e a = \x3cspan class=\x22hljs-literal\x22\x3eNaN\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e b = \x3cspan class=\x22hljs-literal\x22\x3eNaN\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-built_in\x22\x3eisNaN\x3c\/span\x3e(a) \x26amp;\x26amp; \x3cspan class=\x22hljs-built_in\x22\x3eisNaN\x3c\/span\x3e(b));\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e原始值和包装对象\x3c\/h3\x3e\n\x3cp\x3e看完\x3ccode\x3eNaN\x3c\/code\x3e是不是头都大了。好了，我们来轻松一下，看一看原始值和包装对象这一对冤家。\x3c\/p\x3e\n\x3cp\x3e如果你研究过\x3ccode\x3e\x27a\x27.trim()\x3c\/code\x3e这样的代码的话，不知道是否产生过这样的疑问：\x3ccode\x3e\x27a\x27\x3c\/code\x3e明明是一个原始值（字符串），它为什么可以直接调用\x3ccode\x3e.trim()\x3c\/code\x3e方法呢？当然，很可能你已经知道答案：因为JS在执行这样的代码的时候会对原始值做一次包装，让\x3ccode\x3e\x27a\x27\x3c\/code\x3e变成一个字符串对象，然后执行这个对象的方法，执行完之后再把这个包装对象脱掉。可以用下面的代码来理解：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ \x27a\x27.trim();\nvar tmp = new String(\x27a\x27);\ntmp.trim();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x27a\x27.trim();\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e tmp = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eString\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27a\x27\x3c\/span\x3e);\ntmp.trim();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这段代码只是辅助我们理解的。但包装对象这个概念在JS中却是真实存在的。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var a = new String(\x27a\x27);\nvar b = \x27b\x27;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e a = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eString\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27a\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e b = \x3cspan class=\x22hljs-string\x22\x3e\x27b\x27\x3c\/span\x3e;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3ea\x3c\/code\x3e即是一个包装对象，它和\x3ccode\x3eb\x3c\/code\x3e一样，代表一个字符串。它们都可以使用字符串的各种方法（比如\x3ccode\x3etrim()\x3c\/code\x3e），也可以参与字符串运算（\x3ccode\x3e\x2b\x3c\/code\x3e号连接等）。\x3c\/p\x3e\n\x3cp\x3e但他们有一个关键的区别：类型不同！\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22typeof a; \/\/ object\ntypeof b; \/\/ string\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e a; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ object\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e b; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ string\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在做字符串比较的时候，类型的不同会导致结果有一些出乎意料：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var a1 = \x27a\x27;\nvar a2 = new String(\x27a\x27);\nvar a3 = new String(\x27a\x27);\n\na1 == a2; \/\/ true\na1 == a3; \/\/ true\na2 == a3; \/\/ false\na1 === a2; \/\/ false\na1 === a3; \/\/ false\na2 === a3; \/\/ false\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e a1 = \x3cspan class=\x22hljs-string\x22\x3e\x27a\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e a2 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eString\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27a\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e a3 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eString\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27a\x27\x3c\/span\x3e);\n\na1 == a2; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\na1 == a3; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\na2 == a3; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ false\x3c\/span\x3e\na1 === a2; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ false\x3c\/span\x3e\na1 === a3; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ false\x3c\/span\x3e\na2 === a3; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ false\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e同样是表示字符串\x3ccode\x3ea\x3c\/code\x3e的变量，在使用严格比较时竟然不是相等的，在直觉上这是一件比较难接受的事情，在各种开发场景下，也非常容易忽略这些细节。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e对象和对象\x3c\/h3\x3e\n\x3cp\x3e在涉及比较的时候，还会碰到对象。具体而言，大致可以分为三种情况：纯对象、实例对象、其它类型的对象。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e纯对象\x3c\/strong\x3e\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e纯对象（plain object）具体指什么并不是非常明确，为减少不必要的争议，下文中使用纯对象指代由字面量生成的、成员中不含函数和日期、正则表达式等类型的对象。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e如果直接拿两个对象进行比较，不管是\x3ccode\x3e==\x3c\/code\x3e还是\x3ccode\x3e===\x3c\/code\x3e，毫无疑问都是不相等的。但是在实际使用时，这样的规则是否一定满足我们的需求？举个例子，我们的应用中有两个配置项：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 原来有两个属性\n\/\/ var prop1 = 1;\n\/\/ var prop2 = 2;\n\n\/\/ 重构代码时两个属性被放到同一个对象中\n\nvar config = {\n    prop1: 1,\n    prop2: 2\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 原来有两个属性\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ var prop1 = 1;\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ var prop2 = 2;\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 重构代码时两个属性被放到同一个对象中\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e config = {\n    \x3cspan class=\x22hljs-attr\x22\x3eprop1\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3eprop2\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e假设在某些场景下，我们需要比较两次运行的配置项是否相同。在重构前，我们分别比较两次运行的\x3ccode\x3eprop1\x3c\/code\x3e和\x3ccode\x3eprop2\x3c\/code\x3e即可。而在重构后，我们可能需要比较\x3ccode\x3econfig\x3c\/code\x3e对象所代表的配置项是否一致。在这样的场景下，直接用\x3ccode\x3e==\x3c\/code\x3e或者\x3ccode\x3e===\x3c\/code\x3e来比较对象，得到的并不是我们期望的结果。\x3c\/p\x3e\n\x3cp\x3e在这样的场景下，我们可能需要自定义一些方法来处理对象的比较。常见的可能是通过\x3ccode\x3eJSON.stringify()\x3c\/code\x3e对对象进行序列化之后再比较字符串，当然这个过程并非完全可靠，只是一个思路。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e如果你觉得这个场景是无中生有的话，可以再回想一下断言库，同样是基于对象成员，判断结果是否和预期相符。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e\x3cstrong\x3e实例对象\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e实例对象主要指通过构造函数（类）生成的对象。这样的对象和纯对象一样，直接比较都是不等的，但也会碰到需要判断是否是同一对象的情况。一般而言，因为这种对象有比较复杂的内部结构（甚至有一部分数据在原型上），无法直接从外部比较是否相等。比较靠谱的判断方法是由构造函数（类）来提供静态方法或者实例方法来判断是否相等。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var a = Klass();\nvar b = Klass();\n\nKlass.isEqual(a, b);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e a = Klass();\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e b = Klass();\n\nKlass.isEqual(a, b);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e其它对象\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e其它对象主要指数组、日期、正则表达式等这类在\x3ccode\x3eObject\x3c\/code\x3e基础上派生出来的对象。这类对象各有各的特殊性，一般需要根据场景来构造判断方法，决定两个对象是否相等。\x3c\/p\x3e\n\x3cp\x3e比如，日期对象，可能需要通过\x3ccode\x3eDate.prototype.getTime()\x3c\/code\x3e方法获取时间戳来判断是否表示同一时刻。正则表达式可能需要通过\x3ccode\x3etoString()\x3c\/code\x3e方法获取到原始字面量来判断是否是相同的正则表达式。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e==和===\x3c\/h3\x3e\n\x3cp\x3e在一些文章中，看到某一些数组去重的方法，在判断元素是否相等时，使用的是\x3ccode\x3e==\x3c\/code\x3e比较运算符。众所周知，这个运算符在比较前会先查看元素类型，当类型不一致时会做隐式类型转换。这其实是一种非常不严谨的做法。因为无法区分在做隐匿类型转换后值一样的元素，例如\x3ccode\x3e0\x3c\/code\x3e、\x3ccode\x3e\x27\x27\x3c\/code\x3e、\x3ccode\x3efalse\x3c\/code\x3e、\x3ccode\x3enull\x3c\/code\x3e、\x3ccode\x3eundefined\x3c\/code\x3e等。\x3c\/p\x3e\n\x3cp\x3e同时，还有可能出现一些只能黑人问号的结果，例如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22[] == ![]; \/\/true\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e[] == ![]; \x3cspan class=\x22hljs-comment\x22\x3e\/\/true\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3eArray.prototype.indexOf()\x3c\/h3\x3e\n\x3cp\x3e在一些版本的去重中，用到了\x3ccode\x3eArray.prototype.indexOf()\x3c\/code\x3e方法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function unique(arr) {\n    return arr.filter(function(item, index){\n        \/\/ indexOf返回第一个索引值，\n        \/\/ 如果当前索引不是第一个索引，说明是重复值\n        return arr.indexOf(item) === index;\n    });\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eunique\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3earr\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e arr.filter(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eitem, index\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ indexOf返回第一个索引值，\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果当前索引不是第一个索引，说明是重复值\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e arr.indexOf(item) === index;\n    });\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function unique(arr) {\n    var ret = [];\n    arr.forEach(function(item){\n        if(ret.indexOf(item) === -1){\n            ret.push(item);\n        }\n    });\n    return ret;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eunique\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3earr\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e ret = [];\n    arr.forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eitem\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(ret.indexOf(item) === \x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e){\n            ret.push(item);\n        }\n    });\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e ret;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e既然\x3ccode\x3e==\x3c\/code\x3e和\x3ccode\x3e===\x3c\/code\x3e在元素相等的比较中是有巨大差别的，那么\x3ccode\x3eindexOf\x3c\/code\x3e的情况又如何呢？大部分的文章都没有提及这点，于是只好求助规范。通过规范（\x3ca href=\x22http:\/\/www.ecma-international.org\/ecma-262\/6.0\/#sec-array.prototype.indexof\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/www.ecma-international...\x3c\/a\x3e），我们知道了\x3ccode\x3eindexOf()\x3c\/code\x3e使用的是严格比较，也就是\x3ccode\x3e===\x3c\/code\x3e。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e再次强调：按照前文所述，\x3ccode\x3e===\x3c\/code\x3e不能处理\x3ccode\x3eNaN\x3c\/code\x3e的相等性判断。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3eArray.prototype.includes()\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3eArray.prototype.includes()\x3c\/code\x3e是ES2016中新增的方法，用于判断数组中是否包含某个元素，所以上面使用\x3ccode\x3eindexOf()\x3c\/code\x3e方法的第二个版本可以改写成如下版本：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function unique(arr) {\n    var ret = [];\n    arr.forEach(function(item){\n        if(!ret.includes(item)){\n            ret.push(item);\n        }\n    });\n    return ret;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eunique\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3earr\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e ret = [];\n    arr.forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eitem\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(!ret.includes(item)){\n            ret.push(item);\n        }\n    });\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e ret;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e那么，你猜猜，\x3ccode\x3eincludes()\x3c\/code\x3e又是用什么方法来比较的呢？如果想当然的话，会觉得肯定跟\x3ccode\x3eindexOf()\x3c\/code\x3e一样喽。但是，程序员的世界里最怕想当然。翻一翻规范，发现它其实是使用的另一种比较方法，叫作“SameValueZero”比较（\x3ca href=\x22https:\/\/tc39.github.io\/ecma262\/2016\/#sec-samevaluezero\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/tc39.github.io\/ecma26...\x3c\/a\x3e）。\x3c\/p\x3e\n\x3cblockquote\x3e\x3col\x3e\n\x3cli\x3e\x3cp\x3eIf Type(x) is different from Type(y), return false.\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3eIf Type(x) is Number, then\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3eIf x is NaN and y is NaN, return true.\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eIf x is \x2b0 and y is -0, return true.\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eIf x is -0 and y is \x2b0, return true.\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eIf x is the same Number value as y, return true.\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eReturn false.\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eReturn SameValueNonNumber(x, y).\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\x3c\/blockquote\x3e\n\x3cp\x3e注意\x3ccode\x3e2.a\x3c\/code\x3e，如果\x3ccode\x3ex\x3c\/code\x3e和\x3ccode\x3ey\x3c\/code\x3e都是\x3ccode\x3eNaN\x3c\/code\x3e，则返回\x3ccode\x3etrue\x3c\/code\x3e！也就是\x3ccode\x3eincludes()\x3c\/code\x3e是可以正确判断是否包含了\x3ccode\x3eNaN\x3c\/code\x3e的。我们写一段代码验证一下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var arr = [1, 2, NaN];\narr.indexOf(NaN); \/\/ -1\narr.includes(NaN); \/\/ true\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e arr = [\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-literal\x22\x3eNaN\x3c\/span\x3e];\narr.indexOf(\x3cspan class=\x22hljs-literal\x22\x3eNaN\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ -1\x3c\/span\x3e\narr.includes(\x3cspan class=\x22hljs-literal\x22\x3eNaN\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可以看到\x3ccode\x3eindexOf()\x3c\/code\x3e和\x3ccode\x3eincludes()\x3c\/code\x3e对待\x3ccode\x3eNaN\x3c\/code\x3e的行为是完全不一样的。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3e一些方案\x3c\/h2\x3e\n\x3cp\x3e从上面的一大段文字中，我们可以看到，要判断两个元素是否相等（重复）并不是一件简单的事情。在了解了这个背景后，我们来看一些前面没有涉及到的去重方案。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e遍历\x3c\/h3\x3e\n\x3cp\x3e双重遍历是最容易想到的去重方案：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function unique(arr) {\n    var ret = [];\n    var len = arr.length;\n    var isRepeat;\n    for(var i=0; i\x3clen; i\x2b\x2b) {\n        isRepeat = false;\n        for(var j=i\x2b1; j\x3clen; j\x2b\x2b) {\n            if(arr[i] === arr[j]){\n                isRepeat = true;\n                break;\n            }\n        }\n        if(!isRepeat){\n            ret.push(arr[i]);\n        }\n    }\n    return ret;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eunique\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3earr\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e ret = [];\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e len = arr.length;\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e isRepeat;\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i=\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i\x26lt;len; i\x2b\x2b) {\n        isRepeat = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e j=i\x2b\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e; j\x26lt;len; j\x2b\x2b) {\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(arr[i] === arr[j]){\n                isRepeat = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n                \x3cspan class=\x22hljs-keyword\x22\x3ebreak\x3c\/span\x3e;\n            }\n        }\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(!isRepeat){\n            ret.push(arr[i]);\n        }\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e ret;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e双重遍历还有一个优化版本，但是原理和复杂度几乎完全一样：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function unique(arr) {\n    var ret = [];\n    var len = arr.length;\n    for(var i=0; i\x3clen; i\x2b\x2b){\n        for(var j=i\x2b1; j\x3clen; j\x2b\x2b){\n            if(arr[i] === arr[j]){\n                j = \x2b\x2bi;\n            }\n        }\n        ret.push(arr[i]);\n    }\n    return ret;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eunique\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3earr\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e ret = [];\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e len = arr.length;\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i=\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i\x26lt;len; i\x2b\x2b){\n        \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e j=i\x2b\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e; j\x26lt;len; j\x2b\x2b){\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(arr[i] === arr[j]){\n                j = \x2b\x2bi;\n            }\n        }\n        ret.push(arr[i]);\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e ret;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这种方案没什么大问题，用于去重的比较部分也是自己编写实现（\x3ccode\x3earr[i] === arr[j]\x3c\/code\x3e），所以相等性可以自己针对上文说到的各种情况加以特殊处理。唯一比较受诟病的是使用了双重循环，时间复杂度比较高，性能一般。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3e使用对象key来去重\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function unique(arr) {\n    var ret = [];\n    var len = arr.length;\n    var tmp = {};\n    for(var i=0; i\x3clen; i\x2b\x2b){\n        if(!tmp[arr[i]]){\n            tmp[arr[i]] = 1;\n            ret.push(arr[i]);\n        }\n    }\n    return ret;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eunique\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3earr\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e ret = [];\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e len = arr.length;\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e tmp = {};\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i=\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i\x26lt;len; i\x2b\x2b){\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(!tmp[arr[i]]){\n            tmp[arr[i]] = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n            ret.push(arr[i]);\n        }\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e ret;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这种方法是利用了对象（\x3ccode\x3etmp\x3c\/code\x3e）的key不可以重复的特性来进行去重。但由于对象key只能为字符串，因此这种去重方法有许多局限性：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e无法区分隐式类型转换成字符串后一样的值，比如\x3ccode\x3e1\x3c\/code\x3e和\x3ccode\x3e\x271\x27\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e无法处理复杂数据类型，比如对象（因为对象作为key会变成\x3ccode\x3e[object Object]\x3c\/code\x3e）\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e特殊数据，比如\x3ccode\x3e\x27__proto__\x27\x3c\/code\x3e会挂掉，因为\x3ccode\x3etmp\x3c\/code\x3e对象的\x3ccode\x3e__proto__\x3c\/code\x3e属性无法被重写\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e对于第一点，有人提出可以为对象的key增加一个类型，或者将类型放到对象的value中来解决：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function unique(arr) {\n    var ret = [];\n    var len = arr.length;\n    var tmp = {};\n    var tmpKey;\n    for(var i=0; i\x3clen; i\x2b\x2b){\n        tmpKey = typeof arr[i] \x2b arr[i];\n        if(!tmp[tmpKey]){\n            tmp[tmpKey] = 1;\n            ret.push(arr[i]);\n        }\n    }\n    return ret;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eunique\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3earr\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e ret = [];\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e len = arr.length;\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e tmp = {};\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e tmpKey;\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i=\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i\x26lt;len; i\x2b\x2b){\n        tmpKey = \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e arr[i] \x2b arr[i];\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(!tmp[tmpKey]){\n            tmp[tmpKey] = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n            ret.push(arr[i]);\n        }\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e ret;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e该方案也同时解决第三个问题。\x3c\/p\x3e\n\x3cp\x3e而第二个问题，如果像上文所说，在允许对对象进行自定义的比较规则，也可以将对象序列化之后作为key来使用。这里为简单起见，使用\x3ccode\x3eJSON.stringify()\x3c\/code\x3e进行序列化。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function unique(arr) {\n    var ret = [];\n    var len = arr.length;\n    var tmp = {};\n    var tmpKey;\n    for(var i=0; i\x3clen; i\x2b\x2b){\n        tmpKey = typeof arr[i] \x2b JSON.stringify(arr[i]);\n        if(!tmp[tmpKey]){\n            tmp[tmpKey] = 1;\n            ret.push(arr[i]);\n        }\n    }\n    return ret;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eunique\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3earr\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e ret = [];\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e len = arr.length;\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e tmp = {};\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e tmpKey;\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i=\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i\x26lt;len; i\x2b\x2b){\n        tmpKey = \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e arr[i] \x2b \x3cspan class=\x22hljs-built_in\x22\x3eJSON\x3c\/span\x3e.stringify(arr[i]);\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(!tmp[tmpKey]){\n            tmp[tmpKey] = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n            ret.push(arr[i]);\n        }\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e ret;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3eMap Key\x3c\/h3\x3e\n\x3cp\x3e可以看到，使用对象key来处理数组去重的问题，其实是一件比较麻烦的事情，处理不好很容易导致结果不正确。而这些问题的根本原因就是因为key在使用时有限制。\x3c\/p\x3e\n\x3cp\x3e那么，能不能有一种key使用没有限制的对象呢？答案是——真的有！那就是ES2015中的\x3ccode\x3eMap\x3c\/code\x3e。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e\x3ccode\x3eMap\x3c\/code\x3e是一种新的数据类型，可以把它想象成key类型没有限制的对象。此外，它的存取使用单独的\x3ccode\x3eget()\x3c\/code\x3e、\x3ccode\x3eset()\x3c\/code\x3e接口。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var tmp = new Map();\ntmp.set(1, 1);\ntmp.get(1); \/\/ 1\n\ntmp.set(\x272\x27, 2);\ntmp.get(\x272\x27); \/\/ 2\n\ntmp.set(true, 3);\ntmp.get(true); \/\/ 3\n\ntmp.set(undefined, 4);\ntmp.get(undefined); \/\/ 4\n\ntmp.set(NaN, 5);\ntmp.get(NaN); \/\/ 5\n\nvar arr = [], obj = {};\n\ntmp.set(arr, 6);\ntmp.get(arr); \/\/ 6\n\ntmp.set(obj, 7);\ntmp.get(obj); \/\/ 7\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e tmp = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eMap\x3c\/span\x3e();\ntmp.set(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\ntmp.get(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 1\x3c\/span\x3e\n\ntmp.set(\x3cspan class=\x22hljs-string\x22\x3e\x272\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e);\ntmp.get(\x3cspan class=\x22hljs-string\x22\x3e\x272\x27\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 2\x3c\/span\x3e\n\ntmp.set(\x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e);\ntmp.get(\x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 3\x3c\/span\x3e\n\ntmp.set(\x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e);\ntmp.get(\x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 4\x3c\/span\x3e\n\ntmp.set(\x3cspan class=\x22hljs-literal\x22\x3eNaN\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e);\ntmp.get(\x3cspan class=\x22hljs-literal\x22\x3eNaN\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 5\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e arr = [], obj = {};\n\ntmp.set(arr, \x3cspan class=\x22hljs-number\x22\x3e6\x3c\/span\x3e);\ntmp.get(arr); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 6\x3c\/span\x3e\n\ntmp.set(obj, \x3cspan class=\x22hljs-number\x22\x3e7\x3c\/span\x3e);\ntmp.get(obj); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 7\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e由于Map使用单独的接口来存取数据，所以不用担心key会和内置属性重名（如上文提到的\x3ccode\x3e__proto__\x3c\/code\x3e）。使用\x3ccode\x3eMap\x3c\/code\x3e改写一下我们的去重方法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function unique(arr) {\n    var ret = [];\n    var len = arr.length;\n    var tmp = new Map();\n    for(var i=0; i\x3clen; i\x2b\x2b){\n        if(!tmp.get(arr[i])){\n            tmp.set(arr[i], 1);\n            ret.push(arr[i]);\n        }\n    }\n    return ret;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eunique\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3earr\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e ret = [];\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e len = arr.length;\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e tmp = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eMap\x3c\/span\x3e();\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i=\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i\x26lt;len; i\x2b\x2b){\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(!tmp.get(arr[i])){\n            tmp.set(arr[i], \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\n            ret.push(arr[i]);\n        }\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e ret;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader11\x22\x3eSet\x3c\/h3\x3e\n\x3cp\x3e既然都用到了ES2015，数组这件事情不能再简单一点么？当然可以。\x3c\/p\x3e\n\x3cp\x3e除了\x3ccode\x3eMap\x3c\/code\x3e以外，ES2015还引入了一种叫作\x3ccode\x3eSet\x3c\/code\x3e的数据类型。顾名思义，\x3ccode\x3eSet\x3c\/code\x3e就是集合的意思，它不允许重复元素出现，这一点和数学中对集合的定义还是比较像的。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var s = new Set();\ns.add(1);\ns.add(\x271\x27);\ns.add(null);\ns.add(undefined);\ns.add(NaN);\ns.add(true);\ns.add([]);\ns.add({});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e s = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eSet\x3c\/span\x3e();\ns.add(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\ns.add(\x3cspan class=\x22hljs-string\x22\x3e\x271\x27\x3c\/span\x3e);\ns.add(\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e);\ns.add(\x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e);\ns.add(\x3cspan class=\x22hljs-literal\x22\x3eNaN\x3c\/span\x3e);\ns.add(\x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e);\ns.add([]);\ns.add({});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果你重复添加同一个元素的话，\x3ccode\x3eSet\x3c\/code\x3e中只会存在一个。包括\x3ccode\x3eNaN\x3c\/code\x3e也是这样。于是我们想到，这么好的特性，要是能和数组互相转换，不就可以去重了吗？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function unique(arr){\n    var set = new Set(arr);\n    return Array.from(set);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eunique\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3earr\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e set = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eSet\x3c\/span\x3e(arr);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.from(set);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们讨论了这么久的事情，居然两行代码搞定了，简直不可思议。\x3c\/p\x3e\n\x3cp\x3e然而，不要只顾着高兴了。有一句话是这么说的“不要因为走得太远而忘了为什么出发”。我们为什么要为数组去重呢？因为我们想得到不重复的元素列表。而既然已经有\x3ccode\x3eSet\x3c\/code\x3e了，我们为什么还要舍近求远，使用数组呢？是不是在需要去重的情况下，直接使用\x3ccode\x3eSet\x3c\/code\x3e就解决问题了？这个问题值得思考。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader12\x22\x3e小结\x3c\/h2\x3e\n\x3cp\x3e最后，用一个测试用例总结一下文中出现的各种去重方法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var arr = [1,1,\x271\x27,\x271\x27,0,0,\x270\x27,\x270\x27,undefined,undefined,null,null,NaN,NaN,{},{},[],[],\/a\/,\/a\/]\nconsole.log(unique(arr));\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e arr = [\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x271\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x271\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x270\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x270\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e,\x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e,\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e,\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e,\x3cspan class=\x22hljs-literal\x22\x3eNaN\x3c\/span\x3e,\x3cspan class=\x22hljs-literal\x22\x3eNaN\x3c\/span\x3e,{},{},[],[],\/a\/,\/a\/]\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(unique(arr));\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e\x3cp\x3e测试中没有定义对象的比较方法，因此默认情况下，对象不去重是正确的结果，去重是不正确的结果。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ctable\x3e\n\x3cthead\x3e\x3ctr\x3e\n\x3cth\x3e方法\x3c\/th\x3e\n\x3cth\x3e结果\x3c\/th\x3e\n\x3cth\x3e说明\x3c\/th\x3e\n\x3c\/tr\x3e\x3c\/thead\x3e\n\x3ctbody\x3e\n\x3ctr\x3e\n\x3ctd\x3eindexOf#1\x3c\/td\x3e\n\x3ctd\x3eNaN被去掉\x3c\/td\x3e\n\x3ctd\x3e \x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eindexOf#2\x3c\/td\x3e\n\x3ctd\x3eNaN重复\x3c\/td\x3e\n\x3ctd\x3e \x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eincludes\x3c\/td\x3e\n\x3ctd\x3e正确\x3c\/td\x3e\n\x3ctd\x3e \x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e双重循环#1\x3c\/td\x3e\n\x3ctd\x3eNaN重复\x3c\/td\x3e\n\x3ctd\x3e \x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e双重循环#2\x3c\/td\x3e\n\x3ctd\x3eNaN重复\x3c\/td\x3e\n\x3ctd\x3e \x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e对象#1\x3c\/td\x3e\n\x3ctd\x3e字符串和数字无法区分，对象、数组、正则表达式被去重\x3c\/td\x3e\n\x3ctd\x3e \x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e对象#2\x3c\/td\x3e\n\x3ctd\x3e对象、数组、正则表达式被去重\x3c\/td\x3e\n\x3ctd\x3e \x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e对象#3\x3c\/td\x3e\n\x3ctd\x3e对象、数组被去重，正则表达式被消失\x3c\/td\x3e\n\x3ctd\x3eJSON.stringify(\/a\/)结果为{}，和空对象一样\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eMap\x3c\/td\x3e\n\x3ctd\x3e正确\x3c\/td\x3e\n\x3ctd\x3e　\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eSet\x3c\/td\x3e\n\x3ctd\x3e正确\x3c\/td\x3e\n\x3ctd\x3e　\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3c\/tbody\x3e\n\x3c\/table\x3e\n\x3cp\x3e最后的最后：任何脱离场景谈技术都是妄谈，本文也一样。去重这道题，没有正确答案，请根据场景选择合适的去重方法。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>也谈JavaScript数组去重</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000008031081">https://segmentfault.com/a/1190000008031081</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/vda4333rfwn/" target="_blank">https://alili.tech/archive/vda4333rfwn/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>