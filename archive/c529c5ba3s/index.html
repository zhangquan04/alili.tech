<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="30分钟，让你彻底明白Promise原理"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>30分钟，让你彻底明白Promise原理 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/c529c5ba3s/",
				"appid": "1613049289050283", 
				"title": "30分钟，让你彻底明白Promise原理 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-14T02:30:07"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/i6xi3ai08e/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/h0p5utnd1td/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fc529c5ba3s%2f&text=30%e5%88%86%e9%92%9f%ef%bc%8c%e8%ae%a9%e4%bd%a0%e5%bd%bb%e5%ba%95%e6%98%8e%e7%99%bdPromise%e5%8e%9f%e7%90%86"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fc529c5ba3s%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fc529c5ba3s%2f&text=30%e5%88%86%e9%92%9f%ef%bc%8c%e8%ae%a9%e4%bd%a0%e5%bd%bb%e5%ba%95%e6%98%8e%e7%99%bdPromise%e5%8e%9f%e7%90%86"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fc529c5ba3s%2f&title=30%e5%88%86%e9%92%9f%ef%bc%8c%e8%ae%a9%e4%bd%a0%e5%bd%bb%e5%ba%95%e6%98%8e%e7%99%bdPromise%e5%8e%9f%e7%90%86"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fc529c5ba3s%2f&is_video=false&description=30%e5%88%86%e9%92%9f%ef%bc%8c%e8%ae%a9%e4%bd%a0%e5%bd%bb%e5%ba%95%e6%98%8e%e7%99%bdPromise%e5%8e%9f%e7%90%86"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=30%e5%88%86%e9%92%9f%ef%bc%8c%e8%ae%a9%e4%bd%a0%e5%bd%bb%e5%ba%95%e6%98%8e%e7%99%bdPromise%e5%8e%9f%e7%90%86&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fc529c5ba3s%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fc529c5ba3s%2f&title=30%e5%88%86%e9%92%9f%ef%bc%8c%e8%ae%a9%e4%bd%a0%e5%bd%bb%e5%ba%95%e6%98%8e%e7%99%bdPromise%e5%8e%9f%e7%90%86"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fc529c5ba3s%2f&title=30%e5%88%86%e9%92%9f%ef%bc%8c%e8%ae%a9%e4%bd%a0%e5%bd%bb%e5%ba%95%e6%98%8e%e7%99%bdPromise%e5%8e%9f%e7%90%86"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fc529c5ba3s%2f&title=30%e5%88%86%e9%92%9f%ef%bc%8c%e8%ae%a9%e4%bd%a0%e5%bd%bb%e5%ba%95%e6%98%8e%e7%99%bdPromise%e5%8e%9f%e7%90%86"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fc529c5ba3s%2f&title=30%e5%88%86%e9%92%9f%ef%bc%8c%e8%ae%a9%e4%bd%a0%e5%bd%bb%e5%ba%95%e6%98%8e%e7%99%bdPromise%e5%8e%9f%e7%90%86"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">30分钟，让你彻底明白Promise原理</h1><div class="meta"><div class="postdate"><time datetime="2019-01-14" itemprop="datePublished">2019-01-14</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e\x3ca href=\x22https:\/\/mengera88.github.io\/2017\/05\/18\/Promise%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e原文链接\x3c\/a\x3e\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader0\x22\x3e前言\x3c\/h1\x3e\n\x3cp\x3e前一阵子记录了promise的一些常规用法，这篇文章再深入一个层次，来分析分析promise的这种规则机制是如何实现的。ps:本文适合已经对promise的用法有所了解的人阅读,如果对其用法还不是太了解，可以移步我的上一篇\x3ca href=\x22https:\/\/mengera88.github.io\/2017\/05\/15\/promise%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e博文\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3e本文的promise源码是按照\x3ca href=\x22https:\/\/promisesaplus.com\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ePromise\/A\x2b规范\x3c\/a\x3e来编写的（不想看英文版的移步\x3ca href=\x22http:\/\/www.ituring.com.cn\/article\/66566\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ePromise\/A\x2b规范中文翻译\x3c\/a\x3e）\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader1\x22\x3e引子\x3c\/h1\x3e\n\x3cp\x3e为了让大家更容易理解，我们从一个场景开始讲解，让大家一步一步跟着思路思考，相信你一定会更容易看懂。\x3c\/p\x3e\n\x3cp\x3e考虑下面一种获取用户id的请求处理\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/例1\nfunction getUserId() {\n    return new Promise(function(resolve) {\n        \/\/异步请求\n        http.get(url, function(results) {\n            resolve(results.id)\n        })\n    })\n}\n\ngetUserId().then(function(id) {\n    \/\/一些处理\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/例1\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3egetUserId\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/异步请求\x3c\/span\x3e\n        http.get(url, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eresults\x3c\/span\x3e) \x3c\/span\x3e{\n            resolve(results.id)\n        })\n    })\n}\n\ngetUserId().then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eid\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/一些处理\x3c\/span\x3e\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3egetUserId\x3c\/code\x3e方法返回一个\x3ccode\x3epromise\x3c\/code\x3e，可以通过它的\x3ccode\x3ethen\x3c\/code\x3e方法注册(注意\x3ccode\x3e注册\x3c\/code\x3e这个词)在\x3ccode\x3epromise\x3c\/code\x3e异步操作成功时执行的回调。这种执行方式，使得异步调用变得十分顺手。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader2\x22\x3e原理剖析\x3c\/h1\x3e\n\x3cp\x3e那么类似这种功能的\x3ccode\x3ePromise\x3c\/code\x3e怎么实现呢？其实按照上面一句话，实现一个最基础的雏形还是很easy的。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e极简promise雏形\x3c\/h2\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Promise(fn) {\n    var value = null,\n        callbacks = [];  \/\/callbacks为数组，因为可能同时有很多个回调\n\n    this.then = function (onFulfilled) {\n        callbacks.push(onFulfilled);\n    };\n\n    function resolve(value) {\n        callbacks.forEach(function (callback) {\n            callback(value);\n        });\n    }\n\n    fn(resolve);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3efn\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e value = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e,\n        callbacks = [];  \x3cspan class=\x22hljs-comment\x22\x3e\/\/callbacks为数组，因为可能同时有很多个回调\x3c\/span\x3e\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.then = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eonFulfilled\x3c\/span\x3e) \x3c\/span\x3e{\n        callbacks.push(onFulfilled);\n    };\n\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eresolve\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3evalue\x3c\/span\x3e) \x3c\/span\x3e{\n        callbacks.forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ecallback\x3c\/span\x3e) \x3c\/span\x3e{\n            callback(value);\n        });\n    }\n\n    fn(resolve);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上述代码很简单，大致的逻辑是这样的：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e调用\x3ccode\x3ethen\x3c\/code\x3e方法，将想要在\x3ccode\x3ePromise\x3c\/code\x3e异步操作成功时执行的回调放入\x3ccode\x3ecallbacks\x3c\/code\x3e队列，其实也就是注册回调函数，可以向观察者模式方向思考；\x3c\/li\x3e\n\x3cli\x3e创建\x3ccode\x3ePromise\x3c\/code\x3e实例时传入的函数会被赋予一个函数类型的参数，即\x3ccode\x3eresolve\x3c\/code\x3e，它接收一个参数value，代表异步操作返回的结果，当一步操作执行成功后，用户会调用\x3ccode\x3eresolve\x3c\/code\x3e方法，这时候其实真正执行的操作是将\x3ccode\x3ecallbacks\x3c\/code\x3e队列中的回调一一执行；\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e可以结合\x3ccode\x3e例1\x3c\/code\x3e中的代码来看，首先\x3ccode\x3enew Promise\x3c\/code\x3e时，传给\x3ccode\x3epromise\x3c\/code\x3e的函数发送异步请求，接着调用\x3ccode\x3epromise\x3c\/code\x3e对象的\x3ccode\x3ethen\x3c\/code\x3e属性，注册请求成功的回调函数，然后当异步请求发送成功时，调用\x3ccode\x3eresolve(results.id)\x3c\/code\x3e方法, 该方法执行\x3ccode\x3ethen\x3c\/code\x3e方法注册的回调数组。\x3c\/p\x3e\n\x3cp\x3e相信仔细的人应该可以看出来，\x3ccode\x3ethen\x3c\/code\x3e方法应该能够链式调用，但是上面的最基础简单的版本显然无法支持链式调用。想让\x3ccode\x3ethen\x3c\/code\x3e方法支持链式调用，其实也是很简单的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22this.then = function (onFulfilled) {\n    callbacks.push(onFulfilled);\n    return this;\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.then = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eonFulfilled\x3c\/span\x3e) \x3c\/span\x3e{\n    callbacks.push(onFulfilled);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3esee?只要简单一句话就可以实现类似下面的链式调用：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 例2\ngetUserId().then(function (id) {\n    \/\/ 一些处理\n}).then(function (id) {\n    \/\/ 一些处理\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 例2\x3c\/span\x3e\ngetUserId().then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eid\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 一些处理\x3c\/span\x3e\n}).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eid\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 一些处理\x3c\/span\x3e\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e加入延时机制\x3c\/h2\x3e\n\x3cp\x3e细心的同学应该发现，上述代码可能还存在一个问题：如果在\x3ccode\x3ethen\x3c\/code\x3e方法注册回调之前，\x3ccode\x3eresolve\x3c\/code\x3e函数就执行了，怎么办？比如\x3ccode\x3epromise\x3c\/code\x3e内部的函数是同步函数：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 例3\nfunction getUserId() {\n    return new Promise(function (resolve) {\n        resolve(9876);\n    });\n}\ngetUserId().then(function (id) {\n    \/\/ 一些处理\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 例3\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3egetUserId\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eresolve\x3c\/span\x3e) \x3c\/span\x3e{\n        resolve(\x3cspan class=\x22hljs-number\x22\x3e9876\x3c\/span\x3e);\n    });\n}\ngetUserId().then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eid\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 一些处理\x3c\/span\x3e\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这显然是不允许的，\x3ccode\x3ePromises\/A\x2b\x3c\/code\x3e规范明确要求回调需要通过异步方式执行，用以保证一致可靠的执行顺序。因此我们要加入一些处理，保证在\x3ccode\x3eresolve\x3c\/code\x3e执行之前，\x3ccode\x3ethen\x3c\/code\x3e方法已经注册完所有的回调。我们可以这样改造下\x3ccode\x3eresolve\x3c\/code\x3e函数:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function resolve(value) {\n    setTimeout(function() {\n        callbacks.forEach(function (callback) {\n            callback(value);\n        });\n    }, 0)\n} \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eresolve\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3evalue\x3c\/span\x3e) \x3c\/span\x3e{\n    setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        callbacks.forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ecallback\x3c\/span\x3e) \x3c\/span\x3e{\n            callback(value);\n        });\n    }, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e)\n} \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上述代码的思路也很简单，就是通过\x3ccode\x3esetTimeout\x3c\/code\x3e机制，将\x3ccode\x3eresolve\x3c\/code\x3e中执行回调的逻辑放置到\x3ccode\x3eJS\x3c\/code\x3e任务队列末尾，以保证在\x3ccode\x3eresolve\x3c\/code\x3e执行时，\x3ccode\x3ethen\x3c\/code\x3e方法的回调函数已经注册完成.\x3c\/p\x3e\n\x3cp\x3e但是，这样好像还存在一个问题，可以细想一下：如果\x3ccode\x3ePromise\x3c\/code\x3e异步操作已经成功，这时，在异步操作成功之前注册的回调都会执行，但是在\x3ccode\x3ePromise\x3c\/code\x3e异步操作成功这之后调用的\x3ccode\x3ethen\x3c\/code\x3e注册的回调就再也不会执行了，这显然不是我们想要的。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e加入状态\x3c\/h2\x3e\n\x3cp\x3e恩，为了解决上一节抛出的问题，我们必须加入状态机制，也就是大家熟知的\x3ccode\x3epending\x3c\/code\x3e、\x3ccode\x3efulfilled\x3c\/code\x3e、\x3ccode\x3erejected\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3ePromises\/A\x2b\x3c\/code\x3e规范中的2.1\x3ccode\x3ePromise States\x3c\/code\x3e中明确规定了，\x3ccode\x3epending\x3c\/code\x3e可以转化为\x3ccode\x3efulfilled\x3c\/code\x3e或\x3ccode\x3erejected\x3c\/code\x3e并且只能转化一次，也就是说如果\x3ccode\x3epending\x3c\/code\x3e转化到\x3ccode\x3efulfilled\x3c\/code\x3e状态，那么就不能再转化到\x3ccode\x3erejected\x3c\/code\x3e。并且\x3ccode\x3efulfilled\x3c\/code\x3e和\x3ccode\x3erejected\x3c\/code\x3e状态只能由\x3ccode\x3epending\x3c\/code\x3e转化而来，两者之间不能互相转换。一图胜千言：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000009478380?w=353\x26amp;h=260\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000009478380?w=353\x26amp;h=260\x22 alt=\x22alt promise state\x22 title=\x22alt promise state\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e改进后的代码是这样的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Promise(fn) {\n    var state = \x27pending\x27,\n        value = null,\n        callbacks = [];\n\n    this.then = function (onFulfilled) {\n        if (state === \x27pending\x27) {\n            callbacks.push(onFulfilled);\n            return this;\n        }\n        onFulfilled(value);\n        return this;\n    };\n\n    function resolve(newValue) {\n        value = newValue;\n        state = \x27fulfilled\x27;\n        setTimeout(function () {\n            callbacks.forEach(function (callback) {\n                callback(value);\n            });\n        }, 0);\n    }\n\n    fn(resolve);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3efn\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e state = \x3cspan class=\x22hljs-string\x22\x3e\x27pending\x27\x3c\/span\x3e,\n        value = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e,\n        callbacks = [];\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.then = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eonFulfilled\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (state === \x3cspan class=\x22hljs-string\x22\x3e\x27pending\x27\x3c\/span\x3e) {\n            callbacks.push(onFulfilled);\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n        }\n        onFulfilled(value);\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n    };\n\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eresolve\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3enewValue\x3c\/span\x3e) \x3c\/span\x3e{\n        value = newValue;\n        state = \x3cspan class=\x22hljs-string\x22\x3e\x27fulfilled\x27\x3c\/span\x3e;\n        setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n            callbacks.forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ecallback\x3c\/span\x3e) \x3c\/span\x3e{\n                callback(value);\n            });\n        }, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n    }\n\n    fn(resolve);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上述代码的思路是这样的：\x3ccode\x3eresolve\x3c\/code\x3e执行时，会将状态设置为\x3ccode\x3efulfilled\x3c\/code\x3e，在此之后调用\x3ccode\x3ethen\x3c\/code\x3e添加的新回调，都会立即执行。\x3c\/p\x3e\n\x3cp\x3e这里没有任何地方将\x3ccode\x3estate\x3c\/code\x3e设为\x3ccode\x3erejected\x3c\/code\x3e，为了让大家聚焦在核心代码上，这个问题后面会有一小节专门加入。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3e链式Promise\x3c\/h2\x3e\n\x3cp\x3e那么这里问题又来了，如果用户再then函数里面注册的仍然是一个\x3ccode\x3ePromise\x3c\/code\x3e，该如何解决？比如下面的\x3ccode\x3e例4\x3c\/code\x3e：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 例4\ngetUserId()\n    .then(getUserJobById)\n    .then(function (job) {\n        \/\/ 对job的处理\n    });\n\nfunction getUserJobById(id) {\n    return new Promise(function (resolve) {\n        http.get(baseUrl \x2b id, function(job) {\n            resolve(job);\n        });\n    });\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 例4\x3c\/span\x3e\ngetUserId()\n    .then(getUserJobById)\n    .then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ejob\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 对job的处理\x3c\/span\x3e\n    });\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3egetUserJobById\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eid\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eresolve\x3c\/span\x3e) \x3c\/span\x3e{\n        http.get(baseUrl \x2b id, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ejob\x3c\/span\x3e) \x3c\/span\x3e{\n            resolve(job);\n        });\n    });\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这种场景相信用过\x3ccode\x3epromise\x3c\/code\x3e的人都知道会有很多，那么类似这种就是所谓的链式\x3ccode\x3ePromise\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e链式\x3ccode\x3ePromise\x3c\/code\x3e是指在当前\x3ccode\x3epromise\x3c\/code\x3e达到\x3ccode\x3efulfilled\x3c\/code\x3e状态后，即开始进行下一个\x3ccode\x3epromise\x3c\/code\x3e（后邻\x3ccode\x3epromise\x3c\/code\x3e）。那么我们如何衔接当前\x3ccode\x3epromise\x3c\/code\x3e和后邻\x3ccode\x3epromise\x3c\/code\x3e呢？（这是这里的难点）。\x3c\/p\x3e\n\x3cp\x3e其实也不是辣么难，只要在\x3ccode\x3ethen\x3c\/code\x3e方法里面\x3ccode\x3ereturn\x3c\/code\x3e一个\x3ccode\x3epromise\x3c\/code\x3e就好啦。\x3ccode\x3ePromises\/A\x2b\x3c\/code\x3e规范中的2.2.7就是这么说哒(微笑脸)~\x3c\/p\x3e\n\x3cp\x3e下面来看看这段暗藏玄机的\x3ccode\x3ethen\x3c\/code\x3e方法和\x3ccode\x3eresolve\x3c\/code\x3e方法改造代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\nfunction Promise(fn) {\n    var state = \x27pending\x27,\n        value = null,\n        callbacks = [];\n\n    this.then = function (onFulfilled) {\n        return new Promise(function (resolve) {\n            handle({\n                onFulfilled: onFulfilled || null,\n                resolve: resolve\n            });\n        });\n    };\n\n    function handle(callback) {\n        if (state === \x27pending\x27) {\n            callbacks.push(callback);\n            return;\n        }\n        \/\/如果then中没有传递任何东西\n        if(!callback.onFulfilled) {\n            callback.resolve(value);\n            return;\n        }\n\n        var ret = callback.onFulfilled(value);\n        callback.resolve(ret);\n    }\n\n    \n    function resolve(newValue) {\n        if (newValue \x26amp;\x26amp; (typeof newValue === \x27object\x27 || typeof newValue === \x27function\x27)) {\n            var then = newValue.then;\n            if (typeof then === \x27function\x27) {\n                then.call(newValue, resolve);\n                return;\n            }\n        }\n        state = \x27fulfilled\x27;\n        value = newValue;\n        setTimeout(function () {\n            callbacks.forEach(function (callback) {\n                handle(callback);\n            });\n        }, 0);\n    }\n\n    fn(resolve);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3efn\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e state = \x3cspan class=\x22hljs-string\x22\x3e\x27pending\x27\x3c\/span\x3e,\n        value = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e,\n        callbacks = [];\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.then = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eonFulfilled\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eresolve\x3c\/span\x3e) \x3c\/span\x3e{\n            handle({\n                \x3cspan class=\x22hljs-attr\x22\x3eonFulfilled\x3c\/span\x3e: onFulfilled || \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e,\n                \x3cspan class=\x22hljs-attr\x22\x3eresolve\x3c\/span\x3e: resolve\n            });\n        });\n    };\n\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ehandle\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ecallback\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (state === \x3cspan class=\x22hljs-string\x22\x3e\x27pending\x27\x3c\/span\x3e) {\n            callbacks.push(callback);\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n        }\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果then中没有传递任何东西\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(!callback.onFulfilled) {\n            callback.resolve(value);\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n        }\n\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e ret = callback.onFulfilled(value);\n        callback.resolve(ret);\n    }\n\n    \n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eresolve\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3enewValue\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (newValue \x26amp;\x26amp; (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e newValue === \x3cspan class=\x22hljs-string\x22\x3e\x27object\x27\x3c\/span\x3e || \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e newValue === \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e)) {\n            \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e then = newValue.then;\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e then === \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e) {\n                then.call(newValue, resolve);\n                \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n            }\n        }\n        state = \x3cspan class=\x22hljs-string\x22\x3e\x27fulfilled\x27\x3c\/span\x3e;\n        value = newValue;\n        setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n            callbacks.forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ecallback\x3c\/span\x3e) \x3c\/span\x3e{\n                handle(callback);\n            });\n        }, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n    }\n\n    fn(resolve);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们结合\x3ccode\x3e例4\x3c\/code\x3e的代码，分析下上面的代码逻辑，为了方便阅读，我把\x3ccode\x3e例4\x3c\/code\x3e的代码贴在这里：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 例4\ngetUserId()\n    .then(getUserJobById)\n    .then(function (job) {\n        \/\/ 对job的处理\n    });\n\nfunction getUserJobById(id) {\n    return new Promise(function (resolve) {\n        http.get(baseUrl \x2b id, function(job) {\n            resolve(job);\n        });\n    });\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 例4\x3c\/span\x3e\ngetUserId()\n    .then(getUserJobById)\n    .then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ejob\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 对job的处理\x3c\/span\x3e\n    });\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3egetUserJobById\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eid\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eresolve\x3c\/span\x3e) \x3c\/span\x3e{\n        http.get(baseUrl \x2b id, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ejob\x3c\/span\x3e) \x3c\/span\x3e{\n            resolve(job);\n        });\n    });\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3col\x3e\n\x3cli\x3e\n\x3ccode\x3ethen\x3c\/code\x3e方法中，创建并返回了新的\x3ccode\x3ePromise\x3c\/code\x3e实例，这是串行\x3ccode\x3ePromise\x3c\/code\x3e的基础，并且支持链式调用。\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3ehandle\x3c\/code\x3e方法是\x3ccode\x3epromise\x3c\/code\x3e内部的方法。\x3ccode\x3ethen\x3c\/code\x3e方法传入的形参\x3ccode\x3eonFulfilled\x3c\/code\x3e以及创建新\x3ccode\x3ePromise\x3c\/code\x3e实例时传入的\x3ccode\x3eresolve\x3c\/code\x3e均被\x3ccode\x3epush\x3c\/code\x3e到当前\x3ccode\x3epromise\x3c\/code\x3e的\x3ccode\x3ecallbacks\x3c\/code\x3e队列中，这是衔接当前\x3ccode\x3epromise\x3c\/code\x3e和后邻\x3ccode\x3epromise\x3c\/code\x3e的关键所在（这里一定要好好的分析下handle的作用）。\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3egetUserId\x3c\/code\x3e生成的\x3ccode\x3epromise\x3c\/code\x3e（简称\x3ccode\x3egetUserId promise\x3c\/code\x3e）异步操作成功，执行其内部方法\x3ccode\x3eresolve\x3c\/code\x3e，传入的参数正是异步操作的结果\x3ccode\x3eid\x3c\/code\x3e\n\x3c\/li\x3e\n\x3cli\x3e调用\x3ccode\x3ehandle\x3c\/code\x3e方法处理\x3ccode\x3ecallbacks\x3c\/code\x3e队列中的回调：\x3ccode\x3egetUserJobById\x3c\/code\x3e方法，生成新的\x3ccode\x3epromise\x3c\/code\x3e（\x3ccode\x3egetUserJobById promise\x3c\/code\x3e）\x3c\/li\x3e\n\x3cli\x3e执行之前由\x3ccode\x3egetUserId promise\x3c\/code\x3e的\x3ccode\x3ethen\x3c\/code\x3e方法生成的新\x3ccode\x3epromise\x3c\/code\x3e(称为\x3ccode\x3ebridge promise\x3c\/code\x3e)的\x3ccode\x3eresolve\x3c\/code\x3e方法，传入参数为\x3ccode\x3egetUserJobById promise\x3c\/code\x3e。这种情况下，会将该\x3ccode\x3eresolve\x3c\/code\x3e方法传入\x3ccode\x3egetUserJobById promise\x3c\/code\x3e的\x3ccode\x3ethen\x3c\/code\x3e方法中，并直接返回。\x3c\/li\x3e\n\x3cli\x3e在\x3ccode\x3egetUserJobById promise\x3c\/code\x3e异步操作成功时，执行其\x3ccode\x3ecallbacks\x3c\/code\x3e中的回调：\x3ccode\x3egetUserId bridge promise\x3c\/code\x3e中的\x3ccode\x3eresolve\x3c\/code\x3e方法\x3c\/li\x3e\n\x3cli\x3e最后执行\x3ccode\x3egetUserId bridge promise\x3c\/code\x3e的后邻\x3ccode\x3epromise\x3c\/code\x3e的\x3ccode\x3ecallbacks\x3c\/code\x3e中的回调。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e更直白的可以看下面的图，一图胜千言（都是根据自己的理解画出来的，如有不对欢迎指正）：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000009478381?w=2137\x26amp;h=1262\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000009478381?w=2137\x26amp;h=1262\x22 alt=\x22alt promise analysis\x22 title=\x22alt promise analysis\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3e失败处理\x3c\/h2\x3e\n\x3cp\x3e在异步操作失败时，标记其状态为\x3ccode\x3erejected\x3c\/code\x3e，并执行注册的失败回调:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/例5\nfunction getUserId() {\n    return new Promise(function(resolve) {\n        \/\/异步请求\n        http.get(url, function(error, results) {\n            if (error) {\n                reject(error);\n            }\n            resolve(results.id)\n        })\n    })\n}\n\ngetUserId().then(function(id) {\n    \/\/一些处理\n}, function(error) {\n    console.log(error)\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/例5\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3egetUserId\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/异步请求\x3c\/span\x3e\n        http.get(url, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eerror, results\x3c\/span\x3e) \x3c\/span\x3e{\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (error) {\n                reject(error);\n            }\n            resolve(results.id)\n        })\n    })\n}\n\ngetUserId().then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eid\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/一些处理\x3c\/span\x3e\n}, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eerror\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(error)\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e有了之前处理\x3ccode\x3efulfilled\x3c\/code\x3e状态的经验，支持错误处理变得很容易,只需要在注册回调、处理状态变更上都要加入新的逻辑：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Promise(fn) {\n    var state = \x27pending\x27,\n        value = null,\n        callbacks = [];\n\n    this.then = function (onFulfilled, onRejected) {\n        return new Promise(function (resolve, reject) {\n            handle({\n                onFulfilled: onFulfilled || null,\n                onRejected: onRejected || null,\n                resolve: resolve,\n                reject: reject\n            });\n        });\n    };\n\n    function handle(callback) {\n        if (state === \x27pending\x27) {\n            callbacks.push(callback);\n            return;\n        }\n\n        var cb = state === \x27fulfilled\x27 ? callback.onFulfilled : callback.onRejected,\n            ret;\n        if (cb === null) {\n            cb = state === \x27fulfilled\x27 ? callback.resolve : callback.reject;\n            cb(value);\n            return;\n        }\n        ret = cb(value);\n        callback.resolve(ret);\n    }\n\n    function resolve(newValue) {\n        if (newValue \x26amp;\x26amp; (typeof newValue === \x27object\x27 || typeof newValue === \x27function\x27)) {\n            var then = newValue.then;\n            if (typeof then === \x27function\x27) {\n                then.call(newValue, resolve, reject);\n                return;\n            }\n        }\n        state = \x27fulfilled\x27;\n        value = newValue;\n        execute();\n    }\n\n    function reject(reason) {\n        state = \x27rejected\x27;\n        value = reason;\n        execute();\n    }\n\n    function execute() {\n        setTimeout(function () {\n            callbacks.forEach(function (callback) {\n                handle(callback);\n            });\n        }, 0);\n    }\n\n    fn(resolve, reject);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3efn\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e state = \x3cspan class=\x22hljs-string\x22\x3e\x27pending\x27\x3c\/span\x3e,\n        value = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e,\n        callbacks = [];\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.then = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eonFulfilled, onRejected\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eresolve, reject\x3c\/span\x3e) \x3c\/span\x3e{\n            handle({\n                \x3cspan class=\x22hljs-attr\x22\x3eonFulfilled\x3c\/span\x3e: onFulfilled || \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e,\n                \x3cspan class=\x22hljs-attr\x22\x3eonRejected\x3c\/span\x3e: onRejected || \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e,\n                \x3cspan class=\x22hljs-attr\x22\x3eresolve\x3c\/span\x3e: resolve,\n                \x3cspan class=\x22hljs-attr\x22\x3ereject\x3c\/span\x3e: reject\n            });\n        });\n    };\n\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ehandle\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ecallback\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (state === \x3cspan class=\x22hljs-string\x22\x3e\x27pending\x27\x3c\/span\x3e) {\n            callbacks.push(callback);\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n        }\n\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e cb = state === \x3cspan class=\x22hljs-string\x22\x3e\x27fulfilled\x27\x3c\/span\x3e ? callback.onFulfilled : callback.onRejected,\n            ret;\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (cb === \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n            cb = state === \x3cspan class=\x22hljs-string\x22\x3e\x27fulfilled\x27\x3c\/span\x3e ? callback.resolve : callback.reject;\n            cb(value);\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n        }\n        ret = cb(value);\n        callback.resolve(ret);\n    }\n\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eresolve\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3enewValue\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (newValue \x26amp;\x26amp; (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e newValue === \x3cspan class=\x22hljs-string\x22\x3e\x27object\x27\x3c\/span\x3e || \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e newValue === \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e)) {\n            \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e then = newValue.then;\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e then === \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e) {\n                then.call(newValue, resolve, reject);\n                \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n            }\n        }\n        state = \x3cspan class=\x22hljs-string\x22\x3e\x27fulfilled\x27\x3c\/span\x3e;\n        value = newValue;\n        execute();\n    }\n\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ereject\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ereason\x3c\/span\x3e) \x3c\/span\x3e{\n        state = \x3cspan class=\x22hljs-string\x22\x3e\x27rejected\x27\x3c\/span\x3e;\n        value = reason;\n        execute();\n    }\n\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eexecute\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n            callbacks.forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ecallback\x3c\/span\x3e) \x3c\/span\x3e{\n                handle(callback);\n            });\n        }, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n    }\n\n    fn(resolve, reject);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上述代码增加了新的\x3ccode\x3ereject\x3c\/code\x3e方法，供异步操作失败时调用，同时抽出了\x3ccode\x3eresolve\x3c\/code\x3e和\x3ccode\x3ereject\x3c\/code\x3e共用的部分，形成\x3ccode\x3eexecute\x3c\/code\x3e方法。\x3c\/p\x3e\n\x3cp\x3e错误冒泡是上述代码已经支持，且非常实用的一个特性。在\x3ccode\x3ehandle\x3c\/code\x3e中发现没有指定异步操作失败的回调时，会直接将\x3ccode\x3ebridge promise\x3c\/code\x3e(\x3ccode\x3ethen\x3c\/code\x3e函数返回的\x3ccode\x3epromise\x3c\/code\x3e，后同)设为\x3ccode\x3erejected\x3c\/code\x3e状态，如此达成执行后续失败回调的效果。这有利于简化串行\x3ccode\x3ePromise\x3c\/code\x3e的失败处理成本，因为一组异步操作往往会对应一个实际功能，失败处理方法通常是一致的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/例6\ngetUserId()\n    .then(getUserJobById)\n    .then(function (job) {\n        \/\/ 处理job\n    }, function (error) {\n        \/\/ getUserId或者getUerJobById时出现的错误\n        console.log(error);\n    });\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/例6\x3c\/span\x3e\ngetUserId()\n    .then(getUserJobById)\n    .then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ejob\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 处理job\x3c\/span\x3e\n    }, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eerror\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ getUserId或者getUerJobById时出现的错误\x3c\/span\x3e\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(error);\n    });\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3e异常处理\x3c\/h2\x3e\n\x3cp\x3e细心的同学会想到：如果在执行成功回调、失败回调时代码出错怎么办？对于这类异常，可以使用\x3ccode\x3etry-catch\x3c\/code\x3e捕获错误，并将\x3ccode\x3ebridge promise\x3c\/code\x3e设为\x3ccode\x3erejected\x3c\/code\x3e状态。\x3ccode\x3ehandle\x3c\/code\x3e方法改造如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function handle(callback) {\n    if (state === \x27pending\x27) {\n        callbacks.push(callback);\n        return;\n    }\n\n    var cb = state === \x27fulfilled\x27 ? callback.onFulfilled : callback.onRejected,\n        ret;\n    if (cb === null) {\n        cb = state === \x27fulfilled\x27 ? callback.resolve : callback.reject;\n        cb(value);\n        return;\n    }\n    try {\n        ret = cb(value);\n        callback.resolve(ret);\n    } catch (e) {\n        callback.reject(e);\n    } \n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ehandle\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ecallback\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (state === \x3cspan class=\x22hljs-string\x22\x3e\x27pending\x27\x3c\/span\x3e) {\n        callbacks.push(callback);\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e cb = state === \x3cspan class=\x22hljs-string\x22\x3e\x27fulfilled\x27\x3c\/span\x3e ? callback.onFulfilled : callback.onRejected,\n        ret;\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (cb === \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n        cb = state === \x3cspan class=\x22hljs-string\x22\x3e\x27fulfilled\x27\x3c\/span\x3e ? callback.resolve : callback.reject;\n        cb(value);\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n        ret = cb(value);\n        callback.resolve(ret);\n    } \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e (e) {\n        callback.reject(e);\n    } \n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果在异步操作中，多次执行\x3ccode\x3eresolve\x3c\/code\x3e或者\x3ccode\x3ereject\x3c\/code\x3e会重复处理后续回调，可以通过内置一个标志位解决。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader9\x22\x3e总结\x3c\/h1\x3e\n\x3cp\x3e刚开始看promise源码的时候总不能很好的理解then和resolve函数的运行机理，但是如果你静下心来，反过来根据执行promise时的逻辑来推演，就不难理解了。这里一定要注意的点是：promise里面的then函数仅仅是注册了后续需要执行的代码，真正的执行是在resolve方法里面执行的，理清了这层，再来分析源码会省力的多。\x3c\/p\x3e\n\x3cp\x3e现在回顾下Promise的实现过程，其主要使用了设计模式中的观察者模式：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e通过Promise.prototype.then和Promise.prototype.catch方法将观察者方法注册到被观察者Promise对象中，同时返回一个新的Promise对象，以便可以链式调用。\x3c\/li\x3e\n\x3cli\x3e被观察者管理内部pending、fulfilled和rejected的状态转变，同时通过构造函数中传递的resolve和reject方法以主动触发状态转变和通知观察者。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch1 id=\x22articleHeader10\x22\x3e参考文献\x3c\/h1\x3e\n\x3cp\x3e\x3ca href=\x22http:\/\/coderlt.coding.me\/2016\/12\/04\/promise-in-depth-an-introduction-2\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e深入理解 Promise\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22http:\/\/www.mattgreer.org\/articles\/promises-in-wicked-detail\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eJavaScript Promises ... In Wicked Detail\x3c\/a\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>30分钟，让你彻底明白Promise原理</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000009478377">https://segmentfault.com/a/1190000009478377</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/c529c5ba3s/" target="_blank">https://alili.tech/archive/c529c5ba3s/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>