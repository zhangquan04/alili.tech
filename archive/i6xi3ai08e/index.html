<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="50 行代码的 HTML 编译器"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>50 行代码的 HTML 编译器 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/i6xi3ai08e/",
				"appid": "1613049289050283", 
				"title": "50 行代码的 HTML 编译器 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-14T02:30:07"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/j7ye228saha/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/c529c5ba3s/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fi6xi3ai08e%2f&text=50%20%e8%a1%8c%e4%bb%a3%e7%a0%81%e7%9a%84%20HTML%20%e7%bc%96%e8%af%91%e5%99%a8"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fi6xi3ai08e%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fi6xi3ai08e%2f&text=50%20%e8%a1%8c%e4%bb%a3%e7%a0%81%e7%9a%84%20HTML%20%e7%bc%96%e8%af%91%e5%99%a8"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fi6xi3ai08e%2f&title=50%20%e8%a1%8c%e4%bb%a3%e7%a0%81%e7%9a%84%20HTML%20%e7%bc%96%e8%af%91%e5%99%a8"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fi6xi3ai08e%2f&is_video=false&description=50%20%e8%a1%8c%e4%bb%a3%e7%a0%81%e7%9a%84%20HTML%20%e7%bc%96%e8%af%91%e5%99%a8"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=50%20%e8%a1%8c%e4%bb%a3%e7%a0%81%e7%9a%84%20HTML%20%e7%bc%96%e8%af%91%e5%99%a8&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fi6xi3ai08e%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fi6xi3ai08e%2f&title=50%20%e8%a1%8c%e4%bb%a3%e7%a0%81%e7%9a%84%20HTML%20%e7%bc%96%e8%af%91%e5%99%a8"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fi6xi3ai08e%2f&title=50%20%e8%a1%8c%e4%bb%a3%e7%a0%81%e7%9a%84%20HTML%20%e7%bc%96%e8%af%91%e5%99%a8"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fi6xi3ai08e%2f&title=50%20%e8%a1%8c%e4%bb%a3%e7%a0%81%e7%9a%84%20HTML%20%e7%bc%96%e8%af%91%e5%99%a8"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fi6xi3ai08e%2f&title=50%20%e8%a1%8c%e4%bb%a3%e7%a0%81%e7%9a%84%20HTML%20%e7%bc%96%e8%af%91%e5%99%a8"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">50 行代码的 HTML 编译器</h1><div class="meta"><div class="postdate"><time datetime="2019-01-14" itemprop="datePublished">2019-01-14</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e虚拟 DOM 几乎已经是现代 JS 框架的标配了。那么该怎样将 HTML 字符串编译为虚拟 DOM 呢？这样的编译器并不是什么黑科技，这里只用了不到 50 行 JS 就实现了一个。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3eDemo\x3c\/h2\x3e\n\x3cp\x3e在 \x3ca href=\x22http:\/\/ewind.us\/h5\/html-toy-parser\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eHTML Toy Parser Demo\x3c\/a\x3e 中，可以将输入的 HTML 字符串编译成虚拟 DOM 并渲染在页面上。这个玩具项目的源码在 \x3ca href=\x22https:\/\/github.com\/doodlewind\/HTML-Toy-Parser\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eGithub\x3c\/a\x3e 上。\x3c\/p\x3e\n\x3cp\x3e作为一个玩具编译器，它还不能支持一些常见的 HTML 格式，如类似 \x3ccode\x3e\x26lt;h2\x26gt;123\x26lt;small\x26gt;456\x26lt;\/small\x26gt;\x26lt;\/h2\x26gt;\x3c\/code\x3e 这样将值和标签混合的写法。不过，这个玩具是能完善地解析多个并列标签或深层嵌套标签的。下面分享一下如何从头开始搭建出这样一个简单的编译器。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e编译器 101\x3c\/h2\x3e\n\x3cp\x3e编译器和解释器不同的地方在于，编译器是将一种编程语言的代码编译为另一种（例如将高级语言编译为机器语言），而解释器则是将一种编程语言的代码逐条解释执行（例如执行各种脚本语言）。编译器并不需要执行编译得到的代码（如 \x3ccode\x3egcc xxx.c\x3c\/code\x3e 以后是通过 OS 来执行编译得到的 x86 机器码）而解释器是直接执行语言代码（如各种脚本语言都需要通过诸如 \x3ccode\x3epython xxx.py\x3c\/code\x3e 或 \x3ccode\x3enode xxx.js\x3c\/code\x3e 的方式来执行）。\x3c\/p\x3e\n\x3cp\x3e所以，将 HTML 字符串转换为 DOM 对象的程序就是一个编译器（虽然十分简陋）。按照经典的教科书，一般一个完整的编译过程由三步组成：词法分析、语法分析和语义分析。这三个流程各对应一个模块：词法分析器、语法分析器和语义计算模块。\x3c\/p\x3e\n\x3cp\x3e以 \x3ccode\x3e\x26lt;p\x26gt;123\x26lt;\/p\x26gt;\x3c\/code\x3e 这段字符串为例，对它的编译过程，首先始于类似【分词】操作的词法分析。这个过程就是输入一段字符串，输出 \x3ccode\x3e\x26lt;p\x26gt;\x3c\/code\x3e \/ \x3ccode\x3e123\x3c\/code\x3e \/ \x3ccode\x3e\x26lt;\/p\x26gt;\x3c\/code\x3e 三个词法 Token 的过程。这些 Token 都有各自的属性（或类型），比如 \x3ccode\x3e\x26lt;p\x26gt;\x3c\/code\x3e 是一个开始标签、而 \x3ccode\x3e\x26lt;\/p\x26gt;\x3c\/code\x3e 是一个结束标签等。\x3c\/p\x3e\n\x3cp\x3e词法分析器输入的这些 Token 被输入语法分析器中进行语法分析。语法分析，其实就是将输入的一连串 Token 数组构建为一棵抽象语法树（AST）的过程。比如，类似 \x3ccode\x3e\x26lt;h2\x26gt;\x26lt;small\x26gt;123\x26lt;\/small\x26gt;\x26lt;\/h2\x26gt;\x3c\/code\x3e 这样嵌套的标签，解析成语法树后，\x3ccode\x3e\x26lt;small\x26gt;\x3c\/code\x3e 就是 \x3ccode\x3e\x26lt;h2\x26gt;\x3c\/code\x3e 的子节点。而类似 \x3ccode\x3e\x26lt;div\x26gt;123\x26lt;\/div\x26gt; \x26lt;a\x26gt;456\x26lt;\/a\x26gt;\x3c\/code\x3e 这样并列的标签则是语法树中的兄弟节点。构建好这棵语法树后，就可以进行语义计算了。\x3c\/p\x3e\n\x3cp\x3e最后的语义计算过程就是遍历语法树的过程。例如在遍历一棵虚拟 DOM 语法树的过程中，可以将每个语法树上的节点都渲染为真实的 DOM 节点，从而将虚拟 DOM 绑定到真实 DOM，这样就实现了完整的从 HTML 字符串编译到 DOM 元素的流程。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e词法分析\x3c\/h2\x3e\n\x3cp\x3e这里的词法分析器 \x3ca href=\x22https:\/\/github.com\/doodlewind\/HTML-Toy-Parser\/blob\/master\/app\/lexer.js\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eLexer\x3c\/a\x3e 就是一个切分 HTML 字符串的工具。在最简化的情景下，HTML 字符串所包含的内容可以分为这三种：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e起始标签，如 \x3ccode\x3e\x26lt;body\x26gt;\x3c\/code\x3e \/ \x3ccode\x3e\x26lt;div\x26gt;\x3c\/code\x3e \/ \x3ccode\x3e\x26lt;span\x26gt;\x3c\/code\x3e 等\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e标签内容，如 \x3ccode\x3e123\x3c\/code\x3e \/ \x3ccode\x3eabc\x3c\/code\x3e\/ \x3ccode\x3e!@#$%\x3c\/code\x3e 等\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e结束标签，如 \x3ccode\x3e\x26lt;\/body\x26gt;\x3c\/code\x3e \/ \x3ccode\x3e\x26lt;\/div\x26gt;\x3c\/code\x3e \/ \x3ccode\x3e\x26lt;\/span\x26gt;\x3c\/code\x3e 等\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e一个学术上严谨的词法分析器，需要用有限状态机来将文本切分成以上的三种类型。这里为了简单起见，使用了用正则表达式来切分文本。算法很简单：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e从字符串开头开始，首先匹配一个结束标签 Token\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e如果没有匹配到结束标签，那么从字符串开头开始匹配一个开始标签 Token\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e如果还是没有匹配到开始标签，那么匹配一段标签值 Token\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e每次匹配到一个 Token，都记录下这个 Token 的类型和文本\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e将 Token 的 HTML 字符串去除掉，回到步骤 1 直到切完字符串为止\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e词法分析完成后，所获得的 Token 数组内容大致如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22tokens = [\n    { type: \x27TagOpen\x27, val: \x27\x3cp\x3e\x27 },\n    { type: \x27Value\x27, val: \x27hello\x27 },\n    { type: \x27TagClose\x27, val: \x27\x3c\/p\x3e\x27 },\n    { type: \x27TagOpen\x27, val: \x27\x3cdiv\x3e\x27 },\n    { type: \x27TagOpen\x27, val: \x27\x3ch2\x3e\x27 },\n    { type: \x27TagOpen\x27, val: \x27\x3csmall\x3e\x27 },\n    { type: \x27Value\x27, val: \x27world\x27 },\n    { type: \x27TagClose\x27, val: \x27\x3c\/small\x3e\x27 }\n    \/\/ ...\n]\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3etokens = [\n    { \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27TagOpen\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-attr\x22\x3eval\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27\x26lt;p\x26gt;\x27\x3c\/span\x3e },\n    { \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Value\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-attr\x22\x3eval\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27hello\x27\x3c\/span\x3e },\n    { \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27TagClose\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-attr\x22\x3eval\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27\x26lt;\/p\x26gt;\x27\x3c\/span\x3e },\n    { \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27TagOpen\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-attr\x22\x3eval\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27\x26lt;div\x26gt;\x27\x3c\/span\x3e },\n    { \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27TagOpen\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-attr\x22\x3eval\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27\x26lt;h2\x26gt;\x27\x3c\/span\x3e },\n    { \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27TagOpen\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-attr\x22\x3eval\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27\x26lt;small\x26gt;\x27\x3c\/span\x3e },\n    { \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Value\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-attr\x22\x3eval\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27world\x27\x3c\/span\x3e },\n    { \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27TagClose\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-attr\x22\x3eval\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27\x26lt;\/small\x26gt;\x27\x3c\/span\x3e }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n]\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e语法分析\x3c\/h2\x3e\n\x3cp\x3e语法分析是将上面得到的 \x3ccode\x3etokens\x3c\/code\x3e 数组构造为一棵语法树的过程，实现语法分析器 Parser 也是实现简单编译器时的难点。Parser 的算法有自顶向下（LL）和自底向上（LR）之分，\x3ca href=\x22http:\/\/stackoverflow.com\/questions\/5975741\/what-is-the-difference-between-ll-and-lr-parsing\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e对比讨论\x3c\/a\x3e暂且略过，下面介绍这个简单编译器的 Parser 实现：\x3c\/p\x3e\n\x3cp\x3e首先，词法分析中得到的 Tokens 所得到的 \x3ccode\x3eTagOpen\x3c\/code\x3e \/ \x3ccode\x3eValue\x3c\/code\x3e \/ \x3ccode\x3eTagClose\x3c\/code\x3e 这三种类型，在语法树中的位置是有区别的。例如，只有 \x3ccode\x3eValue\x3c\/code\x3e 能成为叶子节点，而 \x3ccode\x3eTagOpen\x3c\/code\x3e 和 \x3ccode\x3eTagClose\x3c\/code\x3e 这两种类型只能用来包裹出一个 HTML 标签 \x3ccode\x3eTag\x3c\/code\x3e 类型。而一个或多个 \x3ccode\x3eTag\x3c\/code\x3e 类型又能够组成 \x3ccode\x3eTags\x3c\/code\x3e 类型。而一棵语法树的根节点则是一个只有一个 \x3ccode\x3eTags\x3c\/code\x3e 子节点的 \x3ccode\x3eHtml\x3c\/code\x3e 类型。\x3c\/p\x3e\n\x3cp\x3e现在我们有了五种类型：即 \x3ccode\x3eTagOpen\x3c\/code\x3e \/ \x3ccode\x3eValue\x3c\/code\x3e \/ \x3ccode\x3eTagClose\x3c\/code\x3e \/ \x3ccode\x3eTag\x3c\/code\x3e \/ \x3ccode\x3eTags\x3c\/code\x3e。这五种类型中，前三种是从词法分析直接得到的，称他们为【\x3cstrong\x3e终止符\x3c\/strong\x3e】，而后两种为构建语法树过程中的 “抽象” 类型，称它们为【\x3cstrong\x3e非终止符\x3c\/strong\x3e】\x3c\/p\x3e\n\x3cp\x3e这个 \x3ca href=\x22https:\/\/github.com\/doodlewind\/HTML-Toy-Parser\/blob\/master\/app\/parser.js\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eParser\x3c\/a\x3e 采用了最简单的递归下降算法来解析 Tokens 数组。递归下降的过程是这样的：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e首先从语法树顶部的根节点开始，向前【匹配非终止符】。每个【匹配非终止符】的过程，都是调用一个函数的过程。例如匹配 \x3ccode\x3eTag\x3c\/code\x3e 需要调用 \x3ccode\x3etag()\x3c\/code\x3e 函数，匹配 \x3ccode\x3eTags\x3c\/code\x3e 需要调用 \x3ccode\x3etags()\x3c\/code\x3e 函数等\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e每个非终止符的函数中，都按照这个非终止符的语法结构，依次匹配各种终止符或非终止符。例如 \x3ccode\x3etag()\x3c\/code\x3e 函数需要依次匹配 \x3ccode\x3eTagOpen\x3c\/code\x3e - \x3ccode\x3eValue\x3c\/code\x3e - \x3ccode\x3eTagClose\x3c\/code\x3e 三个终止符，或者 \x3ccode\x3eTagOpen\x3c\/code\x3e - \x3ccode\x3eTag\x3c\/code\x3e - \x3ccode\x3eTagClose\x3c\/code\x3e 这样两个终止符和一个非终止符。如果在 \x3ccode\x3etag()\x3c\/code\x3e 函数中遇到了又需要匹配 \x3ccode\x3eTag\x3c\/code\x3e 的情况（这就是 HTML 标签嵌套的情形）时，就需要再次调用 \x3ccode\x3etag()\x3c\/code\x3e 函数来向下匹配一个新的 \x3ccode\x3eTag\x3c\/code\x3e，这也就是所谓的递归下降了。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e当所有的 Token 都被吃入并匹配后，完成匹配。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e教科书级的代码示例是这样的（但是这不是伪代码，是能够实际执行语法分析的）：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 简化的 parser.js\n\n\/\/ tokens 为输入的词法 Token 数组\n\/\/ currIndex 为当前语法分析过程所匹配到的下标，只会逐个向前递增，不回退\n\/\/ lookahead 为当前语法分析遇到的 Token，即 tokens[currIndex]\nvar tokens, currIndex, lookahead\n\n\/\/ 返回下一个 token 并将下标前移一位\nfunction nextToken() {\n  return tokens[\x2b\x2bcurrIndex]\n}\n\n\/\/ 按照所需匹配的终止符类型，匹配下一个终止符\n\/\/ 若下一个终止符和需要匹配的类型不一直，则说明代码中存在语法错误\n\/\/ 如在解析 \x3ca\x3e 123 \x3ca\x3e 这三个 Token 时，最后需要 match(\x27TagClose\x27)\n\/\/ 但此时最后一个 Token 类型为 TagOpen，这时就会抛出语法错误\nfunction match(terminalType) {\n  if (lookahead \x26amp;\x26amp; terminalType === lookahead.type) lookahead = nextToken()\n  else throw \x27SyntaxError\x27\n}\n\n\/\/ LL 中的函数均是用于匹配非终止符的函数\n\/\/ 如果有更复杂的非终止符，在此添加它们所对应的函数即可\nconst LL = {\n  \/\/ 匹配 Html 类型非终止符的函数\n  html() {\n    \/\/ 当存在 lookahead 时，不停向前匹配 Tag 标签\n    while (lookahead) LL.tag()\n    \/\/ 当完成对所有 Token 的匹配后，lookahead 为越界的 undefined\n    \/\/ 这时退出循环，在此结束语法分析过程\n    console.log(\x27parse complete!\x27)\n  },\n  \/\/ 匹配 Tag 类型非终止符的函数\n  tag() {\n    \/\/ HTML 标签的第一个 Token 一定是 TagOpen 类型\n    match(\x27TagOpen\x27)\n    \/\/ 匹配完成 TagOpen 后，可能需要匹配一个嵌套的标签\n    \/\/ 也可能需要匹配一个标签的 Value\n    \/\/ 这时候就需要通过向前看符号 lookahead 来判断怎样匹配\n    \/\/ 若需要匹配嵌套的标签，那么下一个符号必然是 TagOpen 类型\n    lookahead.type == \x27TagOpen\x27 ? LL.tag() : match(\x27Value\x27)\n    \/\/ 最后匹配一个结束标签，即 TagClose 类型的 Token\n    match(\x27TagClose\x27)\n    \/\/ 执行到这里时，就完成了对一个 HTML 标签的语法解析\n    console.log(\x27tag matched\x27)\n  }\n}\n\nexport default {\n  parse(inputTokens) {\n    \/\/ 初始化各变量\n    tokens = inputTokens, currIndex = 0, lookahead = tokens[currIndex]\n    \/\/ 开始语法分析，目标是将 Tokens 解析为一整个 HTML 类型\n    LL.html()\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 简化的 parser.js\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ tokens 为输入的词法 Token 数组\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ currIndex 为当前语法分析过程所匹配到的下标，只会逐个向前递增，不回退\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ lookahead 为当前语法分析遇到的 Token，即 tokens[currIndex]\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e tokens, currIndex, lookahead\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 返回下一个 token 并将下标前移一位\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3enextToken\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e tokens[\x2b\x2bcurrIndex]\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 按照所需匹配的终止符类型，匹配下一个终止符\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 若下一个终止符和需要匹配的类型不一直，则说明代码中存在语法错误\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如在解析 \x26lt;a\x26gt; 123 \x26lt;a\x26gt; 这三个 Token 时，最后需要 match(\x27TagClose\x27)\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 但此时最后一个 Token 类型为 TagOpen，这时就会抛出语法错误\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ematch\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eterminalType\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (lookahead \x26amp;\x26amp; terminalType === lookahead.type) lookahead = nextToken()\n  \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27SyntaxError\x27\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ LL 中的函数均是用于匹配非终止符的函数\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果有更复杂的非终止符，在此添加它们所对应的函数即可\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e LL = {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 匹配 Html 类型非终止符的函数\x3c\/span\x3e\n  html() {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当存在 lookahead 时，不停向前匹配 Tag 标签\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (lookahead) LL.tag()\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当完成对所有 Token 的匹配后，lookahead 为越界的 undefined\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这时退出循环，在此结束语法分析过程\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27parse complete!\x27\x3c\/span\x3e)\n  },\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 匹配 Tag 类型非终止符的函数\x3c\/span\x3e\n  tag() {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ HTML 标签的第一个 Token 一定是 TagOpen 类型\x3c\/span\x3e\n    match(\x3cspan class=\x22hljs-string\x22\x3e\x27TagOpen\x27\x3c\/span\x3e)\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 匹配完成 TagOpen 后，可能需要匹配一个嵌套的标签\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 也可能需要匹配一个标签的 Value\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这时候就需要通过向前看符号 lookahead 来判断怎样匹配\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 若需要匹配嵌套的标签，那么下一个符号必然是 TagOpen 类型\x3c\/span\x3e\n    lookahead.type == \x3cspan class=\x22hljs-string\x22\x3e\x27TagOpen\x27\x3c\/span\x3e ? LL.tag() : match(\x3cspan class=\x22hljs-string\x22\x3e\x27Value\x27\x3c\/span\x3e)\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 最后匹配一个结束标签，即 TagClose 类型的 Token\x3c\/span\x3e\n    match(\x3cspan class=\x22hljs-string\x22\x3e\x27TagClose\x27\x3c\/span\x3e)\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 执行到这里时，就完成了对一个 HTML 标签的语法解析\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27tag matched\x27\x3c\/span\x3e)\n  }\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e {\n  parse(inputTokens) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 初始化各变量\x3c\/span\x3e\n    tokens = inputTokens, currIndex = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, lookahead = tokens[currIndex]\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 开始语法分析，目标是将 Tokens 解析为一整个 HTML 类型\x3c\/span\x3e\n    LL.html()\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e语义分析\x3c\/h2\x3e\n\x3cp\x3e上面的语法分析过程中，并没有显式构建一棵语法树的代码。实际上，语法树是在 \x3ccode\x3eLL\x3c\/code\x3e 中各个匹配非终止符的函数的互相调用中，隐式地构建出来的。要将这棵语法树转换为虚拟 DOM，只需要在 \x3ccode\x3etag()\x3c\/code\x3e 和 \x3ccode\x3ehtml()\x3c\/code\x3e 等互相调用的函数中传入参数即可。\x3c\/p\x3e\n\x3cp\x3e例如将 \x3ccode\x3etag()\x3c\/code\x3e 函数签名修改为如下的形式，即可实现\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22tag(currNode) {\n  match(\x27TagOpen\x27)\n  \/\/ 在遇到嵌套标签的情况时，递归向下解析\n  if (lookahead.type == \x27TagOpen\x27) {\n    \/\/ 将当前节点作为参数，调用 tags 匹配掉嵌套的标签\n    \/\/ 将会返回挂载完成了所有子节点的当前节点\n    currNode = NT.tags(currNode)\n  } else {\n    \/\/ 当前标签是一个叶子节点，这时直接修改当前节点的值\n    \/\/ 这时 lookahead 指向的已经是一个 Value 类型的 Token 了\n    currNode.val = lookahead.val\n    \/\/ 匹配掉这个 Value 类型，\n    match(\x27Value\x27)\n    \/\/ 这时的 lookahead 指向 TagClose 类型\n  }\n  match(\x27TagClose\x27)\n  \/\/ 最后返回计算完成的节点给上层\n  return currNode\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3etag(currNode) {\n  match(\x3cspan class=\x22hljs-string\x22\x3e\x27TagOpen\x27\x3c\/span\x3e)\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 在遇到嵌套标签的情况时，递归向下解析\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (lookahead.type == \x3cspan class=\x22hljs-string\x22\x3e\x27TagOpen\x27\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将当前节点作为参数，调用 tags 匹配掉嵌套的标签\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将会返回挂载完成了所有子节点的当前节点\x3c\/span\x3e\n    currNode = NT.tags(currNode)\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当前标签是一个叶子节点，这时直接修改当前节点的值\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这时 lookahead 指向的已经是一个 Value 类型的 Token 了\x3c\/span\x3e\n    currNode.val = lookahead.val\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 匹配掉这个 Value 类型，\x3c\/span\x3e\n    match(\x3cspan class=\x22hljs-string\x22\x3e\x27Value\x27\x3c\/span\x3e)\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这时的 lookahead 指向 TagClose 类型\x3c\/span\x3e\n  }\n  match(\x3cspan class=\x22hljs-string\x22\x3e\x27TagClose\x27\x3c\/span\x3e)\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 最后返回计算完成的节点给上层\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e currNode\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e所以，这种语法分析方式下，语义计算的完整代码实际上耦合在了语法分析器中。最后 \x3ccode\x3ehtml()\x3c\/code\x3e 函数返回的结果，就是一棵虚拟 DOM 语法树了。\x3c\/p\x3e\n\x3cp\x3e要将获得的虚拟 DOM 渲染为真实 DOM，是非常容易的。只需要深度遍历这棵虚拟 DOM 树，将每个节点通过 API 插入 DOM 中即可：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ generator.js\nfunction renderNode(target, nodes) {\n  \/\/ nodes 由调用者传入，是调用者的全部子节点\n  nodes.forEach(node =\x3e {\n    \/\/ trim 用于修剪标签的首尾文本，例如将 \x3cp\x3e 剪为 p\n    \/\/ 然后生成一个全新的 DOM 节点 newNode\n    let newNode = document.createElement(trim(node.type))\n    \n    \/\/ node.val 不存在时，说明当前节点不是子节点\n    \/\/ 此时传入 node 的子节点递归调用自己，深度优先遍历树\n    if (!node.val) newNode = renderNode(newNode, node.children)\n    \n    \/\/ node.val 存在时，说明当前 node 是叶子节点\n    \/\/ 此时 node.val 就是当前 DOM 元素的 innerHTML\n    else newNode.innerHTML = node.val\n    \n    \/\/ 将新生成的节点挂载到 DOM 上\n    target.appendChild(newNode)\n  })\n  \/\/ 向调用者返回挂载后的元素\n  return target\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ generator.js\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3erenderNode\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3etarget, nodes\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ nodes 由调用者传入，是调用者的全部子节点\x3c\/span\x3e\n  nodes.forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3enode\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ trim 用于修剪标签的首尾文本，例如将 \x26lt;p\x26gt; 剪为 p\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 然后生成一个全新的 DOM 节点 newNode\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e newNode = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.createElement(trim(node.type))\n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ node.val 不存在时，说明当前节点不是子节点\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 此时传入 node 的子节点递归调用自己，深度优先遍历树\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!node.val) newNode = renderNode(newNode, node.children)\n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ node.val 存在时，说明当前 node 是叶子节点\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 此时 node.val 就是当前 DOM 元素的 innerHTML\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e newNode.innerHTML = node.val\n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将新生成的节点挂载到 DOM 上\x3c\/span\x3e\n    target.appendChild(newNode)\n  })\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 向调用者返回挂载后的元素\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e target\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3eTODO\x3c\/h2\x3e\n\x3cp\x3e上面的一套流程走完后，实际上就实现了从 HTML 字符串到虚拟 DOM 再到真实 DOM 的流程了。由于虚拟 DOM 的抽象性，因此可以在 HTML 字符串中通过模板语法来绑定若干变量，然后在这些变量改变后，修改虚拟 DOM 对应的位置，并将虚拟 DOM 的相应部分重新渲染到真实 DOM，从而减少手动重新绘制 DOM 的冗余代码，并通过尽量少地重绘 DOM 来提高性能。\x3c\/p\x3e\n\x3cp\x3e当然了，这个编译器的语法分析部分采用的是教科书中最简单的递归下降算法，递归的方式在很多时候性能都不是最好的。如果希望语法分析能够有尽可能高的性能，那么表驱动的 LR 分析可以做到这一点。不过 LR 分析中构造分析表的过程是相当复杂的，在此并没有杀鸡用牛刀的必要。\x3c\/p\x3e\n\x3cp\x3e最后，这个玩具级的编译器能支持的文法其实相当有限，只是 HTML 的一个子集而已。希望它能够为编写其它更有趣的 Parser 提供一些启发吧。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>50 行代码的 HTML 编译器</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000009489605">https://segmentfault.com/a/1190000009489605</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/i6xi3ai08e/" target="_blank">https://alili.tech/archive/i6xi3ai08e/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>