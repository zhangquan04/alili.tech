<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="2016 Git 新视界"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>2016 Git 新视界 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/5qln24wni8e/",
				"appid": "1613049289050283", 
				"title": "2016 Git 新视界 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-23T02:30:08"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/9vz0x8d1eqf/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/2nvg324n1nb/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f5qln24wni8e%2f&text=2016%20Git%20%e6%96%b0%e8%a7%86%e7%95%8c"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f5qln24wni8e%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f5qln24wni8e%2f&text=2016%20Git%20%e6%96%b0%e8%a7%86%e7%95%8c"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f5qln24wni8e%2f&title=2016%20Git%20%e6%96%b0%e8%a7%86%e7%95%8c"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f5qln24wni8e%2f&is_video=false&description=2016%20Git%20%e6%96%b0%e8%a7%86%e7%95%8c"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=2016%20Git%20%e6%96%b0%e8%a7%86%e7%95%8c&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f5qln24wni8e%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f5qln24wni8e%2f&title=2016%20Git%20%e6%96%b0%e8%a7%86%e7%95%8c"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f5qln24wni8e%2f&title=2016%20Git%20%e6%96%b0%e8%a7%86%e7%95%8c"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f5qln24wni8e%2f&title=2016%20Git%20%e6%96%b0%e8%a7%86%e7%95%8c"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f5qln24wni8e%2f&title=2016%20Git%20%e6%96%b0%e8%a7%86%e7%95%8c"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">2016 Git 新视界</h1><div class="meta"><div class="postdate"><time datetime="2019-01-23" itemprop="datePublished">2019-01-23</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n            \x3ch1\x3e\x3ca href=\x22#2016-git-新视界\x22\x3e\x3c\/a\x3e2016 Git 新视界\x3c\/h1\x3e\n\x3cp\x3e2016 年 Git 发生了 \x3cem\x3e惊天动地\x3c\/em\x3e 地变化，发布了五大新特性\x3ca href=\x22https:\/\/hackernoon.com\/git-in-2016-fad96ae22a15#c8e9\x22\x3e¹\x3c\/a\x3e （从 \x3cem\x3ev2.7\x3c\/em\x3e  到  \x3cem\x3ev2.11\x3c\/em\x3e ）和十六个补丁\x3ca href=\x22https:\/\/hackernoon.com\/git-in-2016-fad96ae22a15#408a\x22\x3e²\x3c\/a\x3e。189 位作者\x3ca href=\x22https:\/\/hackernoon.com\/git-in-2016-fad96ae22a15#315b\x22\x3e³\x3c\/a\x3e贡献了 3676 个提交\x3ca href=\x22https:\/\/hackernoon.com\/git-in-2016-fad96ae22a15#dbfb\x22\x3e⁴\x3c\/a\x3e到 \x3ccode\x3emaster\x3c\/code\x3e 分支，比 2015 年多了 15%\x3ca href=\x22https:\/\/hackernoon.com\/git-in-2016-fad96ae22a15#2220\x22\x3e⁵\x3c\/a\x3e！总计有 1545 个文件被修改，其中增加了 276799 行并移除了 100973 行。\x3c\/p\x3e\n\x3cp\x3e但是，通过统计提交的数量和代码行数来衡量生产力是一种十分愚蠢的方法。除了深度研究过的开发者可以做到凭直觉来判断代码质量的地步，我们普通人来作仲裁难免会因我们常人的判断有失偏颇。\x3c\/p\x3e\n\x3cp\x3e谨记这一条于心，我决定整理这一年里六个我最喜爱的 Git 特性涵盖的改进，来做一次分类回顾。这篇文章作为一篇中篇推文有点太过长了，所以我不介意你们直接跳到你们特别感兴趣的特性去。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/hackernoon.com\/git-in-2016-fad96ae22a15#fd10\x22\x3e完成\x3c\/a\x3e \x3ca href=\x22https:\/\/hackernoon.com\/git-in-2016-fad96ae22a15#fd10\x22\x3e\x3ccode\x3egit worktree\x3c\/code\x3e\x3c\/a\x3e \x3ca href=\x22https:\/\/hackernoon.com\/git-in-2016-fad96ae22a15#fd10\x22\x3e命令\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/hackernoon.com\/git-in-2016-fad96ae22a15#cc52\x22\x3e更多方便的\x3c\/a\x3e \x3ca href=\x22https:\/\/hackernoon.com\/git-in-2016-fad96ae22a15#cc52\x22\x3e\x3ccode\x3egit rebase\x3c\/code\x3e\x3c\/a\x3e \x3ca href=\x22https:\/\/hackernoon.com\/git-in-2016-fad96ae22a15#cc52\x22\x3e选项\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/hackernoon.com\/git-in-2016-fad96ae22a15#42b9\x22\x3e\x3ccode\x3egit lfs\x3c\/code\x3e\x3c\/a\x3e \x3ca href=\x22https:\/\/hackernoon.com\/git-in-2016-fad96ae22a15#42b9\x22\x3e梦幻的性能加速\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/hackernoon.com\/git-in-2016-fad96ae22a15#4208\x22\x3e\x3ccode\x3egit diff\x3c\/code\x3e\x3c\/a\x3e \x3ca href=\x22https:\/\/hackernoon.com\/git-in-2016-fad96ae22a15#4208\x22\x3e实验性的算法和更好的默认结果\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/hackernoon.com\/git-in-2016-fad96ae22a15#a5c3\x22\x3e\x3ccode\x3egit submodules\x3c\/code\x3e\x3c\/a\x3e \x3ca href=\x22https:\/\/hackernoon.com\/git-in-2016-fad96ae22a15#a5c3\x22\x3e差强人意\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/hackernoon.com\/git-in-2016-fad96ae22a15#c230\x22\x3e\x3ccode\x3egit stash\x3c\/code\x3e\x3c\/a\x3e 的\x3ca href=\x22https:\/\/hackernoon.com\/git-in-2016-fad96ae22a15#c230\x22\x3e90 个增强\x3c\/a\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e在我们开始之前，请注意在大多数操作系统上都自带有 Git 的旧版本，所以你需要检查你是否在使用最新并且最棒的版本。如果在终端运行 \x3ccode\x3egit --version\x3c\/code\x3e 返回的结果小于 Git \x3ccode\x3ev2.11.0\x3c\/code\x3e，请立刻跳转到 Atlassian 的快速指南 \x3ca href=\x22https:\/\/www.atlassian.com\/git\/tutorials\/install-git\/\x22\x3e更新或安装 Git\x3c\/a\x3e 并根据你的平台做出选择。\x3c\/p\x3e\n\x3cp\x3e###[所需的“引用”]\x3c\/p\x3e\n\x3cp\x3e在我们进入高质量内容之前还需要做一个短暂的停顿：我觉得我需要为你展示我是如何从公开文档生成统计信息（以及开篇的封面图片）的。你也可以使用下面的命令来对你自己的仓库做一个快速的 \x3cem\x3e年度回顾\x3c\/em\x3e！\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3e¹ Tags from 2016 matching the form vX.Y.0\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs perl\x22\x3e$ git \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e-\x3cspan class=\x22hljs-keyword\x22\x3eeach\x3c\/span\x3e-\x3cspan class=\x22hljs-keyword\x22\x3eref\x3c\/span\x3e --\x3cspan class=\x22hljs-keyword\x22\x3esort\x3c\/span\x3e=-taggerdate --\x3cspan class=\x22hljs-keyword\x22\x3eformat\x3c\/span\x3e \\\n\x3cspan class=\x22hljs-string\x22\x3e\x27%(refname) %(taggerdate)\x27\x3c\/span\x3e refs\/tags | \x3cspan class=\x22hljs-keyword\x22\x3egrep\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22v\\d\\.\\d*\\.0 .* 2016\x22\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cblockquote\x3e\n\x3cp\x3e² Tags from 2016 matching the form vX.Y.Z\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs perl\x22\x3e$ git \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e-\x3cspan class=\x22hljs-keyword\x22\x3eeach\x3c\/span\x3e-\x3cspan class=\x22hljs-keyword\x22\x3eref\x3c\/span\x3e --\x3cspan class=\x22hljs-keyword\x22\x3esort\x3c\/span\x3e=-taggerdate --\x3cspan class=\x22hljs-keyword\x22\x3eformat\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27%(refname) %(taggerdate)\x27\x3c\/span\x3e refs\/tags | \x3cspan class=\x22hljs-keyword\x22\x3egrep\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22v\\d\\.\\d*\\.[^0] .* 2016\x22\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cblockquote\x3e\n\x3cp\x3e³ Commits by author in 2016\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs lsl\x22\x3e$ git shortlog -s -n --since=\x3cspan class=\x22hljs-number\x22\x3e2016\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e-01\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e-01\x3c\/span\x3e --until=\x3cspan class=\x22hljs-number\x22\x3e2017\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e-01\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e-01\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cblockquote\x3e\n\x3cp\x3e⁴ Count commits in 2016\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs lsl\x22\x3e$ git log --oneline --since=\x3cspan class=\x22hljs-number\x22\x3e2016\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e-01\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e-01\x3c\/span\x3e --until=\x3cspan class=\x22hljs-number\x22\x3e2017\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e-01\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e-01\x3c\/span\x3e | wc -l\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cblockquote\x3e\n\x3cp\x3e⁵ ... and in 2015\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs lsl\x22\x3e$ git log --oneline --since=\x3cspan class=\x22hljs-number\x22\x3e2015\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e-01\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e-01\x3c\/span\x3e --until=\x3cspan class=\x22hljs-number\x22\x3e2016\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e-01\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e-01\x3c\/span\x3e | wc -l\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cblockquote\x3e\n\x3cp\x3e⁶ Net LOC added\/removed in 2016\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs lsl\x22\x3e$ git diff --shortstat `git rev-\x3cspan class=\x22hljs-type\x22\x3elist\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e --until=\x3cspan class=\x22hljs-number\x22\x3e2016\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e-01\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e-01\x3c\/span\x3e master` \\\n `git rev-\x3cspan class=\x22hljs-type\x22\x3elist\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e --until=\x3cspan class=\x22hljs-number\x22\x3e2017\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e-01\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e-01\x3c\/span\x3e master`\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e以上的命令是在 Git 的 \x3ccode\x3emaster\x3c\/code\x3e 分支运行的，所以不会显示其他出色的分支上没有合并的工作。如果你使用这些命令，请记住提交的数量和代码行数不是应该值得信赖的度量方式。请不要使用它们来衡量你的团队成员的贡献。\x3c\/p\x3e\n\x3cp\x3e现在，让我们开始说好的回顾……\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22#完成-git-工作树worktree\x22\x3e\x3c\/a\x3e完成 Git 工作树（worktree）\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3egit worktree\x3c\/code\x3e 命令首次出现于 Git v2.5 ，但是在 2016 年有了一些显著的增强。两个有价值的新特性在 v2.7 被引入：\x3ccode\x3elist\x3c\/code\x3e 子命令，和为二分搜索增加了命令空间的 refs。而 \x3ccode\x3elock\x3c\/code\x3e\/\x3ccode\x3eunlock\x3c\/code\x3e 子命令则是在 v2.10 被引入。\x3c\/p\x3e\n\x3ch4\x3e\x3ca href=\x22#什么是工作树呢\x22\x3e\x3c\/a\x3e什么是工作树呢？\x3c\/h4\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/git-scm.com\/docs\/git-worktree\x22\x3e\x3ccode\x3egit worktree\x3c\/code\x3e\x3c\/a\x3e 命令允许你同步地检出和操作处于不同路径下的同一仓库的多个分支。例如，假如你需要做一次快速的修复工作但又不想扰乱你当前的工作区，你可以使用以下命令在一个新路径下检出一个新分支：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs armasm\x22\x3e$ git worktree \x3cspan class=\x22hljs-keyword\x22\x3eadd \x3c\/span\x3e-\x3cspan class=\x22hljs-keyword\x22\x3eb \x3c\/span\x3ehotfix\/\x3cspan class=\x22hljs-keyword\x22\x3eBB-1234 \x3c\/span\x3e..\/hotfix\/\x3cspan class=\x22hljs-keyword\x22\x3eBB-1234\n\x3c\/span\x3e\x3cspan class=\x22hljs-symbol\x22\x3ePreparing\x3c\/span\x3e ..\/hotfix\/\x3cspan class=\x22hljs-keyword\x22\x3eBB-1234 \x3c\/span\x3e(identifier \x3cspan class=\x22hljs-keyword\x22\x3eBB-1234)\n\x3c\/span\x3e\x3cspan class=\x22hljs-symbol\x22\x3eHEAD\x3c\/span\x3e is now at \x3cspan class=\x22hljs-number\x22\x3e886\x3c\/span\x3ee0ba Merged in \x3cspan class=\x22hljs-keyword\x22\x3ebedwards\/BB-13430-api-merge-pr \x3c\/span\x3e(pull request \x3cspan class=\x22hljs-number\x22\x3e#7822\x3c\/span\x3e)\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e工作树不仅仅是为分支工作。你可以检出多个里程碑（tags）作为不同的工作树来并行构建或测试它们。例如，我从 Git v2.6 和 v2.7 的里程碑中创建工作树来检验不同版本 Git 的行为特征。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs lsl\x22\x3e$ git worktree add ..\/git-v2\x3cspan class=\x22hljs-number\x22\x3e.6\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e.0\x3c\/span\x3e v2\x3cspan class=\x22hljs-number\x22\x3e.6\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e.0\x3c\/span\x3e\nPreparing ..\/git-v2\x3cspan class=\x22hljs-number\x22\x3e.6\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e.0\x3c\/span\x3e (identifier git-v2\x3cspan class=\x22hljs-number\x22\x3e.6\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e.0\x3c\/span\x3e)\nHEAD is now at be08dee Git \x3cspan class=\x22hljs-number\x22\x3e2.6\x3c\/span\x3e\n\n$ git worktree add ..\/git-v2\x3cspan class=\x22hljs-number\x22\x3e.7\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e.0\x3c\/span\x3e v2\x3cspan class=\x22hljs-number\x22\x3e.7\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e.0\x3c\/span\x3e\nPreparing ..\/git-v2\x3cspan class=\x22hljs-number\x22\x3e.7\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e.0\x3c\/span\x3e (identifier git-v2\x3cspan class=\x22hljs-number\x22\x3e.7\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e.0\x3c\/span\x3e)\nHEAD is now at \x3cspan class=\x22hljs-number\x22\x3e7548842\x3c\/span\x3e Git \x3cspan class=\x22hljs-number\x22\x3e2.7\x3c\/span\x3e\n\n$ git worktree \x3cspan class=\x22hljs-type\x22\x3elist\x3c\/span\x3e\n\/Users\/kannonboy\/src\/git         \x3cspan class=\x22hljs-number\x22\x3e7548842\x3c\/span\x3e [master]\n\/Users\/kannonboy\/src\/git-v2\x3cspan class=\x22hljs-number\x22\x3e.6\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e.0\x3c\/span\x3e  be08dee (detached HEAD)\n\/Users\/kannonboy\/src\/git-v2\x3cspan class=\x22hljs-number\x22\x3e.7\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e.0\x3c\/span\x3e  \x3cspan class=\x22hljs-number\x22\x3e7548842\x3c\/span\x3e (detached HEAD)\n\n$ cd ..\/git-v2\x3cspan class=\x22hljs-number\x22\x3e.7\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e.0\x3c\/span\x3e \x26amp;\x26amp; make\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e你也使用同样的技术来并行构造和运行你自己应用程序的不同版本。\x3c\/p\x3e\n\x3ch4\x3e\x3ca href=\x22#列出工作树\x22\x3e\x3c\/a\x3e列出工作树\x3c\/h4\x3e\n\x3cp\x3e\x3ccode\x3egit worktree list\x3c\/code\x3e 子命令（于 Git v2.7 引入）显示所有与当前仓库有关的工作树。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs groovy\x22\x3e$ git worktree list\n\x3cspan class=\x22hljs-regexp\x22\x3e\/Users\/\x3c\/span\x3ekannonboy\x3cspan class=\x22hljs-regexp\x22\x3e\/src\/\x3c\/span\x3ebitbucket\/bitbucket       \x3cspan class=\x22hljs-number\x22\x3e37732\x3c\/span\x3ebd [master]\n\x3cspan class=\x22hljs-regexp\x22\x3e\/Users\/\x3c\/span\x3ekannonboy\x3cspan class=\x22hljs-regexp\x22\x3e\/src\/\x3c\/span\x3ebitbucket\/staging         d5924bc [staging]\n\x3cspan class=\x22hljs-regexp\x22\x3e\/Users\/\x3c\/span\x3ekannonboy\x3cspan class=\x22hljs-regexp\x22\x3e\/src\/\x3c\/span\x3ebitbucket\x3cspan class=\x22hljs-regexp\x22\x3e\/hotfix-1234     37732bd [hotfix\/\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e1234\x3c\/span\x3e]\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3ch4\x3e\x3ca href=\x22#二分查找工作树\x22\x3e\x3c\/a\x3e二分查找工作树\x3c\/h4\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/git-scm.com\/book\/en\/v2\/Git-Tools-Debugging-with-Git#Binary-Search\x22\x3e\x3ccode\x3egitbisect\x3c\/code\x3e\x3c\/a\x3e 是一个简洁的 Git 命令，可以让我们对提交记录执行一次二分搜索。通常用来找到哪一次提交引入了一个指定的退化。例如，如果在我的 \x3ccode\x3emaster\x3c\/code\x3e 分支最后的提交上有一个测试没有通过，我可以使用 \x3ccode\x3egit bisect\x3c\/code\x3e 来贯穿仓库的历史来找寻第一次造成这个错误的提交。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs shell\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3e$\x3c\/span\x3e\x3cspan class=\x22bash\x22\x3e git bisect start\x3c\/span\x3e\n\x3cspan class=\x22hljs-meta\x22\x3e\n#\x3c\/span\x3e\x3cspan class=\x22bash\x22\x3e 找到已知通过测试的最后提交\x3c\/span\x3e\n\x3cspan class=\x22hljs-meta\x22\x3e#\x3c\/span\x3e\x3cspan class=\x22bash\x22\x3e （例如最新的发布里程碑）\x3c\/span\x3e\n\x3cspan class=\x22hljs-meta\x22\x3e$\x3c\/span\x3e\x3cspan class=\x22bash\x22\x3e git bisect good v2.0.0\x3c\/span\x3e\n\x3cspan class=\x22hljs-meta\x22\x3e\n#\x3c\/span\x3e\x3cspan class=\x22bash\x22\x3e 找到已知的出问题的提交\x3c\/span\x3e\n\x3cspan class=\x22hljs-meta\x22\x3e#\x3c\/span\x3e\x3cspan class=\x22bash\x22\x3e （例如在 `master` 上的提示）\x3c\/span\x3e\n\x3cspan class=\x22hljs-meta\x22\x3e$\x3c\/span\x3e\x3cspan class=\x22bash\x22\x3e git bisect bad master\x3c\/span\x3e\n\x3cspan class=\x22hljs-meta\x22\x3e\n#\x3c\/span\x3e\x3cspan class=\x22bash\x22\x3e 告诉 git bisect 要运行的脚本\/命令；\x3c\/span\x3e\n\x3cspan class=\x22hljs-meta\x22\x3e#\x3c\/span\x3e\x3cspan class=\x22bash\x22\x3e git bisect 会在 “good” 和 “bad”范围内\x3c\/span\x3e\n\x3cspan class=\x22hljs-meta\x22\x3e#\x3c\/span\x3e\x3cspan class=\x22bash\x22\x3e 找到导致脚本以非 0 状态退出的最旧的提交\x3c\/span\x3e\n\x3cspan class=\x22hljs-meta\x22\x3e$\x3c\/span\x3e\x3cspan class=\x22bash\x22\x3e git bisect run npm \x3cspan class=\x22hljs-built_in\x22\x3etest\x3c\/span\x3e\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e在后台，bisect 使用 refs 来跟踪 “good” 与 “bad” 的提交来作为二分搜索范围的上下界限。不幸的是，对工作树的粉丝来说，这些 refs 都存储在寻常的 \x3ccode\x3e.git\/refs\/bisect\x3c\/code\x3e 命名空间，意味着 \x3ccode\x3egit bisect\x3c\/code\x3e 操作如果运行在不同的工作树下可能会互相干扰。\x3c\/p\x3e\n\x3cp\x3e到了 v2.7 版本，bisect 的 refs 移到了 \x3ccode\x3e.git\/worktrees\/$worktree_name\/refs\/bisect\x3c\/code\x3e， 所以你可以并行运行 bisect 操作于多个工作树中。\x3c\/p\x3e\n\x3ch4\x3e\x3ca href=\x22#锁定工作树\x22\x3e\x3c\/a\x3e锁定工作树\x3c\/h4\x3e\n\x3cp\x3e当你完成了一颗工作树的工作，你可以直接删除它，然后通过运行 \x3ccode\x3egit worktree prune\x3c\/code\x3e 等它被当做垃圾自动回收。但是，如果你在网络共享或者可移除媒介上存储了一颗工作树，如果工作树目录在删除期间不可访问，工作树会被完全清除——不管你喜不喜欢！Git v2.10 引入了 \x3ccode\x3egit worktree lock\x3c\/code\x3e 和 \x3ccode\x3eunlock\x3c\/code\x3e 子命令来防止这种情况发生。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs jboss-cli\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e# 在我的 USB 盘上锁定 git-v2.7 工作树\x3c\/span\x3e\n$ git worktree lock \x3cspan class=\x22hljs-string\x22\x3e\/Volumes\/Flash_Gordon\/git-v2.7\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e--reason\x3c\/span\x3e \\\n\x3cspan class=\x22hljs-string\x22\x3e\x22In case I remove my removable media\x22\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs shell\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3e#\x3c\/span\x3e\x3cspan class=\x22bash\x22\x3e 当我完成时，解锁（并删除）该工作树\x3c\/span\x3e\n\x3cspan class=\x22hljs-meta\x22\x3e$\x3c\/span\x3e\x3cspan class=\x22bash\x22\x3e git worktree unlock \/Volumes\/Flash_Gordon\/git-v2.7\x3c\/span\x3e\n\x3cspan class=\x22hljs-meta\x22\x3e$\x3c\/span\x3e\x3cspan class=\x22bash\x22\x3e rm -rf \/Volumes\/Flash_Gordon\/git-v2.7\x3c\/span\x3e\n\x3cspan class=\x22hljs-meta\x22\x3e$\x3c\/span\x3e\x3cspan class=\x22bash\x22\x3e git worktree prune\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e\x3ccode\x3e--reason\x3c\/code\x3e 标签允许为未来的你留一个记号，描述为什么当初工作树被锁定。\x3ccode\x3egit worktree unlock\x3c\/code\x3e 和 \x3ccode\x3elock\x3c\/code\x3e 都要求你指定工作树的路径。或者，你可以 \x3ccode\x3ecd\x3c\/code\x3e 到工作树目录然后运行 \x3ccode\x3egit worktree lock .\x3c\/code\x3e 来达到同样的效果。\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22#更多-git-变基rebase选项\x22\x3e\x3c\/a\x3e更多 Git 变基（rebase）选项\x3c\/h3\x3e\n\x3cp\x3e2016 年三月，Git v2.8 增加了在拉取过程中交互进行变基的命令 \x3ccode\x3egit pull --rebase=interactive\x3c\/code\x3e 。对应地，六月份 Git v2.9 发布了通过 \x3ccode\x3egit rebase -x\x3c\/code\x3e 命令对执行变基操作而不需要进入交互模式的支持。\x3c\/p\x3e\n\x3ch4\x3e\x3ca href=\x22#re-啥\x22\x3e\x3c\/a\x3eRe-啥？\x3c\/h4\x3e\n\x3cp\x3e在我们继续深入前，我假设读者中有些并不是很熟悉或者没有完全习惯变基命令或者交互式变基。从概念上说，它很简单，但是与很多 Git 的强大特性一样，变基散发着听起来很复杂的专业术语的气息。所以，在我们深入前，先来快速的复习一下什么是变基（rebase）。\x3c\/p\x3e\n\x3cp\x3e变基操作意味着将一个或多个提交在一个指定分支上重写。\x3ccode\x3egit rebase\x3c\/code\x3e 命令是被深度重载了，但是 rebase 这个名字的来源事实上还是它经常被用来改变一个分支的基准提交（你基于此提交创建了这个分支）。\x3c\/p\x3e\n\x3cp\x3e从概念上说，rebase 通过将你的分支上的提交临时存储为一系列补丁包，接着将这些补丁包按顺序依次打在目标提交之上。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/camo.githubusercontent.com\/feb165dcdbf54431e200296b84f1cfb3e75890de\/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f312a6d67796c3338736c6d716d63453453545335366e58412e676966\x22\x3e\x3cimg src=\x22https:\/\/p2.ssl.qhimg.com\/t01508ce62853e9bc66.gif\x22 alt=\x22\x22\x3e\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e对 master 分支的一个功能分支执行变基操作 （\x3ccode\x3egit reabse master\x3c\/code\x3e）是一种通过将 master 分支上最新的改变合并到功能分支的“保鲜法”。对于长期存在的功能分支，规律的变基操作能够最大程度的减少开发过程中出现冲突的可能性和严重性。\x3c\/p\x3e\n\x3cp\x3e有些团队会选择在合并他们的改动到 master 前立即执行变基操作以实现一次快速合并 （\x3ccode\x3egit merge --ff \x26lt;feature\x26gt;\x3c\/code\x3e）。对 master 分支快速合并你的提交是通过简单的将 master ref 指向你的重写分支的顶点而不需要创建一个合并提交。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/camo.githubusercontent.com\/6133fe06ec97aed2d332294d5ccf1f1b845b5d1d\/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f312a515861337a6e5169754e57446a78726f5836323856412e676966\x22\x3e\x3cimg src=\x22https:\/\/p1.ssl.qhimg.com\/t01a7b979f8c3feb531.gif\x22 alt=\x22\x22\x3e\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e变基是如此方便和功能强大以致于它已经被嵌入其他常见的 Git 命令中，例如拉取操作 \x3ccode\x3egit pull\x3c\/code\x3e 。如果你在本地 master 分支有未推送的提交，运行 \x3ccode\x3egit pull\x3c\/code\x3e 命令从 origin 拉取你队友的改动会造成不必要的合并提交。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/camo.githubusercontent.com\/d24f3cc8d8b80c4893125d912ac7a6d4b8ac91ec\/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f312a497844644a354379677653576444384d434e705a4e672e676966\x22\x3e\x3cimg src=\x22https:\/\/p3.ssl.qhimg.com\/t0131c11f438f346269.gif\x22 alt=\x22\x22\x3e\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e这有点混乱，而且在繁忙的团队，你会获得成堆的不必要的合并提交。\x3ccode\x3egit pull --rebase\x3c\/code\x3e 将你本地的提交在你队友的提交上执行变基而不产生一个合并提交。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/camo.githubusercontent.com\/6c057ba9e971889452cf02b40a6f0a370cdbd8a5\/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f312a4863726f444d774245396d32312d684f654977526d772e676966\x22\x3e\x3cimg src=\x22https:\/\/p4.ssl.qhimg.com\/t010b84ded6c060964b.gif\x22 alt=\x22\x22\x3e\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e这很整洁吧！甚至更酷，Git v2.8 引入了一个新特性，允许你在拉取时 \x3cem\x3e交互地\x3c\/em\x3e 变基。\x3c\/p\x3e\n\x3ch4\x3e\x3ca href=\x22#交互式变基\x22\x3e\x3c\/a\x3e交互式变基\x3c\/h4\x3e\n\x3cp\x3e交互式变基是变基操作的一种更强大的形态。和标准变基操作相似，它可以重写提交，但它也可以向你提供一个机会让你能够交互式地修改这些将被重新运用在新基准上的提交。\x3c\/p\x3e\n\x3cp\x3e当你运行 \x3ccode\x3egit rebase --interactive\x3c\/code\x3e (或 \x3ccode\x3egit pull --rebase=interactive\x3c\/code\x3e)时，你会在你的文本编辑器中得到一个可供选择的提交列表视图。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs routeros\x22\x3e$ git rebase master --interactive\n\npick 2fde787 ACE-1294: replaced miniamalCommit with string \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e test\npick ed93626 ACE-1294: removed pull request\x3cspan class=\x22hljs-built_in\x22\x3e service \x3c\/span\x3e\x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e test\npick b02eb9a ACE-1294: moved fromHash, toHash \x3cspan class=\x22hljs-keyword\x22\x3eand\x3c\/span\x3e diffType \x3cspan class=\x22hljs-keyword\x22\x3eto\x3c\/span\x3e batch\npick e68f710 ACE-1294: added testing data \x3cspan class=\x22hljs-keyword\x22\x3eto\x3c\/span\x3e batch email file\n\n\x3cspan class=\x22hljs-comment\x22\x3e# Rebase f32fa9d..0ddde5f onto f32fa9d (4 commands)\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e#\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e# Commands:\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e# p, pick = use commit\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e# r, reword = use commit, but edit the commit message\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e# e, edit = use commit, but stop for amending\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e# s, squash = use commit, but meld into previous commit\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e# f, fixup = like \x22squash\x22, but discard this commit\x27s log message\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e# x, exec = run command (the rest of the line) using shell\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e# d, drop = remove commit\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e#\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e# These lines can be re-ordered; they are executed from top to \x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e# bottom.\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e#\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e# If you remove a line here THAT COMMIT WILL BE LOST.\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e注意到每一条提交旁都有一个 \x3ccode\x3epick\x3c\/code\x3e。这是对 rebase 而言，“照原样留下这个提交”。如果你现在就退出文本编辑器，它会执行一次如上文所述的普通变基操作。但是，如果你将 \x3ccode\x3epick\x3c\/code\x3e 改为 \x3ccode\x3eedit\x3c\/code\x3e 或者其他 rebase 命令中的一个，变基操作会允许你在它被重新运用前改变它。有效的变基命令有如下几种：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3ccode\x3ereword\x3c\/code\x3e：编辑提交信息。\x3c\/li\x3e\n\x3cli\x3e\x3ccode\x3eedit\x3c\/code\x3e：编辑提交了的文件。\x3c\/li\x3e\n\x3cli\x3e\x3ccode\x3esquash\x3c\/code\x3e：将提交与之前的提交（同在文件中）合并，并将提交信息拼接。\x3c\/li\x3e\n\x3cli\x3e\x3ccode\x3efixup\x3c\/code\x3e：将本提交与上一条提交合并，并且逐字使用上一条提交的提交信息（这很方便，如果你为一个很小的改动创建了第二个提交，而它本身就应该属于上一条提交，例如，你忘记暂存了一个文件）。\x3c\/li\x3e\n\x3cli\x3e\x3ccode\x3eexec\x3c\/code\x3e: 运行一条任意的 shell 命令（我们将会在下一节看到本例一次简洁的使用场景）。\x3c\/li\x3e\n\x3cli\x3e\x3ccode\x3edrop\x3c\/code\x3e: 这将丢弃这条提交。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e你也可以在文件内重新整理提交，这样会改变它们被重新应用的顺序。当你对不同的主题创建了交错的提交时这会很顺手，你可以使用 \x3ccode\x3esquash\x3c\/code\x3e 或者 \x3ccode\x3efixup\x3c\/code\x3e 来将其合并成符合逻辑的原子提交。\x3c\/p\x3e\n\x3cp\x3e当你设置完命令并且保存这个文件后，Git 将递归每一条提交，在每个 \x3ccode\x3ereword\x3c\/code\x3e 和 \x3ccode\x3eedit\x3c\/code\x3e 命令处为你暂停来执行你设计好的改变，并且自动运行 \x3ccode\x3esquash\x3c\/code\x3e， \x3ccode\x3efixup\x3c\/code\x3e，\x3ccode\x3eexec\x3c\/code\x3e 和 \x3ccode\x3edrop\x3c\/code\x3e 命令。\x3c\/p\x3e\n\x3cp\x3e####非交互性式执行\x3c\/p\x3e\n\x3cp\x3e当你执行变基操作时，本质上你是在通过将你每一条新提交应用于指定基址的头部来重写历史。\x3ccode\x3egit pull --rebase\x3c\/code\x3e 可能会有一点危险，因为根据上游分支改动的事实，你的新建历史可能会由于特定的提交遭遇测试失败甚至编译问题。如果这些改动引起了合并冲突，变基过程将会暂停并且允许你来解决它们。但是，整洁的合并改动仍然有可能打断编译或测试过程，留下破败的提交弄乱你的提交历史。\x3c\/p\x3e\n\x3cp\x3e但是，你可以指导 Git 为每一个重写的提交来运行你的项目测试套件。在 Git v2.9 之前，你可以通过绑定 \x3ccode\x3egit rebase --interactive\x3c\/code\x3e 和 \x3ccode\x3eexec\x3c\/code\x3e 命令来实现。例如这样：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs shell\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3e$\x3c\/span\x3e\x3cspan class=\x22bash\x22\x3e git rebase master −−interactive −−\x3cspan class=\x22hljs-built_in\x22\x3eexec\x3c\/span\x3e=”npm \x3cspan class=\x22hljs-built_in\x22\x3etest\x3c\/span\x3e”\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e……这会生成一个交互式变基计划，在重写每条提交后执行 \x3ccode\x3enpm test\x3c\/code\x3e ，保证你的测试仍然会通过：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs routeros\x22\x3epick 2fde787 ACE-1294: replaced miniamalCommit with string \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e test\nexec npm test\npick ed93626 ACE-1294: removed pull request\x3cspan class=\x22hljs-built_in\x22\x3e service \x3c\/span\x3e\x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e test\nexec npm test\npick b02eb9a ACE-1294: moved fromHash, toHash \x3cspan class=\x22hljs-keyword\x22\x3eand\x3c\/span\x3e diffType \x3cspan class=\x22hljs-keyword\x22\x3eto\x3c\/span\x3e batch\nexec npm test\npick e68f710 ACE-1294: added testing data \x3cspan class=\x22hljs-keyword\x22\x3eto\x3c\/span\x3e batch email file\nexec npm test\n\n\x3cspan class=\x22hljs-comment\x22\x3e# Rebase f32fa9d..0ddde5f onto f32fa9d (4 command(s))\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e如果出现了测试失败的情况，变基会暂停并让你修复这些测试(并且将你的修改应用于相应提交)：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs stata\x22\x3e291 passing\n1 failing\n\n1) Host request \x3cspan class=\x22hljs-string\x22\x3e\x22after all\x22\x3c\/span\x3e hook:\nUncaught \x3cspan class=\x22hljs-keyword\x22\x3eError\x3c\/span\x3e: connect ECONNRESET 127.0.0.1:3001\n…\nnpm \x3cspan class=\x22hljs-keyword\x22\x3eERR\x3c\/span\x3e! \x3cspan class=\x22hljs-keyword\x22\x3eTest\x3c\/span\x3e failed.\nExecution failed: npm \x3cspan class=\x22hljs-keyword\x22\x3etest\x3c\/span\x3e\nYou can fix the problem, and then \x3cspan class=\x22hljs-keyword\x22\x3erun\x3c\/span\x3e\n        git rebase −−\x3cspan class=\x22hljs-keyword\x22\x3econtinue\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e这很方便，但是使用交互式变基有一点臃肿。到了 Git v2.9，你可以这样来实现非交互式变基：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs crmsh\x22\x3e$ git rebase \x3cspan class=\x22hljs-keyword\x22\x3emaster\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e-x\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22npm test\x22\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e可以简单替换 \x3ccode\x3enpm test\x3c\/code\x3e 为 \x3ccode\x3emake\x3c\/code\x3e，\x3ccode\x3erake\x3c\/code\x3e，\x3ccode\x3emvn clean install\x3c\/code\x3e，或者任何你用来构建或测试你的项目的命令。\x3c\/p\x3e\n\x3ch4\x3e\x3ca href=\x22#小小警告\x22\x3e\x3c\/a\x3e小小警告\x3c\/h4\x3e\n\x3cp\x3e就像电影里一样，重写历史可是一个危险的行当。任何提交被重写为变基操作的一部分都将改变它的 SHA-1 ID，这意味着 Git 会把它当作一个全新的提交对待。如果重写的历史和原来的历史混杂，你将获得重复的提交，而这可能在你的团队中引起不少的疑惑。\x3c\/p\x3e\n\x3cp\x3e为了避免这个问题，你仅仅需要遵照一条简单的规则：\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3e\x3cem\x3e永远不要变基一条你已经推送的提交！\x3c\/em\x3e\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e坚持这一点你会没事的。\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22#git-lfs-的性能提升\x22\x3e\x3c\/a\x3eGit LFS 的性能提升\x3c\/h3\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/www.atlassian.com\/git\/tutorials\/what-is-git\/\x22\x3eGit 是一个分布式版本控制系统\x3c\/a\x3e，意味着整个仓库的历史会在克隆阶段被传送到客户端。对包含大文件的项目——尤其是大文件经常被修改——初始克隆会非常耗时，因为每一个版本的每一个文件都必须下载到客户端。\x3ca href=\x22https:\/\/www.atlassian.com\/git\/tutorials\/git-lfs\/\x22\x3eGit LFS（Large File Storage 大文件存储）\x3c\/a\x3e 是一个 Git 拓展包，由 Atlassian、GitHub 和其他一些开源贡献者开发，通过需要时才下载大文件的相对版本来减少仓库中大文件的影响。更明确地说，大文件是在检出过程中按需下载的而不是在克隆或抓取过程中。\x3c\/p\x3e\n\x3cp\x3e在 Git 2016 年的五大发布中，Git LFS 自身就有四个功能版本的发布：v1.2 到 v1.5。你可以仅对 Git LFS 这一项来写一系列回顾文章，但是就这篇文章而言，我将专注于 2016 年解决的一项最重要的主题：速度。一系列针对 Git 和 Git LFS 的改进极大程度地优化了将文件传入\/传出服务器的性能。\x3c\/p\x3e\n\x3ch4\x3e\x3ca href=\x22#长期过滤进程\x22\x3e\x3c\/a\x3e长期过滤进程\x3c\/h4\x3e\n\x3cp\x3e当你 \x3ccode\x3egit add\x3c\/code\x3e 一个文件时，Git 的净化过滤系统会被用来在文件被写入 Git 目标存储之前转化文件的内容。Git LFS 通过使用净化过滤器（clean filter）将大文件内容存储到 LFS 缓存中以缩减仓库的大小，并且增加一个小“指针”文件到 Git 目标存储中作为替代。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/camo.githubusercontent.com\/658ecc8755b6080a0ad81e1bbe14151ff8c614b8\/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f302a4b7533323865636137474c4f6f3773532e706e67\x22\x3e\x3cimg src=\x22https:\/\/p2.ssl.qhimg.com\/t01eb7a45ac12938ac0.png\x22 alt=\x22\x22\x3e\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e污化过滤器（smudge filter）是净化过滤器的对立面——正如其名。在 \x3ccode\x3egit checkout\x3c\/code\x3e 过程中从一个 Git 目标仓库读取文件内容时，污化过滤系统有机会在文件被写入用户的工作区前将其改写。Git LFS 污化过滤器通过将指针文件替代为对应的大文件将其转化，可以是从 LFS 缓存中获得或者通过读取存储在 Bitbucket 的 Git LFS。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/camo.githubusercontent.com\/2d49fed339b6b1b42c3606ab46e674a3ccbb1a39\/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f302a435536306d6545316c62437569766e372e706e67\x22\x3e\x3cimg src=\x22https:\/\/p4.ssl.qhimg.com\/t01c820b5bfd70608f7.png\x22 alt=\x22\x22\x3e\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e传统上，污化和净化过滤进程在每个文件被增加和检出时只能被唤起一次。所以，一个项目如果有 1000 个文件在被 Git LFS 追踪 ，做一次全新的检出需要唤起 \x3ccode\x3egit-lfs-smudge\x3c\/code\x3e 命令 1000 次。尽管单次操作相对很迅速，但是经常执行 1000 次独立的污化进程总耗费惊人。、\x3c\/p\x3e\n\x3cp\x3e针对 Git v2.11（和 Git LFS v1.5），污化和净化过滤器可以被定义为长期进程，为第一个需要过滤的文件调用一次，然后为之后的文件持续提供污化或净化过滤直到父 Git 操作结束。\x3ca href=\x22https:\/\/twitter.com\/kit3bus\x22\x3eLars Schneider\x3c\/a\x3e，Git 的长期过滤系统的贡献者，简洁地总结了对 Git LFS 性能改变带来的影响。\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3e使用 12k 个文件的测试仓库的过滤进程在 macOS 上快了 80 倍，在 Windows 上 快了 58 倍。在 Windows 上，这意味着测试运行了 57 秒而不是 55 分钟。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e这真是一个让人印象深刻的性能增强！\x3c\/p\x3e\n\x3ch4\x3e\x3ca href=\x22#lfs-专有克隆\x22\x3e\x3c\/a\x3eLFS 专有克隆\x3c\/h4\x3e\n\x3cp\x3e长期运行的污化和净化过滤器在对向本地缓存读写的加速做了很多贡献，但是对大目标传入\/传出 Git LFS 服务器的速度提升贡献很少。 每次 Git LFS 污化过滤器在本地 LFS 缓存中无法找到一个文件时，它不得不使用两次 HTTP 请求来获得该文件：一个用来定位文件，另外一个用来下载它。在一次 \x3ccode\x3egit clone\x3c\/code\x3e 过程中，你的本地 LFS 缓存是空的，所以 Git LFS 会天真地为你的仓库中每个 LFS 所追踪的文件创建两个 HTTP 请求：\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/camo.githubusercontent.com\/f9a0c13263703d626730c22f6135bc3fd3c09ff2\/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f302a56694c3772335a686b477646307a332d2e706e67\x22\x3e\x3cimg src=\x22https:\/\/p5.ssl.qhimg.com\/t0171d4a980ea3d70ff.png\x22 alt=\x22\x22\x3e\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e幸运的是，Git LFS v1.2 提供了专门的 \x3ca href=\x22https:\/\/www.atlassian.com\/git\/tutorials\/git-lfs\/#speeding-up-clones\x22\x3e\x3ccode\x3egit lfs clone\x3c\/code\x3e\x3c\/a\x3e 命令。不再是一次下载一个文件； \x3ccode\x3egit lfs clone\x3c\/code\x3e 禁止 Git LFS 污化过滤器，等待检出结束，然后从 Git LFS 存储中按批下载任何需要的文件。这允许了并行下载并且将需要的 HTTP 请求数量减半。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/camo.githubusercontent.com\/02039747318974fe99415d945a77af87a7919a79\/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f302a543433564130445954756a444e676b482e706e67\x22\x3e\x3cimg src=\x22https:\/\/p2.ssl.qhimg.com\/t0176960e23d33f59ca.png\x22 alt=\x22\x22\x3e\x3c\/a\x3e\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22#自定义传输路由器transfer-adapter\x22\x3e\x3c\/a\x3e自定义传输路由器（Transfer Adapter）\x3c\/h3\x3e\n\x3cp\x3e正如之前讨论过的，Git LFS 在 v1.5 中提供对长期过滤进程的支持。不过，对另外一种类型的可插入进程的支持早在今年年初就发布了。 Git LFS 1.3 包含了对可插拔传输路由器（pluggable transfer adapter）的支持，因此不同的 Git LFS 托管服务可以定义属于它们自己的协议来向或从 LFS 存储中传输文件。\x3c\/p\x3e\n\x3cp\x3e直到 2016 年底，Bitbucket 是唯一一个执行专属 Git LFS 传输协议 \x3ca href=\x22https:\/\/confluence.atlassian.com\/bitbucket\/bitbucket-lfs-media-adapter-856699998.html\x22\x3eBitbucket LFS Media Adapter\x3c\/a\x3e 的托管服务商。这是为了从 Bitbucket 的一个被称为 chunking 的 LFS 存储 API 独特特性中获益。Chunking 意味着在上传或下载过程中，大文件被分解成 4MB 的文件块（chunk）。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/camo.githubusercontent.com\/7f97ef6727044419029b93d887cb0eacd20d7465\/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f312a4e3353706a515a51314765384f777657727453316f672e676966\x22\x3e\x3cimg src=\x22https:\/\/p1.ssl.qhimg.com\/t0152c8fea85f077fe7.gif\x22 alt=\x22\x22\x3e\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e分块给予了 Bitbucket 支持的 Git LFS 三大优势：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e并行下载与上传。默认地，Git LFS 最多并行传输三个文件。但是，如果只有一个文件被单独传输（这也是 Git LFS 污化过滤器的默认行为），它会在一个单独的流中被传输。Bitbucket 的分块允许同一文件的多个文件块同时被上传或下载，经常能够神奇地提升传输速度。\x3c\/li\x3e\n\x3cli\x3e可续传的文件块传输。文件块都在本地缓存，所以如果你的下载或上传被打断，Bitbucket 的自定义 LFS 流媒体路由器会在下一次你推送或拉取时仅为丢失的文件块恢复传输。\x3c\/li\x3e\n\x3cli\x3e免重复。Git LFS，正如 Git 本身，是一种可定位的内容；每一个 LFS 文件都由它的内容生成的 SHA-256 哈希值认证。所以，哪怕你稍微修改了一位数据，整个文件的 SHA-256 就会修改而你不得不重新上传整个文件。分块允许你仅仅重新上传文件真正被修改的部分。举个例子，想想一下 Git LFS 在追踪一个 41M 的精灵表格（spritesheet）。如果我们增加在此精灵表格上增加 2MB 的新的部分并且提交它，传统上我们需要推送整个新的 43M 文件到服务器端。但是，使用 Bitbucket 的自定义传输路由，我们仅仅需要推送大约 7MB：先是 4MB 文件块（因为文件的信息头会改变）和我们刚刚添加的包含新的部分的 3MB 文件块！其余未改变的文件块在上传过程中被自动跳过，节省了巨大的带宽和时间消耗。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e可自定义的传输路由器是 Git LFS 的一个伟大的特性，它们使得不同服务商在不重载核心项目的前提下体验适合其服务器的优化后的传输协议。\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22#更佳的-git-diff-算法与默认值\x22\x3e\x3c\/a\x3e更佳的 git diff 算法与默认值\x3c\/h3\x3e\n\x3cp\x3e不像其他的版本控制系统，Git 不会明确地存储文件被重命名了的事实。例如，如果我编辑了一个简单的 Node.js 应用并且将 \x3ccode\x3eindex.js\x3c\/code\x3e 重命名为 \x3ccode\x3eapp.js\x3c\/code\x3e，然后运行 \x3ccode\x3egit diff\x3c\/code\x3e，我会得到一个看起来像一个文件被删除另一个文件被新建的结果。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/camo.githubusercontent.com\/f9cb182eebbe4ab52533eaeb270ee7669d887c85\/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f312a6f684d55427053685f6a717a32666653634a374170512e706e67\x22\x3e\x3cimg src=\x22https:\/\/p1.ssl.qhimg.com\/t011f50b83c9e5d0a3b.png\x22 alt=\x22\x22\x3e\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e我猜测移动或重命名一个文件从技术上来讲是一次删除后跟着一次新建，但这不是对人类最友好的描述方式。其实，你可以使用 \x3ccode\x3e-M\x3c\/code\x3e 标志来指示 Git 在计算差异时同时尝试检测是否是文件重命名。对之前的例子，\x3ccode\x3egit diff -M\x3c\/code\x3e 给我们如下结果：\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/camo.githubusercontent.com\/8265772aeb8e1d2d7affdf30bd5fbba0e411ece1\/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f312a7977596a78426331776969354f3845684862704354412e706e67\x22\x3e\x3cimg src=\x22https:\/\/p4.ssl.qhimg.com\/t01b39940a7306968d2.png\x22 alt=\x22\x22\x3e\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e第二行显示的 similarity index 告诉我们文件内容经过比较后的相似程度。默认地，\x3ccode\x3e-M\x3c\/code\x3e 会处理任意两个超过 50% 相似度的文件。这意味着，你需要编辑少于 50% 的行数来确保它们可以被识别成一个重命名后的文件。你可以通过加上一个百分比来选择你自己的 similarity index，如，\x3ccode\x3e-M80%\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e到 Git v2.9 版本，无论你是否使用了 \x3ccode\x3e-M\x3c\/code\x3e 标志， \x3ccode\x3egit diff\x3c\/code\x3e 和 \x3ccode\x3egit log\x3c\/code\x3e 命令都会默认检测重命名。如果不喜欢这种行为（或者，更现实的情况，你在通过一个脚本来解析 diff 输出），那么你可以通过显式的传递 \x3ccode\x3e--no-renames\x3c\/code\x3e 标志来禁用这种行为。\x3c\/p\x3e\n\x3ch4\x3e\x3ca href=\x22#详细的提交\x22\x3e\x3c\/a\x3e详细的提交\x3c\/h4\x3e\n\x3cp\x3e你经历过调用 \x3ccode\x3egit commit\x3c\/code\x3e 然后盯着空白的 shell 试图想起你刚刚做过的所有改动吗？\x3ccode\x3everbose\x3c\/code\x3e 标志就为此而来！\x3c\/p\x3e\n\x3cp\x3e不像这样：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs shell\x22\x3eAh crap, which dependency did I just rev?\n\x3cspan class=\x22hljs-meta\x22\x3e\n#\x3c\/span\x3e\x3cspan class=\x22bash\x22\x3e Please enter the commit message \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e your changes. Lines starting\x3c\/span\x3e\n\x3cspan class=\x22hljs-meta\x22\x3e#\x3c\/span\x3e\x3cspan class=\x22bash\x22\x3e with ‘\x3cspan class=\x22hljs-comment\x22\x3e#’ will be ignored, and an empty message aborts the commit.\x3c\/span\x3e\x3c\/span\x3e\n\x3cspan class=\x22hljs-meta\x22\x3e#\x3c\/span\x3e\x3cspan class=\x22bash\x22\x3e On branch master\x3c\/span\x3e\n\x3cspan class=\x22hljs-meta\x22\x3e#\x3c\/span\x3e\x3cspan class=\x22bash\x22\x3e Your branch is up-to-date with ‘origin\/master’.\x3c\/span\x3e\n\x3cspan class=\x22hljs-meta\x22\x3e#\x3c\/span\x3e\x3cspan class=\x22bash\x22\x3e\x3c\/span\x3e\n\x3cspan class=\x22hljs-meta\x22\x3e#\x3c\/span\x3e\x3cspan class=\x22bash\x22\x3e Changes to be committed:\x3c\/span\x3e\n\x3cspan class=\x22hljs-meta\x22\x3e#\x3c\/span\x3e\x3cspan class=\x22bash\x22\x3e new file: package.json\x3c\/span\x3e\n\x3cspan class=\x22hljs-meta\x22\x3e#\x3c\/span\x3e\x3cspan class=\x22bash\x22\x3e\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e……你可以调用 \x3ccode\x3egit commit --verbose\x3c\/code\x3e 来查看你改动造成的行内差异。不用担心，这不会包含在你的提交信息中：\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/camo.githubusercontent.com\/179110cbdaeb0f82695d8915cec2907227239867\/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f312a31764f5945326f77335a44533842505f5166737351772e706e67\x22\x3e\x3cimg src=\x22https:\/\/p1.ssl.qhimg.com\/t01fdc5296997d2168f.png\x22 alt=\x22\x22\x3e\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3e--verbose\x3c\/code\x3e 标志并不是新出现的，但是直到 Git v2.9 你才可以通过 \x3ccode\x3egit config --global commit.verbose true\x3c\/code\x3e 永久的启用它。\x3c\/p\x3e\n\x3ch4\x3e\x3ca href=\x22#实验性的-diff-改进\x22\x3e\x3c\/a\x3e实验性的 Diff 改进\x3c\/h4\x3e\n\x3cp\x3e当一个被修改部分前后几行相同时，\x3ccode\x3egit diff\x3c\/code\x3e 可能产生一些稍微令人迷惑的输出。如果在一个文件中有两个或者更多相似结构的函数时这可能发生。来看一个有些刻意人为的例子，想象我们有一个 JS 文件包含一个单独的函数：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs lua\x22\x3e\/* @\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e} \x3cspan class=\x22hljs-string\x22\x3e\x22Bitbucket\x22\x3c\/span\x3e *\/\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eproductName\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22Bitbucket\x22\x3c\/span\x3e;\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e现在想象一下我们刚提交的改动包含一个我们专门做的 \x3cem\x3e另一个\x3c\/em\x3e可以做相似事情的函数：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs lua\x22\x3e\/* @\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e} \x3cspan class=\x22hljs-string\x22\x3e\x22Bitbucket\x22\x3c\/span\x3e *\/\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eproductId\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22Bitbucket\x22\x3c\/span\x3e;\n}\n\n\/* @\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e} \x3cspan class=\x22hljs-string\x22\x3e\x22Bitbucket\x22\x3c\/span\x3e *\/\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eproductName\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22Bitbucket\x22\x3c\/span\x3e;\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e我们希望 \x3ccode\x3egit diff\x3c\/code\x3e 显示开头五行被新增，但是实际上它不恰当地将最初提交的第一行也包含进来。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/camo.githubusercontent.com\/d07f58331dc2ea2fd4fc7142cdb0b21adcfa639f\/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f312a39433744574d4f6247484d4571442d514647486d65772e706e67\x22\x3e\x3cimg src=\x22https:\/\/p5.ssl.qhimg.com\/t014c8d7564755e3395.png\x22 alt=\x22\x22\x3e\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e错误的注释被包含在了 diff 中！这虽不是世界末日，但每次发生这种事情总免不了花费几秒钟的意识去想 _啊？_ 在十二月，Git v2.11 介绍了一个新的实验性的 diff 选项，\x3ccode\x3e--indent-heuristic\x3c\/code\x3e，尝试生成从美学角度来看更赏心悦目的 diff。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/camo.githubusercontent.com\/d9cfb9bef9a55aed9d700e4f3d02a423542b2478\/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f312a5579575a364a6a432d697a4471757957434134626f772e706e67\x22\x3e\x3cimg src=\x22https:\/\/p4.ssl.qhimg.com\/t01e999c68423a7c9a1.png\x22 alt=\x22\x22\x3e\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e在后台，\x3ccode\x3e--indent-heuristic\x3c\/code\x3e 在每一次改动造成的所有可能的 diff 中循环，并为它们分别打上一个 “不良” 分数。这是基于启发式的，如差异文件块是否以不同等级的缩进开始和结束（从美学角度讲“不良”），以及差异文件块前后是否有空白行（从美学角度讲令人愉悦）。最后，有着最低不良分数的块就是最终输出。\x3c\/p\x3e\n\x3cp\x3e这个特性还是实验性的，但是你可以通过应用 \x3ccode\x3e--indent-heuristic\x3c\/code\x3e 选项到任何 \x3ccode\x3egit diff\x3c\/code\x3e 命令来专门测试它。如果，如果你喜欢尝鲜，你可以这样将其在你的整个系统内启用：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs routeros\x22\x3e$ git\x3cspan class=\x22hljs-built_in\x22\x3e config \x3c\/span\x3e--global diff.indentHeuristic \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3ch3\x3e\x3ca href=\x22#子模块submodule差强人意\x22\x3e\x3c\/a\x3e子模块（Submodule）差强人意\x3c\/h3\x3e\n\x3cp\x3e子模块允许你从 Git 仓库内部引用和包含其他 Git 仓库。这通常被用在当一些项目管理的源依赖也在被 Git 跟踪时，或者被某些公司用来作为包含一系列相关项目的 \x3ca href=\x22https:\/\/developer.atlassian.com\/blog\/2015\/10\/monorepos-in-git\/\x22\x3emonorepo\x3c\/a\x3e 的替代品。\x3c\/p\x3e\n\x3cp\x3e由于某些用法的复杂性以及使用错误的命令相当容易破坏它们的事实，Submodule 得到了一些坏名声。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/camo.githubusercontent.com\/d31e0f36d567995d345c7fc9d47ec5fbeba11788\/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f312a784e666669456c5937425a4e4d444d306a6d304a4e512e676966\x22\x3e\x3cimg src=\x22https:\/\/p3.ssl.qhimg.com\/t010fa121f9d98d7a0a.gif\x22 alt=\x22\x22\x3e\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e但是，它们还是有着它们的用处，而且，我想这仍然是用于需要厂商依赖项的最好选择。 幸运的是，2016 对子模块的用户来说是伟大的一年，在几次发布中落地了许多意义重大的性能和特性提升。\x3c\/p\x3e\n\x3ch4\x3e\x3ca href=\x22#并行抓取\x22\x3e\x3c\/a\x3e并行抓取\x3c\/h4\x3e\n\x3cp\x3e当克隆或则抓取一个仓库时，加上 \x3ccode\x3e--recurse-submodules\x3c\/code\x3e 选项意味着任何引用的子模块也将被克隆或更新。传统上，这会被串行执行，每次只抓取一个子模块。直到 Git v2.8，你可以附加 \x3ccode\x3e--jobs=n\x3c\/code\x3e 选项来使用 _n_ 个并行线程来抓取子模块。\x3c\/p\x3e\n\x3cp\x3e我推荐永久的配置这个选项：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs routeros\x22\x3e$ git\x3cspan class=\x22hljs-built_in\x22\x3e config \x3c\/span\x3e--global submodule.fetchJobs 4\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e……或者你可以选择使用任意程度的平行化。\x3c\/p\x3e\n\x3ch4\x3e\x3ca href=\x22#浅层化子模块\x22\x3e\x3c\/a\x3e浅层化子模块\x3c\/h4\x3e\n\x3cp\x3eGit v2.9 介绍了 \x3ccode\x3egit clone —shallow-submodules\x3c\/code\x3e 标志。它允许你抓取你仓库的完整克隆，然后递归地以一个提交的深度浅层化克隆所有引用的子模块。如果你不需要项目的依赖的完整记录时会很有用。\x3c\/p\x3e\n\x3cp\x3e例如，一个仓库有着一些混合了的子模块，其中包含有其他厂商提供的依赖和你自己其它的项目。你可能希望初始化时执行浅层化子模块克隆，然后深度选择几个你想工作与其上的项目。\x3c\/p\x3e\n\x3cp\x3e另一种情况可能是配置持续集成或部署工作。Git 需要一个包含了子模块的超级仓库以及每个子模块最新的提交以便能够真正执行构建。但是，你可能并不需要每个子模块全部的历史记录，所以仅仅检索最新的提交可以为你省下时间和带宽。\x3c\/p\x3e\n\x3ch4\x3e\x3ca href=\x22#子模块的替代品\x22\x3e\x3c\/a\x3e子模块的替代品\x3c\/h4\x3e\n\x3cp\x3e\x3ccode\x3e--reference\x3c\/code\x3e 选项可以和 \x3ccode\x3egit clone\x3c\/code\x3e 配合使用来指定另一个本地仓库作为一个替代的对象存储，来避免跨网络重新复制你本地已经存在的对象。语法为：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs shell\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3e$\x3c\/span\x3e\x3cspan class=\x22bash\x22\x3e git \x3cspan class=\x22hljs-built_in\x22\x3eclone\x3c\/span\x3e --reference \x26lt;\x3cspan class=\x22hljs-built_in\x22\x3elocal\x3c\/span\x3e repo\x26gt; \x26lt;url\x26gt;\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e到 Git v2.11，你可以使用 \x3ccode\x3e—reference\x3c\/code\x3e 选项与 \x3ccode\x3e—recurse-submodules\x3c\/code\x3e 结合来设置子模块指向一个来自另一个本地仓库的子模块。其语法为：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs crmsh\x22\x3e$ git \x3cspan class=\x22hljs-keyword\x22\x3eclone\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e--recurse-submodules\x3c\/span\x3e --\x3cspan class=\x22hljs-keyword\x22\x3ereference\x3c\/span\x3e \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;local repo\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;url\x26gt;\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e这潜在的可以省下大量的带宽和本地磁盘空间，但是如果引用的本地仓库不包含你克隆的远程仓库所必需的所有子模块时，它可能会失败。\x3c\/p\x3e\n\x3cp\x3e幸运的是，方便的 \x3ccode\x3e—-reference-if-able\x3c\/code\x3e 选项将会让它优雅地失败，然后为丢失了的被引用的本地仓库的所有子模块回退为一次普通的克隆。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs crmsh\x22\x3e$ git \x3cspan class=\x22hljs-keyword\x22\x3eclone\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e--recurse-submodules\x3c\/span\x3e --\x3cspan class=\x22hljs-keyword\x22\x3ereference\x3c\/span\x3e-if-able \\\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;local repo\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;url\x26gt;\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3ch4\x3e\x3ca href=\x22#子模块的-diff\x22\x3e\x3c\/a\x3e子模块的 diff\x3c\/h4\x3e\n\x3cp\x3e在 Git v2.11 之前，Git 有两种模式来显示对更新你的仓库子模块的提交之间的差异。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3egit diff —-submodule=short\x3c\/code\x3e 显示你的项目引用的子模块中的旧提交和新提交（这也是如果你整体忽略 \x3ccode\x3e--submodule\x3c\/code\x3e 选项的默认结果）：\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/camo.githubusercontent.com\/1e00043e1bdeaf2334ff93fbc0221105d1ebd2d1\/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f312a4b3731634a33304e6f6b4f354236392d613437304e412e706e67\x22\x3e\x3cimg src=\x22https:\/\/p0.ssl.qhimg.com\/t012ed4939fbd6ecc14.png\x22 alt=\x22\x22\x3e\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3egit diff —submodule=log\x3c\/code\x3e 有一点啰嗦，显示更新了的子模块中任意新建或移除的提交的信息中统计行。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/camo.githubusercontent.com\/40cf83184cafbcc4aafbbe25a2a4ad7a34c8cfca\/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f312a66727673645f5434344465385f713075764e484231672e706e67\x22\x3e\x3cimg src=\x22https:\/\/p1.ssl.qhimg.com\/t01055401d8dce89eb7.png\x22 alt=\x22\x22\x3e\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3eGit v2.11 引入了第三个更有用的选项：\x3ccode\x3e—-submodule=diff\x3c\/code\x3e。这会显示更新后的子模块所有改动的完整的 diff。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/camo.githubusercontent.com\/306d919468131c0c5fc77e5896c4f51226560c18\/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f312a6e50684a546a503874634a306344387333594f6d6a772e706e67\x22\x3e\x3cimg src=\x22https:\/\/p1.ssl.qhimg.com\/t016d4df7e746812330.png\x22 alt=\x22\x22\x3e\x3c\/a\x3e\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22#git-stash-的-90-个增强\x22\x3e\x3c\/a\x3egit stash 的 90 个增强\x3c\/h3\x3e\n\x3cp\x3e不像子模块，几乎没有 Git 用户不钟爱 \x3ca href=\x22https:\/\/www.atlassian.com\/git\/tutorials\/git-stash\/\x22\x3e\x3ccode\x3egit stash\x3c\/code\x3e\x3c\/a\x3e。 \x3ccode\x3egit stash\x3c\/code\x3e 临时搁置（或者 _藏匿_）你对工作区所做的改动使你能够先处理其他事情，结束后重新将搁置的改动恢复到先前状态。\x3c\/p\x3e\n\x3ch4\x3e\x3ca href=\x22#自动搁置\x22\x3e\x3c\/a\x3e自动搁置\x3c\/h4\x3e\n\x3cp\x3e如果你是 \x3ccode\x3egit rebase\x3c\/code\x3e 的粉丝，你可能很熟悉 \x3ccode\x3e--autostash\x3c\/code\x3e 选项。它会在变基之前自动搁置工作区所有本地修改然后等变基结束再将其复用。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs applescript\x22\x3e$ git rebase master \x3cspan class=\x22hljs-comment\x22\x3e--autostash\x3c\/span\x3e\nCreated autostash: \x3cspan class=\x22hljs-number\x22\x3e54\x3c\/span\x3ef212a\nHEAD \x3cspan class=\x22hljs-keyword\x22\x3eis\x3c\/span\x3e now \x3cspan class=\x22hljs-keyword\x22\x3eat\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e8303\x3c\/span\x3edca It\x27s a kludge, \x3cspan class=\x22hljs-keyword\x22\x3ebut\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eput\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethe\x3c\/span\x3e tuple \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethe\x3c\/span\x3e database \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethe\x3c\/span\x3e cache.\nFirst, rewinding head \x3cspan class=\x22hljs-keyword\x22\x3eto\x3c\/span\x3e replay your work \x3cspan class=\x22hljs-keyword\x22\x3eon\x3c\/span\x3e top \x3cspan class=\x22hljs-keyword\x22\x3eof\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eit\x3c\/span\x3e...\nApplied autostash.\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e这很方便，因为它使得你可以在一个不洁的工作区执行变基。有一个方便的配置标志叫做 \x3ccode\x3erebase.autostash\x3c\/code\x3e 可以将这个特性设为默认，你可以这样来全局启用它：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs routeros\x22\x3e$ git\x3cspan class=\x22hljs-built_in\x22\x3e config \x3c\/span\x3e--global rebase.autostash \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e\x3ccode\x3erebase.autostash\x3c\/code\x3e 实际上自从 \x3ca href=\x22https:\/\/blogs.atlassian.com\/2013\/08\/what-you-need-to-know-about-the-new-git-1-8-4\/\x22\x3eGit v1.8.4\x3c\/a\x3e 就可用了，但是 v2.7 引入了通过 \x3ccode\x3e--no-autostash\x3c\/code\x3e 选项来取消这个标志的功能。如果你对未暂存的改动使用这个选项，变基会被一条工作树被污染的警告禁止：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs crmsh\x22\x3e$ git rebase \x3cspan class=\x22hljs-keyword\x22\x3emaster\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e--no-autostash\x3c\/span\x3e\nCannot rebase: You have unstaged changes.\nPlease commit \x3cspan class=\x22hljs-keyword\x22\x3eor\x3c\/span\x3e stash them.\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3ch4\x3e\x3ca href=\x22#补丁式搁置\x22\x3e\x3c\/a\x3e补丁式搁置\x3c\/h4\x3e\n\x3cp\x3e说到配置标签，Git v2.7 也引入了 \x3ccode\x3estash.showPatch\x3c\/code\x3e。\x3ccode\x3egit stash show\x3c\/code\x3e 的默认行为是显示你搁置文件的汇总。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs lsl\x22\x3e$ git stash show\npackage.json | \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e \x2b-\n\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e file \x3cspan class=\x22hljs-section\x22\x3echanged\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e insertion(\x2b), \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e deletion(-)\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e将 \x3ccode\x3e-p\x3c\/code\x3e 标志传入会将 \x3ccode\x3egit stash show\x3c\/code\x3e 变为 “补丁模式”，这将会显示完整的 diff：\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/camo.githubusercontent.com\/2b8c7b7f1b2d4300d368eca25cd29a4ae9888537\/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f3830302f312a48706354337175754b4b516a39436e657150757566772e706e67\x22\x3e\x3cimg src=\x22https:\/\/p0.ssl.qhimg.com\/t0197bc19d10975e68f.png\x22 alt=\x22\x22\x3e\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3estash.showPatch\x3c\/code\x3e 将这个行为定为默认。你可以将其全局启用：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs routeros\x22\x3e$ git\x3cspan class=\x22hljs-built_in\x22\x3e config \x3c\/span\x3e--global stash.showPatch \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e如果你使能 \x3ccode\x3estash.showPatch\x3c\/code\x3e 但却之后决定你仅仅想要查看文件总结，你可以通过传入 \x3ccode\x3e--stat\x3c\/code\x3e 选项来重新获得之前的行为。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs lsl\x22\x3e$ git stash show --stat\npackage.json | \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e \x2b-\n\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e file \x3cspan class=\x22hljs-section\x22\x3echanged\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e insertion(\x2b), \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e deletion(-)\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e顺便一提：\x3ccode\x3e--no-patch\x3c\/code\x3e 是一个有效选项但它不会如你所希望的取消 \x3ccode\x3estash.showPatch\x3c\/code\x3e。不仅如此，它会传递给用来生成补丁时潜在调用的 \x3ccode\x3egit diff\x3c\/code\x3e 命令，然后你会发现完全没有任何输出。\x3c\/p\x3e\n\x3ch4\x3e\x3ca href=\x22#简单的搁置标识\x22\x3e\x3c\/a\x3e简单的搁置标识\x3c\/h4\x3e\n\x3cp\x3e如果你惯用 \x3ccode\x3egit stash\x3c\/code\x3e ，你可能知道你可以搁置多次改动然后通过 \x3ccode\x3egit stash list\x3c\/code\x3e 来查看它们：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs stata\x22\x3e$ git stash \x3cspan class=\x22hljs-keyword\x22\x3elist\x3c\/span\x3e\nstash@{0}: \x3cspan class=\x22hljs-keyword\x22\x3eOn\x3c\/span\x3e master: crazy idea that might work \x3cspan class=\x22hljs-keyword\x22\x3eone\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eday\x3c\/span\x3e\nstash@{1}: \x3cspan class=\x22hljs-keyword\x22\x3eOn\x3c\/span\x3e master: desperate samurai refactor; don\x27t apply\nstash@{2}: \x3cspan class=\x22hljs-keyword\x22\x3eOn\x3c\/span\x3e master: perf improvement that I forgot I stashed\nstash@{3}: \x3cspan class=\x22hljs-keyword\x22\x3eOn\x3c\/span\x3e master: pop this when we \x3cspan class=\x22hljs-keyword\x22\x3euse\x3c\/span\x3e Docker \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e production\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e但是，你可能不知道为什么 Git 的搁置有着这么难以理解的标识（\x3ccode\x3estash@{1}\x3c\/code\x3e、\x3ccode\x3estash@{2}\x3c\/code\x3e 等），或许你可能将它们勾勒成 “仅仅是 Git 的癖好吧”。实际上就像很多 Git 特性一样，这些奇怪的标志实际上是 Git 数据模型的一个非常巧妙使用（或者说是滥用了的）的结果。\x3c\/p\x3e\n\x3cp\x3e在后台，\x3ccode\x3egit stash\x3c\/code\x3e 命令实际创建了一系列特定的提交目标，这些目标对你搁置的改动做了编码并且维护一个 \x3ca href=\x22https:\/\/www.atlassian.com\/git\/tutorials\/refs-and-the-reflog\/\x22\x3ereglog\x3c\/a\x3e 来保存对这些特殊提交的引用。 这也是为什么 \x3ccode\x3egit stash list\x3c\/code\x3e 的输出看起来很像 \x3ccode\x3egit reflog\x3c\/code\x3e 的输出。当你运行 \x3ccode\x3egit stash apply stash@{1}\x3c\/code\x3e 时，你实际上在说，“从 stash reflog 的位置 1 上应用这条提交。”\x3c\/p\x3e\n\x3cp\x3e到了 Git v2.11，你不再需要使用完整的 \x3ccode\x3estash@{n}\x3c\/code\x3e 语句。相反，你可以通过一个简单的整数指出该搁置在 stash reflog 中的位置来引用它们。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs shell\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3e$\x3c\/span\x3e\x3cspan class=\x22bash\x22\x3e git stash show 1\x3c\/span\x3e\n\x3cspan class=\x22hljs-meta\x22\x3e$\x3c\/span\x3e\x3cspan class=\x22bash\x22\x3e git stash apply 1\x3c\/span\x3e\n\x3cspan class=\x22hljs-meta\x22\x3e$\x3c\/span\x3e\x3cspan class=\x22bash\x22\x3e git stash pop 1\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e讲了很多了。如果你还想要多学一些搁置是怎么保存的，我在 \x3ca href=\x22https:\/\/www.atlassian.com\/git\/tutorials\/git-stash\/#how-git-stash-works\x22\x3e这篇教程\x3c\/a\x3e 中写了一点这方面的内容。\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22#2016-2017\x22\x3e\x3c\/a\x3e\x26lt;\/2016\x26gt; \x26lt;2017\x26gt;\x3c\/h3\x3e\n\x3cp\x3e好了，结束了。感谢您的阅读！我希望您喜欢阅读这份长篇大论，正如我乐于在 Git 的源码、发布文档和 \x3ccode\x3eman\x3c\/code\x3e 手册中探险一番来撰写它。如果你认为我忘记了一些重要的事，请留下一条评论或者在 \x3ca href=\x22https:\/\/twitter.com\/kannonboy\x22\x3eTwitter\x3c\/a\x3e 上让我知道，我会努力写一份后续篇章。\x3c\/p\x3e\n\x3cp\x3e至于 Git 接下来会发生什么，这要靠广大维护者和贡献者了（其中有可能就是你！）。随着 Git 的采用日益增长，我猜测简化、改进的用户体验，和更好的默认结果将会是 2017 年 Git 主要的主题。随着 Git 仓库变得越来越大、越来越旧，我猜我们也可以看到继续持续关注性能和对大文件、深度树和长历史的改进处理。\x3c\/p\x3e\n\x3cp\x3e如果你关注 Git 并且很期待能够和一些项目背后的开发者会面，请考虑来 Brussels 花几周时间来参加 \x3ca href=\x22http:\/\/git-merge.com\/\x22\x3eGit Merge\x3c\/a\x3e 。我会在\x3ca href=\x22http:\/\/git-merge.com\/#git-aliases\x22\x3e那里发言\x3c\/a\x3e！但是更重要的是，很多维护 Git 的开发者将会出席这次会议而且一年一度的 Git 贡献者峰会很可能会指定来年发展的方向。\x3c\/p\x3e\n\x3cp\x3e或者如果你实在等不及，想要获得更多的技巧和指南来改进你的工作流，请参看这份 Atlassian 的优秀作品： \x3ca href=\x22https:\/\/www.atlassian.com\/git\/tutorials\x22\x3eGit 教程\x3c\/a\x3e 。\x3c\/p\x3e\n\x3cp\x3e封面图片是由 \x3ca href=\x22http:\/\/instaco.de\/\x22\x3einstaco.de\x3c\/a\x3e 生成的。\x3c\/p\x3e\n\x3chr\x3e\n\x3cp\x3evia: \x3ca href=\x22https:\/\/medium.com\/hacker-daily\/git-in-2016-fad96ae22a15\x22\x3ehttps:\/\/medium.com\/hacker-daily\/git-in-2016-fad96ae22a15\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e作者：\x3ca href=\x22https:\/\/hackernoon.com\/@kannonboy?source=post_header_lockup\x22\x3eTim Pettersen\x3c\/a\x3e 译者：\x3ca href=\x22https:\/\/github.com\/xiaow6\x22\x3exiaow6\x3c\/a\x3e 校对：\x3ca href=\x22https:\/\/github.com\/wxy\x22\x3ewxy\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e本文由 \x3ca href=\x22https:\/\/github.com\/LCTT\/TranslateProject\x22\x3eLCTT\x3c\/a\x3e 原创编译，\x3ca href=\x22https:\/\/linux.cn\/\x22\x3eLinux中国\x3c\/a\x3e 荣誉推出\x3c\/p\x3e\n\n          \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>2016 Git 新视界</p><h2 id="原文链接">原文链接</h2><p><a href="https://www.zcfy.cc/article/git-in-2016">https://www.zcfy.cc/article/git-in-2016</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/5qln24wni8e/" target="_blank">https://alili.tech/archive/5qln24wni8e/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>