<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="为什么要用原生 JavaScript 代替 jQuery？"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>为什么要用原生 JavaScript 代替 jQuery？ | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/6lp3aa7vyfk/",
				"appid": "1613049289050283", 
				"title": "为什么要用原生 JavaScript 代替 jQuery？ | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-27T02:30:59"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/ohqta45t29/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/ch8km2kvy5n/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f6lp3aa7vyfk%2f&text=%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%94%a8%e5%8e%9f%e7%94%9f%20JavaScript%20%e4%bb%a3%e6%9b%bf%20jQuery%ef%bc%9f"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f6lp3aa7vyfk%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f6lp3aa7vyfk%2f&text=%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%94%a8%e5%8e%9f%e7%94%9f%20JavaScript%20%e4%bb%a3%e6%9b%bf%20jQuery%ef%bc%9f"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f6lp3aa7vyfk%2f&title=%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%94%a8%e5%8e%9f%e7%94%9f%20JavaScript%20%e4%bb%a3%e6%9b%bf%20jQuery%ef%bc%9f"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f6lp3aa7vyfk%2f&is_video=false&description=%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%94%a8%e5%8e%9f%e7%94%9f%20JavaScript%20%e4%bb%a3%e6%9b%bf%20jQuery%ef%bc%9f"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%94%a8%e5%8e%9f%e7%94%9f%20JavaScript%20%e4%bb%a3%e6%9b%bf%20jQuery%ef%bc%9f&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f6lp3aa7vyfk%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f6lp3aa7vyfk%2f&title=%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%94%a8%e5%8e%9f%e7%94%9f%20JavaScript%20%e4%bb%a3%e6%9b%bf%20jQuery%ef%bc%9f"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f6lp3aa7vyfk%2f&title=%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%94%a8%e5%8e%9f%e7%94%9f%20JavaScript%20%e4%bb%a3%e6%9b%bf%20jQuery%ef%bc%9f"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f6lp3aa7vyfk%2f&title=%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%94%a8%e5%8e%9f%e7%94%9f%20JavaScript%20%e4%bb%a3%e6%9b%bf%20jQuery%ef%bc%9f"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f6lp3aa7vyfk%2f&title=%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%94%a8%e5%8e%9f%e7%94%9f%20JavaScript%20%e4%bb%a3%e6%9b%bf%20jQuery%ef%bc%9f"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">为什么要用原生 JavaScript 代替 jQuery？</h1><div class="meta"><div class="postdate"><time datetime="2019-01-27" itemprop="datePublished">2019-01-27</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e随着 JavaScript 本身的完善，越来越多的人开始喜欢使用原生 JavaScript 开发代替各种库，其中不少人发出了用原生 JavaScript 代替 jQuery 的声音。这并不是什么坏事，但也不见得就是好事。如果你真的想把 jQuery 从前端依赖库中移除掉，我建议你慎重考虑。\x3c\/p\x3e\n\x3cp\x3e首先 jQuery 是一个第三方库。库存在的价值之一在于它能极大地简化开发。一般情况下，第三方库都是由原生语言特性和基础 API 库实现的。因此，理论上来说，任何库第三方库都是可以用原生语言特性代替的，问题在于\x3cstrong\x3e是否值得？\x3c\/strong\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3ejQuery 的作用\x3c\/h2\x3e\n\x3cp\x3e引用一段 jQuery 官网的话：\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3ejQuery is a fast, small, and feature-rich JavaScript library. It makes things like HTML document \x3cstrong\x3e\x3cem\x3etraversal\x3c\/em\x3e\x3c\/strong\x3e and \x3cstrong\x3e\x3cem\x3emanipulation\x3c\/em\x3e\x3c\/strong\x3e, \x3cstrong\x3e\x3cem\x3eevent handling\x3c\/em\x3e\x3c\/strong\x3e, \x3cstrong\x3e\x3cem\x3eanimation\x3c\/em\x3e\x3c\/strong\x3e, and \x3cstrong\x3e\x3cem\x3eAjax\x3c\/em\x3e\x3c\/strong\x3e much simpler with an easy-to-use API that works across \x3cstrong\x3e\x3cem\x3ea multitude of\x3c\/em\x3e\x3c\/strong\x3e browsers.\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e这一段话很谦虚的介绍了 jQuery 在处理 DOM 和跨浏览器方面做出的贡献。而事实上，这也正是我们选用 jQuery 的主要原因，并顺带使用了它带来的一些工具，比如数组工具，Deferred 等。\x3c\/p\x3e\n\x3cp\x3e对于我来说，最常用的功能包括\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e在 DOM 树中进行查询\x3c\/li\x3e\n\x3cli\x3e修改 DOM 树及 DOM 相关操作\x3c\/li\x3e\n\x3cli\x3e事件处理\x3c\/li\x3e\n\x3cli\x3eAjax\x3c\/li\x3e\n\x3cli\x3eDeferred 和 Promise\x3c\/li\x3e\n\x3cli\x3e对象和数组处理\x3c\/li\x3e\n\x3cli\x3e还有一个一直在用却很难在列清单时想到的——跨浏览器\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e到底是谁在替代谁？\x3c\/h2\x3e\n\x3cp\x3e上面提到的所有功能都能用原生代码来实现。从本质上来说，jQuery 就是用来代替原生实现，以达到减少代码，增强可读性的目的的——所以，到底是用 jQuery 代替原生代码，还是用原生代码代替 jQuery？这个先后因果关系可否搞明白？\x3c\/p\x3e\n\x3cp\x3e我看到说用 \x3ccode\x3equerySelectorAll()\x3c\/code\x3e 代替 \x3ccode\x3e$()\x3c\/code\x3e 的时候，不禁在想，用 jQuery 一个字符就能解决的，为什么要写十六个字符？大部分浏览器是有实现 \x3ccode\x3e$()\x3c\/code\x3e，但是写原生代码的时候你会考虑 \x3ccode\x3e$()\x3c\/code\x3e 的浏览器兼容性吗？jQuery 已经考虑了！\x3c\/p\x3e\n\x3cp\x3e我看到一大堆创建 DOM 结构的原生 JavaScript 代码的时候，不禁在想，用 jQuery 只需要一个方法链就解决了，我甚至可以用和 HTML 结构类似的代码(包含缩进)，比如\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 创建一个 ul 列表并加在 #container 中\n$(\x26quot;\x3cul\x3e\x26quot;).append(\n    $(\x26quot;\x3cli\x3e\x26quot;).append(\n        $(\x26quot;\x3ca\x3e\x26quot;).attr(\x26quot;href\x26quot;, \x26quot;#\x26quot;).text(\x26quot;first\x26quot;)),\n    $(\x26quot;\x3cli\x3e\x26quot;).append(\n        $(\x26quot;\x3ca\x3e\x26quot;).attr(\x26quot;href\x26quot;, \x26quot;#\x26quot;).text(\x26quot;second\x26quot;)),\n    $(\x26quot;\x3cli\x3e\x26quot;).append(\n        $(\x26quot;\x3ca\x3e\x26quot;).attr(\x26quot;href\x26quot;, \x26quot;#\x26quot;).text(\x26quot;third\x26quot;))\n).appendTo($(\x26quot;#container\x26quot;));\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建一个 ul 列表并加在 #container 中\x3c\/span\x3e\n$(\x3cspan class=\x22hljs-string\x22\x3e\x22\x26lt;ul\x26gt;\x22\x3c\/span\x3e).append(\n    $(\x3cspan class=\x22hljs-string\x22\x3e\x22\x26lt;li\x26gt;\x22\x3c\/span\x3e).append(\n        $(\x3cspan class=\x22hljs-string\x22\x3e\x22\x26lt;a\x26gt;\x22\x3c\/span\x3e).attr(\x3cspan class=\x22hljs-string\x22\x3e\x22href\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22#\x22\x3c\/span\x3e).text(\x3cspan class=\x22hljs-string\x22\x3e\x22first\x22\x3c\/span\x3e)),\n    $(\x3cspan class=\x22hljs-string\x22\x3e\x22\x26lt;li\x26gt;\x22\x3c\/span\x3e).append(\n        $(\x3cspan class=\x22hljs-string\x22\x3e\x22\x26lt;a\x26gt;\x22\x3c\/span\x3e).attr(\x3cspan class=\x22hljs-string\x22\x3e\x22href\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22#\x22\x3c\/span\x3e).text(\x3cspan class=\x22hljs-string\x22\x3e\x22second\x22\x3c\/span\x3e)),\n    $(\x3cspan class=\x22hljs-string\x22\x3e\x22\x26lt;li\x26gt;\x22\x3c\/span\x3e).append(\n        $(\x3cspan class=\x22hljs-string\x22\x3e\x22\x26lt;a\x26gt;\x22\x3c\/span\x3e).attr(\x3cspan class=\x22hljs-string\x22\x3e\x22href\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22#\x22\x3c\/span\x3e).text(\x3cspan class=\x22hljs-string\x22\x3e\x22third\x22\x3c\/span\x3e))\n).appendTo($(\x3cspan class=\x22hljs-string\x22\x3e\x22#container\x22\x3c\/span\x3e));\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这段代码用 \x3ccode\x3edocument.createElement()\x3c\/code\x3e 来实现完全没有问题，只不过代码量要大得多，而且会出现大量重复(或类似)的代码。当然是可以把这些重复代码提取出来写成函数的……不过 jQuery 已经做了。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e注，拼 HTML 的方法实在弱爆了，既容易出错，又不易阅读。如果有 ES6 的字符串模板之后，用它来写 HTML 也是个不错的主意。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e就 DOM 操作这一部分来说，jQuery 仍然是一个非常好用的工具。这是 jQuery 替代了原生 JavaScript，以前如此，现在仍然如此。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e没落的 jQuery 工具函数\x3c\/h2\x3e\n\x3cp\x3ejQuery 2006 年被发明出来的时候，还没有 ES5(2011年6月发布)。即使在 ES5 发布之后很长一段时间里，也不是所有浏览器都支持。因此在这一时期，除 DOM 操作外，jQuery 的巨大贡献在于解决跨浏览器的问题，以及提供了方便的对象和数组操作工具，比如 \x3ccode\x3eeach()\x3c\/code\x3e、\x3ccode\x3eindex()\x3c\/code\x3e 和 \x3ccode\x3efilter\x3c\/code\x3e 等。\x3c\/p\x3e\n\x3cp\x3e如今 ECMAScript 刚刚发布了 2017 的标准，浏览器标准混乱的问题也已经得到了很好的解决，前端界还出现了 Babel 这样的转译工具和 TypeScript 之类的新语言。所以现在大家都尽可放心的使用各种新的语言特性，哪怕 ECMAScript 的相关标准还在制定中。在这一时期，jQuery 提供的大量工具方法都已经有了原生替代品——在使用上差别不大的情况下，确实宁愿用原生实现。\x3c\/p\x3e\n\x3cp\x3e事实上，jQuery 也在极尽可能地采用原生实现，以提高执行效率。jQuery 没有放弃这些已有原生实现的工具函数\/方法，主要还是因为向下兼容，以及一如既往的提供浏览器兼容性——毕竟不是每一个使用 jQuery 的开发者都会使用转译工具。\x3c\/p\x3e\n\x3cp\x3e那么，对于 JavaScript 开发者而言，jQuery 确实有很多工具方法可以被原生 JavaScript 函数\/方法替代。比如\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3ccode\x3e$.parseJSON()\x3c\/code\x3e 可以用 \x3ccode\x3eJSON.parse()\x3c\/code\x3e 替代，而且 \x3ccode\x3eJSON.stringify()\x3c\/code\x3e 还弥补了 jQuery \x3cstrong\x3e没有\x3c\/strong\x3e \x3ccode\x3e$.toJSON()\x3c\/code\x3e 的不足；\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3e$.extend()\x3c\/code\x3e 的部分功能可以由 \x3ccode\x3eObject.assign()\x3c\/code\x3e 替代`\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3e$.fn\x3c\/code\x3e 的一些数据处理工具方法，比如 \x3ccode\x3eeach()\x3c\/code\x3e、\x3ccode\x3eindex()\x3c\/code\x3e 等都可以用 \x3ccode\x3eArray.prototype\x3c\/code\x3e 中相应的工具方法替代，比如 \x3ccode\x3eforEach()\x3c\/code\x3e、\x3ccode\x3eindexOf()\x3c\/code\x3e 等。\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3e$.Deferred()\x3c\/code\x3e 和 jQuery Promise 在某些情况下可以用原生 Promise 替代。它们在没有 ES6 之前也算是个不错的 Promise 实现。\x3c\/li\x3e\n\x3cli\x3e\x3ccode\x3e......\x3c\/code\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cblockquote\x3e\x3cp\x3e\x3ccode\x3e$.fn\x3c\/code\x3e 就是 \x3ccode\x3ejQuery.prototype\x3c\/code\x3e，也就是 jQuery 对象的原型。所以在其上定义的方法就是 jQuery 对象的方法。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e这些工具方法在原生 JavaScript 中已经逐渐补充完善，但它们仍然只是在某些情况下可以被替代……因为 jQuery 对象是一个特有的数据结构，针对 jQuery 自身创建的工具方法在作用于 jQuery 对象的时候会有一些针对性的实现——既然 DOM 操作仍然不能把 jQuery 抛开，那这些方法也就不可能被完全替换掉。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3ejQuery 与原生 JavaScript 的结合\x3c\/h2\x3e\n\x3cp\x3e有时候需要用 jQuery，有时候不需要用，该如何分辨？\x3c\/p\x3e\n\x3cp\x3ejQuery 的优势在于它的 DOM 处理、Ajax，以及跨浏览器。如果在项目中引入 jQuery，多半是因为对这些功能的需求。而对于不操作 DOM，也不需要考虑跨浏览器(比如用于转译工具)的部分，则考虑尽可能的用原生 JavaScript 实现。\x3c\/p\x3e\n\x3cp\x3e如此以来，一定会存在 jQuery 和原生 JavaScript 的交集，那么，就不得不说说需要注意的地方。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3ejQuery 对象实现了部分数组功能的伪数组\x3c\/h3\x3e\n\x3cp\x3e首先要注意的一点，就是 jQuery 对象是一个伪数组，它是对原生数组或伪数组(比如 DOM 节点列表)的封装。\x3c\/p\x3e\n\x3cp\x3e如果要获得某个元素，可以用 \x3ccode\x3e[]\x3c\/code\x3e 运算符或 \x3ccode\x3eget(index)\x3c\/code\x3e 方法；如果要获得包含所有元素的数组，可以使用 \x3ccode\x3etoArray()\x3c\/code\x3e 方法，或者通过 ES6 中引入的 \x3ccode\x3eArray.from()\x3c\/code\x3e 来转换。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 将普通数组转换成 jQuery 对象\nconst jo = $([1, 2, 3]);\njo instanceof jQuery;   \/\/ true\nArray.isArray(jo);      \/\/ false\n\n\/\/ 从 jQuery 对象获取元素值\nconst a1 = jo[0];       \/\/ 1\nconst a2 = jo.get(1);   \/\/ 2\n\n\/\/ 将 jQuery 对象转换成普通数组\nconst arr1 = jo.toArray();      \/\/ [1, 2, 3]\nArray.isArray(arr1);            \/\/ true\nconst arr2 = Array.from(jo);    \/\/ [1, 2, 3]\nArray.isArray(arr2);            \/\/ true\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将普通数组转换成 jQuery 对象\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e jo = $([\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e]);\njo \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e jQuery;   \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.isArray(jo);      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ false\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 从 jQuery 对象获取元素值\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e a1 = jo[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e];       \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 1\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e a2 = jo.get(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);   \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 2\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将 jQuery 对象转换成普通数组\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e arr1 = jo.toArray();      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ [1, 2, 3]\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.isArray(arr1);            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e arr2 = \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.from(jo);    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ [1, 2, 3]\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.isArray(arr2);            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e注意 \x3ccode\x3eeach\/map\x3c\/code\x3e 和 \x3ccode\x3eforEach\/map\x3c\/code\x3e 回调函数的参数顺序\x3c\/h3\x3e\n\x3cp\x3ejQuery 定义在 \x3ccode\x3e$.fn\x3c\/code\x3e 上的 \x3ccode\x3eeach()\x3c\/code\x3e 和 \x3ccode\x3emap()\x3c\/code\x3e 方法与定义在 \x3ccode\x3eArray.prototype\x3c\/code\x3e 上的原生方法 \x3ccode\x3eforEach()\x3c\/code\x3e 和 \x3ccode\x3emap()\x3c\/code\x3e 对应，它们的参数都是回调函数，但它们的回调函数定义有一些细节上的差别。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3e$.fn.each()\x3c\/code\x3e 的回调定义如下：\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e\x3ccode\x3eFunction(Integer index, Element element )\x3c\/code\x3e\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e回调的第一个参数是数组元素所在的位置(序号，从 \x3ccode\x3e0\x3c\/code\x3e 开始)，第二个参数是元素本身。\x3c\/p\x3e\n\x3cp\x3e而 \x3ccode\x3eArray.prototype.forEach()\x3c\/code\x3e 的回调定义是\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e\x3ccode\x3eFunction(currentValue, index, array)\x3c\/code\x3e\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e回调的第一个参数是数组元素本身，第二个参数才是元素所有的位置(序号)。而且这个回调有第三个参数，即整个数组的引用。\x3c\/p\x3e\n\x3cp\x3e请特别注意这两个回调定义的第一个参数和第二个参数，所表示的意义正好交换，这在混用 jQuery 和原生代码的时候很容易发生失误。\x3c\/p\x3e\n\x3cp\x3e对于 \x3ccode\x3e$.fn.map()\x3c\/code\x3e 和 \x3ccode\x3eArray.prototype.map()\x3c\/code\x3e 的回调也是如此，而且由于这两个方法同名，发生失误的概率会更大。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e注意 \x3ccode\x3eeach()\/map()\x3c\/code\x3e 中的 \x3ccode\x3ethis\x3c\/code\x3e\n\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3e$.fn.each()\x3c\/code\x3e 和 \x3ccode\x3e$.fn.map()\x3c\/code\x3e 回调中经常会使用 \x3ccode\x3ethis\x3c\/code\x3e，这个 \x3ccode\x3ethis\x3c\/code\x3e 指向的就是当前数组元素。正是因为有这个便利，所以 jQuery 在定义回请贩时候没有把元素本身作为第一个参数，而是把序号作为第一个参数。\x3c\/p\x3e\n\x3cp\x3e不过 ES6 带来了箭头函数。箭头函数最常见的作用就是用于回调。箭头函数中的 \x3ccode\x3ethis\x3c\/code\x3e 与箭头函数定义的上下文相关，而不像普通函数中的 \x3ccode\x3ethis\x3c\/code\x3e 是与调用者相关。\x3c\/p\x3e\n\x3cp\x3e现在问题来了，如果把箭头函数作为 \x3ccode\x3e$.fn.each()\x3c\/code\x3e 或 \x3ccode\x3e$.fn.map()\x3c\/code\x3e 的回调，需要特别注意 \x3ccode\x3ethis\x3c\/code\x3e 的使用——箭头函数中的 \x3ccode\x3ethis\x3c\/code\x3e 不再是元素本身。鉴于这个问题，建议若非必要，仍然使用函数表达式作为 \x3ccode\x3e$.fn.each()\x3c\/code\x3e 和 \x3ccode\x3e$.fn.map()\x3c\/code\x3e 的回调，以保持原有的 jQuery 编程习惯。实在需要使用箭头函数来引用上下文 \x3ccode\x3ethis\x3c\/code\x3e 的情况下，千万记得用其回调定义的第二个参数作为元素引用，而不是 \x3ccode\x3ethis\x3c\/code\x3e。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 将所有输入控制的 name 设置为其 id\n$(\x26quot;:input\x26quot;).each((index, input) =\x3e {\n    \/\/ const $input = $(this) 这是错误的！！！\n    const $input = $(input);\n    $input.prop(\x26quot;name\x26quot;, $input.prop(\x26quot;id\x26quot;));\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将所有输入控制的 name 设置为其 id\x3c\/span\x3e\n$(\x3cspan class=\x22hljs-string\x22\x3e\x22:input\x22\x3c\/span\x3e).each(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eindex, input\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ const $input = $(this) 这是错误的！！！\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e $input = $(input);\n    $input.prop(\x3cspan class=\x22hljs-string\x22\x3e\x22name\x22\x3c\/span\x3e, $input.prop(\x3cspan class=\x22hljs-string\x22\x3e\x22id\x22\x3c\/span\x3e));\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e\n\x3ccode\x3e$.fn.map()\x3c\/code\x3e 返回的并不是数组\x3c\/h3\x3e\n\x3cp\x3e与 \x3ccode\x3eArray.prototype.map()\x3c\/code\x3e 不同，\x3ccode\x3e$.fn.map()\x3c\/code\x3e 返回的不是数组，而是 jQuery 对象，是伪数组。如果需要得到原生数组，可以采用 \x3ccode\x3etoArray()\x3c\/code\x3e 或 \x3ccode\x3eArray.from()\x3c\/code\x3e 输出。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const codes = $([97, 98, 99]);\nconst chars = codes.map(function() {\n    return String.fromCharCode(this);\n});     \/\/ [\x26quot;a\x26quot;, \x26quot;b\x26quot;, \x26quot;c\x26quot;]\n\nchars instanceof jQuery;    \/\/ true\nArray.isArray(chars);       \/\/ false\n\nconst chars2 = chars.toArray();\nArray.isArray(chars2);      \/\/ true\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e codes = $([\x3cspan class=\x22hljs-number\x22\x3e97\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e98\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e99\x3c\/span\x3e]);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e chars = codes.map(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eString\x3c\/span\x3e.fromCharCode(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n});     \x3cspan class=\x22hljs-comment\x22\x3e\/\/ [\x22a\x22, \x22b\x22, \x22c\x22]\x3c\/span\x3e\n\nchars \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e jQuery;    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.isArray(chars);       \x3cspan class=\x22hljs-comment\x22\x3e\/\/ false\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e chars2 = chars.toArray();\n\x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.isArray(chars2);      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3ejQuery Promise\x3c\/h2\x3e\n\x3cp\x3ejQuery 是通过 \x3ccode\x3e$.Deferred()\x3c\/code\x3e 来实现的 Promise 功能。在 ES6 以前，如果引用了 jQuery，基本上不需要再专门引用一个 Promise 库，jQuery 已经实现了 Promise 的基本功能。\x3c\/p\x3e\n\x3cp\x3e不过 jQuery Promise 虽然实现了 \x3ccode\x3ethen()\x3c\/code\x3e，却没有实现 \x3ccode\x3ecatch()\x3c\/code\x3e，所以它不能兼容原生的 Promise，不过用于 \x3ca href=\x22https:\/\/github.com\/tj\/co\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eco\x3c\/a\x3e 或者 ES2017 的 \x3ccode\x3easync\/await\x3c\/code\x3e 毫无压力。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 模拟异步操作\nfunction mock(value, ms = 200) {\n    const d = $.Deferred();\n    setTimeout(() =\x3e {\n        d.resolve(value);\n    }, ms);\n    return d.promise();\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 模拟异步操作\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emock\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3evalue, ms = \x3cspan class=\x22hljs-number\x22\x3e200\x3c\/span\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e d = $.Deferred();\n    setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n        d.resolve(value);\n    }, ms);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e d.promise();\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ co 实现\nco(function* () {\n    const r1 = yield mock([\x26quot;first\x26quot;]);\n    const r2 = yield mock([...r1, \x26quot;second\x26quot;]);\n    const r3 = yield mock([...r2, \x26quot;third\x26quot;]);\n    console.log(r1, r2, r3);\n});\n\n\/\/ [\x27first\x27]\n\/\/ [\x27first\x27, \x27second\x27]\n\/\/ [\x27first\x27, \x27second\x27, \x27third\x27]\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ co 实现\x3c\/span\x3e\nco(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e* (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e r1 = \x3cspan class=\x22hljs-keyword\x22\x3eyield\x3c\/span\x3e mock([\x3cspan class=\x22hljs-string\x22\x3e\x22first\x22\x3c\/span\x3e]);\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e r2 = \x3cspan class=\x22hljs-keyword\x22\x3eyield\x3c\/span\x3e mock([...r1, \x3cspan class=\x22hljs-string\x22\x3e\x22second\x22\x3c\/span\x3e]);\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e r3 = \x3cspan class=\x22hljs-keyword\x22\x3eyield\x3c\/span\x3e mock([...r2, \x3cspan class=\x22hljs-string\x22\x3e\x22third\x22\x3c\/span\x3e]);\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(r1, r2, r3);\n});\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ [\x27first\x27]\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ [\x27first\x27, \x27second\x27]\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ [\x27first\x27, \x27second\x27, \x27third\x27]\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ async\/await 实现，需要 Chrome 55 以上版本测试\n(async () =\x3e {\n    const r1 = await mock([\x26quot;first\x26quot;]);\n    const r2 = await mock([...r1, \x26quot;second\x26quot;]);\n    const r3 = await mock([...r2, \x26quot;third\x26quot;]);\n    console.log(r1, r2, r3);\n})();\n\n\/\/ [\x27first\x27]\n\/\/ [\x27first\x27, \x27second\x27]\n\/\/ [\x27first\x27, \x27second\x27, \x27third\x27]\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ async\/await 实现，需要 Chrome 55 以上版本测试\x3c\/span\x3e\n(\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e () =\x26gt; {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e r1 = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e mock([\x3cspan class=\x22hljs-string\x22\x3e\x22first\x22\x3c\/span\x3e]);\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e r2 = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e mock([...r1, \x3cspan class=\x22hljs-string\x22\x3e\x22second\x22\x3c\/span\x3e]);\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e r3 = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e mock([...r2, \x3cspan class=\x22hljs-string\x22\x3e\x22third\x22\x3c\/span\x3e]);\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(r1, r2, r3);\n})();\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ [\x27first\x27]\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ [\x27first\x27, \x27second\x27]\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ [\x27first\x27, \x27second\x27, \x27third\x27]\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e虽然 jQuery 的 Promise 没有 \x3ccode\x3ecatch()\x3c\/code\x3e，但是提供了 \x3ccode\x3efail\x3c\/code\x3e 事件处理，这个事件在 Deferred \x3ccode\x3ereject()\x3c\/code\x3e 的时候触发。相应的还有 \x3ccode\x3edone\x3c\/code\x3e 事件，在 Deferred \x3ccode\x3eresovle()\x3c\/code\x3e 的时候触发，以及 \x3ccode\x3ealways\x3c\/code\x3e 事件，不论什么情况都会触发。\x3c\/p\x3e\n\x3cp\x3e与一次性的 \x3ccode\x3ethen()\x3c\/code\x3e 不同，事件可以注册多个处理函数，在事件触发的时候，相应的处理函数会依次执行。另外，事件不具备传递性，所以 \x3ccode\x3efail()\x3c\/code\x3e 不能在写在 \x3ccode\x3ethen()\x3c\/code\x3e 链的最后。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader9\x22\x3e结语\x3c\/h2\x3e\n\x3cp\x3e总的来说，在大量操作 DOM 的前端代码中使用 jQuery 可以带来极大的便利，也使 DOM 操作的相关代码更易读。另一方面，原生 JavaScript 带来的新特性确实可以替代 jQuery 的部分工具函数\/方法，以降低项目对 jQuery 的依赖程序。\x3c\/p\x3e\n\x3cp\x3ejQuery 和原生 JavaScript 应该是共生关系，而不是互斥关系。应该在合适的时候选用合适的方法，而不是那么绝对的非要用谁代替谁。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>为什么要用原生 JavaScript 代替 jQuery？</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000008234056">https://segmentfault.com/a/1190000008234056</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/6lp3aa7vyfk/" target="_blank">https://alili.tech/archive/6lp3aa7vyfk/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>