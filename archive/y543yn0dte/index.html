<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="探索 RxJS - 做一个 github 小应用"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>探索 RxJS - 做一个 github 小应用 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/y543yn0dte/",
				"appid": "1613049289050283", 
				"title": "探索 RxJS - 做一个 github 小应用 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-31T02:31:16"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/bwe6h0cryeg/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/5z5wl0qd2ib/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fy543yn0dte%2f&text=%e6%8e%a2%e7%b4%a2%20RxJS%20-%20%e5%81%9a%e4%b8%80%e4%b8%aa%20github%20%e5%b0%8f%e5%ba%94%e7%94%a8"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fy543yn0dte%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fy543yn0dte%2f&text=%e6%8e%a2%e7%b4%a2%20RxJS%20-%20%e5%81%9a%e4%b8%80%e4%b8%aa%20github%20%e5%b0%8f%e5%ba%94%e7%94%a8"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fy543yn0dte%2f&title=%e6%8e%a2%e7%b4%a2%20RxJS%20-%20%e5%81%9a%e4%b8%80%e4%b8%aa%20github%20%e5%b0%8f%e5%ba%94%e7%94%a8"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fy543yn0dte%2f&is_video=false&description=%e6%8e%a2%e7%b4%a2%20RxJS%20-%20%e5%81%9a%e4%b8%80%e4%b8%aa%20github%20%e5%b0%8f%e5%ba%94%e7%94%a8"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e6%8e%a2%e7%b4%a2%20RxJS%20-%20%e5%81%9a%e4%b8%80%e4%b8%aa%20github%20%e5%b0%8f%e5%ba%94%e7%94%a8&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fy543yn0dte%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fy543yn0dte%2f&title=%e6%8e%a2%e7%b4%a2%20RxJS%20-%20%e5%81%9a%e4%b8%80%e4%b8%aa%20github%20%e5%b0%8f%e5%ba%94%e7%94%a8"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fy543yn0dte%2f&title=%e6%8e%a2%e7%b4%a2%20RxJS%20-%20%e5%81%9a%e4%b8%80%e4%b8%aa%20github%20%e5%b0%8f%e5%ba%94%e7%94%a8"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fy543yn0dte%2f&title=%e6%8e%a2%e7%b4%a2%20RxJS%20-%20%e5%81%9a%e4%b8%80%e4%b8%aa%20github%20%e5%b0%8f%e5%ba%94%e7%94%a8"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fy543yn0dte%2f&title=%e6%8e%a2%e7%b4%a2%20RxJS%20-%20%e5%81%9a%e4%b8%80%e4%b8%aa%20github%20%e5%b0%8f%e5%ba%94%e7%94%a8"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">探索 RxJS - 做一个 github 小应用</h1><div class="meta"><div class="postdate"><time datetime="2019-01-31" itemprop="datePublished">2019-01-31</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e本文是一篇 RxJS 实战教程，利用 RxJS 和 github API 来一步步做一个 github 小应用。因此，文章的重点是解释 RxJS 的使用，而涉及的 ES6语法、webpack 等知识点不予讲解。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e本例的所有代码在 github 仓库：\x3ca href=\x22https:\/\/github.com\/ecmadao\/rxjs-example\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3erxjs-example\x3c\/a\x3e\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e首先要注意的是，目前在 github 上有两个主流 RxJS，它们代表不同的版本：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/ReactiveX\/rxjs\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eReactiveX - rxjs\x3c\/a\x3e RxJS 5 beta 版\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/Reactive-Extensions\/RxJS\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eReactive-Extensions - RxJS\x3c\/a\x3e RxJS 4.x 稳定版\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e这两个版本的安装和引用稍有不同：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22# 安装 4.x 稳定版\n$ npm install rx --save\n# 安装 5 beta 版\n$ npm install rxjs --save\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22bash hljs\x22\x3e\x3ccode class=\x22bash\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e# 安装 4.x 稳定版\x3c\/span\x3e\n$ npm install rx --save\n\x3cspan class=\x22hljs-comment\x22\x3e# 安装 5 beta 版\x3c\/span\x3e\n$ npm install rxjs --save\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 4.x 稳定版\nimport Rx from \x27rx\x27;\n\/\/ 5 beta 版\nimport Rx from \x27rxjs\/Rx\x27;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 4.x 稳定版\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e Rx \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27rx\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 5 beta 版\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e Rx \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27rxjs\/Rx\x27\x3c\/span\x3e;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e除此以外，它们的语法也稍有不同，比如在 5 beta 版里，\x3ccode\x3esubscribe\x3c\/code\x3e时可以代入一个对象作为参数，也可以代入回调函数作为参数，而 4.x 版则只支持以回调函数为参数的情况：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 5 beta\nvar observer = {\n  next: x =\x3e console.log(\x27Observer got a next value: \x27 \x2b x),\n  error: err =\x3e console.error(\x27Observer got an error: \x27 \x2b err),\n  complete: () =\x3e console.log(\x27Observer got a complete notification\x27),\n};\nObservable.subscribe(observer);\n\n\/\/ 5 和 4.x 都支持：\nObservable.subscribe(x =\x3e console.log(x), (err) =\x3e console.log(err), () =\x3e console.log(\x27completed\x27));\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 5 beta\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e observer = {\n  \x3cspan class=\x22hljs-attr\x22\x3enext\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3ex\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27Observer got a next value: \x27\x3c\/span\x3e \x2b x),\n  \x3cspan class=\x22hljs-attr\x22\x3eerror\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.error(\x3cspan class=\x22hljs-string\x22\x3e\x27Observer got an error: \x27\x3c\/span\x3e \x2b err),\n  \x3cspan class=\x22hljs-attr\x22\x3ecomplete\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27Observer got a complete notification\x27\x3c\/span\x3e),\n};\nObservable.subscribe(observer);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 5 和 4.x 都支持：\x3c\/span\x3e\nObservable.subscribe(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3ex\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(x), (err) =\x26gt; \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(err), () =\x26gt; \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27completed\x27\x3c\/span\x3e));\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e其他更多语法不同可以参考：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/Reactive-Extensions\/RxJS\/tree\/master\/doc\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e4.x 稳定版 Document\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/reactivex.io\/rxjs\/manual\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e5 beta 版 Document\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/ReactiveX\/rxjs\/blob\/master\/MIGRATION.md\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e从 4 到 5 的迁移\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3eLet\x27s start\x3c\/h2\x3e\n\x3cp\x3e如上所说，我们要利用 RxJS 和 github API 来一步步做一个 github 小应用。首先完成其基本功能，即通过一个 input 输入文字，并实时根据 input 内值的变化去发送异步请求，调用 github API 进行搜索。如图所示（\x3ca href=\x22https:\/\/ecmadao.github.io\/rxjs-example\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e线上 Demo\x3c\/a\x3e）：\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e通过\x3ccode\x3eRxJS\x3c\/code\x3e，在输入过程中实时进行异步搜索：\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVFTz4?w=1348\x26amp;h=1286\x22 src=\x22https:\/\/static.alili.tech\/img\/bVFTz4?w=1348\x26amp;h=1286\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e\x3ccode\x3ehover\x3c\/code\x3e到 avator 上之后异步获取用户信息\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVFTz9?w=1152\x26amp;h=870\x22 src=\x22https:\/\/static.alili.tech\/img\/bVFTz9?w=1152\x26amp;h=870\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e安装 webpack 配置编译环境，并使用 ES6 语法。安装如下依赖，并配置好 webpack：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3ewebpack\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ewebpack-dev-server\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ebabel-loader\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ebabel-preset-es2015\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ehtml-webpack-plugin\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ecss-loader \/ postcss 及其他\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ejquery\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3erx（4.x 版本）\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e通过\x3ccode\x3ewebpack-dev-server\x3c\/code\x3e，我们将会启动一个 8080 端口的服务器，使得我们编译好的资源可以在\x3ccode\x3elocalhost:8080\/webpack-dev-server\x3c\/code\x3e访问到。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3e初始化 DOM 事件流\x3c\/h3\x3e\n\x3cp\x3e在\x3ccode\x3eindex.html\x3c\/code\x3e中编写一个\x3ccode\x3einput\x3c\/code\x3e，我们将在\x3ccode\x3eindex.js\x3c\/code\x3e中，通过 RxJS 的 Observable 监听\x3ccode\x3einput\x3c\/code\x3e的\x3ccode\x3ekeyup\x3c\/code\x3e事件。可以使用\x3ca href=\x22http:\/\/reactivex.io\/documentation\/operators\/from.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\x3ccode\x3efromEvent\x3c\/code\x3e\x3c\/a\x3e来创建一个基于 DOM 事件的流，并通过\x3ca href=\x22http:\/\/reactivex.io\/documentation\/operators\/map.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\x3ccode\x3emap\x3c\/code\x3e\x3c\/a\x3e和\x3ca href=\x22http:\/\/reactivex.io\/documentation\/operators\/filter.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\x3ccode\x3efilter\x3c\/code\x3e\x3c\/a\x3e进一步处理。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3c!-- index.html --\x3e\n\x3cinput class=\x26quot;search\x26quot; type=\x26quot;text\x26quot; maxlength=\x26quot;1000\x26quot; required placeholder=\x26quot;search in github\x26quot;\/\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22xml hljs\x22\x3e\x3ccode class=\x22html\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\x26lt;!-- index.html --\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3einput\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eclass\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22search\x22\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22text\x22\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3emaxlength\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x221000\x22\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3erequired\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eplaceholder\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22search in github\x22\x3c\/span\x3e\/\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ src\/js\/index.js\nimport Rx from \x27rx\x27;\n\n$(() =\x3e {\n  const $input = $(\x27.search\x27);\n  \/\/ 通过 input 的 keyup 事件来创建流\n  const observable = Rx.Observable.fromEvent($input, \x27keyup\x27)\n      \/\/ 并获取每次 keyup 时搜索框的值，筛选出合法值\n      .map(() =\x3e $input.val().trim())\n    .filter((text) =\x3e !!text)\n    \/\/ 利用 do 可以做一些不影响流的事件，比如这里打印出 input 的值\n    .do((value) =\x3e console.log(value));\n  \/\/ 开启监听\n  observable.subscribe();\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ src\/js\/index.js\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e Rx \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27rx\x27\x3c\/span\x3e;\n\n$(() =\x26gt; {\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e $input = $(\x3cspan class=\x22hljs-string\x22\x3e\x27.search\x27\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 通过 input 的 keyup 事件来创建流\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e observable = Rx.Observable.fromEvent($input, \x3cspan class=\x22hljs-string\x22\x3e\x27keyup\x27\x3c\/span\x3e)\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 并获取每次 keyup 时搜索框的值，筛选出合法值\x3c\/span\x3e\n      .map(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e $input.val().trim())\n    .filter(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3etext\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e !!text)\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 利用 do 可以做一些不影响流的事件，比如这里打印出 input 的值\x3c\/span\x3e\n    .do(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3evalue\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(value));\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 开启监听\x3c\/span\x3e\n  observable.subscribe();\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e去 input 里随便打打字，可以看到我们已经成功监听了\x3ccode\x3ekeyup\x3c\/code\x3e事件，并在每次\x3ccode\x3ekeyup\x3c\/code\x3e时在 console 里输出 input 当前的值。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e实时进行异步获取\x3c\/h3\x3e\n\x3cp\x3e监听了 input 事件，我们就能够在每次\x3ccode\x3ekeyup\x3c\/code\x3e时拿到 value，那么就可以通过它来异步获取数据。将整个过程拆分一下：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e用户在 input 里输入任意内容\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e触发\x3ccode\x3ekeyup\x3c\/code\x3e事件，获取到当前 value\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e将 value 代入到一个异步方法里，通过接口获取数据\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e利用返回数据渲染 DOM\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e也就是说，我们要把原有的 Observable 中每个事件返回的 value 进行异步处理，并使其返回一个新的 Observable。可以这么处理：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e让每个 value 返回一个 Observable\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e通过\x3ca href=\x22http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\x3ccode\x3eflatMap\x3c\/code\x3e\x3c\/a\x3e将所有的 Observable 扁平化，成为一个新的 Observable\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e图解\x3ccode\x3eflatMap\x3c\/code\x3e：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVFTAh?w=1280\x26amp;h=620\x22 src=\x22https:\/\/static.alili.tech\/img\/bVFTAh?w=1280\x26amp;h=620\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e而既然需要异步获取数据，那么在上面的第一步时，可以通过\x3ca href=\x22http:\/\/reactivex.io\/documentation\/operators\/from.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\x3ccode\x3efromPromise\x3c\/code\x3e\x3c\/a\x3e来创建一个 Observable：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ src\/js\/helper.js\nconst SEARCH_REPOS = \x27https:\/\/api.github.com\/search\/repositories?sort=stars\x26amp;order=desc\x26amp;q=\x27;\n\n\/\/ 创建一个 ajax 的 promise\nconst getReposPromise = (query) =\x3e {\n  return $.ajax({\n      type: \x26quot;GET\x26quot;,\n    url: `${SEARCH_REPOS}${query}`,\n  }).promise();\n};\n\/\/ 通过 fromPromise 创建一个 Observable\nexport const getRepos = (query) =\x3e {\n  const promise = getReposPromise(query);\n  return Rx.Observable.fromPromise(promise);\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ src\/js\/helper.js\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e SEARCH_REPOS = \x3cspan class=\x22hljs-string\x22\x3e\x27https:\/\/api.github.com\/search\/repositories?sort=stars\x26amp;order=desc\x26amp;q=\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建一个 ajax 的 promise\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e getReposPromise = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3equery\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e $.ajax({\n      \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22GET\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3eurl\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e`\x3cspan class=\x22hljs-subst\x22\x3e${SEARCH_REPOS}\x3c\/span\x3e\x3cspan class=\x22hljs-subst\x22\x3e${query}\x3c\/span\x3e`\x3c\/span\x3e,\n  }).promise();\n};\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 通过 fromPromise 创建一个 Observable\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e getRepos = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3equery\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e promise = getReposPromise(query);\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e Rx.Observable.fromPromise(promise);\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ src\/js\/index.js\nimport {getRepos} from \x27.\/helper\x27;\n\n\/\/ ...\nconst observable = Rx.Observable.fromEvent($input, \x27keyup\x27)\n      .map(() =\x3e $input.val())\n    .filter((text) =\x3e !!text)\n    .do((value) =\x3e console.log(value))\n    \/\/ 调用 getRepos 方法将返回一个 Observable\n    \/\/ flatMap 则将所有 Observable 合并，转为一个 Observable\n    .flatMap(getRepos);\n\/\/ ...\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ src\/js\/index.js\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e {getRepos} \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/helper\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e observable = Rx.Observable.fromEvent($input, \x3cspan class=\x22hljs-string\x22\x3e\x27keyup\x27\x3c\/span\x3e)\n      .map(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e $input.val())\n    .filter(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3etext\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e !!text)\n    .do(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3evalue\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(value))\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 调用 getRepos 方法将返回一个 Observable\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ flatMap 则将所有 Observable 合并，转为一个 Observable\x3c\/span\x3e\n    .flatMap(getRepos);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样，每一次\x3ccode\x3ekeyup\x3c\/code\x3e的时候，都会根据此时 input 的 value 去异步获取数据。但这样做有几个问题：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e不断打字时会连续不断触发异步请求，占用资源影响体验\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e如果相邻的\x3ccode\x3ekeyup\x3c\/code\x3e事件触发时 input 的值一样，也就是说按下了不改变 value 的按键（比如方向键），会重复触发一样的异步事件\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e发出多个异步事件之后，每个事件所耗费的时间不一定相同。如果前一个异步所用时间较后一个长，那么当它最终返回结果时，有可能把后面的异步率先返回的结果覆盖\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e所以接下来我们就处理这几个问题。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e优化事件流\x3c\/h3\x3e\n\x3cp\x3e针对上面的问题，一步一步进行优化。\x3c\/p\x3e\n\x3chr\x3e\n\x3cblockquote\x3e\x3cp\x3e不断打字时会连续不断触发异步请求，占用资源影响体验\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e也就是说，当用户在连续打字时，我们不应该继续进行之后的事件处理，而如果打字中断，或者说两次\x3ccode\x3ekeyup\x3c\/code\x3e事件的时间间隔足够长时，才应该发送异步请求。针对这点，可以使用 RxJS 的\x3ca href=\x22http:\/\/reactivex.io\/documentation\/operators\/debounce.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\x3ccode\x3edebounce\x3c\/code\x3e\x3c\/a\x3e方法：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVFTAi?w=1280\x26amp;h=620\x22 src=\x22https:\/\/static.alili.tech\/img\/bVFTAi?w=1280\x26amp;h=620\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e如图所示，在一段时间内事件被不断触发时，不会被之后的操作所处理；只有超过指定时间间隔的事件才会留下来：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ src\/js\/index.js\n\/\/ ...\nconst observable = Rx.Observable.fromEvent($input, \x27keyup\x27)\n    \/\/ 若 400ms 内连续触发 keyup 事件，则不会继续往下处理\n    .debounce(400)\n      .map(() =\x3e $input.val())\n    .filter((text) =\x3e !!text)\n    .do((value) =\x3e console.log(value))\n    .flatMap(getRepos);\n\/\/ ...\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ src\/js\/index.js\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e observable = Rx.Observable.fromEvent($input, \x3cspan class=\x22hljs-string\x22\x3e\x27keyup\x27\x3c\/span\x3e)\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 若 400ms 内连续触发 keyup 事件，则不会继续往下处理\x3c\/span\x3e\n    .debounce(\x3cspan class=\x22hljs-number\x22\x3e400\x3c\/span\x3e)\n      .map(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e $input.val())\n    .filter(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3etext\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e !!text)\n    .do(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3evalue\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(value))\n    .flatMap(getRepos);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3chr\x3e\n\x3cblockquote\x3e\x3cp\x3e如果相邻的\x3ccode\x3ekeyup\x3c\/code\x3e事件触发时 input 的值一样，也就是说按下了不改变 value 的按键（比如方向键），会重复触发一样的异步事件\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e也就是说，对于任意相邻的事件，如果它们的返回值一样，则只要取一个（重复事件中的第一个）就好了。可以利用\x3ca href=\x22http:\/\/reactivex.io\/documentation\/operators\/distinct.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\x3ccode\x3edistinctUntilChanged\x3c\/code\x3e\x3c\/a\x3e方法：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVFTAn?w=1280\x26amp;h=620\x22 src=\x22https:\/\/static.alili.tech\/img\/bVFTAn?w=1280\x26amp;h=620\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ src\/js\/index.js\n\/\/ ...\nconst observable = Rx.Observable.fromEvent($input, \x27keyup\x27)\n    .debounce(400)\n      .map(() =\x3e $input.val())\n    .filter((text) =\x3e !!text)\n    \/\/ 只取不一样的值进行异步\n    .distinctUntilChanged()\n    .do((value) =\x3e console.log(value))\n    .flatMap(getRepos);\n\/\/ ...\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ src\/js\/index.js\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e observable = Rx.Observable.fromEvent($input, \x3cspan class=\x22hljs-string\x22\x3e\x27keyup\x27\x3c\/span\x3e)\n    .debounce(\x3cspan class=\x22hljs-number\x22\x3e400\x3c\/span\x3e)\n      .map(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e $input.val())\n    .filter(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3etext\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e !!text)\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 只取不一样的值进行异步\x3c\/span\x3e\n    .distinctUntilChanged()\n    .do(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3evalue\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(value))\n    .flatMap(getRepos);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3chr\x3e\n\x3cblockquote\x3e\x3cp\x3e发出多个异步事件之后，每个事件所耗费的时间不一定相同。如果前一个异步所用时间较后一个长，那么当它最终返回结果时，有可能把后面的异步率先返回的结果覆盖\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e这个蛋疼的问题我相信大家很可能遇见过。在发送多个异步请求时，因为所用时长不一定，无法保障异步返回的先后顺序，所以，有时候可能\x3cstrong\x3e早请求的异步的结果会覆盖后来请求的异步结果\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e而这种情况的处理方式就是，在连续发出多个异步的时候，既然我们期待的是最后一个异步返回的结果，那么就可以把之前的异步取消掉，不 care 其返回了什么。因此，我们可以使用\x3ca href=\x22http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\x3ccode\x3eflatMapLatest\x3c\/code\x3e\x3c\/a\x3e API（类似于 RxJava 中的\x3ccode\x3eswitchMap\x3c\/code\x3e API，同时在 RxJS 5.0 中也已经改名为\x3ccode\x3eswitchMap\x3c\/code\x3e）\x3c\/p\x3e\n\x3cp\x3e通过\x3ccode\x3eflatMapLatest\x3c\/code\x3e，当 Observable 触发某个事件，返回新的 Observable 时，将取消之前触发的事件，并且不再关心返回结果的处理，只监视当前这一个。也就是说，发送多个请求时，不关心之前请求的处理，只处理最后一次的请求：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVFRfd?w=1280\x26amp;h=700\x22 src=\x22https:\/\/static.alili.tech\/img\/bVFRfd?w=1280\x26amp;h=700\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ src\/js\/index.js\n\/\/ ...\nconst observable = Rx.Observable.fromEvent($input, \x27keyup\x27)\n    .debounce(400)\n      .map(() =\x3e $input.val())\n    .filter((text) =\x3e !!text)\n    .distinctUntilChanged()\n    .do((value) =\x3e console.log(value))\n    \/\/ 仅处理最后一次的异步\n    .flatMapLatest(getRepos);\n\/\/ ...\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ src\/js\/index.js\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e observable = Rx.Observable.fromEvent($input, \x3cspan class=\x22hljs-string\x22\x3e\x27keyup\x27\x3c\/span\x3e)\n    .debounce(\x3cspan class=\x22hljs-number\x22\x3e400\x3c\/span\x3e)\n      .map(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e $input.val())\n    .filter(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3etext\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e !!text)\n    .distinctUntilChanged()\n    .do(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3evalue\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(value))\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 仅处理最后一次的异步\x3c\/span\x3e\n    .flatMapLatest(getRepos);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e流的监听\x3c\/h3\x3e\n\x3cp\x3e至此，我们对 input \x3ccode\x3ekeyup\x3c\/code\x3e以及异步获取数据的整个事件流处理完毕，并进行了一定的优化，避免了过多的请求、异步返回结果错乱等问题。但创建了一个流之后也有对其进行监听：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ src\/js\/index.js\n\/\/ ...\nconst observable = Rx.Observable.fromEvent($input, \x27keyup\x27)\n    .debounce(400)\n      .map(() =\x3e $input.val())\n    .filter((text) =\x3e !!text)\n    .distinctUntilChanged()\n    .do((value) =\x3e console.log(value))\n    .flatMapLatest(getRepos);\n\/\/ 第一个回调中的 data 代表异步的返回值\nobservable.subscribe((data) =\x3e {\n  \/\/ 在 showNewResults 方法中使用返回值渲染 DOM\n  showNewResults(data);\n}, (err) =\x3e {\n  console.log(err);\n}, () =\x3e {\n  console.log(\x27completed\x27);\n});\n\n\/\/ 异步返回的结果是个 Array，代表搜索到的各个仓库 item\n\/\/ 遍历所有 item，转化为 jQuery 对象，最后插入到 content_container 中\nconst showNewResults = (items) =\x3e {\n  const repos = items.map((item, i) =\x3e {\n    return reposTemplate(item);\n  }).join(\x27\x27);\n  $(\x27.content_container\x27).html(repos);\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ src\/js\/index.js\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e observable = Rx.Observable.fromEvent($input, \x3cspan class=\x22hljs-string\x22\x3e\x27keyup\x27\x3c\/span\x3e)\n    .debounce(\x3cspan class=\x22hljs-number\x22\x3e400\x3c\/span\x3e)\n      .map(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e $input.val())\n    .filter(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3etext\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e !!text)\n    .distinctUntilChanged()\n    .do(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3evalue\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(value))\n    .flatMapLatest(getRepos);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 第一个回调中的 data 代表异步的返回值\x3c\/span\x3e\nobservable.subscribe(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 在 showNewResults 方法中使用返回值渲染 DOM\x3c\/span\x3e\n  showNewResults(data);\n}, (err) =\x26gt; {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(err);\n}, () =\x26gt; {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27completed\x27\x3c\/span\x3e);\n});\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 异步返回的结果是个 Array，代表搜索到的各个仓库 item\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 遍历所有 item，转化为 jQuery 对象，最后插入到 content_container 中\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e showNewResults = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eitems\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e repos = items.map(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eitem, i\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e reposTemplate(item);\n  }).join(\x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e);\n  $(\x3cspan class=\x22hljs-string\x22\x3e\x27.content_container\x27\x3c\/span\x3e).html(repos);\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3chr\x3e\n\x3cp\x3e这样，一个通过 RxJS 监听事件的流已经完全建立完毕了。整个过程使用图像来表示则如下：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVFTAy?w=569\x26amp;h=601\x22 src=\x22https:\/\/static.alili.tech\/img\/bVFTAy?w=569\x26amp;h=601\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e而如果我们不使用 RxJS，用传统方式监听 input 的话：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ src\/js\/index.js\nimport {getRepos} from \x27.\/helper\x27;\n\n$(() =\x3e {\n  const $input = $(\x27.search\x27);\n  const interval = 400;\n  var previousValue = null;\n  var fetching = false;\n  var lastKeyUp = Date.now() - interval;\n  $input.on(\x27keyup\x27, (e) =\x3e {\n    const nextValue = $input.val();\n    if (!nextValue) {\n      return;\n    }\n    if (Date.now() - lastKeyUp \x3c= interval) {\n      return;\n    }\n    lastKeyUp = Date.now();\n    if (nextValue === previousValue) {\n      return;\n    }\n    previousValue = nextValue;\n    if (!fetching) {\n      fetching = true;\n      getRepos(nextValue).then((data) =\x3e {\n          fetching = false;\n        showNewResults(data);\n      });\n    }\n  });\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ src\/js\/index.js\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e {getRepos} \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/helper\x27\x3c\/span\x3e;\n\n$(() =\x26gt; {\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e $input = $(\x3cspan class=\x22hljs-string\x22\x3e\x27.search\x27\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e interval = \x3cspan class=\x22hljs-number\x22\x3e400\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e previousValue = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e fetching = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e lastKeyUp = \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e.now() - interval;\n  $input.on(\x3cspan class=\x22hljs-string\x22\x3e\x27keyup\x27\x3c\/span\x3e, (e) =\x26gt; {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e nextValue = $input.val();\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!nextValue) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e.now() - lastKeyUp \x26lt;= interval) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n    }\n    lastKeyUp = \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e.now();\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (nextValue === previousValue) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n    }\n    previousValue = nextValue;\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!fetching) {\n      fetching = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n      getRepos(nextValue).then(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n          fetching = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n        showNewResults(data);\n      });\n    }\n  });\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e挺复杂了吧？而且即便如此，这样的处理还是不够到位。上面仅仅是通过\x3ccode\x3efetching\x3c\/code\x3e变量来判断是否正在异步，如果正在异步，则不进行新的异步；而我们更希望的是能够取消旧的异步，只处理新的异步请求。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e更加优雅的 Rx 风格\x3c\/h3\x3e\n\x3cp\x3e按照上面的教程，我们在 Observable 中获取到了数据、发送异步请求并拿到了最新一次的返回值。之后，再通过\x3ccode\x3esubscribe\x3c\/code\x3e，在监听的回调中将返回值拼接成 HTML 并插入 DOM。\x3c\/p\x3e\n\x3cp\x3e但是有一个问题：小应用的另一个功能是，当鼠标\x3ccode\x3ehover\x3c\/code\x3e到头像上时，异步获取并展现用户的信息。可是用户头像是在\x3ccode\x3esubscribe\x3c\/code\x3e回调中动态插入的，又该如何创建事件流呢？当然了，可以在每次插入 DOM 之后在利用\x3ccode\x3efromEvent\x3c\/code\x3e创建一个基于\x3ccode\x3ehover\x3c\/code\x3e的事件流，但那样总是不太好的，写出来的代码也不够 Rx。或许我们就不应该在\x3ccode\x3e.flatMapLatest(getRepos)\x3c\/code\x3e之后中断流的传递？但那样的话，又该如何把异步的返回值插入 DOM 呢？\x3c\/p\x3e\n\x3cp\x3e针对这种情况，我们可以使用 RxJS 的\x3ca href=\x22http:\/\/reactivex.io\/documentation\/operators\/do.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\x3ccode\x3edo\x3c\/code\x3e\x3c\/a\x3e方法：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVFTAM?w=1280\x26amp;h=620\x22 src=\x22https:\/\/static.alili.tech\/img\/bVFTAM?w=1280\x26amp;h=620\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e你想在\x3ccode\x3edo\x3c\/code\x3e的回调内做什么都可以，它不会影响到流内的事件；除此以外，还可以拿到流中各个事件的返回值：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var observable = Rx.Observable.from([0, 1, 2])\n    .do((x) =\x3e console.log(x))\n    .map((x) =\x3e x \x2b 1);\nobservable.subscribe((x) =\x3e {\n  console.log(x);\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e observable = Rx.Observable.from([\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e])\n    .do(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3ex\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(x))\n    .map(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3ex\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e x \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\nobservable.subscribe(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3ex\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(x);\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e所以，我们可以利用\x3ccode\x3edo\x3c\/code\x3e来完成 DOM 的渲染：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ src\/js\/index.js\n\/\/ ...\n\/\/ $conatiner 是装载搜索结果的容器 div\nconst $conatiner = $(\x27.content_container\x27);\n\nconst observable = Rx.Observable.fromEvent($input, \x27keyup\x27)\n    .debounce(400)\n      .map(() =\x3e $input.val())\n    .filter((text) =\x3e !!text)\n    .distinctUntilChanged()\n    .do((value) =\x3e console.log(value))\n    .flatMapLatest(getRepos)\n    \/\/ 首先把之前的搜索结果清空\n    .do((results) =\x3e $conatiner.html(\x27\x27))\n    \/\/ 利用 Rx.Observable.from 将异步的结果转化为 Observable，并通过 flatMap 合并到原有的流中。此时流中的每个元素是 results 中的每个 item\n    .flatMap((results) =\x3e Rx.Observable.from(results))\n    \/\/ 将各 item 转化为 jQuery 对象\n    .map((repos) =\x3e $(reposTemplate(repos)))\n    \/\/ 最后把每个 jQuery 对象依次加到容器里\n    .do(($repos) =\x3e {\n      $conatiner.append($repos);\n    });\n\n\/\/ 在 subscribe 中实际上什么都不用做，就能达到之前的效果\nobservable.subscribe(() =\x3e {\n  console.log(\x27success\x27);\n}, (err) =\x3e {\n  console.log(err);\n}, () =\x3e {\n  console.log(\x27completed\x27);\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ src\/js\/index.js\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ $conatiner 是装载搜索结果的容器 div\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e $conatiner = $(\x3cspan class=\x22hljs-string\x22\x3e\x27.content_container\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e observable = Rx.Observable.fromEvent($input, \x3cspan class=\x22hljs-string\x22\x3e\x27keyup\x27\x3c\/span\x3e)\n    .debounce(\x3cspan class=\x22hljs-number\x22\x3e400\x3c\/span\x3e)\n      .map(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e $input.val())\n    .filter(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3etext\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e !!text)\n    .distinctUntilChanged()\n    .do(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3evalue\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(value))\n    .flatMapLatest(getRepos)\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 首先把之前的搜索结果清空\x3c\/span\x3e\n    .do(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresults\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e $conatiner.html(\x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e))\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 利用 Rx.Observable.from 将异步的结果转化为 Observable，并通过 flatMap 合并到原有的流中。此时流中的每个元素是 results 中的每个 item\x3c\/span\x3e\n    .flatMap(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresults\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e Rx.Observable.from(results))\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将各 item 转化为 jQuery 对象\x3c\/span\x3e\n    .map(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3erepos\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e $(reposTemplate(repos)))\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 最后把每个 jQuery 对象依次加到容器里\x3c\/span\x3e\n    .do(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3e$repos\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n      $conatiner.append($repos);\n    });\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 在 subscribe 中实际上什么都不用做，就能达到之前的效果\x3c\/span\x3e\nobservable.subscribe(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27success\x27\x3c\/span\x3e);\n}, (err) =\x26gt; {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(err);\n}, () =\x26gt; {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27completed\x27\x3c\/span\x3e);\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e简直完美！现在我们这个\x3ccode\x3eobservable\x3c\/code\x3e在最后通过\x3ccode\x3emap\x3c\/code\x3e，依次返回了一个 jQuery 对象。那么之后如果要对头像添加\x3ccode\x3ehover\x3c\/code\x3e的监听，则可以在这个流的基础上继续进行。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e创建基于\x3ccode\x3ehover\x3c\/code\x3e的事件流\x3c\/h3\x3e\n\x3cp\x3e我们接下来针对用户头像的\x3ccode\x3ehover\x3c\/code\x3e事件创建一个流。用户的详细资料是异步加载的，而\x3ccode\x3ehover\x3c\/code\x3e到头像上时弹出 modal。如果是第一个\x3ccode\x3ehover\x3c\/code\x3e，则 modal 里只有一个 loading 的图标，并且异步获取数据，之后将返回的数据插入到 modal 里；而如果已经拿到并插入好了数据，则不再有异步请求，直接展示：\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e没有数据时展示 loading，同时异步获取数据\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVFTAO?w=1150\x26amp;h=428\x22 src=\x22https:\/\/static.alili.tech\/img\/bVFTAO?w=1150\x26amp;h=428\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e异步返回后插入数据。且如果已经有了数据则直接展示\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVFTAS?w=1130\x26amp;h=432\x22 src=\x22https:\/\/static.alili.tech\/img\/bVFTAS?w=1130\x26amp;h=432\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e先不管上一个流，我们先创建一个新的事件流：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ src\/js\/index.js\n\/\/ ...\nconst initialUserInfoSteam = () =\x3e {\n  const $avator = $(\x27.user_header\x27);\n  \/\/ 通过头像 $avator 的 hover 事件来创建流\n  const avatorMouseover = Rx.Observable.fromEvent($avator, \x27mouseover\x27)\n    \/\/ 500ms 内重复触发事件则会被忽略\n    .debounce(500)\n    \/\/ 只有当满足了下列条件的流才会继续执行，否则将中断\n    .takeWhile((e) =\x3e {\n      \/\/ 异步获取的用户信息被新建到 DOM 里，该 DOM 最外层是 infos_container\n      \/\/ 因此，如果已经有了 infos_container，则可以认为我们已经异步获取过数据了，此时 takeWhile 将返回 false，流将会中断\n      const $infosWrapper = $(e.target).parent().find(\x27.user_infos_wrapper\x27);\n      return $infosWrapper.find(\x27.infos_container\x27).length === 0;\n    })\n    .map((e) =\x3e {\n      const $infosWrapper = $(e.target).parent().find(\x27.user_infos_wrapper\x27);\n      return {\n        conatiner: $infosWrapper,\n        url: $(e.target).attr(\x27data-api\x27)\n      }\n    })\n    .filter((data) =\x3e !!data.url)\n    \/\/ getUser 来异步获取用户信息\n    .flatMapLatest(getUser)\n    .do((result) =\x3e {\n      \/\/ 将用户信息组建成为 DOM 元素，并插入到页面中。在这之后，该用户对应的 DOM 里就会拥有 infos_container 这个 div，所以 takeWhile 会返回 false。也就是说，之后再 hover 上去，流也不会被触发了\n      const {data, conatiner} = result;\n      showUserInfo(conatiner, data);\n    });\n\n  avatorMouseover.subscribe((result) =\x3e {\n      console.log(\x27fetch user info succeed\x27);\n  }, (err) =\x3e {\n    console.log(err);\n  }, () =\x3e {\n    console.log(\x27completed\x27);\n  });\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ src\/js\/index.js\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e initialUserInfoSteam = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e $avator = $(\x3cspan class=\x22hljs-string\x22\x3e\x27.user_header\x27\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 通过头像 $avator 的 hover 事件来创建流\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e avatorMouseover = Rx.Observable.fromEvent($avator, \x3cspan class=\x22hljs-string\x22\x3e\x27mouseover\x27\x3c\/span\x3e)\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 500ms 内重复触发事件则会被忽略\x3c\/span\x3e\n    .debounce(\x3cspan class=\x22hljs-number\x22\x3e500\x3c\/span\x3e)\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 只有当满足了下列条件的流才会继续执行，否则将中断\x3c\/span\x3e\n    .takeWhile(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3ee\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 异步获取的用户信息被新建到 DOM 里，该 DOM 最外层是 infos_container\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 因此，如果已经有了 infos_container，则可以认为我们已经异步获取过数据了，此时 takeWhile 将返回 false，流将会中断\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e $infosWrapper = $(e.target).parent().find(\x3cspan class=\x22hljs-string\x22\x3e\x27.user_infos_wrapper\x27\x3c\/span\x3e);\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e $infosWrapper.find(\x3cspan class=\x22hljs-string\x22\x3e\x27.infos_container\x27\x3c\/span\x3e).length === \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n    })\n    .map(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3ee\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e $infosWrapper = $(e.target).parent().find(\x3cspan class=\x22hljs-string\x22\x3e\x27.user_infos_wrapper\x27\x3c\/span\x3e);\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-attr\x22\x3econatiner\x3c\/span\x3e: $infosWrapper,\n        \x3cspan class=\x22hljs-attr\x22\x3eurl\x3c\/span\x3e: $(e.target).attr(\x3cspan class=\x22hljs-string\x22\x3e\x27data-api\x27\x3c\/span\x3e)\n      }\n    })\n    .filter(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e !!data.url)\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ getUser 来异步获取用户信息\x3c\/span\x3e\n    .flatMapLatest(getUser)\n    .do(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将用户信息组建成为 DOM 元素，并插入到页面中。在这之后，该用户对应的 DOM 里就会拥有 infos_container 这个 div，所以 takeWhile 会返回 false。也就是说，之后再 hover 上去，流也不会被触发了\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e {data, conatiner} = result;\n      showUserInfo(conatiner, data);\n    });\n\n  avatorMouseover.subscribe(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27fetch user info succeed\x27\x3c\/span\x3e);\n  }, (err) =\x26gt; {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(err);\n  }, () =\x26gt; {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27completed\x27\x3c\/span\x3e);\n  });\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面的代码中有一个 API 需要讲解：\x3ca href=\x22http:\/\/reactivex.io\/documentation\/operators\/takewhile.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\x3ccode\x3etakeWhile\x3c\/code\x3e\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVFTAU?w=1280\x26amp;h=610\x22 src=\x22https:\/\/static.alili.tech\/img\/bVFTAU?w=1280\x26amp;h=610\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e由图可知，当\x3ccode\x3etakeWhile\x3c\/code\x3e中的回调返回\x3ccode\x3etrue\x3c\/code\x3e时，流可以正常进行；而一旦返回\x3ccode\x3efalse\x3c\/code\x3e，则之后的事件不会再发生，流将直接终止：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var source = Rx.Observable.range(1, 5)\n    .takeWhile(function (x) { return x \x3c 3; });\n\nvar subscription = source.subscribe(\n    function (x) { console.log(\x27Next: \x27 \x2b x); },\n    function (err) { console.log(\x27Error: \x27 \x2b err); },\n    function () { console.log(\x27Completed\x27); });\n\/\/ Next: 0\n\/\/ Next: 1\n\/\/ Next: 2\n\/\/ Completed\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e source = Rx.Observable.range(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e)\n    .takeWhile(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ex\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e x \x26lt; \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e; });\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e subscription = source.subscribe(\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ex\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27Next: \x27\x3c\/span\x3e \x2b x); },\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27Error: \x27\x3c\/span\x3e \x2b err); },\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27Completed\x27\x3c\/span\x3e); });\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Next: 0\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Next: 1\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Next: 2\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Completed\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3chr\x3e\n\x3cp\x3e创建好针对\x3ccode\x3ehover\x3c\/code\x3e的事件流，我们可以把它和上一个事件流结合起来：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ src\/js\/index.js\n\/\/ ...\nconst initialUserInfoSteam = ($repos) =\x3e {\n  const $avator = $repos.find(\x27.user_header\x27);\n  \/\/ ...\n}\n\nconst observable = Rx.Observable.fromEvent($input, \x27keyup\x27)\n    \/\/ ...\n    .do(($repos) =\x3e {\n      $conatiner.append($repos);\n      initialUserInfoSteam($repos);\n    });\n\/\/ ...\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ src\/js\/index.js\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e initialUserInfoSteam = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3e$repos\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e $avator = $repos.find(\x3cspan class=\x22hljs-string\x22\x3e\x27.user_header\x27\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e observable = Rx.Observable.fromEvent($input, \x3cspan class=\x22hljs-string\x22\x3e\x27keyup\x27\x3c\/span\x3e)\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n    .do(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3e$repos\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n      $conatiner.append($repos);\n      initialUserInfoSteam($repos);\n    });\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e现在这样就已经可以使用了，但依旧不够好。目前总共有两个流：监听 input \x3ccode\x3ekeyup\x3c\/code\x3e的流和监听\x3ccode\x3emouseover\x3c\/code\x3e的流。但是，因为用户头像是动态插入的 ，所以我们必须在\x3ccode\x3e$conatiner.append($repos);\x3c\/code\x3e之后才能创建并监听\x3ccode\x3emouseover\x3c\/code\x3e。不过鉴于我们已经在最后的\x3ccode\x3edo\x3c\/code\x3e方法里插入了获取的数据，所以可以试着把两个流合并到一起：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ src\/js\/index.js\n\/\/ ...\nconst initialUserInfoSteam = ($repos) =\x3e {\n  const $avator = $repos.find(\x27.user_header\x27);\n  const avatorMouseover = Rx.Observable.fromEvent($avator, \x27mouseover\x27)\n  \/\/ ... 流的处理跟之前的一样\n  \/\/ 但我们不再需要 subscribe 它，而是返回这个 Observable\n  return avatorMouseover;\n};\n\nconst observable = Rx.Observable.fromEvent($input, \x27keyup\x27)\n    \/\/ ...\n    .do(($repos) =\x3e {\n      $conatiner.append($repos);\n      \/\/ 不再在 do 里面创建新的流并监听\n      \/\/ initialUserInfoSteam($repos);\n    })\n    \/\/ 相反，我们继续这个流的传递，只是通过 flatMap 将原来的流变成了监听 mouseover 的流\n    .flatMap(($repos) =\x3e {\n      return initialUserInfoSteam($repos);\n    });\n\/\/ ...\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ src\/js\/index.js\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e initialUserInfoSteam = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3e$repos\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e $avator = $repos.find(\x3cspan class=\x22hljs-string\x22\x3e\x27.user_header\x27\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e avatorMouseover = Rx.Observable.fromEvent($avator, \x3cspan class=\x22hljs-string\x22\x3e\x27mouseover\x27\x3c\/span\x3e)\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ... 流的处理跟之前的一样\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 但我们不再需要 subscribe 它，而是返回这个 Observable\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e avatorMouseover;\n};\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e observable = Rx.Observable.fromEvent($input, \x3cspan class=\x22hljs-string\x22\x3e\x27keyup\x27\x3c\/span\x3e)\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n    .do(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3e$repos\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n      $conatiner.append($repos);\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 不再在 do 里面创建新的流并监听\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ initialUserInfoSteam($repos);\x3c\/span\x3e\n    })\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 相反，我们继续这个流的传递，只是通过 flatMap 将原来的流变成了监听 mouseover 的流\x3c\/span\x3e\n    .flatMap(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3e$repos\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e initialUserInfoSteam($repos);\n    });\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eDONE ！\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3eAPIS\x3c\/h2\x3e\n\x3cp\x3e栗子中使用到的 RxJS API：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/reactivex.io\/documentation\/operators\/from.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\x3ccode\x3efrom\x3c\/code\x3e\x3c\/a\x3e 通过一个可迭代对象来创建流\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/reactivex.io\/documentation\/operators\/from.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\x3ccode\x3efromEvent\x3c\/code\x3e\x3c\/a\x3e 通过 DOM 事件来创建流\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/reactivex.io\/documentation\/operators\/debounce.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\x3ccode\x3edebounce\x3c\/code\x3e\x3c\/a\x3e 如果在一定时间内流中的某个事件不断被触发，则不会进行之后的事件操作\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/reactivex.io\/documentation\/operators\/map.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\x3ccode\x3emap\x3c\/code\x3e\x3c\/a\x3e 遍历流中所有事件，返回新的流\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/reactivex.io\/documentation\/operators\/filter.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\x3ccode\x3efilter\x3c\/code\x3e\x3c\/a\x3e 筛选流中所有事件，返回新的流\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\x3ccode\x3eflatMap\x3c\/code\x3e\x3c\/a\x3e 对各个事件返回的值进行处理并返回 Observable，然后将所有的 Observable 扁平化，成为一个新的 Observable\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/reactivex.io\/documentation\/operators\/flatmap.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\x3ccode\x3eflatMapLatest\x3c\/code\x3e\x3c\/a\x3e 对各个事件返回的值进行处理并返回 Observable，然后将所有的 Observable 扁平化，成为一个新的 Observable。但只会获取最后一次返回的 Observable，其他的返回结果不予处理\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/reactivex.io\/documentation\/operators\/distinct.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\x3ccode\x3edistinctUntilChanged\x3c\/code\x3e\x3c\/a\x3e 流中如果相邻事件的结果一样，则仅筛选出一个（剔除重复值）\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/reactivex.io\/documentation\/operators\/do.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\x3ccode\x3edo\x3c\/code\x3e\x3c\/a\x3e 可以依次拿到流上每个事件的返回值，利用其做一些无关流传递的事情\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/reactivex.io\/documentation\/operators\/takewhile.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\x3ccode\x3etakeWhile\x3c\/code\x3e\x3c\/a\x3e 给予流一个判断，只有当\x3ccode\x3etakeWhile\x3c\/code\x3e中的回调返回\x3ccode\x3etrue\x3c\/code\x3e时，流才会继续执行；否则将中断之后的事件\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3e扩展阅读\x3c\/h2\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/stackoverflow.com\/questions\/30840247\/what-does-rxjs-observable-debounce-do\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eWhat does RxJS observable debounce do\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/Reactive-Extensions\/RxJS\/blob\/master\/doc\/howdoi\/jquery.md\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eHow do I work with jQuery and RxJS\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/reactivex.io\/documentation\/operators.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eIntroduction of observable operators\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/ecmadao\/rxjs-example\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e文章源码 - rxjs-example\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>探索 RxJS - 做一个 github 小应用</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000007562818">https://segmentfault.com/a/1190000007562818</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/y543yn0dte/" target="_blank">https://alili.tech/archive/y543yn0dte/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>