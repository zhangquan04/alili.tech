<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="你想要的——vuex源码分析"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>你想要的——vuex源码分析 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/tdj2egk7sgk/",
				"appid": "1613049289050283", 
				"title": "你想要的——vuex源码分析 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-08T02:30:11"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/fbd5kdztg34/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/kf1clr62wpg/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2ftdj2egk7sgk%2f&text=%e4%bd%a0%e6%83%b3%e8%a6%81%e7%9a%84%e2%80%94%e2%80%94vuex%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2ftdj2egk7sgk%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2ftdj2egk7sgk%2f&text=%e4%bd%a0%e6%83%b3%e8%a6%81%e7%9a%84%e2%80%94%e2%80%94vuex%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2ftdj2egk7sgk%2f&title=%e4%bd%a0%e6%83%b3%e8%a6%81%e7%9a%84%e2%80%94%e2%80%94vuex%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2ftdj2egk7sgk%2f&is_video=false&description=%e4%bd%a0%e6%83%b3%e8%a6%81%e7%9a%84%e2%80%94%e2%80%94vuex%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e4%bd%a0%e6%83%b3%e8%a6%81%e7%9a%84%e2%80%94%e2%80%94vuex%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2ftdj2egk7sgk%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2ftdj2egk7sgk%2f&title=%e4%bd%a0%e6%83%b3%e8%a6%81%e7%9a%84%e2%80%94%e2%80%94vuex%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2ftdj2egk7sgk%2f&title=%e4%bd%a0%e6%83%b3%e8%a6%81%e7%9a%84%e2%80%94%e2%80%94vuex%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2ftdj2egk7sgk%2f&title=%e4%bd%a0%e6%83%b3%e8%a6%81%e7%9a%84%e2%80%94%e2%80%94vuex%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2ftdj2egk7sgk%2f&title=%e4%bd%a0%e6%83%b3%e8%a6%81%e7%9a%84%e2%80%94%e2%80%94vuex%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">你想要的——vuex源码分析</h1><div class="meta"><div class="postdate"><time datetime="2019-01-08" itemprop="datePublished">2019-01-08</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22大家好，今天给大家带来的是vuex（2.3.1）源码分析，希望能够能跟大家进行交流，欢迎提意见，写的不好的地方欢迎拍砖\n\n[github源码地址][1]\n\n首先我们先来看看vuex是如何跟vue项目一起结合使用的，以下是官方demo中的一个简单例子\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs markdown\x22\x3e\x3ccode\x3e大家好，今天给大家带来的是vuex（2.3.1）源码分析，希望能够能跟大家进行交流，欢迎提意见，写的不好的地方欢迎拍砖\n\n[\x3cspan class=\x22hljs-string\x22\x3egithub源码地址\x3c\/span\x3e][\x3cspan class=\x22hljs-symbol\x22\x3e1\x3c\/span\x3e]\n\n首先我们先来看看vuex是如何跟vue项目一起结合使用的，以下是官方demo中的一个简单例子\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e（1）我们必须先创建一个store\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import Vue from \x27vue\x27\nimport Vuex from \x27vuex\x27\nimport { state, mutations } from \x27.\/mutations\x27\nimport plugins from \x27.\/plugins\x27\n\nVue.use(Vuex)\n\nexport default new Vuex.Store({\n  state,\n  mutations,\n  plugins\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e Vue \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27vue\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e Vuex \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27vuex\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { state, mutations } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/mutations\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e plugins \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/plugins\x27\x3c\/span\x3e\n\nVue.use(Vuex)\n\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Vuex.Store({\n  state,\n  mutations,\n  plugins\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e（2）将这个store传给vue的实例，这样我们就能够在vue中获取到这个store并且使用它的功能了\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import \x27babel-polyfill\x27\nimport Vue from \x27vue\x27\nimport store from \x27.\/store\x27\nimport App from \x27.\/components\/App.vue\x27\n\nnew Vue({\n  store, \/\/ inject store to all children\n  el: \x27#app\x27,\n  render: h =\x3e h(App)\n})\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27babel-polyfill\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e Vue \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27vue\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e store \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/store\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e App \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/components\/App.vue\x27\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Vue({\n  store, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ inject store to all children\x3c\/span\x3e\n  el: \x3cspan class=\x22hljs-string\x22\x3e\x27#app\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3erender\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eh\x3c\/span\x3e =\x26gt;\x3c\/span\x3e h(App)\n})\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上就是vuex的简单使用方法，然后接下来我们就开始来分析vuex的源码吧\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\n\x3cp\x3e目录结构\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVQXxj?w=392\x26amp;h=532\x22 src=\x22https:\/\/static.alili.tech\/img\/bVQXxj?w=392\x26amp;h=532\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e从目录结构可以看出，vuex是一个代码比较简洁的框架\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3eindex.js——入口文件\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import { Store, install } from \x27.\/store\x27\nimport { mapState, mapMutations, mapGetters, mapActions, createNamespacedHelpers } from \x27.\/helpers\x27\n\nexport default {\n  Store,\n  install,\n  version: \x27__VERSION__\x27,\n  mapState,\n  mapMutations,\n  mapGetters,\n  mapActions,\n  createNamespacedHelpers\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { Store, install } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/store\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { mapState, mapMutations, mapGetters, mapActions, createNamespacedHelpers } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/helpers\x27\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e {\n  Store,\n  install,\n  version: \x3cspan class=\x22hljs-string\x22\x3e\x27__VERSION__\x27\x3c\/span\x3e,\n  mapState,\n  mapMutations,\n  mapGetters,\n  mapActions,\n  createNamespacedHelpers\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e入口文件只做了一件事，就是导入了其他相关的文件，并且将vuex的功能export出去，相当于定义vuex对外使用的API\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3estore.js——vuex的仓库，也是vuex中比较重要的一环\x3cbr\x3e   这个文件比较长，我们可以一点一点来分析：\x3cbr\x3e   总体来说，这个文件做了几件事，定义并导出了Store这个类和install方法，并执行了install这个方法，我们都知道，vue的所有插件都是通过install这个方法来安装的\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import applyMixin from \x27.\/mixin\x27\nimport devtoolPlugin from \x27.\/plugins\/devtool\x27\nimport ModuleCollection from \x27.\/module\/module-collection\x27\nimport { forEachValue, isObject, isPromise, assert } from \x27.\/util\x27\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs moonscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e applyMixin \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/mixin\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e devtoolPlugin \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/plugins\/devtool\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e ModuleCollection \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/module\/module-collection\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { forEachValue, isObject, isPromise, \x3cspan class=\x22hljs-built_in\x22\x3eassert\x3c\/span\x3e } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/util\x27\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e一开始导入相关的方法，后面会解释这些方法的用处\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let Vue \/\/ 定义了变量Vue，为的是引用外部的vue构造函数，这样vuex框架就可以不用导入vue这个库了\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs ceylon\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e Vue \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 定义了变量Vue，为的是引用外部的vue构造函数，这样vuex框架就可以不用导入vue这个库了\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e----------------------------------------------------------这是分割线----------------------------------------------------------------------------------------\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e接下来是定义Store这个类，从图中可以看出这个vuex中的外store对外提供的能力，包括常用的commit,dispatch，watch等\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVQXBK?w=502\x26amp;h=699\x22 src=\x22https:\/\/static.alili.tech\/img\/bVQXBK?w=502\x26amp;h=699\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e先看看构造函数吧：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22constructor (options = {}) {\n    \/\/ 这个是在开发过程中的一些环节判断，vuex要求在创建vuex store实例之前必须先使用这个方法Vue.use(Vuex)来安装vuex，项目必须也得支持promise，store也必须通过new来创建实例\n    \n    if (process.env.NODE_ENV !== \x27production\x27) {\n      assert(Vue, `must call Vue.use(Vuex) before creating a store instance.`)\n      assert(typeof Promise !== \x27undefined\x27, `vuex requires a Promise polyfill in this browser.`)\n      assert(this instanceof Store, `Store must be called with the new operator.`)\n    }\n    \n    \/\/ 从参数options中结构出相关变量\n    const {\n      plugins = [],\n      strict = false\n    } = options\n\n    let {\n      state = {}\n    } = options\n    \n    \/\/ 这个简单的，不解释\n    if (typeof state === \x27function\x27) {\n      state = state()\n    }\n\n    \/\/ store internal state\n    \/\/ 初始化store内部状态，Object.create(null)可以创建一个干净的空对象\n    this._committing = false\n    this._actions = Object.create(null)\n    this._mutations = Object.create(null)\n    this._wrappedGetters = Object.create(null)\n    \/\/ vuex支持模块，即将state通过key-value的形式拆分为多个模块\n    \/\/ 模块的具体内容可以查看这里 ：https:\/\/vuex.vuejs.org\/en\/mutations.html\n    this._modules = new ModuleCollection(options)\n    this._modulesNamespaceMap = Object.create(null)\n    \/\/ 监听队列，当执行commit时会执行队列中的函数\n    this._subscribers = []\n    \/\/ 创建一个vue实例，利用vue的watch的能力，可以监控state的改变，具体后续watch方法会介绍\n    this._watcherVM = new Vue()\n\n    \/\/ bind commit and dispatch to self\n    \n    const store = this\n    \/\/ 缓存dispatch和commit方法\n    const { dispatch, commit } = this\n    \/\/ 定义dispatch方法\n    this.dispatch = function boundDispatch (type, payload) {\n      return dispatch.call(store, type, payload)\n    }\n    \/\/ 定义commit方法\n    this.commit = function boundCommit (type, payload, options) {\n      return commit.call(store, type, payload, options)\n    }\n\n    \/\/ strict mode\n    \/\/ 定义严格模式，不要在发布环境下启用严格模式！严格模式会深度监测状态树来检测不合规的状态变更——请确保在发布环境下关闭严格模式，以避免性能损失。\n    \/\/ 具体后续enableStrictMode方法会提到\n    this.strict = strict\n\n    \/\/ init root module.\n    \/\/ this also recursively registers all sub-modules\n    \/\/ and collects all module getters inside this._wrappedGetters\n    \/\/ 这个作者的注释已经写得挺明白，就是初始化根模块，递归注册子模块，收集getter\n    installModule(this, state, [], this._modules.root)\n\n    \/\/ initialize the store vm, which is responsible for the reactivity\n    \/\/ (also registers _wrappedGetters as computed properties)\n    \/\/ 初始化store中的state,使得state变成响应式的，原理就是将state作为一个vue实例的data属性传入,具体在分析这个函数的时候会介绍\n    resetStoreVM(this, state)\n\n    \/\/ apply plugins\n    \/\/ 执行插件，这个是一个数组，所以遍历他，然后执行每个插件的函数\n    plugins.concat(devtoolPlugin).forEach(plugin =\x3e plugin(this))\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eoptions = {}\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这个是在开发过程中的一些环节判断，vuex要求在创建vuex store实例之前必须先使用这个方法Vue.use(Vuex)来安装vuex，项目必须也得支持promise，store也必须通过new来创建实例\x3c\/span\x3e\n    \n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (process.env.NODE_ENV !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e) {\n      assert(Vue, \x3cspan class=\x22hljs-string\x22\x3e`must call Vue.use(Vuex) before creating a store instance.`\x3c\/span\x3e)\n      assert(\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e !== \x3cspan class=\x22hljs-string\x22\x3e\x27undefined\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e`vuex requires a Promise polyfill in this browser.`\x3c\/span\x3e)\n      assert(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e Store, \x3cspan class=\x22hljs-string\x22\x3e`Store must be called with the new operator.`\x3c\/span\x3e)\n    }\n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 从参数options中结构出相关变量\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e {\n      plugins = [],\n      strict = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n    } = options\n\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e {\n      state = {}\n    } = options\n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这个简单的，不解释\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e state === \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e) {\n      state = state()\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ store internal state\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 初始化store内部状态，Object.create(null)可以创建一个干净的空对象\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._committing = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._actions = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.create(\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e)\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._mutations = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.create(\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e)\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._wrappedGetters = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.create(\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e)\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ vuex支持模块，即将state通过key-value的形式拆分为多个模块\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 模块的具体内容可以查看这里 ：https:\/\/vuex.vuejs.org\/en\/mutations.html\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._modules = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e ModuleCollection(options)\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._modulesNamespaceMap = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.create(\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e)\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 监听队列，当执行commit时会执行队列中的函数\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._subscribers = []\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建一个vue实例，利用vue的watch的能力，可以监控state的改变，具体后续watch方法会介绍\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._watcherVM = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Vue()\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ bind commit and dispatch to self\x3c\/span\x3e\n    \n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e store = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 缓存dispatch和commit方法\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e { dispatch, commit } = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 定义dispatch方法\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.dispatch = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eboundDispatch\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e, payload\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e dispatch.call(store, \x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e, payload)\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 定义commit方法\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.commit = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eboundCommit\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e, payload, options\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e commit.call(store, \x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e, payload, options)\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ strict mode\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 定义严格模式，不要在发布环境下启用严格模式！严格模式会深度监测状态树来检测不合规的状态变更——请确保在发布环境下关闭严格模式，以避免性能损失。\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 具体后续enableStrictMode方法会提到\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.strict = strict\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ init root module.\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ this also recursively registers all sub-modules\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ and collects all module getters inside this._wrappedGetters\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这个作者的注释已经写得挺明白，就是初始化根模块，递归注册子模块，收集getter\x3c\/span\x3e\n    installModule(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, state, [], \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._modules.root)\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ initialize the store vm, which is responsible for the reactivity\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ (also registers _wrappedGetters as computed properties)\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 初始化store中的state,使得state变成响应式的，原理就是将state作为一个vue实例的data属性传入,具体在分析这个函数的时候会介绍\x3c\/span\x3e\n    resetStoreVM(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, state)\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ apply plugins\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 执行插件，这个是一个数组，所以遍历他，然后执行每个插件的函数\x3c\/span\x3e\n    plugins.concat(devtoolPlugin).forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eplugin\x3c\/span\x3e =\x26gt;\x3c\/span\x3e plugin(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e))\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e呼呼呼~ 至此，终于把store类全部读完了，休息五分钟，然后继续往下看哈。\x3c\/p\x3e\n\x3cp\x3e接下来关于state的获取和设置\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  \/\/ 获取state,  直接返回内部data的$$state\n  get state () {\n    return this._vm._data.$$state\n  }\n\n  set state (v) {\n    if (process.env.NODE_ENV !== \x27production\x27) {\n      assert(false, `Use store.replaceState() to explicit replace store state.`)\n    }\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs pf\x22\x3e\x3ccode\x3e  \/\/ 获取\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e,  直接返回内部data的$\x3cspan class=\x22hljs-variable\x22\x3e$state\x3c\/span\x3e\n  get \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e () {\n    return this._vm._data.$\x3cspan class=\x22hljs-variable\x22\x3e$state\x3c\/span\x3e\n  }\n\n  \x3cspan class=\x22hljs-built_in\x22\x3eset\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e (v) {\n    if (process.env.NODE_ENV !== \x27production\x27) {\n      assert(false, `Use store.replaceState() \x3cspan class=\x22hljs-keyword\x22\x3eto\x3c\/span\x3e explicit replace store \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e.`)\n    }\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3ecommit是vuex中一个比较重要的操作，因为它可以触发mutation修改对state的修改，并且是同步执行的\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22commit (_type, _payload, _options) {\n    \/\/ check object-style commit\n    \/\/ 首先统一传入参数的格式，主要是针对当type是个对象的情况，需要把这个对象解析出来\n    const {\n      type,\n      payload,\n      options\n    } = unifyObjectStyle(_type, _payload, _options)\n    \n    \/\/ 缓存本次commit操作的类型和负荷，以供后续监听队列（this._subscribers）使用\n    const mutation = { type, payload }\n    \/\/ 获取相关的type的mutation函数，我们都知道，在vuex中都是通过commit一个类型然后触发相关的mutation函数来操作state的，所以在此必须获取相关的函数\n    const entry = this._mutations[type]\n    if (!entry) {\n      if (process.env.NODE_ENV !== \x27production\x27) {\n        console.error(`[vuex] unknown mutation type: ${type}`)\n      }\n      return\n    }\n    \/\/ 在_withCommit中触发上面获取的mutation函数，简单粗暴使用数组的forEach执行哈哈，之所以要在外面包一层_withCommit，是表明操作的同步性\n    this._withCommit(() =\x3e {\n      entry.forEach(function commitIterator (handler) {\n        handler(payload)\n      })\n    })\n    \/\/ 这个就是之前说的监听队列，在每次执行commit函数时都会遍历执行一下这个队列\n    this._subscribers.forEach(sub =\x3e sub(mutation, this.state))\n\n    if (\n      process.env.NODE_ENV !== \x27production\x27 \x26amp;\x26amp;\n      options \x26amp;\x26amp; options.silent\n    ) {\n      console.warn(\n        `[vuex] mutation type: ${type}. Silent option has been removed. ` \x2b\n        \x27Use the filter functionality in the vue-devtools\x27\n      )\n    }\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3ecommit (_type, _payload, _options) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ check object-style commit\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 首先统一传入参数的格式，主要是针对当type是个对象的情况，需要把这个对象解析出来\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e,\n      payload,\n      options\n    } = unifyObjectStyle(_type, _payload, _options)\n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 缓存本次commit操作的类型和负荷，以供后续监听队列（this._subscribers）使用\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e mutation = { \x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e, payload }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 获取相关的type的mutation函数，我们都知道，在vuex中都是通过commit一个类型然后触发相关的mutation函数来操作state的，所以在此必须获取相关的函数\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e entry = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._mutations[\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e]\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!entry) {\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (process.env.NODE_ENV !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.error(\x3cspan class=\x22hljs-string\x22\x3e`[vuex] unknown mutation type: \x3cspan class=\x22hljs-subst\x22\x3e${type}\x3c\/span\x3e`\x3c\/span\x3e)\n      }\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 在_withCommit中触发上面获取的mutation函数，简单粗暴使用数组的forEach执行哈哈，之所以要在外面包一层_withCommit，是表明操作的同步性\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._withCommit(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n      entry.forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecommitIterator\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ehandler\x3c\/span\x3e) \x3c\/span\x3e{\n        handler(payload)\n      })\n    })\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这个就是之前说的监听队列，在每次执行commit函数时都会遍历执行一下这个队列\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._subscribers.forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3esub\x3c\/span\x3e =\x26gt;\x3c\/span\x3e sub(mutation, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state))\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\n      process.env.NODE_ENV !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e \x26amp;\x26amp;\n      options \x26amp;\x26amp; options.silent\n    ) {\n      \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.warn(\n        \x3cspan class=\x22hljs-string\x22\x3e`[vuex] mutation type: \x3cspan class=\x22hljs-subst\x22\x3e${type}\x3c\/span\x3e. Silent option has been removed. `\x3c\/span\x3e \x2b\n        \x3cspan class=\x22hljs-string\x22\x3e\x27Use the filter functionality in the vue-devtools\x27\x3c\/span\x3e\n      )\n    }\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3edispatch是跟commit有点相似的函数，但是commit必须是同步的，而dispatch是异步的，内部还是必须通过commit来操作state\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22dispatch (_type, _payload) {\n    \/\/ check object-style dispatch\n    \/\/ 同上面commit，不解释\n    const {\n      type,\n      payload\n    } = unifyObjectStyle(_type, _payload)\n    \n    \/\/ 因为dispatch触发的是actions中的函数，所以这里获取actions相关函数，过程类似commit\n    const entry = this._actions[type]\n    if (!entry) {\n      if (process.env.NODE_ENV !== \x27production\x27) {\n        console.error(`[vuex] unknown action type: ${type}`)\n      }\n      return\n    }\n    \/\/ 因为dispatch支持异步，所以这里作者使用Promise.all来执行异步函数并且判断所有异步函数是否都已经执行完成，所以在文件最开始判断了当前环境必须支持promise就是这个原因\n    return entry.length \x3e 1\n      ? Promise.all(entry.map(handler =\x3e handler(payload)))\n      : entry[0](payload)\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3edispatch (_type, _payload) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ check object-style dispatch\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 同上面commit，不解释\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e,\n      payload\n    } = unifyObjectStyle(_type, _payload)\n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 因为dispatch触发的是actions中的函数，所以这里获取actions相关函数，过程类似commit\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e entry = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._actions[\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e]\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!entry) {\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (process.env.NODE_ENV !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.error(\x3cspan class=\x22hljs-string\x22\x3e`[vuex] unknown action type: \x3cspan class=\x22hljs-subst\x22\x3e${type}\x3c\/span\x3e`\x3c\/span\x3e)\n      }\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 因为dispatch支持异步，所以这里作者使用Promise.all来执行异步函数并且判断所有异步函数是否都已经执行完成，所以在文件最开始判断了当前环境必须支持promise就是这个原因\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e entry.length \x26gt; \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n      ? \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.all(entry.map(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3ehandler\x3c\/span\x3e =\x26gt;\x3c\/span\x3e handler(payload)))\n      : entry[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e](payload)\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3esubscribe函数，这是pub\/sub模式在vuex中的一个运用，用户可以通过subscribe函数来监听state的变化，函数返回一个取消监听的函数，便于用户在合适的时机取消订阅\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22subscribe (fn) {\n    const subs = this._subscribers\n    if (subs.indexOf(fn) \x3c 0) {\n      subs.push(fn)\n    }\n    \/\/ 返回取消订阅的函数，通过函数额splice方法，来清除函数中不需要的项\n    return () =\x3e {\n      const i = subs.indexOf(fn)\n      if (i \x3e -1) {\n        subs.splice(i, 1)\n      }\n    }\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs armasm\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3esubscribe \x3c\/span\x3e(\x3cspan class=\x22hljs-meta\x22\x3efn\x3c\/span\x3e) {\n    const \x3cspan class=\x22hljs-keyword\x22\x3esubs \x3c\/span\x3e= this._subscribers\n    \x3cspan class=\x22hljs-meta\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3esubs.indexOf(fn) \x3c\/span\x3e\x26lt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-keyword\x22\x3esubs.push(fn)\n\x3c\/span\x3e    }\n    \/\/ 返回取消订阅的函数，通过函数额splice方法，来清除函数中不需要的项\n    return () =\x26gt; {\n      const i = \x3cspan class=\x22hljs-keyword\x22\x3esubs.indexOf(fn)\n\x3c\/span\x3e      \x3cspan class=\x22hljs-meta\x22\x3eif\x3c\/span\x3e (i \x26gt; -\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-keyword\x22\x3esubs.splice(i, \x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e)\n      }\n    }\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3ewatch函数，响应式地监测一个 getter 方法的返回值，当值改变时调用回调函数，原理其实就是利用vue中的watch方法\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22watch (getter, cb, options) {\n    if (process.env.NODE_ENV !== \x27production\x27) {\n      assert(typeof getter === \x27function\x27, `store.watch only accepts a function.`)\n    }\n    \/\/ 在上面构造函数中，我们看到this._watcherVM就是一个vue的实例，所以可以利用它的watch来实现vuex的watch，原理都一样，当监听的值或者函数的返回值发送改变的时候，就触发相应的回调函数，也就是我们传入的cb参数，options则可以来让监听立即执行\x26amp;深度监听对象\n    return this._watcherVM.$watch(() =\x3e getter(this.state, this.getters), cb, options)\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3ewatch (getter, cb, options) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (process.env.NODE_ENV !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e) {\n      assert(\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e getter === \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e, `\x3cspan class=\x22javascript\x22\x3estore.watch only accepts a \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e.\x3c\/span\x3e\x3c\/span\x3e`)\n    }\n    \x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e 在上面构造函数中，我们看到\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._watcherVM就是一个vue的实例，所以可以利用它的watch来实现vuex的watch，原理都一样，当监听的值或者函数的返回值发送改变的时候，就触发相应的回调函数，也就是我们传入的cb参数，options则可以来让监听立即执行\x26amp;深度监听对象\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._watcherVM.$watch(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e getter(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getters), cb, options)\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3ereplaceState，根据名字就可知道，是替换当前的state\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22replaceState (state) {\n    this._withCommit(() =\x3e {\n      this._vm._data.$$state = state\n    })\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs pf\x22\x3e\x3ccode\x3ereplaceState (\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e) {\n    this._withCommit(() =\x26gt; {\n      this._vm._data.$\x3cspan class=\x22hljs-variable\x22\x3e$state\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e\n    })\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eregisterModule函数，可以使用 store.registerModule 方法注册模块\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22registerModule (path, rawModule) {\n    if (typeof path === \x27string\x27) path = [path]\n\n    if (process.env.NODE_ENV !== \x27production\x27) {\n      assert(Array.isArray(path), `module path must be a string or an Array.`)\n      assert(path.length \x3e 0, \x27cannot register the root module by using registerModule.\x27)\n    }\n    \/\/其实内部时候通过,register方法，递归寻找路径，然后将新的模块注册root模块上，具体后续介绍到module的时候会详细分析\n    this._modules.register(path, rawModule)\n    \/\/安装模块，因为每个模块都有他自身的getters,actions, modules等，所以，每次注册模块都必须把这些都注册上，后续介绍installModule的时候，会详细介绍到\n    installModule(this, this.state, path, this._modules.get(path))\n    \/\/ reset store to update getters...\n    \/\/ 重置VM\n    resetStoreVM(this, this.state)\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3eregisterModule (path, rawModule) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (typeof path === \x3cspan class=\x22hljs-string\x22\x3e\x27string\x27\x3c\/span\x3e) path = [path]\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (process.env.NODE_ENV !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e) {\n      assert(Array.isArray(path), `module path must be a string or an Array.`)\n      assert(path.length \x26gt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27cannot register the root module by using registerModule.\x27\x3c\/span\x3e)\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/其实内部时候通过,register方法，递归寻找路径，然后将新的模块注册root模块上，具体后续介绍到module的时候会详细分析\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._modules.register(path, rawModule)\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/安装模块，因为每个模块都有他自身的getters,actions, modules等，所以，每次注册模块都必须把这些都注册上，后续介绍installModule的时候，会详细介绍到\x3c\/span\x3e\n    installModule(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state, path, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._modules.\x3cspan class=\x22hljs-keyword\x22\x3eget\x3c\/span\x3e(path))\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ reset store to update getters...\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 重置VM\x3c\/span\x3e\n    resetStoreVM(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state)\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eunregisterModule函数，上述registerModule函数的相反操作，具体在module的时候会介绍到，在此了解个大概，先不纠结细节\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22unregisterModule (path) {\n    if (typeof path === \x27string\x27) path = [path]\n\n    if (process.env.NODE_ENV !== \x27production\x27) {\n      assert(Array.isArray(path), `module path must be a string or an Array.`)\n    }\n\n    this._modules.unregister(path)\n    this._withCommit(() =\x3e {\n      const parentState = getNestedState(this.state, path.slice(0, -1))\n      \/\/ 利用vue.delete方法，确保模块在被删除的时候，视图能监听到变化\n      Vue.delete(parentState, path[path.length - 1])\n    })\n    resetStore(this)\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3eunregisterModule (path) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e path === \x3cspan class=\x22hljs-string\x22\x3e\x27string\x27\x3c\/span\x3e) path = [path]\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (process.env.NODE_ENV !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e) {\n      assert(Array.isArray(path), `\x3cspan class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e path must be a string or an \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.\x3c\/span\x3e`)\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._modules.unregister(path)\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._withCommit(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n      const parentState = getNestedState(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state, path.slice(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e))\n      \x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e 利用vue.\x3cspan class=\x22hljs-keyword\x22\x3edelete\x3c\/span\x3e方法，确保模块在被删除的时候，视图能监听到变化\n      Vue.\x3cspan class=\x22hljs-keyword\x22\x3edelete\x3c\/span\x3e(parentState, path[path.length - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e])\n    })\n    resetStore(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e)\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3ehotUpdate函数，Vuex 支持在开发过程中热重载 mutation、modules、actions、和getters\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22hotUpdate (newOptions) {\n    this._modules.update(newOptions)\n    resetStore(this, true)\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs haxe\x22\x3e\x3ccode\x3ehotUpdate (\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eOptions\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e._modules.update(\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eOptions\x3c\/span\x3e)\n    resetStore(\x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e, \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e)\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e_withCommit函数，从函数名可以看出这是一个内部方法，作用就是保证commit过程中执行的方法都是同步的\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22_withCommit (fn) {\n    \/\/ 保存原来的committing的状态\n    const committing = this._committing\n    \/\/将想在的committing状态设置为true\n    this._committing = true\n    \/\/执行函数\n    fn()\n    \/\/将committing状态设置为原来的状态\n    this._committing = committing\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e_withCommit (fn) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 保存原来的committing的状态\x3c\/span\x3e\n    const committing = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._committing\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/将想在的committing状态设置为true\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._committing = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/执行函数\x3c\/span\x3e\n    fn()\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/将committing状态设置为原来的状态\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._committing = committing\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e到目前为止，我们已经看完了Store这个类的所有代码~慢慢消化，然后继续往下\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e----------------------------------------------------------这又是分割线----------------------------------------------------------------------------------------\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e接下来，我们分析一下，一些其他的辅助方法，跟上面store的一些内容会有相关。ready? Go\x3c\/p\x3e\n\x3cp\x3eresetStore函数，用于重置整个vuex中的store,从代码中可以看出，这个函数主要的功能，就是将传入的store实例的_actions，_mutations，_wrappedGetters，_modulesNamespaceMap置为空，然后重新安装模块和重置VM，此方法在上述热更新和注销模块的时候会使用到\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function resetStore (store, hot) {\n  store._actions = Object.create(null)\n  store._mutations = Object.create(null)\n  store._wrappedGetters = Object.create(null)\n  store._modulesNamespaceMap = Object.create(null)\n  const state = store.state\n  \/\/ init all modules\n  installModule(store, state, [], store._modules.root, true)\n  \/\/ reset vm\n  resetStoreVM(store, state, hot)\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs pf\x22\x3e\x3ccode\x3efunction resetStore (store, hot) {\n  store._actions = Object.create(null)\n  store._mutations = Object.create(null)\n  store._wrappedGetters = Object.create(null)\n  store._modulesNamespaceMap = Object.create(null)\n  const \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e = store.\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e\n  \/\/ init \x3cspan class=\x22hljs-literal\x22\x3eall\x3c\/span\x3e modules\n  installModule(store, \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e, [], store._modules.root, true)\n  \/\/ reset vm\n  resetStoreVM(store, \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e, hot)\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eresetStoreVM函数，这个用于重置store中的vm,所谓vm，指的就是视图模型，也就是常见mvvm中的vm，在此指的是将state作为data中$$state属性的一个vue实例\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function resetStoreVM (store, state, hot) {\n   \/\/ 保存原有store的_vm\n  const oldVm = store._vm\n    \n  \/\/ bind store public getters\n  store.getters = {}\n  \/\/ store的_wrappedGetters缓存了当前store中所有的getter\n  const wrappedGetters = store._wrappedGetters\n  const computed = {}\n  \/\/遍历这个对象，获取每个getter的key和对应的方法\n  forEachValue(wrappedGetters, (fn, key) =\x3e {\n    \/\/ use computed to leverage its lazy-caching mechanism\n    \/\/ 将getter以key-value的形式缓存在变量computed中，其实后面就是将getter作为vue实例中的计算属性\n    computed[key] = () =\x3e fn(store)\n    \/\/ 当用户获取getter时，相当于获取vue实例中的计算属性，使用es5的这个Object.defineProperty方法做一层代理\n    Object.defineProperty(store.getters, key, {\n      get: () =\x3e store._vm[key],\n      enumerable: true \/\/ for local getters\n    })\n  })\n\n  \/\/ use a Vue instance to store the state tree\n  \/\/ suppress warnings just in case the user has added\n  \/\/ some funky global mixins\n  const silent = Vue.config.silent\n  \/\/ silent设置为true，则取消了所有的警告和日志，眼不见为净\n  Vue.config.silent = true\n  \n  \/\/ 将传入的state，作为vue实例中的data的$$state属性，将刚刚使用computed变量搜集的getter，作为实例的计算属性，所以当state和getter都变成了响应式的了\n  store._vm = new Vue({\n    data: {\n      $$state: state\n    },\n    computed\n  })\n  Vue.config.silent = silent\n\n  \/\/ enable strict mode for new vm\n    \n  if (store.strict) {\n    \/\/如果设置了严格模式则，不允许用户在使用mutation以外的方式去修改state\n    enableStrictMode(store)\n  }\n\n  if (oldVm) {\n    if (hot) {\n      \/\/ dispatch changes in all subscribed watchers\n      \/\/ to force getter re-evaluation for hot reloading.\n      store._withCommit(() =\x3e {\n        \/\/ 将原有的vm中的state设置为空，所以原有的getter都会重新计算一遍，利用的就是vue中的响应式，getter作为computed属性，只有他的依赖改变了，才会重新计算，而现在把state设置为null，所以计算属性重新计算\n        oldVm._data.$$state = null\n      })\n    }\n    \/\/ 在下一次周期销毁实例\n    Vue.nextTick(() =\x3e oldVm.$destroy())\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs pf\x22\x3e\x3ccode\x3efunction resetStoreVM (store, \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e, hot) {\n   \/\/ 保存原有store的_vm\n  const oldVm = store._vm\n    \n  \/\/ bind store public getters\n  store.getters = {}\n  \/\/ store的_wrappedGetters缓存了当前store中所有的getter\n  const wrappedGetters = store._wrappedGetters\n  const computed = {}\n  \/\/遍历这个对象，获取每个getter的key和对应的方法\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3eEachValue(wrappedGetters, (fn, key) =\x26gt; {\n    \/\/ use computed \x3cspan class=\x22hljs-keyword\x22\x3eto\x3c\/span\x3e leverage its lazy-caching mechanism\n    \/\/ 将getter以key-value的形式缓存在变量computed中，其实后面就是将getter作为vue实例中的计算属性\n    computed[key] = () =\x26gt; fn(store)\n    \/\/ 当用户获取getter时，相当于获取vue实例中的计算属性，使用es5的这个Object.defineProperty方法做一层代理\n    Object.defineProperty(store.getters, key, {\n      get: () =\x26gt; store._vm[key],\n      enumerable: true \/\/ \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e local getters\n    })\n  })\n\n  \/\/ use a Vue instance \x3cspan class=\x22hljs-keyword\x22\x3eto\x3c\/span\x3e store the \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e tree\n  \/\/ suppress warnings just \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e case the \x3cspan class=\x22hljs-keyword\x22\x3euser\x3c\/span\x3e has added\n  \/\/ some funky \x3cspan class=\x22hljs-keyword\x22\x3eglobal\x3c\/span\x3e mixins\n  const silent = Vue.config.silent\n  \/\/ silent设置为true，则取消了所有的警告和日志，眼不见为净\n  Vue.config.silent = true\n  \n  \/\/ 将传入的\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e，作为vue实例中的data的$\x3cspan class=\x22hljs-variable\x22\x3e$state\x3c\/span\x3e属性，将刚刚使用computed变量搜集的getter，作为实例的计算属性，所以当\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e和getter都变成了响应式的了\n  store._vm = new Vue({\n    data: {\n      $\x3cspan class=\x22hljs-variable\x22\x3e$state\x3c\/span\x3e: \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e\n    },\n    computed\n  })\n  Vue.config.silent = silent\n\n  \/\/ enable strict mode \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e new vm\n    \n  if (store.strict) {\n    \/\/如果设置了严格模式则，不允许用户在使用mutation以外的方式去修改\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e\n    enableStrictMode(store)\n  }\n\n  if (oldVm) {\n    if (hot) {\n      \/\/ dispatch changes \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3eall\x3c\/span\x3e subscribed watchers\n      \/\/ \x3cspan class=\x22hljs-keyword\x22\x3eto\x3c\/span\x3e force getter re-evaluation \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e hot reloading.\n      store._withCommit(() =\x26gt; {\n        \/\/ 将原有的vm中的\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e设置为空，所以原有的getter都会重新计算一遍，利用的就是vue中的响应式，getter作为computed属性，只有他的依赖改变了，才会重新计算，而现在把\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e设置为null，所以计算属性重新计算\n        oldVm._data.$\x3cspan class=\x22hljs-variable\x22\x3e$state\x3c\/span\x3e = null\n      })\n    }\n    \/\/ 在下一次周期销毁实例\n    Vue.nextTick(() =\x26gt; oldVm.\x3cspan class=\x22hljs-variable\x22\x3e$destroy\x3c\/span\x3e())\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3einstallModule函数，用于安装模块，注册相应的mutation,action,getter和子模块等\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function installModule (store, rootState, path, module, hot) {\n   \/\/判断是否为根模块\n  const isRoot = !path.length\n   \/\/根据路径生成相应的命名空间\n  const namespace = store._modules.getNamespace(path)\n\n  \/\/ register in namespace map\n  if (module.namespaced) {\n    store._modulesNamespaceMap[namespace] = module\n  }\n\n  \/\/ set state\n  if (!isRoot \x26amp;\x26amp; !hot) {\n    \/\/ 将模块的state设置为响应式\n    const parentState = getNestedState(rootState, path.slice(0, -1))\n    const moduleName = path[path.length - 1]\n    store._withCommit(() =\x3e {\n      Vue.set(parentState, moduleName, module.state)\n    })\n  }\n  \/\/设置本地上下文，主要是针对模块的命名空间，对dispatch,commit,getters和state进行修改，后面讲到makeLocalContext的时候会详细分析，现在只需要知道，这个操作让用户能够直接获取到对象子模块下的对象就可以了\n  const local = module.context = makeLocalContext(store, namespace, path)\n \n  \/\/将mutation注册到模块上\n  module.forEachMutation((mutation, key) =\x3e {\n    const namespacedType = namespace \x2b key\n    registerMutation(store, namespacedType, mutation, local)\n  })\n  \/\/将action注册到模块上  \n  module.forEachAction((action, key) =\x3e {\n    const namespacedType = namespace \x2b key\n    registerAction(store, namespacedType, action, local)\n  })\n  \/\/将getter注册到模块上\n  module.forEachGetter((getter, key) =\x3e {\n    const namespacedType = namespace \x2b key\n    registerGetter(store, namespacedType, getter, local)\n  })\n  \/\/递归安装子模块  \n  module.forEachChild((child, key) =\x3e {\n    installModule(store, rootState, path.concat(key), child, hot)\n  })\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3einstallModule\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3estore, rootState, path, \x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e, hot\x3c\/span\x3e) \x3c\/span\x3e{\n   \x3cspan class=\x22hljs-comment\x22\x3e\/\/判断是否为根模块\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e isRoot = !path.length\n   \x3cspan class=\x22hljs-comment\x22\x3e\/\/根据路径生成相应的命名空间\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enamespace\x3c\/span\x3e = store._modules.getNamespace(path)\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ register in namespace map\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.namespaced) {\n    store._modulesNamespaceMap[\x3cspan class=\x22hljs-keyword\x22\x3enamespace\x3c\/span\x3e] = \x3cspan class=\x22hljs-keyword\x22\x3emodule\x3c\/span\x3e\n  }\n\n  \/\/ set state\n  if (!isRoot \x26amp;\x26amp; !hot) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将模块的state设置为响应式\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e parentState = getNestedState(rootState, path.slice(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e))\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e moduleName = path[path.length - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e]\n    store._withCommit(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n      Vue.set(parentState, moduleName, \x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.state)\n    })\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/设置本地上下文，主要是针对模块的命名空间，对dispatch,commit,getters和state进行修改，后面讲到makeLocalContext的时候会详细分析，现在只需要知道，这个操作让用户能够直接获取到对象子模块下的对象就可以了\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e local = \x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.context = makeLocalContext(store, \x3cspan class=\x22hljs-keyword\x22\x3enamespace\x3c\/span\x3e, path)\n \n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/将mutation注册到模块上\x3c\/span\x3e\n  \x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.forEachMutation(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3emutation, key\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e namespacedType = \x3cspan class=\x22hljs-keyword\x22\x3enamespace\x3c\/span\x3e \x2b key\n    registerMutation(store, namespacedType, mutation, local)\n  })\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/将action注册到模块上  \x3c\/span\x3e\n  \x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.forEachAction(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eaction, key\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e namespacedType = \x3cspan class=\x22hljs-keyword\x22\x3enamespace\x3c\/span\x3e \x2b key\n    registerAction(store, namespacedType, action, local)\n  })\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/将getter注册到模块上\x3c\/span\x3e\n  \x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.forEachGetter(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3egetter, key\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e namespacedType = \x3cspan class=\x22hljs-keyword\x22\x3enamespace\x3c\/span\x3e \x2b key\n    registerGetter(store, namespacedType, getter, local)\n  })\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/递归安装子模块  \x3c\/span\x3e\n  \x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.forEachChild(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3echild, key\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n    installModule(store, rootState, path.concat(key), child, hot)\n  })\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3emakeLocalContext函数，就是installModule中设置本地上下文的具体实现\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function makeLocalContext (store, namespace, path) {\n   \/\/如果没有命名空间，则是使用全局store上的属性，否则对store上的属性进行本地化处理\n  const noNamespace = namespace === \x27\x27\n\n  const local = {\n    dispatch: noNamespace ? store.dispatch : (_type, _payload, _options) =\x3e {\n      \/\/dispatch的本地化处理，就是修改type\n      const args = unifyObjectStyle(_type, _payload, _options)\n      const { payload, options } = args\n      let { type } = args\n\n      if (!options || !options.root) {\n         \/\/在type前面加上命名空间\n        type = namespace \x2b type\n        if (process.env.NODE_ENV !== \x27production\x27 \x26amp;\x26amp; !store._actions[type]) {\n          console.error(`[vuex] unknown local action type: ${args.type}, global type: ${type}`)\n          return\n        }\n      }\n        \/\/调用store上的dispatch方法\n      return store.dispatch(type, payload)\n    },\n\n    commit: noNamespace ? store.commit : (_type, _payload, _options) =\x3e {\n    \/\/ commit的本地化修改跟dispatch相似，也是只是修改了type，然后调用store上面的commit\n      const args = unifyObjectStyle(_type, _payload, _options)\n      const { payload, options } = args\n      let { type } = args\n\n      if (!options || !options.root) {\n        type = namespace \x2b type\n        if (process.env.NODE_ENV !== \x27production\x27 \x26amp;\x26amp; !store._mutations[type]) {\n          console.error(`[vuex] unknown local mutation type: ${args.type}, global type: ${type}`)\n          return\n        }\n      }\n\n      store.commit(type, payload, options)\n    }\n  }\n\n  \/\/ getters and state object must be gotten lazily\n  \/\/ because they will be changed by vm update\n   \/\/gettters和state的修改，则依赖于makeLocalGetters函数和getNestedState函数，后面会分析\n  Object.defineProperties(local, {\n    getters: {\n      get: noNamespace\n        ? () =\x3e store.getters\n        : () =\x3e makeLocalGetters(store, namespace)\n    },\n    state: {\n      get: () =\x3e getNestedState(store.state, path)\n    }\n  })\n\n  return local\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emakeLocalContext\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3estore, \x3cspan class=\x22hljs-keyword\x22\x3enamespace\x3c\/span\x3e, path\x3c\/span\x3e) \x3c\/span\x3e{\n   \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果没有命名空间，则是使用全局store上的属性，否则对store上的属性进行本地化处理\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e noNamespace = \x3cspan class=\x22hljs-keyword\x22\x3enamespace\x3c\/span\x3e === \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e\n\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e local = {\n    dispatch: noNamespace ? store.dispatch : \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3e_type, _payload, _options\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/dispatch的本地化处理，就是修改type\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e args = unifyObjectStyle(_type, _payload, _options)\n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e { payload, options } = args\n      \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e { \x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e } = args\n\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!options || !options.root) {\n         \x3cspan class=\x22hljs-comment\x22\x3e\/\/在type前面加上命名空间\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3enamespace\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (process.env.NODE_ENV !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e \x26amp;\x26amp; !store._actions[\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e]) {\n          \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.error(\x3cspan class=\x22hljs-string\x22\x3e`[vuex] unknown local action type: \x3cspan class=\x22hljs-subst\x22\x3e${args.type}\x3c\/span\x3e, global type: \x3cspan class=\x22hljs-subst\x22\x3e${type}\x3c\/span\x3e`\x3c\/span\x3e)\n          \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n        }\n      }\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/调用store上的dispatch方法\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e store.dispatch(\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e, payload)\n    },\n\n    commit: noNamespace ? store.commit : \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3e_type, _payload, _options\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ commit的本地化修改跟dispatch相似，也是只是修改了type，然后调用store上面的commit\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e args = unifyObjectStyle(_type, _payload, _options)\n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e { payload, options } = args\n      \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e { \x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e } = args\n\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!options || !options.root) {\n        \x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3enamespace\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (process.env.NODE_ENV !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e \x26amp;\x26amp; !store._mutations[\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e]) {\n          \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.error(\x3cspan class=\x22hljs-string\x22\x3e`[vuex] unknown local mutation type: \x3cspan class=\x22hljs-subst\x22\x3e${args.type}\x3c\/span\x3e, global type: \x3cspan class=\x22hljs-subst\x22\x3e${type}\x3c\/span\x3e`\x3c\/span\x3e)\n          \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n        }\n      }\n\n      store.commit(\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e, payload, options)\n    }\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ getters and state object must be gotten lazily\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ because they will be changed by vm update\x3c\/span\x3e\n   \x3cspan class=\x22hljs-comment\x22\x3e\/\/gettters和state的修改，则依赖于makeLocalGetters函数和getNestedState函数，后面会分析\x3c\/span\x3e\n  \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperties(local, {\n    getters: {\n      \x3cspan class=\x22hljs-keyword\x22\x3eget\x3c\/span\x3e: noNamespace\n        ? \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e store.getters\n        : \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e makeLocalGetters(store, \x3cspan class=\x22hljs-keyword\x22\x3enamespace\x3c\/span\x3e)\n    },\n    state: {\n      \x3cspan class=\x22hljs-keyword\x22\x3eget\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e getNestedState(store.state, path)\n    }\n  })\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e local\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3emakeLocalGetters函数，则是对getter进行本地化处理\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function makeLocalGetters (store, namespace) {\n  const gettersProxy = {}\n\n  const splitPos = namespace.length\n  Object.keys(store.getters).forEach(type =\x3e {\n    \/\/这里获取的每个type都是一个有命名空间\x2b本地type的字符串，例如: type的值可能为 “m1\/m2\/”\x2b\x26quot;typeName\x26quot;\n    \/\/ skip if the target getter is not match this namespace\n    if (type.slice(0, splitPos) !== namespace) return\n\n    \/\/ extract local getter type\n    const localType = type.slice(splitPos)\n\n    \/\/ Add a port to the getters proxy.\n    \/\/ Define as getter property because\n    \/\/ we do not want to evaluate the getters in this time.\n    \/\/相当于做了一层代理，将子模块的localType映射到store上的type\n    Object.defineProperty(gettersProxy, localType, {\n      get: () =\x3e store.getters[type],\n      enumerable: true\n    })\n  })\n\n  return gettersProxy\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emakeLocalGetters\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3estore, \x3cspan class=\x22hljs-keyword\x22\x3enamespace\x3c\/span\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e gettersProxy = {}\n\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e splitPos = \x3cspan class=\x22hljs-keyword\x22\x3enamespace\x3c\/span\x3e.length\n  \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.keys(store.getters).forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3etype\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/这里获取的每个type都是一个有命名空间\x2b本地type的字符串，例如: type的值可能为 “m1\/m2\/”\x2b\x22typeName\x22\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ skip if the target getter is not match this namespace\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e.slice(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, splitPos) !== \x3cspan class=\x22hljs-keyword\x22\x3enamespace\x3c\/span\x3e) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ extract local getter type\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e localType = \x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e.slice(splitPos)\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Add a port to the getters proxy.\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Define as getter property because\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ we do not want to evaluate the getters in this time.\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/相当于做了一层代理，将子模块的localType映射到store上的type\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperty(gettersProxy, localType, {\n      \x3cspan class=\x22hljs-keyword\x22\x3eget\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e store.getters[\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e],\n      enumerable: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n    })\n  })\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e gettersProxy\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eregisterMutation函数,就是注册mutation的过程，将相应type的mutation推到store._mutations[type]的队列中，当commit这个type的时候就触发执行队列中的函数\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function registerMutation (store, type, handler, local) {\n  const entry = store._mutations[type] || (store._mutations[type] = [])\n  entry.push(function wrappedMutationHandler (payload) {\n    handler(local.state, payload)\n  })\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs fortran\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3c\/span\x3e registerMutation (store, \x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e, handler, local) {\n  const \x3cspan class=\x22hljs-built_in\x22\x3eentry\x3c\/span\x3e = store._mutations[\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e] || (store._mutations[\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e] = [])\n  \x3cspan class=\x22hljs-built_in\x22\x3eentry\x3c\/span\x3e.push(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3c\/span\x3e wrappedMutationHandler (payload) {\n    handler(local.state, payload)\n  })\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eregisterAction函数，注册action的过程，原理类似于registerMutation，不同点在于action支持异步，所以必须用promise进行包装\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function registerAction (store, type, handler, local) {\n  const entry = store._actions[type] || (store._actions[type] = [])\n  entry.push(function wrappedActionHandler (payload, cb) {\n    let res = handler({\n      dispatch: local.dispatch,\n      commit: local.commit,\n      getters: local.getters,\n      state: local.state,\n      rootGetters: store.getters,\n      rootState: store.state\n    }, payload, cb)\n    if (!isPromise(res)) {\n      res = Promise.resolve(res)\n    }\n    if (store._devtoolHook) {\n      return res.catch(err =\x3e {\n        store._devtoolHook.emit(\x27vuex:error\x27, err)\n        throw err\n      })\n    } else {\n      return res\n    }\n  })\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs vim\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eregisterAction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(store, type, handler, local)\x3c\/span\x3e {\x3c\/span\x3e\n  const entry = store._actions[\x3cspan class=\x22hljs-built_in\x22\x3etype\x3c\/span\x3e] || (store._actions[\x3cspan class=\x22hljs-built_in\x22\x3etype\x3c\/span\x3e] = [])\n  entry.push(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ewrappedActionHandler\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(payload, cb)\x3c\/span\x3e {\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eres\x3c\/span\x3e = handler({\n      dispatch: local.dispatch,\n      commi\x3cspan class=\x22hljs-variable\x22\x3et:\x3c\/span\x3e local.commit,\n      getter\x3cspan class=\x22hljs-variable\x22\x3es:\x3c\/span\x3e local.getters,\n      state: local.state,\n      rootGetter\x3cspan class=\x22hljs-variable\x22\x3es:\x3c\/span\x3e store.getters,\n      rootState: store.state\n    }, payload, \x3cspan class=\x22hljs-keyword\x22\x3ecb\x3c\/span\x3e)\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!isPromise(\x3cspan class=\x22hljs-keyword\x22\x3eres\x3c\/span\x3e)) {\n      \x3cspan class=\x22hljs-keyword\x22\x3eres\x3c\/span\x3e = Promise.\x3cspan class=\x22hljs-built_in\x22\x3eresolve\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3eres\x3c\/span\x3e)\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (store._devtoolHook) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eres\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e(err =\x26gt; {\n        store._devtoolHook.emit(\x3cspan class=\x22hljs-string\x22\x3e\x27vuex:error\x27\x3c\/span\x3e, err)\n        \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e err\n      })\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eres\x3c\/span\x3e\n    }\n  })\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eregisterGetters函数,根据type，将getter方法挂载在store._wrappedGetters[type]下面\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function registerGetter (store, type, rawGetter, local) {\n  if (store._wrappedGetters[type]) {\n    if (process.env.NODE_ENV !== \x27production\x27) {\n      console.error(`[vuex] duplicate getter key: ${type}`)\n    }\n    return\n  }\n  store._wrappedGetters[type] = function wrappedGetter (store) {\n    \/\/ 为子模块的getter提供了这个四个参数，方便用户获取，如果是根模块，则local跟store取出来的state和getters相同\n    return rawGetter(\n      local.state, \/\/ local state\n      local.getters, \/\/ local getters\n      store.state, \/\/ root state\n      store.getters \/\/ root getters\n    )\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs pf\x22\x3e\x3ccode\x3efunction registerGetter (store, type, rawGetter, local) {\n  if (store._wrappedGetters[type]) {\n    if (process.env.NODE_ENV !== \x27production\x27) {\n      console.error(`[vuex] duplicate getter key: ${type}`)\n    }\n    return\n  }\n  store._wrappedGetters[type] = function wrappedGetter (store) {\n    \/\/ 为子模块的getter提供了这个四个参数，方便用户获取，如果是根模块，则local跟store取出来的\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e和getters相同\n    return rawGetter(\n      local.\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e, \/\/ local \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e\n      local.getters, \/\/ local getters\n      store.\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e, \/\/ root \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e\n      store.getters \/\/ root getters\n    )\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eenableStrictMode函数则是在严格模式下，不允许state被除mutation之外的其他操作修改，代码比较简单，利用vue的$watch方法实现的\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function enableStrictMode (store) {\n  store._vm.$watch(function () { return this._data.$$state }, () =\x3e {\n    if (process.env.NODE_ENV !== \x27production\x27) {\n      assert(store._committing, `Do not mutate vuex store state outside mutation handlers.`)\n    }\n  }, { deep: true, sync: true })\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs php\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eenableStrictMode\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(store)\x3c\/span\x3e \x3c\/span\x3e{\n  store._vm.$watch(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{ \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e this._data.$$state }, () =\x26gt; {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (process.env.NODE_ENV !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e) {\n      assert(store._committing, `\x3cspan class=\x22hljs-keyword\x22\x3eDo\x3c\/span\x3e not mutate vuex store state outside mutation handlers.`)\n    }\n  }, { deep: \x3cspan class=\x22hljs-keyword\x22\x3etrue\x3c\/span\x3e, sync: \x3cspan class=\x22hljs-keyword\x22\x3etrue\x3c\/span\x3e })\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3egetNestedState函数，获取对应路径下的state\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function getNestedState (state, path) {\n  return path.length\n    ? path.reduce((state, key) =\x3e state[key], state)\n    : state\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs pf\x22\x3e\x3ccode\x3efunction getNestedState (\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e, path) {\n  return path.length\n    ? path.reduce((\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e, key) =\x26gt; \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e[key], \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e)\n    : \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eunifyObjectStyle函数，作用是调整参数，主要是当type是一个对象的时候，对参数进行调整\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function unifyObjectStyle (type, payload, options) {\n  if (isObject(type) \x26amp;\x26amp; type.type) {\n    options = payload\n    payload = type\n    type = type.type\n  }\n\n  if (process.env.NODE_ENV !== \x27production\x27) {\n    assert(typeof type === \x27string\x27, `Expects string as the type, but found ${typeof type}.`)\n  }\n\n  return { type, payload, options }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs ada\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eunifyObjectStyle\x3c\/span\x3e (type, payload, options) {\n  if (\x3cspan class=\x22hljs-keyword\x22\x3eis\x3c\/span\x3eObject(\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e) \x26amp;\x26amp; \x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e) {\n    options = payload\n    payload = \x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e\n    \x3cspan class=\x22hljs-type\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e \x3c\/span\x3e= \x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e\n  \x3cspan class=\x22hljs-type\x22\x3e}\n\n  \x3c\/span\x3e\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (process.env.NODE_ENV !== \x3cspan class=\x22hljs-symbol\x22\x3e\x27production\x3c\/span\x3e\x27) {\n    assert(typeof \x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3e=== \x3c\/span\x3e\x3cspan class=\x22hljs-symbol\x22\x3e\x27string\x3c\/span\x3e\x27, `Expects string as the \x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e, but found ${typeof \x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e}.`)\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e { \x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e, payload, options }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上是相关辅助函数的全部内容，你看明白了么~\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e----------------------------------------------------------这依然是分割线------------------------------------------------------------------------------------\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e文件的最后，就是定义了install函数，然后自动执行了这个函数，让vuex能够在项目中运作起来\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export function install (_Vue) {\n  if (Vue) {\n    if (process.env.NODE_ENV !== \x27production\x27) {\n      console.error(\n        \x27[vuex] already installed. Vue.use(Vuex) should be called only once.\x27\n      )\n    }\n    return\n  }\n  Vue = _Vue\n  \/\/在vue的生命周期中初始化vuex，具体实现后面讲到mixin.js这个文件时会说明\n  applyMixin(Vue)\n}\n\n\/\/ auto install in dist mode\nif (typeof window !== \x27undefined\x27 \x26amp;\x26amp; window.Vue) {\n  install(window.Vue)\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3einstall\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e_Vue\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (Vue) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (process.env.NODE_ENV !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.error(\n        \x3cspan class=\x22hljs-string\x22\x3e\x27[vuex] already installed. Vue.use(Vuex) should be called only once.\x27\x3c\/span\x3e\n      )\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n  }\n  Vue = _Vue\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/在vue的生命周期中初始化vuex，具体实现后面讲到mixin.js这个文件时会说明\x3c\/span\x3e\n  applyMixin(Vue)\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ auto install in dist mode\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e !== \x3cspan class=\x22hljs-string\x22\x3e\x27undefined\x27\x3c\/span\x3e \x26amp;\x26amp; \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.Vue) {\n  install(\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.Vue)\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上就是store.js的所有内容啦~\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e----------------------------------------------------------严肃分割线------------------------------------------------------------------------------------\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e接下来讲解有关module目录下的内容，该目录有两个文件分别是module-collection.js和module.js，这两个文件主要是有关于vuex中模块的内容；\x3cbr\x3e首先我们看看module-collection.js,这个文件主要导出一个ModuleCollection类:\x3cbr\x3e构造函数\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22constructor (rawRootModule) {\n    \/\/ register root module (Vuex.Store options)\n    \/\/主要是注册根模块，我们在之前store的构造函数中曾经使用到 this._modules = new ModuleCollection(options)，注册一个根模块然后缓存在this._module中\n    this.register([], rawRootModule, false)\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs delphi\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(rawRootModule)\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e{\n    \/\/ register root module (Vuex.Store options)\n    \/\/主要是注册根模块，我们在之前store的构造函数中曾经使用到 this._modules = new ModuleCollection(options)，注册一个根模块然后缓存在this._module中\n    this.register([], rawRootModule, false)\n  }\x3c\/span\x3e\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e紧接着看看下面register函数，它用于注册模块\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22register (path, rawModule, runtime = true) {\n    if (process.env.NODE_ENV !== \x27production\x27) {\n      assertRawModule(path, rawModule)\n    }\n    \/\/ 创建一个新模块，具体会在后面讲到Module的时候分析\n    const newModule = new Module(rawModule, runtime)\n    \/\/ 判读是否为根模块\n    if (path.length === 0) {\n      this.root = newModule\n    } else {\n      \/\/根据path路径，利用get方法获取父模块  \n      const parent = this.get(path.slice(0, -1))\n      \/\/为父模块添加子模块\n      parent.addChild(path[path.length - 1], newModule)\n    }\n\n    \/\/ register nested modules\n    \/\/ 如果当前模块里面有子模块，则递归的去注册子模块\n    if (rawModule.modules) {\n      forEachValue(rawModule.modules, (rawChildModule, key) =\x3e {\n        this.register(path.concat(key), rawChildModule, runtime)\n      })\n    }\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs haxe\x22\x3e\x3ccode\x3eregister (path, rawModule, runtime = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (process.env.NODE_ENV !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e) {\n      assertRawModule(path, rawModule)\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建一个新模块，具体会在后面讲到Module的时候分析\x3c\/span\x3e\n    const \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eModule\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eModule\x3c\/span\x3e(rawModule, runtime)\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 判读是否为根模块\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (path.length === \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e.root = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eModule\x3c\/span\x3e\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/根据path路径，利用get方法获取父模块  \x3c\/span\x3e\n      const parent = \x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3eget\x3c\/span\x3e(path.slice(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e))\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/为父模块添加子模块\x3c\/span\x3e\n      parent.addChild(path[path.length - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e], \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eModule\x3c\/span\x3e)\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ register nested modules\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果当前模块里面有子模块，则递归的去注册子模块\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (rawModule.modules) {\n      forEachValue(rawModule.modules, (rawChildModule, key) =\x26gt; {\n        \x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e.register(path.concat(key), rawChildModule, runtime)\n      })\n    }\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e相反，unregister函数则是移除一个模块\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22unregister (path) {\n    \/\/ 通过get方法获取父模块\n    const parent = this.get(path.slice(0, -1))\n    \/\/获取需要删除的模块的名称，即他的key\n    const key = path[path.length - 1]\n    if (!parent.getChild(key).runtime) return\n    \/\/利用module中removeChild方法删除该模块，其实就是delete了对象上的一个key\n    parent.removeChild(key)\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs processing\x22\x3e\x3ccode\x3eunregister (path) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 通过get方法获取父模块\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e parent = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.\x3cspan class=\x22hljs-built_in\x22\x3eget\x3c\/span\x3e(path.slice(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e))\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/获取需要删除的模块的名称，即他的key\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e = path[path.length - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e]\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!parent.getChild(\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e).runtime) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/利用module中removeChild方法删除该模块，其实就是delete了对象上的一个key\x3c\/span\x3e\n    parent.removeChild(\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e)\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eget函数，其实就是利用es5中数组reduce方法，从根模块开始根据传入的path来获取相应的子模块\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22get (path) {\n    return path.reduce((module, key) =\x3e {\n      return module.getChild(key)\n    }, this.root)\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3eget (path) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e path.reduce(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e, key)\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.getChild(key)\n    }, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.root)\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3egetNamespace函数，利用传入的参数path，生成相应的命名空间，实现的原理跟上述的get方法类似\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22getNamespace (path) {\n    let module = this.root\n    return path.reduce((namespace, key) =\x3e {\n      module = module.getChild(key)\n      return namespace \x2b (module.namespaced ? key \x2b \x27\/\x27 : \x27\x27)\n    }, \x27\x27)\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3egetNamespace (path) {\n    let \x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.root\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e path.reduce(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(namespace, key)\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e = \x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.getChild(key)\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e namespace \x2b (\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.namespaced ? key \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27\/\x27\x3c\/span\x3e : \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e)\n    }, \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e)\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eupate方法，就是更新模块，具体看下面update方法的实现\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22update (rawRootModule) {\n    update([], this.root, rawRootModule)\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs erlang\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3eupdate\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(rawRootModule)\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-title\x22\x3eupdate\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e([], this.root, rawRootModule)\x3c\/span\x3e\n  }\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上就是整个ModuleCollection类的实现\x3c\/p\x3e\n\x3cp\x3e接下来讲解一下function update的实现\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function update (path, targetModule, newModule) {\n  if (process.env.NODE_ENV !== \x27production\x27) {\n    assertRawModule(path, newModule)\n  }\n\n  \/\/ update target module\n  \/\/目标模块更新为新模块，具体实现是将原有模块的namespaced，actions，mutations，getters替换为新模块的namespaced，actions，mutations，getters\n  \/\/ 具体会在Module类中update方法讲解\n  targetModule.update(newModule)\n\n  \/\/ update nested modules\n  \/\/ 如果新的模块有子模块，则递归更新子模块\n  if (newModule.modules) {\n    for (const key in newModule.modules) {\n      if (!targetModule.getChild(key)) {\n        if (process.env.NODE_ENV !== \x27production\x27) {\n          console.warn(\n            `[vuex] trying to add a new module \x27${key}\x27 on hot reloading, ` \x2b\n            \x27manual reload is needed\x27\n          )\n        }\n        return\n      }\n      update(\n        path.concat(key),\n        targetModule.getChild(key),\n        newModule.modules[key]\n      )\n    }\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs haxe\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eupdate\x3c\/span\x3e \x3c\/span\x3e(path, targetModule, \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eModule\x3c\/span\x3e) {\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (process.env.NODE_ENV !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e) {\n    assertRawModule(path, \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eModule\x3c\/span\x3e)\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ update target module\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/目标模块更新为新模块，具体实现是将原有模块的namespaced，actions，mutations，getters替换为新模块的namespaced，actions，mutations，getters\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 具体会在Module类中update方法讲解\x3c\/span\x3e\n  targetModule.update(\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eModule\x3c\/span\x3e)\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ update nested modules\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果新的模块有子模块，则递归更新子模块\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eModule\x3c\/span\x3e.modules) {\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (const key \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eModule\x3c\/span\x3e.modules) {\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!targetModule.getChild(key)) {\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (process.env.NODE_ENV !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e) {\n          console.warn(\n            `[vuex] trying to add a \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3emodule\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27\x3cspan class=\x22hljs-subst\x22\x3e${key}\x3c\/span\x3e\x27\x3c\/span\x3e on hot reloading, ` \x2b\n            \x3cspan class=\x22hljs-string\x22\x3e\x27manual reload is needed\x27\x3c\/span\x3e\n          )\n        }\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n      }\n      update(\n        path.concat(key),\n        targetModule.getChild(key),\n        \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eModule\x3c\/span\x3e.modules[key]\n      )\n    }\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e至于assertRawModule方法和makeAssertionMessage方法，就是一些简单的校验和提示，不影响主流程\x26amp;代码比较简单，这里不做赘述\x3c\/p\x3e\n\x3cp\x3e以上就是整个module-collection.js文件的所有内容\x3c\/p\x3e\n\x3cp\x3e接下来就应该分析目录中的另一个文件module.js，这个文件主要导出一个Module类，这个类主要描述了vuex中模块的功能\x3c\/p\x3e\n\x3cp\x3e构造函数，主要做了一些模块初始化的事情\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/构造函数，主要做了一些模块初始化的事情\n  constructor (rawModule, runtime) {\n    \/\/缓存运行时的标志\n    this.runtime = runtime\n    \/\/创建一个空对象来保存子模块\n    this._children = Object.create(null)\n    \/\/缓存传入的模块\n    this._rawModule = rawModule\n    \/\/缓存传入模块的state，如果state是一个函数，则执行这个函数\n    const rawState = rawModule.state\n    this.state = (typeof rawState === \x27function\x27 ? rawState() : rawState) || {}\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs pf\x22\x3e\x3ccode\x3e\/\/构造函数，主要做了一些模块初始化的事情\n  constructor (rawModule, runtime) {\n    \/\/缓存运行时的标志\n    this.runtime = runtime\n    \/\/创建一个空对象来保存子模块\n    this._children = Object.create(null)\n    \/\/缓存传入的模块\n    this._rawModule = rawModule\n    \/\/缓存传入模块的\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e，如果\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e是一个函数，则执行这个函数\n    const rawState = rawModule.\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e\n    this.\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e = (typeof rawState === \x27function\x27 ? rawState() : rawState) || {}\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3enamespaced函数是主要就是获取当前模块是否是命名模块，vuex支持命名模块和匿名模块\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22get namespaced () {\n    return !!this._rawModule.namespaced\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eget\x3c\/span\x3e namespaced () {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e !!\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._rawModule.namespaced\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eaddChild,removeChild,getChild这三个函数就分别是添加，删除，获取子模块，内容比较简单，不赘述\x3c\/p\x3e\n\x3cp\x3eupdate方法，将原有缓存模块的namespaced，actions，mutations，getters替换成新传入模块的namespaced，actions，mutations，getters\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22update (rawModule) {\n    this._rawModule.namespaced = rawModule.namespaced\n    if (rawModule.actions) {\n      this._rawModule.actions = rawModule.actions\n    }\n    if (rawModule.mutations) {\n      this._rawModule.mutations = rawModule.mutations\n    }\n    if (rawModule.getters) {\n      this._rawModule.getters = rawModule.getters\n    }\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3eupdate (rawModule) {\n    this._rawModule\x3cspan class=\x22hljs-selector-class\x22\x3e.namespaced\x3c\/span\x3e = rawModule\x3cspan class=\x22hljs-selector-class\x22\x3e.namespaced\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (rawModule.actions) {\n      this._rawModule\x3cspan class=\x22hljs-selector-class\x22\x3e.actions\x3c\/span\x3e = rawModule\x3cspan class=\x22hljs-selector-class\x22\x3e.actions\x3c\/span\x3e\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (rawModule.mutations) {\n      this._rawModule\x3cspan class=\x22hljs-selector-class\x22\x3e.mutations\x3c\/span\x3e = rawModule\x3cspan class=\x22hljs-selector-class\x22\x3e.mutations\x3c\/span\x3e\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (rawModule.getters) {\n      this._rawModule\x3cspan class=\x22hljs-selector-class\x22\x3e.getters\x3c\/span\x3e = rawModule\x3cspan class=\x22hljs-selector-class\x22\x3e.getters\x3c\/span\x3e\n    }\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eforEachChild函数，利用util中forEachValue方法，变量每个子模块，将每个子模块作为传入的回调函数参数，然后执行回调函数\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22forEachChild (fn) {\n    forEachValue(this._children, fn)\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs rust\x22\x3e\x3ccode\x3eforEachChild (\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efn\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-title\x22\x3eforEachValue\x3c\/span\x3e\x3c\/span\x3e(this._children, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efn\x3c\/span\x3e)\n  }\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eforEachGetter，forEachAction，forEachMutation代码逻辑跟上述forEachChild十分类似，不在赘述\x3c\/p\x3e\n\x3cp\x3e以上就是module.js文件的所有内容，至此我们也已经全部分析完module目录下的所有代码了\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e---------------------------------------------------一本正经分割线--------------------------------------------------------------------------------\x3c\/strong\x3e\x3cbr\x3e接下来，我们再看看help.js这个文件，这个文件主要是提供了一些帮助性的方法，使得用户在使用vuex的过程中体验更好，更加方便\x3c\/p\x3e\n\x3cp\x3e首先我们先看看文件后面三个函数：normalizeMap，normalizeNamespace，getModuleByNamespace\x3c\/p\x3e\n\x3cp\x3enormalizeMap函数，这个方法的作用是格式化传入的对象\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function normalizeMap (map) {\n  \/\/ 如果传入的对象是数组，则放回一个每一项都是key-val对象的数组，其中key和val的值相同\n  \/\/ 如果出入的是一个对象,则变量这个对象，放回一个每一项都是key-val数组，其中key对应对象的key,val对应相应key的值\n  return Array.isArray(map)\n    ? map.map(key =\x3e ({ key, val: key }))\n    : Object.keys(map).map(key =\x3e ({ key, val: map[key] }))\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs maxima\x22\x3e\x3ccode\x3efunction normalizeMap (\x3cspan class=\x22hljs-built_in\x22\x3emap\x3c\/span\x3e) {\n  \/\/ 如果传入的对象是数组，则放回一个每一项都是\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e-val对象的数组，其中\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e和val的值相同\n  \/\/ 如果出入的是一个对象,则变量这个对象，放回一个每一项都是\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e-val数组，其中\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e对应对象的\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e,val对应相应\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e的值\n  \x3cspan class=\x22hljs-built_in\x22\x3ereturn\x3c\/span\x3e Array.isArray(\x3cspan class=\x22hljs-built_in\x22\x3emap\x3c\/span\x3e)\n    ? \x3cspan class=\x22hljs-built_in\x22\x3emap\x3c\/span\x3e.\x3cspan class=\x22hljs-built_in\x22\x3emap\x3c\/span\x3e(\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e =\x26gt; ({ \x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e, val: \x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e }))\n    : Object.keys(\x3cspan class=\x22hljs-built_in\x22\x3emap\x3c\/span\x3e).\x3cspan class=\x22hljs-built_in\x22\x3emap\x3c\/span\x3e(\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e =\x26gt; ({ \x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e, val: \x3cspan class=\x22hljs-built_in\x22\x3emap\x3c\/span\x3e[\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e] }))\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3enormalizeNamespace函数，调整参数，格式化命名空间\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function normalizeNamespace (fn) {\n  return (namespace, map) =\x3e {\n    \/\/如果没传入命名空间，或者传入的命名空间不是一个字符串，则丢弃该参数\n    if (typeof namespace !== \x27string\x27) {\n      map = namespace\n      namespace = \x27\x27\n    } else if (namespace.charAt(namespace.length - 1) !== \x27\/\x27) {\n      \/\/否则判断命名空间后面是否有加上‘\/’，如果没有则加上\n      namespace \x2b= \x27\/\x27\n    }\n    \/\/最后执行传入的回调函数\n    return fn(namespace, map)\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3enormalizeNamespace\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3efn\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3enamespace\x3c\/span\x3e, map\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果没传入命名空间，或者传入的命名空间不是一个字符串，则丢弃该参数\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enamespace\x3c\/span\x3e !== \x3cspan class=\x22hljs-string\x22\x3e\x27string\x27\x3c\/span\x3e) {\n      map = \x3cspan class=\x22hljs-keyword\x22\x3enamespace\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3enamespace\x3c\/span\x3e = \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3enamespace\x3c\/span\x3e.charAt(\x3cspan class=\x22hljs-keyword\x22\x3enamespace\x3c\/span\x3e.length - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e) !== \x3cspan class=\x22hljs-string\x22\x3e\x27\/\x27\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/否则判断命名空间后面是否有加上‘\/’，如果没有则加上\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3enamespace\x3c\/span\x3e \x2b= \x3cspan class=\x22hljs-string\x22\x3e\x27\/\x27\x3c\/span\x3e\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/最后执行传入的回调函数\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e fn(\x3cspan class=\x22hljs-keyword\x22\x3enamespace\x3c\/span\x3e, map)\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3egetModuleByNamespace函数，通过命名空间来获取模块\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function getModuleByNamespace (store, helper, namespace) {\n  \/\/ 返回store._modulesNamespaceMap缓存的模块\n  const module = store._modulesNamespaceMap[namespace]\n  if (process.env.NODE_ENV !== \x27production\x27 \x26amp;\x26amp; !module) {\n    console.error(`[vuex] module namespace not found in ${helper}(): ${namespace}`)\n  }\n  return module\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3egetModuleByNamespace\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3estore, helper, namespace\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 返回store._modulesNamespaceMap缓存的模块\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e = store._modulesNamespaceMap[namespace]\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (process.env.NODE_ENV !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e \x26amp;\x26amp; !\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.error(\x3cspan class=\x22hljs-string\x22\x3e`[vuex] module namespace not found in \x3cspan class=\x22hljs-subst\x22\x3e${helper}\x3c\/span\x3e(): \x3cspan class=\x22hljs-subst\x22\x3e${namespace}\x3c\/span\x3e`\x3c\/span\x3e)\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3emapState函数，我们可以通过这个方法将state解构到vue项目中去，使其变成vue实例中的计算属性\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export const mapState = normalizeNamespace((namespace, states) =\x3e {\n  \/\/定义一个空对象\n  const res = {}\n  normalizeMap(states).forEach(({ key, val }) =\x3e {\n    \/\/收集states的所有key,对应key的值，改变成一个mappedState方法，符合计算属性的特点\n    res[key] = function mappedState () {\n      \/\/获取store的state和getters\n      let state = this.$store.state\n      let getters = this.$store.getters\n      \/\/如果存在命名空间，则将命名空间下子模块的state和getters覆盖原来store的state和getters\n      if (namespace) {\n        const module = getModuleByNamespace(this.$store, \x27mapState\x27, namespace)\n        if (!module) {\n          return\n        }\n        state = module.context.state\n        getters = module.context.getters\n      }\n      \/\/如果对应的val是函数则执行，否则返回state下的值\n      return typeof val === \x27function\x27\n        ? val.call(this, state, getters)\n        : state[val]\n    }\n    \/\/ mark vuex getter for devtools\n    res[key].vuex = true\n  })\n  \/\/返回这个包装过state的对象，这个对象可以结构成vue中的计算属性\n  return res\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs pf\x22\x3e\x3ccode\x3eexport const mapState = normalizeNamespace((namespace, states) =\x26gt; {\n  \/\/定义一个空对象\n  const res = {}\n  normalizeMap(states).\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3eEach(({ key, val }) =\x26gt; {\n    \/\/收集states的所有key,对应key的值，改变成一个mappedState方法，符合计算属性的特点\n    res[key] = function mappedState () {\n      \/\/获取store的\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e和getters\n      let \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e = this.\x3cspan class=\x22hljs-variable\x22\x3e$store\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e\n      let getters = this.\x3cspan class=\x22hljs-variable\x22\x3e$store\x3c\/span\x3e.getters\n      \/\/如果存在命名空间，则将命名空间下子模块的\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e和getters覆盖原来store的\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e和getters\n      if (namespace) {\n        const module = getModuleByNamespace(this.\x3cspan class=\x22hljs-variable\x22\x3e$store\x3c\/span\x3e, \x27mapState\x27, namespace)\n        if (!module) {\n          return\n        }\n        \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e = module.context.\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e\n        getters = module.context.getters\n      }\n      \/\/如果对应的val是函数则执行，否则返回\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e下的值\n      return typeof val === \x27function\x27\n        ? val.call(this, \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e, getters)\n        : \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e[val]\n    }\n    \/\/ mark vuex getter \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e devtools\n    res[key].vuex = true\n  })\n  \/\/返回这个包装过\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e的对象，这个对象可以结构成vue中的计算属性\n  return res\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3emapMutations函数，则是将mutation解构到vue实例中的methods中，使得用户可以直接调用methods中的方法来执行store.commit\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export const mapMutations = normalizeNamespace((namespace, mutations) =\x3e {\n  \/\/定义一个空对象\n  const res = {}\n  normalizeMap(mutations).forEach(({ key, val }) =\x3e {\n    val = namespace \x2b val\n    res[key] = function mappedMutation (...args) {\n      if (namespace \x26amp;\x26amp; !getModuleByNamespace(this.$store, \x27mapMutations\x27, namespace)) {\n        return\n      }\n      \/\/调用了store中的commit方法，触发相应的mutation函数的执行\n      return this.$store.commit.apply(this.$store, [val].concat(args))\n    }\n  })\n  return res\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3eexport \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e mapMutations = normalizeNamespace((\x3cspan class=\x22hljs-keyword\x22\x3enamespace\x3c\/span\x3e, mutations) =\x26gt; {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/定义一个空对象\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e res = {}\n  normalizeMap(mutations).forEach(({ key, val }) =\x26gt; {\n    val = \x3cspan class=\x22hljs-keyword\x22\x3enamespace\x3c\/span\x3e \x2b val\n    res[key] = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emappedMutation\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(\x3cspan class=\x22hljs-rest_arg\x22\x3e...args\x3c\/span\x3e)\x3c\/span\x3e \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3enamespace\x3c\/span\x3e \x26amp;\x26amp; !getModuleByNamespace(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$store, \x3cspan class=\x22hljs-string\x22\x3e\x27mapMutations\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3enamespace\x3c\/span\x3e)) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n      }\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/调用了store中的commit方法，触发相应的mutation函数的执行\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$store.commit.apply(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$store, [val].concat(args))\n    }\n  })\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e res\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3emapGetters的逻辑跟mapState类似，mapActions的逻辑跟mapMutations类似，这里不再赘述\x3c\/p\x3e\n\x3cp\x3e自此，我们把help.js的内容也分析完了\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e---------------------------------------------------一本正经分割线--------------------------------------------------------------------------------\x3c\/strong\x3e\x3cbr\x3e接下来我们看看mixin.js文件\x3cbr\x3e还记得之前store.js里面有个install方法么，这个方法就用到了mixin.js文件提供的内容\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 这个文件其实就导出了一个方法，供vuex在被引入的时候，能够顺利安装到项目中\nexport default function (Vue) {\n  \/\/ 首先，判断vue版本,不同的vue版本，生命周期不同，所以需要做差异处理\n  const version = Number(Vue.version.split(\x27.\x27)[0])\n\n  if (version \x3e= 2) {\n    \/\/ 如果版本是2.0以上的，则在vue的beforeCreate生命周期中，触发vuex的初始化\n    \/\/ 利用的是vue中全局混入的形式\n    Vue.mixin({ beforeCreate: vuexInit })\n  } else {\n    \/\/ override init and inject vuex init procedure\n    \/\/ for 1.x backwards compatibility.\n    \/\/ 如果是1.x版本的话，就改写原有Vue原型上的_init方法\n    \/\/ 先将原来的函数保存在常量_init中\n    const _init = Vue.prototype._init\n    Vue.prototype._init = function (options = {}) {\n      options.init = options.init\n        ? [vuexInit].concat(options.init)\n        : vuexInit\n        \/\/ 将初始化方法作为原有init的参数传入，所以在vue初始化的时候就会执行vuexInit方法来初始化vuex\n      _init.call(this, options)\n    }\n  }\n\n  \/**\n   * Vuex init hook, injected into each instances init hooks list.\n   *\/\n  \/\/ vuex的初始化钩子 \n  function vuexInit () {\n    const options = this.$options\n    \/\/ store injection\n    \/\/ 注入store\n    if (options.store) {\n      this.$store = typeof options.store === \x27function\x27\n        ? options.store()\n        : options.store\n    } else if (options.parent \x26amp;\x26amp; options.parent.$store) {\n      this.$store = options.parent.$store\n    }\n  }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs php\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这个文件其实就导出了一个方法，供vuex在被引入的时候，能够顺利安装到项目中\x3c\/span\x3e\nexport \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(Vue)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 首先，判断vue版本,不同的vue版本，生命周期不同，所以需要做差异处理\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e version = Number(Vue.version.split(\x3cspan class=\x22hljs-string\x22\x3e\x27.\x27\x3c\/span\x3e)[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e])\n\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (version \x26gt;= \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果版本是2.0以上的，则在vue的beforeCreate生命周期中，触发vuex的初始化\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 利用的是vue中全局混入的形式\x3c\/span\x3e\n    Vue.mixin({ beforeCreate: vuexInit })\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ override init and inject vuex init procedure\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ for 1.x backwards compatibility.\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果是1.x版本的话，就改写原有Vue原型上的_init方法\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 先将原来的函数保存在常量_init中\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e _init = Vue.prototype._init\n    Vue.prototype._init = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(options = {})\x3c\/span\x3e \x3c\/span\x3e{\n      options.init = options.init\n        ? [vuexInit].concat(options.init)\n        : vuexInit\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将初始化方法作为原有init的参数传入，所以在vue初始化的时候就会执行vuexInit方法来初始化vuex\x3c\/span\x3e\n      _init.call(this, options)\n    }\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/**\n   * Vuex init hook, injected into each instances init hooks list.\n   *\/\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ vuex的初始化钩子 \x3c\/span\x3e\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3evuexInit\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e options = this.$options\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ store injection\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 注入store\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (options.store) {\n      this.$store = typeof options.store === \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e\n        ? options.store()\n        : options.store\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (options.\x3cspan class=\x22hljs-keyword\x22\x3eparent\x3c\/span\x3e \x26amp;\x26amp; options.\x3cspan class=\x22hljs-keyword\x22\x3eparent\x3c\/span\x3e.$store) {\n      this.$store = options.\x3cspan class=\x22hljs-keyword\x22\x3eparent\x3c\/span\x3e.$store\n    }\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eplugins文件夹中，主要是关于插件相关的内容\x3c\/p\x3e\n\x3cp\x3edevtool.js，是关于是当用户开启vue-devtools时，触发了一些操作\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 通过全局变量__VUE_DEVTOOLS_GLOBAL_HOOK__，判断是否开启vue-devtools\nconst devtoolHook =\n  typeof window !== \x27undefined\x27 \x26amp;\x26amp;\n  window.__VUE_DEVTOOLS_GLOBAL_HOOK__\n\nexport default function devtoolPlugin (store) {\n  if (!devtoolHook) return\n\n  store._devtoolHook = devtoolHook\n  \/\/ vue-devtool自身实现了一套事件机制，有兴趣可以看看其中的实现\n  devtoolHook.emit(\x27vuex:init\x27, store)\n\n  devtoolHook.on(\x27vuex:travel-to-state\x27, targetState =\x3e {\n    \/\/用targetState替换当前的state\n    store.replaceState(targetState)\n  })\n  \/\/ 当触发commit的时候执行这个方法\n  store.subscribe((mutation, state) =\x3e {\n    \/\/ devtoolHook会emit一个vuex:mutation事件\n    devtoolHook.emit(\x27vuex:mutation\x27, mutation, state)\n  })\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 通过全局变量__VUE_DEVTOOLS_GLOBAL_HOOK__，判断是否开启vue-devtools\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e devtoolHook =\n  \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e !== \x3cspan class=\x22hljs-string\x22\x3e\x27undefined\x27\x3c\/span\x3e \x26amp;\x26amp;\n  \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.__VUE_DEVTOOLS_GLOBAL_HOOK__\n\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3edevtoolPlugin\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3estore\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!devtoolHook) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n\n  store._devtoolHook = devtoolHook\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ vue-devtool自身实现了一套事件机制，有兴趣可以看看其中的实现\x3c\/span\x3e\n  devtoolHook.emit(\x3cspan class=\x22hljs-string\x22\x3e\x27vuex:init\x27\x3c\/span\x3e, store)\n\n  devtoolHook.on(\x3cspan class=\x22hljs-string\x22\x3e\x27vuex:travel-to-state\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3etargetState\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/用targetState替换当前的state\x3c\/span\x3e\n    store.replaceState(targetState)\n  })\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当触发commit的时候执行这个方法\x3c\/span\x3e\n  store.subscribe(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3emutation, state\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ devtoolHook会emit一个vuex:mutation事件\x3c\/span\x3e\n    devtoolHook.emit(\x3cspan class=\x22hljs-string\x22\x3e\x27vuex:mutation\x27\x3c\/span\x3e, mutation, state)\n  })\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3elogger.js是在开发过程中记录日志的插件\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ Credits: borrowed code from fcomb\/redux-logger\n\/\/ 引入深拷贝方法\nimport { deepCopy } from \x27..\/util\x27\n\nexport default function createLogger ({\n  collapsed = true,\n  filter = (mutation, stateBefore, stateAfter) =\x3e true,\n  transformer = state =\x3e state,\n  mutationTransformer = mut =\x3e mut\n} = {}) {\n  return store =\x3e {\n    \/\/ 保存原有的state\n    let prevState = deepCopy(store.state)\n    \/\/ 监听state的变化\n    store.subscribe((mutation, state) =\x3e {\n      if (typeof console === \x27undefined\x27) {\n        return\n      }\n      \/\/深拷贝并且获取新的state\n      const nextState = deepCopy(state)\n\n      if (filter(mutation, prevState, nextState)) {\n        \/\/ 获取当前时间\n        const time = new Date()\n        \/\/ 格式化时间\n        const formattedTime = ` @ ${pad(time.getHours(), 2)}:${pad(time.getMinutes(), 2)}:${pad(time.getSeconds(), 2)}.${pad(time.getMilliseconds(), 3)}`\n        \/\/ 格式化mutation\n        const formattedMutation = mutationTransformer(mutation)\n        \/\/ 获取输出的信息\n        const message = `mutation ${mutation.type}${formattedTime}`\n        \/\/ 在 Web控制台上创建一个新的分组.随后输出到控制台上的内容都会被添加一个缩进\n        const startMessage = collapsed\n          ? console.groupCollapsed\n          : console.group\n\n        \/\/ render\n        try {\n          \/\/ 输出日志\n          startMessage.call(console, message)\n        } catch (e) {\n          console.log(message)\n        }\n\n        console.log(\x27%c prev state\x27, \x27color: #9E9E9E; font-weight: bold\x27, transformer(prevState))\n        console.log(\x27%c mutation\x27, \x27color: #03A9F4; font-weight: bold\x27, formattedMutation)\n        console.log(\x27%c next state\x27, \x27color: #4CAF50; font-weight: bold\x27, transformer(nextState))\n\n        try {\n          console.groupEnd()\n        } catch (e) {\n          console.log(\x27—— log end ——\x27)\n        }\n      }\n      \/\/ 替换state\n      prevState = nextState\n    })\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs pf\x22\x3e\x3ccode\x3e\/\/ Credits: borrowed code \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e fcomb\/redux-logger\n\/\/ 引入深拷贝方法\nimport { deepCopy } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x27..\/util\x27\n\nexport \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e function createLogger ({\n  collapsed = true,\n  filter = (mutation, \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3eBefore, \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3eAfter) =\x26gt; true,\n  transformer = \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e =\x26gt; \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e,\n  mutationTransformer = mut =\x26gt; mut\n} = {}) {\n  return store =\x26gt; {\n    \/\/ 保存原有的\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e\n    let prevState = deepCopy(store.\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e)\n    \/\/ 监听\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e的变化\n    store.subscribe((mutation, \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e) =\x26gt; {\n      if (typeof console === \x27undefined\x27) {\n        return\n      }\n      \/\/深拷贝并且获取新的\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e\n      const nextState = deepCopy(\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e)\n\n      if (filter(mutation, prevState, nextState)) {\n        \/\/ 获取当前时间\n        const time = new Date()\n        \/\/ 格式化时间\n        const formattedTime = ` @ ${pad(time.getHours(), \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e)}:${pad(time.getMinutes(), \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e)}:${pad(time.getSeconds(), \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e)}.${pad(time.getMilliseconds(), \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e)}`\n        \/\/ 格式化mutation\n        const formattedMutation = mutationTransformer(mutation)\n        \/\/ 获取输出的信息\n        const message = `mutation ${mutation.type}${formattedTime}`\n        \/\/ 在 Web控制台上创建一个新的分组.随后输出到控制台上的内容都会被添加一个缩进\n        const startMessage = collapsed\n          ? console.\x3cspan class=\x22hljs-keyword\x22\x3egroup\x3c\/span\x3eCollapsed\n          : console.\x3cspan class=\x22hljs-keyword\x22\x3egroup\x3c\/span\x3e\n\n        \/\/ render\n        try {\n          \/\/ 输出日志\n          startMessage.call(console, message)\n        } catch (e) {\n          console.\x3cspan class=\x22hljs-keyword\x22\x3elog\x3c\/span\x3e(message)\n        }\n\n        console.\x3cspan class=\x22hljs-keyword\x22\x3elog\x3c\/span\x3e(\x27%c prev \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e\x27, \x27color: \x3cspan class=\x22hljs-comment\x22\x3e#9E9E9E; font-weight: bold\x27, transformer(prevState))\x3c\/span\x3e\n        console.\x3cspan class=\x22hljs-keyword\x22\x3elog\x3c\/span\x3e(\x27%c mutation\x27, \x27color: \x3cspan class=\x22hljs-comment\x22\x3e#03A9F4; font-weight: bold\x27, formattedMutation)\x3c\/span\x3e\n        console.\x3cspan class=\x22hljs-keyword\x22\x3elog\x3c\/span\x3e(\x27%c next \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e\x27, \x27color: \x3cspan class=\x22hljs-comment\x22\x3e#4CAF50; font-weight: bold\x27, transformer(nextState))\x3c\/span\x3e\n\n        try {\n          console.\x3cspan class=\x22hljs-keyword\x22\x3egroup\x3c\/span\x3eEnd()\n        } catch (e) {\n          console.\x3cspan class=\x22hljs-keyword\x22\x3elog\x3c\/span\x3e(\x27—— \x3cspan class=\x22hljs-keyword\x22\x3elog\x3c\/span\x3e end ——\x27)\n        }\n      }\n      \/\/ 替换\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e\n      prevState = nextState\n    })\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e至于util.js,内部提供一些简单的工具方法，不再赘述啦~可自行研究\x3cbr\x3e\x3cstrong\x3e---------------------------------------------------最后的分割线--------------------------------------------------------------------------------\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e以上，便是vuex源码的所有内容。。不管写的怎么样，你都看到这里啦，对此\x3cstrong\x3e深表感谢\x3c\/strong\x3e~\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>你想要的——vuex源码分析</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000010203499">https://segmentfault.com/a/1190000010203499</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/tdj2egk7sgk/" target="_blank">https://alili.tech/archive/tdj2egk7sgk/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>