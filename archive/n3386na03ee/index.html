<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="React之key详解"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>React之key详解 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/n3386na03ee/",
				"appid": "1613049289050283", 
				"title": "React之key详解 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-16T02:30:08"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/myr5wgoeqj/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/rpgyy3qiqc9/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fn3386na03ee%2f&text=React%e4%b9%8bkey%e8%af%a6%e8%a7%a3"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fn3386na03ee%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fn3386na03ee%2f&text=React%e4%b9%8bkey%e8%af%a6%e8%a7%a3"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fn3386na03ee%2f&title=React%e4%b9%8bkey%e8%af%a6%e8%a7%a3"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fn3386na03ee%2f&is_video=false&description=React%e4%b9%8bkey%e8%af%a6%e8%a7%a3"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=React%e4%b9%8bkey%e8%af%a6%e8%a7%a3&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fn3386na03ee%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fn3386na03ee%2f&title=React%e4%b9%8bkey%e8%af%a6%e8%a7%a3"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fn3386na03ee%2f&title=React%e4%b9%8bkey%e8%af%a6%e8%a7%a3"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fn3386na03ee%2f&title=React%e4%b9%8bkey%e8%af%a6%e8%a7%a3"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fn3386na03ee%2f&title=React%e4%b9%8bkey%e8%af%a6%e8%a7%a3"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">React之key详解</h1><div class="meta"><div class="postdate"><time datetime="2019-01-16" itemprop="datePublished">2019-01-16</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch2 id=\x22articleHeader0\x22\x3e一个例子\x3c\/h2\x3e\n\x3cp\x3e有这样的一个场景如下图所示，有一组动态数量的input，可以增加和删除和重新排序，数组元素生成的组件用\x3ccode\x3eindex\x3c\/code\x3e作为key的值，例如下图生成的ui展示：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVMyFi?w=640\x26amp;h=457\x22 src=\x22https:\/\/static.alili.tech\/img\/bVMyFi?w=640\x26amp;h=457\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3cbr\x3e上面例子中的input组件渲染的代码如下所示，全部完整代码可以参考 ==\x26gt;\x3ca href=\x22http:\/\/codepen.io\/fetest\/pen\/jBaaRQ?editors=1010\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e完整code\x3c\/a\x3e\x3cbutton class=\x22btn btn-xs btn-default ml10 preview\x22 data-url=\x22fetest\/pen\/jBaaRQ\x22 data-typeid=\x223\x22\x3e点击预览\x3c\/button\x3e。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{this.state.data.map((v,idx)=\x3e\x3cItem key={idx} v={v} \/\x3e)}\n\n\/\/Item组件render方法\nrender(){\n   return \x3cli\x3e{this.props.v} \x3cinput type=\x26quot;text\x26quot;\/\x3e\x3c\/li\x3e\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e{\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.data.map(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3ev,idx\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e\x26lt;Item key={idx} v={v} \/\x26gt;)}\n\n\/\/Item组件render方法\nrender(){\n   return \x26lt;li\x26gt;{this.props.v} \x26lt;input type=\x22text\x22\/\x26gt;\x26lt;\/li\x26gt;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e首先说明的是，若页面中数组内容是固定而不是动态的话，上面的代码也不会有什么问题(｡•ˇ‸ˇ•｡ 但是如此这也是不是推荐的做法)。\x3c\/p\x3e\n\x3cp\x3e但是，动态数组导致其渲染的组件就会有问题，从上面图中你也能看出问题：数组动态改变后，页面上input的输入内容跟对应的数组元素顺序不对应。\x3c\/p\x3e\n\x3cp\x3e为什么会这样呢？本文后面会有解释。react初学者对这可能更加迷惑，本文就来跟大家探讨一下react的key用法，\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3ereact key概述\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3ekey的作用\x3c\/h3\x3e\n\x3cp\x3ereact中的key属性，它是一个特殊的属性，它是出现不是给开发者用的（例如你为一个组件设置key之后不能获取组件的这个key props），而是给react自己用的。\x3c\/p\x3e\n\x3cp\x3e那么react是怎么用key的呢？react的作者之一Paul O’Shannessy有提到：\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3eKey is not really about performance, it’s more about identity (which in turn leads to better performance). Randomly assigned and changing values do not form an identity\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e简单来说，\x3cstrong\x3ereact利用key来识别组件，它是一种身份标识标识\x3c\/strong\x3e，就像我们的身份证用来辨识一个人一样。每个key对应一个组件，相同的key react认为是同一个组件，这样后续相同的key对应组件都不会被创建。例如下面代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/this.state.users内容\nthis.state = {\n users: [{id:1,name: \x27张三\x27}, {id:2, name: \x27李四\x27}, {id: 2, name: \x26quot;王五\x26quot;}],\n ....\/\/省略\n}\nrender()\n return(\n  \x3cdiv\x3e\n    \x3ch3\x3e用户列表\x3c\/h3\x3e\n    {this.state.users.map(u =\x3e \x3cdiv key={u.id}\x3e{u.id}:{u.name}\x3c\/div\x3e)}\n  \x3c\/div\x3e\n )\n);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/this.state.users内容\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = {\n \x3cspan class=\x22hljs-attr\x22\x3eusers\x3c\/span\x3e: [{\x3cspan class=\x22hljs-attr\x22\x3eid\x3c\/span\x3e:\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27张三\x27\x3c\/span\x3e}, {\x3cspan class=\x22hljs-attr\x22\x3eid\x3c\/span\x3e:\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27李四\x27\x3c\/span\x3e}, {\x3cspan class=\x22hljs-attr\x22\x3eid\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22王五\x22\x3c\/span\x3e}],\n ....\x3cspan class=\x22hljs-comment\x22\x3e\/\/省略\x3c\/span\x3e\n}\nrender()\n \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e(\n  \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eh3\x3c\/span\x3e\x26gt;\x3c\/span\x3e用户列表\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eh3\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    {this.state.users.map(u =\x26gt; \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ekey\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{u.id}\x3c\/span\x3e\x26gt;\x3c\/span\x3e{u.id}:{u.name}\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e)}\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n )\n);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面代码在dom渲染挂载后，用户列表只有\x3ccode\x3e张三\x3c\/code\x3e和\x3ccode\x3e李四\x3c\/code\x3e两个用户，\x3ccode\x3e王五\x3c\/code\x3e并没有展示处理，主要是因为react根据key认为\x3ccode\x3e李四\x3c\/code\x3e和\x3ccode\x3e王五\x3c\/code\x3e是同一个组件，导致第一个被渲染，后续的会被丢弃掉。\x3c\/p\x3e\n\x3cp\x3e这样，有了key属性后，就可以与组件建立了一种对应关系，react根据key来决定是销毁重新创建组件还是更新组件。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3ekey相同\x3c\/strong\x3e，若组件属性有所变化，则react只更新组件对应的属性；没有变化则不更新。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3ekey值不同\x3c\/strong\x3e，则react先销毁该组件(有状态组件的\x3ccode\x3ecomponentWillUnmount会执行\x3c\/code\x3e)，然后重新创建该组件（有状态组件的\x3ccode\x3econstructor\x3c\/code\x3e和\x3ccode\x3ecomponentWillUnmount\x3c\/code\x3e都会执行）\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e另外需要指明的是:\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3ekey不是用来提升react的性能的，不过用好key对性能是有帮组的。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3ekey的使用场景\x3c\/h3\x3e\n\x3cp\x3e在项目开发中，\x3ccode\x3ekey属性的使用场景最多的还是由数组动态创建的子组件的情况\x3c\/code\x3e，需要为每个子组件添加唯一的key属性值。\x3c\/p\x3e\n\x3cp\x3e那么，为何由数组动态创建的组件必须要用到key属性呢？这跟数组元素的动态性有关。\x3c\/p\x3e\n\x3cp\x3e拿上述用户列表的例子来说，看一下babel对上述代码的转换情况：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 转换前\nconst element = (\n  \x3cdiv\x3e\n    \x3ch3\x3e用户列表\x3c\/h3\x3e\n    {[\x3cdiv key={1}\x3e1:张三\x3c\/div\x3e, \x3cdiv key={2}\x3e2:李四\x3c\/div\x3e]}\n  \x3c\/div\x3e\n);\n\n\/\/ 转换后\n\x26quot;use strict\x26quot;;\n\nvar element = React.createElement(\n  \x26quot;div\x26quot;,\n  null,\n  React.createElement(\x26quot;h3\x26quot;,null,\x26quot;用户列表\x26quot;),\n  [\n    React.createElement(\x26quot;div\x26quot;,{ key: 1 },\x26quot;1:张三\x26quot;), \n    React.createElement(\x26quot;div\x26quot;,{ key: 2 },\x26quot;2:李四\x26quot;)\n  ]\n);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 转换前\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e element = (\n  \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eh3\x3c\/span\x3e\x26gt;\x3c\/span\x3e用户列表\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eh3\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    {[\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ekey\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{1}\x3c\/span\x3e\x26gt;\x3c\/span\x3e1:张三\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e, \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ekey\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{2}\x3c\/span\x3e\x26gt;\x3c\/span\x3e2:李四\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e]}\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 转换后\x3c\/span\x3e\n\x3cspan class=\x22hljs-meta\x22\x3e\x22use strict\x22\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e element = React.createElement(\n  \x3cspan class=\x22hljs-string\x22\x3e\x22div\x22\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e,\n  React.createElement(\x3cspan class=\x22hljs-string\x22\x3e\x22h3\x22\x3c\/span\x3e,\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x22用户列表\x22\x3c\/span\x3e),\n  [\n    React.createElement(\x3cspan class=\x22hljs-string\x22\x3e\x22div\x22\x3c\/span\x3e,{ \x3cspan class=\x22hljs-attr\x22\x3ekey\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e },\x3cspan class=\x22hljs-string\x22\x3e\x221:张三\x22\x3c\/span\x3e), \n    React.createElement(\x3cspan class=\x22hljs-string\x22\x3e\x22div\x22\x3c\/span\x3e,{ \x3cspan class=\x22hljs-attr\x22\x3ekey\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e },\x3cspan class=\x22hljs-string\x22\x3e\x222:李四\x22\x3c\/span\x3e)\n  ]\n);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e有babel转换后\x3ccode\x3eReact.createElement\x3c\/code\x3e中的代码可以看出，其它元素之所以不是必须需要key是因为不管组件的\x3ccode\x3estate\x3c\/code\x3e或者\x3ccode\x3eprops\x3c\/code\x3e如何变化，这些元素始终占据着\x3ccode\x3eReact.createElement\x3c\/code\x3e固定的位置，这个位置就是天然的key。\x3c\/p\x3e\n\x3cp\x3e而由数组创建的组件可能由于动态的操作导致重新渲染时，子组件的位置发生了变化，例如上面用户列表子组件新增一个用户，上面两个用户的位置可能变化为下面这样：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var element = React.createElement(\n  \x26quot;div\x26quot;,\n  null,\n  React.createElement(\x26quot;h3\x26quot;,null,\x26quot;用户列表\x26quot;),\n  [\n    React.createElement(\x26quot;div\x26quot;,{ key: 3 },\x26quot;1:王五\x26quot;), \n    React.createElement(\x26quot;div\x26quot;,{ key: 1 },\x26quot;2:张三\x26quot;), \n    React.createElement(\x26quot;div\x26quot;,{ key: 2 },\x26quot;3:李四\x26quot;)\n  ]\n);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e element = React.createElement(\n  \x3cspan class=\x22hljs-string\x22\x3e\x22div\x22\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e,\n  React.createElement(\x3cspan class=\x22hljs-string\x22\x3e\x22h3\x22\x3c\/span\x3e,\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x22用户列表\x22\x3c\/span\x3e),\n  [\n    React.createElement(\x3cspan class=\x22hljs-string\x22\x3e\x22div\x22\x3c\/span\x3e,{ \x3cspan class=\x22hljs-attr\x22\x3ekey\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e },\x3cspan class=\x22hljs-string\x22\x3e\x221:王五\x22\x3c\/span\x3e), \n    React.createElement(\x3cspan class=\x22hljs-string\x22\x3e\x22div\x22\x3c\/span\x3e,{ \x3cspan class=\x22hljs-attr\x22\x3ekey\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e },\x3cspan class=\x22hljs-string\x22\x3e\x222:张三\x22\x3c\/span\x3e), \n    React.createElement(\x3cspan class=\x22hljs-string\x22\x3e\x22div\x22\x3c\/span\x3e,{ \x3cspan class=\x22hljs-attr\x22\x3ekey\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e },\x3cspan class=\x22hljs-string\x22\x3e\x223:李四\x22\x3c\/span\x3e)\n  ]\n);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可以看出，数组创建子组件的位置并不固定，动态改变的；这样有了key属性后，react就可以根据key值来判断是否为同一组件。\x3c\/p\x3e\n\x3cp\x3e另外，还有一种比较常见的场景：\x3ccode\x3e为一个有复杂繁琐逻辑的组件添加key后，后续操作可以改变该组件的key属性值，从而达到先销毁之前的组件，再重新创建该组件。\x3c\/code\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3ekey的最佳实践\x3c\/h2\x3e\n\x3cp\x3e上面说到了，由数组创建的子组件必须有key属性，否则的话你可能见到下面这样的warning：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Warning: Each child in an array or iterator should have a unique \x26quot;key\x26quot; prop. Check the render method of `ServiceInfo`. See https:\/\/fb.me\/react-warning-keys for more information.\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs livecodeserver\x22\x3e\x3ccode class=\x22text\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3eWarning: Each child \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ean\x3c\/span\x3e array \x3cspan class=\x22hljs-keyword\x22\x3eor\x3c\/span\x3e iterator should have \x3cspan class=\x22hljs-keyword\x22\x3ea\x3c\/span\x3e unique \x3cspan class=\x22hljs-string\x22\x3e\x22key\x22\x3c\/span\x3e prop. Check \x3cspan class=\x22hljs-keyword\x22\x3ethe\x3c\/span\x3e render method \x3cspan class=\x22hljs-keyword\x22\x3eof\x3c\/span\x3e `ServiceInfo`. See \x3cspan class=\x22hljs-keyword\x22\x3ehttps\x3c\/span\x3e:\/\/fb.me\/react-warning-\x3cspan class=\x22hljs-built_in\x22\x3ekeys\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e more information.\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可能你会发现，这只是warning而不是error，它不是强制性的，为什么react不强制要求用key而报error呢？其实是强制要求的，只不过react为按要求来默认上帮我们做了，它是以数组的\x3ccode\x3eindex\x3c\/code\x3e作为key的。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3eindex作为key是一种反模式\x3c\/h3\x3e\n\x3cp\x3e在list数组中，用key来标识数组创建子组件时，若数组的内容只是作为纯展示，而不涉及到数组的动态变更，其实是可以使用\x3ccode\x3eindex\x3c\/code\x3e作为key的。\x3c\/p\x3e\n\x3cp\x3e但是，若涉及到数组的动态变更，例如数组新增元素、删除元素或者重新排序等，这时index作为key会导致展示错误的数据。本文开始引入的例子就是最好的证明。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{this.state.data.map((v,idx)=\x3e\x3cItem key={idx} v={v} \/\x3e)}\n\/\/ 开始时：[\x27a\x27,\x27b\x27,\x27c\x27]=\x3e\n\x3cul\x3e\n    \x3cli key=\x26quot;0\x26quot;\x3ea \x3cinput type=\x26quot;text\x26quot;\/\x3e\x3c\/li\x3e\n    \x3cli key=\x26quot;1\x26quot;\x3eb \x3cinput type=\x26quot;text\x26quot;\/\x3e\x3c\/li\x3e\n    \x3cli key=\x26quot;2\x26quot;\x3ec \x3cinput type=\x26quot;text\x26quot;\/\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\n\/\/ 数组重排 -\x3e [\x27c\x27,\x27b\x27,\x27a\x27] =\x3e\n\x3cul\x3e\n    \x3cli key=\x26quot;0\x26quot;\x3ec \x3cinput type=\x26quot;text\x26quot;\/\x3e\x3c\/li\x3e\n    \x3cli key=\x26quot;1\x26quot;\x3eb \x3cinput type=\x26quot;text\x26quot;\/\x3e\x3c\/li\x3e\n    \x3cli key=\x26quot;2\x26quot;\x3ea \x3cinput type=\x26quot;text\x26quot;\/\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e{\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.data.map(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3ev,idx\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e\x26lt;Item key={idx} v={v} \/\x26gt;)}\n\/\/ 开始时：[\x27a\x27,\x27b\x27,\x27c\x27]=\x26gt;\n\x26lt;ul\x26gt;\n    \x26lt;li key=\x220\x22\x26gt;a \x26lt;input type=\x22text\x22\/\x26gt;\x26lt;\/li\x26gt;\n    \x26lt;li key=\x221\x22\x26gt;b \x26lt;input type=\x22text\x22\/\x26gt;\x26lt;\/li\x26gt;\n    \x26lt;li key=\x222\x22\x26gt;c \x26lt;input type=\x22text\x22\/\x26gt;\x26lt;\/li\x26gt;\n\x26lt;\/ul\x26gt;\n\n\/\/ 数组重排 -\x26gt; [\x27c\x27,\x27b\x27,\x27a\x27] =\x26gt;\n\x26lt;ul\x26gt;\n    \x26lt;li key=\x220\x22\x26gt;c \x26lt;input type=\x22text\x22\/\x26gt;\x26lt;\/li\x26gt;\n    \x26lt;li key=\x221\x22\x26gt;b \x26lt;input type=\x22text\x22\/\x26gt;\x26lt;\/li\x26gt;\n    \x26lt;li key=\x222\x22\x26gt;a \x26lt;input type=\x22text\x22\/\x26gt;\x26lt;\/li\x26gt;\n\x26lt;\/ul\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面实例中在数组重新排序后，key对应的实例都没有销毁，而是重新更新。具体更新过程我们拿\x3ccode\x3ekey=0\x3c\/code\x3e的元素来说明， 数组重新排序后：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e组件重新render得到新的虚拟dom；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e新老两个虚拟dom进行diff，新老版的都有\x3ccode\x3ekey=0\x3c\/code\x3e的组件，react认为同一个组件，则只可能更新组件；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e然后比较其children，发现内容的文本内容不同（由\x3ccode\x3ea---\x26gt;c\x3c\/code\x3e)，而input组件并没有变化，这时触发组件的\x3ccode\x3ecomponentWillReceiveProps\x3c\/code\x3e方法，从而更新其子组件文本内容;\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e因为组件的children中input组件没有变化，其又与父组件传入的任\x3ccode\x3eprops\x3c\/code\x3e没有关联，所以input组件不会更新(即其\x3ccode\x3ecomponentWillReceiveProps\x3c\/code\x3e方法不会被执行)，导致用户输入的值不会变化。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e这就是\x3ccode\x3eindex\x3c\/code\x3e作为key存在的问题，所以\x3ccode\x3e不要使用index作为key\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3ekey的值要稳定唯一\x3c\/h3\x3e\n\x3cp\x3e在数组中生成的每项都要有key属性，并且\x3ccode\x3ekey的值是一个永久且唯一的值\x3c\/code\x3e，即稳定唯一。\x3c\/p\x3e\n\x3cp\x3e在理想情况下，在循环一个对象数组时，数组的每一项都会有用于区分其他项的一个键值，相当数据库中主键。这样就可以用该属性值作为key值。但是一般情况下可能是没有这个属性值的，这时就需要我们自己保证。\x3c\/p\x3e\n\x3cp\x3e但是，需要指出的一点是，我们在保证数组每项的唯一的标识时，还需要保证其值的稳定性，不能经常改变。例如下面代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n    this.state.data.map(el=\x3e\x3cMyComponent key={Math.random()}\/\x3e)\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.data.map(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eel\x3c\/span\x3e=\x26gt;\x3c\/span\x3e\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eMyComponent\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ekey\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{Math.random()}\/\x3c\/span\x3e\x26gt;\x3c\/span\x3e)\n}\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面代码中中MyComponent的key值是用\x3ccode\x3eMath.random\x3c\/code\x3e随机生成的，虽然能够保持其唯一性，但是它的值是随机而不是稳定的，在数组动态改变时会导致数组元素中的每项都重新销毁然后重新创建，有一定的性能开销；另外可能导致一些意想不到的问题出现。所以：\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3ekey的值要保持稳定且唯一，不能使用\x3ccode\x3erandom\x3c\/code\x3e来生成key的值。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e所以，在不能使用random随机生成key时，我们可以像下面这样用一个全局的\x3cstrong\x3elocalCounter\x3c\/strong\x3e变量来添加稳定唯一的key值。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var localCounter = 1;\nthis.data.forEach(el=\x3e{\n    el.id = localCounter\x2b\x2b;\n});\n\/\/向数组中动态添加元素时，\nfunction createUser(user) {\n    return {\n        ...user,\n        id: localCounter\x2b\x2b\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e localCounter = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.data.forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eel\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n    el.id = localCounter\x2b\x2b;\n});\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/向数组中动态添加元素时，\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecreateUser\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3euser\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n        ...user,\n        \x3cspan class=\x22hljs-attr\x22\x3eid\x3c\/span\x3e: localCounter\x2b\x2b\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3ekey其它注意事项\x3c\/h3\x3e\n\x3cp\x3e当然除了为数据元素生成的组件要添加key，且key要稳定且唯一之外，还需要注意以下几点：\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3e\x3cstrong\x3ekey属性是添加到自定义的子组件上，而不是子组件内部的顶层的组件上。\x3c\/strong\x3e\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/MyComponent\n...\nrender() {\/\/error\n    \x3cdiv key=\x22{{\x22item.key\x22}}\x22\x3e\x22{{\x22item.name\x22}}\x22\x3c\/div\x3e\n}\n...\n\n\/\/right\n\x3cMyComponent key=\x22{{\x22item.key\x22}}\x22\/\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/MyComponent\x3c\/span\x3e\n...\nrender() {\x3cspan class=\x22hljs-comment\x22\x3e\/\/error\x3c\/span\x3e\n    \x26lt;div key=\x22{{\x22item.key\x22}}\x22\x26gt;\x22{{\x22item.name\x22}}\x22\x26lt;\x3cspan class=\x22hljs-regexp\x22\x3e\/div\x26gt;\n}\n...\n\n\/\x3c\/span\x3e\x3cspan class=\x22hljs-regexp\x22\x3e\/right\n\x26lt;MyComponent key=\x22{{\x22item.key\x22}}\x22\/\x3c\/span\x3e\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3ekey值的唯一是有范围的，即在数组生成的同级同类型的组件上要保持唯一，而不是所有组件的key都要保持唯一\x3c\/strong\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e不仅仅在数组生成组件上，其他地方也可以使用key，主要是\x3cstrong\x3ereact利用key来区分组件的，相同的key表示同一个组件，react不会重新销毁创建组件实例，只可能更新；key不同，react会销毁已有的组件实例，重新创建组件新的实例\x3c\/strong\x3e。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n  this.state.type ? \n    \x3cdiv\x3e\x3cSon_1\/\x3e\x3cSon_2\/\x3e\x3c\/div\x3e\n    : \x3cdiv\x3e\x3cSon_2\/\x3e\x3cSon_1\/\x3e\x3c\/div\x3e\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.type ? \n    \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eSon_1\x3c\/span\x3e\/\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eSon_2\x3c\/span\x3e\/\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n    : \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eSon_2\x3c\/span\x3e\/\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eSon_1\x3c\/span\x3e\/\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e例如上面代码中，\x3cstrong\x3ethis.state.type\x3c\/strong\x3e的值改变时，原Son_1和Son2组件的实例都将会被销毁，并重新创建Son_1和Son_2组件新的实例，不能继承原来的状态，其实他们只是互换了位置。为了避免这种问题，我们可以给组件加上key。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n  this.state.type ? \n    \x3cdiv\x3e\x3cSon_1 key=\x26quot;1\x26quot;\/\x3e\x3cSon_2 key=\x26quot;2\x26quot;\/\x3e\x3c\/div\x3e\n    : \x3cdiv\x3e\x3cSon_2 key=\x26quot;2\x26quot; \/\x3e\x3cSon_1 key=\x26quot;1\x26quot;\/\x3e\x3c\/div\x3e\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.type ? \n    \x26lt;div\x26gt;\x26lt;Son_1 key=\x221\x22\/\x26gt;\x26lt;Son_2 key=\x222\x22\/\x26gt;\x26lt;\/div\x26gt;\n    : \x26lt;div\x26gt;\x26lt;Son_2 key=\x222\x22 \/\x26gt;\x26lt;Son_1 key=\x221\x22\/\x26gt;\x26lt;\/div\x26gt;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样，\x3cstrong\x3ethis.state.type\x3c\/strong\x3e的值改变时，Son_1和Son2组件的实例没有重新创建，react只是将他们互换位置。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3e参考文献\x3c\/h2\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/www.tuicool.com\/articles\/UVvaMz\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eReact 实践心得：key 属性的原理和用法\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/www.jstips.co\/en\/react\/keys-in-children-components-are-important\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eKeys in children components are important\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000007910897\x22\x3ereact反模式之index作为key\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>React之key详解</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000009149186">https://segmentfault.com/a/1190000009149186</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/n3386na03ee/" target="_blank">https://alili.tech/archive/n3386na03ee/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>