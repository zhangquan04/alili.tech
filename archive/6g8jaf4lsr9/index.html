<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="介绍RxJS在Angular中的应用"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>介绍RxJS在Angular中的应用 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/6g8jaf4lsr9/",
				"appid": "1613049289050283", 
				"title": "介绍RxJS在Angular中的应用 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-12T02:30:25"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/h79kbhu4ruj/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/qouq2lehwb/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f6g8jaf4lsr9%2f&text=%e4%bb%8b%e7%bb%8dRxJS%e5%9c%a8Angular%e4%b8%ad%e7%9a%84%e5%ba%94%e7%94%a8"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f6g8jaf4lsr9%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f6g8jaf4lsr9%2f&text=%e4%bb%8b%e7%bb%8dRxJS%e5%9c%a8Angular%e4%b8%ad%e7%9a%84%e5%ba%94%e7%94%a8"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f6g8jaf4lsr9%2f&title=%e4%bb%8b%e7%bb%8dRxJS%e5%9c%a8Angular%e4%b8%ad%e7%9a%84%e5%ba%94%e7%94%a8"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f6g8jaf4lsr9%2f&is_video=false&description=%e4%bb%8b%e7%bb%8dRxJS%e5%9c%a8Angular%e4%b8%ad%e7%9a%84%e5%ba%94%e7%94%a8"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e4%bb%8b%e7%bb%8dRxJS%e5%9c%a8Angular%e4%b8%ad%e7%9a%84%e5%ba%94%e7%94%a8&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f6g8jaf4lsr9%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f6g8jaf4lsr9%2f&title=%e4%bb%8b%e7%bb%8dRxJS%e5%9c%a8Angular%e4%b8%ad%e7%9a%84%e5%ba%94%e7%94%a8"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f6g8jaf4lsr9%2f&title=%e4%bb%8b%e7%bb%8dRxJS%e5%9c%a8Angular%e4%b8%ad%e7%9a%84%e5%ba%94%e7%94%a8"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f6g8jaf4lsr9%2f&title=%e4%bb%8b%e7%bb%8dRxJS%e5%9c%a8Angular%e4%b8%ad%e7%9a%84%e5%ba%94%e7%94%a8"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f6g8jaf4lsr9%2f&title=%e4%bb%8b%e7%bb%8dRxJS%e5%9c%a8Angular%e4%b8%ad%e7%9a%84%e5%ba%94%e7%94%a8"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">介绍RxJS在Angular中的应用</h1><div class="meta"><div class="postdate"><time datetime="2019-01-12" itemprop="datePublished">2019-01-12</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/ReactiveX\/rxjs\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eRxJS\x3c\/a\x3e是一种针对异步数据流编程工具，或者叫响应式扩展编程；可不管如何解释RxJS其目标就是异步编程，Angular引入RxJS为了就是让异步可控、更简单。\x3c\/p\x3e\n\x3cp\x3e而今就是要探讨什么是Observable、observer、operator、Submit、EventEmmit，以及如何去使用它们。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader0\x22\x3e什么是Observable？\x3c\/h1\x3e\n\x3cp\x3eObservable只是一个普通函数，要想让他有所作为，就需要跟observer一起使用；\x3cstrong\x3e前者是受后者是攻\x3c\/strong\x3e。而这个observer（后面我们会介绍）只是一个带有 \x3ccode\x3enext\x3c\/code\x3e、\x3ccode\x3eerror\x3c\/code\x3e、\x3ccode\x3ecomplete\x3c\/code\x3e 的简单对象而已。最后，还需要通过 \x3ccode\x3esubscribe\x3c\/code\x3e 订阅来启动Observable；否则它是不会有任何反应；\x3cstrong\x3e可以理解为陌*为了他们能在一起而提供的环境\x3c\/strong\x3e，而订阅也会返回一个可用于取消操作（在RxJS里叫 \x3ccode\x3eunsubscribe\x3c\/code\x3e）。\x3c\/p\x3e\n\x3cp\x3e当Observable设置观察者后，而连接并获取原始数据的这个过程叫生产者，可能是DOM中的 \x3ccode\x3eclick\x3c\/code\x3e 事件、\x3ccode\x3einput\x3c\/code\x3e 事件、或者更加复杂的HTTP通信。\x3c\/p\x3e\n\x3cp\x3e为了更好理解，先从一个简单的示例开始：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import { Component } from \x27@angular\/core\x27;\nimport { Observable, Subscription } from \x27rxjs\x27;\n\n@Component({\n  selector: \x27app-home\x27,\n  template: `\x3cinput type=\x26quot;text\x26quot;\x3e `\n})\nexport class HomeComponent {\n  ngOnInit() {\n    const node = document.querySelector(\x27input[type=text]\x27);\n\n    \/\/ 第二个参数 input 是事件名，对于input元素有一个 oninput 事件用于接受用户输入\n    const input$ = Observable.fromEvent(node, \x27input\x27);\n    input$.subscribe({\n      next: (event: any) =\x3e console.log(`You just typed ${event.target.value}!`),\n      error: (err) =\x3e console.log(`Oops... ${err}`),\n      complete: () =\x3e console.log(`Complete!`)\n    });\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { Component } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27@angular\/core\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { Observable, Subscription } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27rxjs\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-meta\x22\x3e@Component\x3c\/span\x3e({\n  selector: \x3cspan class=\x22hljs-string\x22\x3e\x27app-home\x27\x3c\/span\x3e,\n  template: \x3cspan class=\x22hljs-string\x22\x3e`\x26lt;input type=\x22text\x22\x26gt; `\x3c\/span\x3e\n})\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e HomeComponent {\n  ngOnInit() {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e node = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.querySelector(\x3cspan class=\x22hljs-string\x22\x3e\x27input[type=text]\x27\x3c\/span\x3e);\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 第二个参数 input 是事件名，对于input元素有一个 oninput 事件用于接受用户输入\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e input$ = Observable.fromEvent(node, \x3cspan class=\x22hljs-string\x22\x3e\x27input\x27\x3c\/span\x3e);\n    input$.subscribe({\n      next: \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eevent: \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e`You just typed \x3cspan class=\x22hljs-subst\x22\x3e${event.target.value}\x3c\/span\x3e!`\x3c\/span\x3e),\n      error: \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e`Oops... \x3cspan class=\x22hljs-subst\x22\x3e${err}\x3c\/span\x3e`\x3c\/span\x3e),\n      complete: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e`Complete!`\x3c\/span\x3e)\n    });\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e示例中 \x3ccode\x3eObservable.fromEvent()\x3c\/code\x3e 会返回一个Observable，并且监听 \x3ccode\x3einput\x3c\/code\x3e 事件，当事件被触发后会发送一个 \x3ccode\x3eEvent\x3c\/code\x3e 给对应的observer观察者。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader1\x22\x3e什么是observer？\x3c\/h1\x3e\n\x3cp\x3eobserver非常简单，像上面示例中 \x3ccode\x3esubscribe\x3c\/code\x3e 订阅就是接收一个 observer 方法。\x3c\/p\x3e\n\x3cp\x3e一般在Angular我们 \x3ccode\x3esubscribe\x3c\/code\x3e 会这么写：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22input$.subscribe((event: any) =\x3e {\n\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3einput$.subscribe(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eevent: \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e从语法角度来讲和 \x3ccode\x3esubscribe({ next, error, complete })\x3c\/code\x3e 是一样的。\x3c\/p\x3e\n\x3cp\x3e当Observable产生一个新值时，会通知 observer 的 \x3ccode\x3enext()\x3c\/code\x3e，而当捕获失败可以调用 \x3ccode\x3eerror()\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e当Observable被订阅后，除非调用observer的 \x3ccode\x3ecomplete()\x3c\/code\x3e 或 \x3ccode\x3eunsubscribe()\x3c\/code\x3e 取消订阅两情况以外；会一直将值传递给 observer。\x3c\/p\x3e\n\x3cp\x3eObservable的生产的值允许经过一序列格式化或操作，最终得到一个有价值的数据给观察者，而这一切是由一序列链式operator来完成的，每一个operator都会产生一个新的Observable。而我们也称这一序列过程为：流。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader2\x22\x3e什么是operator？\x3c\/h1\x3e\n\x3cp\x3e正如前面说到的，Observable可以链式写法，这意味着我们可以这样：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Observable.fromEvent(node, \x27input\x27)\n  .map((event: any) =\x3e event.target.value)\n  .filter(value =\x3e value.length \x3e= 2)\n  .subscribe(value =\x3e { console.log(value); });\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3eObservable.fromEvent(node, \x3cspan class=\x22hljs-string\x22\x3e\x27input\x27\x3c\/span\x3e)\n  .map(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eevent: \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e event.target.value)\n  .filter(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3evalue\x3c\/span\x3e =\x26gt;\x3c\/span\x3e value.length \x26gt;= \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e)\n  .subscribe(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3evalue\x3c\/span\x3e =\x26gt;\x3c\/span\x3e { \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(value); });\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e下面是整个顺序步骤：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e假设用户输入：a\x3c\/li\x3e\n\x3cli\x3eObservable对触发 \x3ccode\x3eoninput\x3c\/code\x3e 事件作出反应，将值以参数的形式传递给observer的 \x3ccode\x3enext()\x3c\/code\x3e。\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3emap()\x3c\/code\x3e 根据 \x3ccode\x3eevent.target.value\x3c\/code\x3e 的内容返回一个新的 Observable，并调用 \x3ccode\x3enext()\x3c\/code\x3e 传递给下一个observer。\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3efilter()\x3c\/code\x3e 如果值长度 \x3ccode\x3e\x26gt;=2\x3c\/code\x3e 的话，则返回一个新的 Observable，并调用 \x3ccode\x3enext()\x3c\/code\x3e 传递给下一个observer。\x3c\/li\x3e\n\x3cli\x3e最后，将结果传递给 \x3ccode\x3esubscribe\x3c\/code\x3e 订阅块。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e你只要记住每一次 operator 都会返回一个新的 Observable，不管 operator 有多少个，最终只有最后一个 Observable 会被订阅。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader3\x22\x3e不要忘记取消订阅\x3c\/h1\x3e\n\x3cp\x3e\x3cstrong\x3e为什么需要取消订阅\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3eObservable 当有数据产生时才会推送给订阅者，所以它可能会无限次向订阅者推送数据。正因为如此，在Angular里面创建组件的时候务必要取消订阅操作，以避免\x3cstrong\x3e内存泄漏\x3c\/strong\x3e，要知道在SPA世界里懂得\x3cstrong\x3e擦屁股\x3c\/strong\x3e是一件必须的事。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3eunsubscribe\x3c\/h2\x3e\n\x3cp\x3e前面示例讲过，调用 \x3ccode\x3esubscribe()\x3c\/code\x3e 后，会返回一个 \x3ccode\x3eSubscription\x3c\/code\x3e 可用于取消操作 \x3ccode\x3eunsubscribe()\x3c\/code\x3e。最合理的方式在 \x3ccode\x3engOnDestroy\x3c\/code\x3e 调用它。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22ngOnDestroy() {\n    this.inputSubscription.unsubscribe();\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3engOnDestroy() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.inputSubscription.unsubscribe();\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3etakeWhile\x3c\/h2\x3e\n\x3cp\x3e如果组件有很多订阅者的话，则需要将这些订阅者存储在数组中，并组件被销毁时再逐个取消订阅。但，我们有更好的办法：\x3c\/p\x3e\n\x3cp\x3e使用 [takeWhile()\x3cbr\x3e](\x3ca href=\x22http:\/\/reactivex.io\/documentation\/operators\/takewhile.html)\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/reactivex.io\/documenta...\x3c\/a\x3e operator，它会在你传递一个布尔值是调用 \x3ccode\x3enext()\x3c\/code\x3e 还是 \x3ccode\x3ecomplete()\x3c\/code\x3e。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22private alive: boolean = true;\nngOnInit() {\n  const node = document.querySelector(\x27input[type=text]\x27);\n\n  this.s = Observable.fromEvent(node, \x27input\x27)\n    .takeWhile(() =\x3e this.alive)\n    .map((event: any) =\x3e event.target.value)\n    .filter(value =\x3e value.length \x3e= 2)\n    .subscribe(value =\x3e { console.log(value) });\n}\n\nngOnDestroy() {\n  this.alive = false;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eprivate\x3c\/span\x3e alive: \x3cspan class=\x22hljs-built_in\x22\x3eboolean\x3c\/span\x3e = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\nngOnInit() {\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e node = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.querySelector(\x3cspan class=\x22hljs-string\x22\x3e\x27input[type=text]\x27\x3c\/span\x3e);\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.s = Observable.fromEvent(node, \x3cspan class=\x22hljs-string\x22\x3e\x27input\x27\x3c\/span\x3e)\n    .takeWhile(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.alive)\n    .map(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eevent: \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e event.target.value)\n    .filter(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3evalue\x3c\/span\x3e =\x26gt;\x3c\/span\x3e value.length \x26gt;= \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e)\n    .subscribe(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3evalue\x3c\/span\x3e =\x26gt;\x3c\/span\x3e { \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(value) });\n}\n\nngOnDestroy() {\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.alive = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e简单有效，而且优雅。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader6\x22\x3eSubject\x3c\/h1\x3e\n\x3cp\x3e如果说 \x3ccode\x3eObservable\x3c\/code\x3e 与 \x3ccode\x3eobserver\x3c\/code\x3e 是攻受结合体的话，那么 \x3ccode\x3eSubject\x3c\/code\x3e 就是一个人即攻亦受。正因为如此，我们在写一个Service用于数据传递时，总是使用 \x3ccode\x3enew Subject\x3c\/code\x3e。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22@Injectable()\nexport class MessageService {\n    private subject = new Subject\x3cany\x3e();\n\n    send(message: any) {\n        this.subject.next(message);\n    }\n\n    get(): Observable\x3cany\x3e {\n        return this.subject.asObservable();\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3e@Injectable\x3c\/span\x3e()\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e MessageService {\n    \x3cspan class=\x22hljs-keyword\x22\x3eprivate\x3c\/span\x3e subject = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Subject\x26lt;\x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e\x26gt;();\n\n    send(message: \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.subject.next(message);\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eget\x3c\/span\x3e(): Observable\x26lt;\x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e\x26gt; {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.subject.asObservable();\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当F组件需要向M组件传递数据时，我们可以在F组件中使用 \x3ccode\x3esend()\x3c\/code\x3e。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22constructor(public srv: MessageService) { }\n\nngOnInit() {\n    this.srv.send(\x27w s k f m?\x27)\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3epublic\x3c\/span\x3e srv: MessageService\x3c\/span\x3e) { }\n\nngOnInit() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.srv.send(\x3cspan class=\x22hljs-string\x22\x3e\x27w s k f m?\x27\x3c\/span\x3e)\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e而M组件只需要订阅内容就行：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22constructor(private srv: MessageService) {}\n\nmessage: any;\nngOnInit() {\n    this.srv.get().subscribe((result) =\x3e {\n        this.message = result;\n    })\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eprivate\x3c\/span\x3e srv: MessageService\x3c\/span\x3e) {}\n\nmessage: \x3cspan class=\x22hljs-built_in\x22\x3eany\x3c\/span\x3e;\nngOnInit() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.srv.get().subscribe(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.message = result;\n    })\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch1 id=\x22articleHeader7\x22\x3eEventEmitter\x3c\/h1\x3e\n\x3cp\x3e其实EventEmitter跟RxJS没有直接关系，因为他是Angular的产物，而非RxJS的东西。或者我们压根没必要去谈，因为EventEmitter就是Subject。\x3c\/p\x3e\n\x3cp\x3eEventEmitter的作用是\x3cstrong\x3e使指令或组件能自定义事件\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22@Output() changed = new EventEmitter\x3cstring\x3e();\n\nclick() {\n    this.changed.emit(\x27hi~\x27);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3e@Output\x3c\/span\x3e() changed = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e EventEmitter\x26lt;\x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e\x26gt;();\n\nclick() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.changed.emit(\x3cspan class=\x22hljs-string\x22\x3e\x27hi~\x27\x3c\/span\x3e);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22@Component({\n  template: `\x3ccomp (changed)=\x26quot;subscribe($event)\x26quot;\x3e\x3c\/comp\x3e`\n})\nexport class HomeComponent {\n  subscribe(message: string) {\n     \/\/ 接收：hi~\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22xml hljs\x22\x3e\x3ccode class=\x22html\x22\x3e@Component({\n  template: `\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ecomp\x3c\/span\x3e (\x3cspan class=\x22hljs-attr\x22\x3echanged\x3c\/span\x3e)=\x3cspan class=\x22hljs-string\x22\x3e\x22subscribe($event)\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ecomp\x3c\/span\x3e\x26gt;\x3c\/span\x3e`\n})\nexport class HomeComponent {\n  subscribe(message: string) {\n     \/\/ 接收：hi~\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面示例其实和上一个示例中 \x3ccode\x3eMessageService\x3c\/code\x3e 如出一辙，只不过是将 \x3ccode\x3enext()\x3c\/code\x3e 换成 \x3ccode\x3eemit()\x3c\/code\x3e 仅此而已。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader8\x22\x3e结论\x3c\/h1\x3e\n\x3cp\x3eRxJS最难我想就是各种operator的应用了，这需要一些经验的积累。\x3c\/p\x3e\n\x3cp\x3eRxJS很火很大原因我认还是提供了丰富的API，以下是摘抄：\x3c\/p\x3e\n\x3cp\x3e创建数据流：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e单值：of, empty, never\x3c\/li\x3e\n\x3cli\x3e多值：from\x3c\/li\x3e\n\x3cli\x3e定时：interval, timer\x3c\/li\x3e\n\x3cli\x3e从事件创建：fromEvent\x3c\/li\x3e\n\x3cli\x3e从Promise创建：fromPromise\x3c\/li\x3e\n\x3cli\x3e自定义创建：create\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e转换操作：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e改变数据形态：map, mapTo, pluck\x3c\/li\x3e\n\x3cli\x3e过滤一些值：filter, skip, first, last, take\x3c\/li\x3e\n\x3cli\x3e时间轴上的操作：delay, timeout, throttle, debounce, audit, bufferTime\x3c\/li\x3e\n\x3cli\x3e累加：reduce, scan\x3c\/li\x3e\n\x3cli\x3e异常处理：throw, catch, retry, finally\x3c\/li\x3e\n\x3cli\x3e条件执行：takeUntil, delayWhen, retryWhen, subscribeOn, ObserveOn\x3c\/li\x3e\n\x3cli\x3e转接：switch\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e组合数据流：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3econcat，保持原来的序列顺序连接两个数据流\x3c\/li\x3e\n\x3cli\x3emerge，合并序列\x3c\/li\x3e\n\x3cli\x3erace，预设条件为其中一个数据流完成\x3c\/li\x3e\n\x3cli\x3eforkJoin，预设条件为所有数据流都完成\x3c\/li\x3e\n\x3cli\x3ezip，取各来源数据流最后一个值合并为对象\x3c\/li\x3e\n\x3cli\x3ecombineLatest，取各来源数据流最后一个值合并为数组\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e另，最好使用 **$** 结尾的命名方式来表示Observable，例：input$。\x3c\/p\x3e\n\x3cp\x3ehappy coding!\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>介绍RxJS在Angular中的应用</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000009729247">https://segmentfault.com/a/1190000009729247</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/6g8jaf4lsr9/" target="_blank">https://alili.tech/archive/6g8jaf4lsr9/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>