<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="减少 curl 中内存分配操作（malloc）"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>减少 curl 中内存分配操作（malloc） | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/q6ydalwzuci/",
				"appid": "1613049289050283", 
				"title": "减少 curl 中内存分配操作（malloc） | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-22T02:30:07"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/4cphvukmryc/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/a44z6i0asye/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fq6ydalwzuci%2f&text=%e5%87%8f%e5%b0%91%20curl%20%e4%b8%ad%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e6%93%8d%e4%bd%9c%ef%bc%88malloc%ef%bc%89"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fq6ydalwzuci%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fq6ydalwzuci%2f&text=%e5%87%8f%e5%b0%91%20curl%20%e4%b8%ad%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e6%93%8d%e4%bd%9c%ef%bc%88malloc%ef%bc%89"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fq6ydalwzuci%2f&title=%e5%87%8f%e5%b0%91%20curl%20%e4%b8%ad%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e6%93%8d%e4%bd%9c%ef%bc%88malloc%ef%bc%89"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fq6ydalwzuci%2f&is_video=false&description=%e5%87%8f%e5%b0%91%20curl%20%e4%b8%ad%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e6%93%8d%e4%bd%9c%ef%bc%88malloc%ef%bc%89"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e5%87%8f%e5%b0%91%20curl%20%e4%b8%ad%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e6%93%8d%e4%bd%9c%ef%bc%88malloc%ef%bc%89&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fq6ydalwzuci%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fq6ydalwzuci%2f&title=%e5%87%8f%e5%b0%91%20curl%20%e4%b8%ad%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e6%93%8d%e4%bd%9c%ef%bc%88malloc%ef%bc%89"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fq6ydalwzuci%2f&title=%e5%87%8f%e5%b0%91%20curl%20%e4%b8%ad%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e6%93%8d%e4%bd%9c%ef%bc%88malloc%ef%bc%89"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fq6ydalwzuci%2f&title=%e5%87%8f%e5%b0%91%20curl%20%e4%b8%ad%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e6%93%8d%e4%bd%9c%ef%bc%88malloc%ef%bc%89"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fq6ydalwzuci%2f&title=%e5%87%8f%e5%b0%91%20curl%20%e4%b8%ad%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e6%93%8d%e4%bd%9c%ef%bc%88malloc%ef%bc%89"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">减少 curl 中内存分配操作（malloc）</h1><div class="meta"><div class="postdate"><time datetime="2019-01-22" itemprop="datePublished">2019-01-22</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n            \x3ch1\x3e\x3ca href=\x22#减少-curl-中内存分配操作malloc\x22\x3e\x3c\/a\x3e减少 curl 中内存分配操作（malloc）\x3c\/h1\x3e\n\x3cp\x3e今天我在 libcurl 内部又做了\x3ca href=\x22https:\/\/github.com\/curl\/curl\/commit\/cbae73e1dd95946597ea74ccb580c30f78e3fa73\x22\x3e一个小改动\x3c\/a\x3e，使其做更少的 malloc。这一次，泛型链表函数被转换成更少的 malloc (这才是链表函数应有的方式，真的)。\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22#研究-malloc\x22\x3e\x3c\/a\x3e研究 malloc\x3c\/h3\x3e\n\x3cp\x3e几周前我开始研究内存分配。这很容易，因为多年前我们 curl 中就已经有内存调试和日志记录系统了。使用 curl 的调试版本，并在我的构建目录中运行此脚本：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs bash\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3e#!\/bin\/sh\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3eexport\x3c\/span\x3e CURL_MEMDEBUG=\x3cspan class=\x22hljs-variable\x22\x3e$HOME\x3c\/span\x3e\/tmp\/curlmem.log\n.\/src\/curl http:\/\/localhost\n.\/tests\/memanalyze.pl -v \x3cspan class=\x22hljs-variable\x22\x3e$HOME\x3c\/span\x3e\/tmp\/curlmem.log\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e对于 curl 7.53.1，这大约有 115 次内存分配。这算多还是少？\x3c\/p\x3e\n\x3cp\x3e内存日志非常基础。为了让你有所了解，这是一个示例片段：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs stylus\x22\x3eMEM getinfo\x3cspan class=\x22hljs-selector-class\x22\x3e.c\x3c\/span\x3e:\x3cspan class=\x22hljs-number\x22\x3e70\x3c\/span\x3e free((nil))\nMEM getinfo\x3cspan class=\x22hljs-selector-class\x22\x3e.c\x3c\/span\x3e:\x3cspan class=\x22hljs-number\x22\x3e73\x3c\/span\x3e free((nil))\nMEM url\x3cspan class=\x22hljs-selector-class\x22\x3e.c\x3c\/span\x3e:\x3cspan class=\x22hljs-number\x22\x3e294\x3c\/span\x3e free((nil))\nMEM url\x3cspan class=\x22hljs-selector-class\x22\x3e.c\x3c\/span\x3e:\x3cspan class=\x22hljs-number\x22\x3e297\x3c\/span\x3e strdup(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3ex559e7150d616) (\x3cspan class=\x22hljs-number\x22\x3e24\x3c\/span\x3e) = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3ex559e73760f98\nMEM url\x3cspan class=\x22hljs-selector-class\x22\x3e.c\x3c\/span\x3e:\x3cspan class=\x22hljs-number\x22\x3e294\x3c\/span\x3e free((nil))\nMEM url\x3cspan class=\x22hljs-selector-class\x22\x3e.c\x3c\/span\x3e:\x3cspan class=\x22hljs-number\x22\x3e297\x3c\/span\x3e strdup(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3ex559e7150d62e) (\x3cspan class=\x22hljs-number\x22\x3e22\x3c\/span\x3e) = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3ex559e73760fc8\nMEM multi\x3cspan class=\x22hljs-selector-class\x22\x3e.c\x3c\/span\x3e:\x3cspan class=\x22hljs-number\x22\x3e302\x3c\/span\x3e calloc(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e480\x3c\/span\x3e) = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3ex559e73760ff8\nMEM hash\x3cspan class=\x22hljs-selector-class\x22\x3e.c\x3c\/span\x3e:\x3cspan class=\x22hljs-number\x22\x3e75\x3c\/span\x3e malloc(\x3cspan class=\x22hljs-number\x22\x3e224\x3c\/span\x3e) = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3ex559e737611f8\nMEM hash\x3cspan class=\x22hljs-selector-class\x22\x3e.c\x3c\/span\x3e:\x3cspan class=\x22hljs-number\x22\x3e75\x3c\/span\x3e malloc(\x3cspan class=\x22hljs-number\x22\x3e29152\x3c\/span\x3e) = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3ex559e737a2bc8\nMEM hash\x3cspan class=\x22hljs-selector-class\x22\x3e.c\x3c\/span\x3e:\x3cspan class=\x22hljs-number\x22\x3e75\x3c\/span\x3e malloc(\x3cspan class=\x22hljs-number\x22\x3e3104\x3c\/span\x3e) = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3ex559e737a9dc8\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3ch3\x3e\x3ca href=\x22#检查日志\x22\x3e\x3c\/a\x3e检查日志\x3c\/h3\x3e\n\x3cp\x3e然后，我对日志进行了更深入的研究，我意识到在相同的代码行做了许多小内存分配。我们显然有一些相当愚蠢的代码模式，我们分配一个结构体，然后将该结构添加到链表或哈希，然后该代码随后再添加另一个小结构体，如此这般，而且经常在循环中执行。（我在这里说的是_我们_，不是为了责怪某个人，当然大部分的责任是我自己……）\x3c\/p\x3e\n\x3cp\x3e这两种分配操作将总是成对地出现，并被同时释放。我决定解决这些问题。做非常小的（小于 32 字节）的分配也是浪费的，因为非常多的数据将被用于（在 malloc 系统内）跟踪那个微小的内存区域。更不用说堆碎片了。\x3c\/p\x3e\n\x3cp\x3e因此，将该哈希和链表代码修复为不使用 malloc 是快速且简单的方法，对于最简单的 “curl \x3ca href=\x22http:\/\/localhost%E2%80%9D\x22\x3ehttp:\/\/localhost”\x3c\/a\x3e 传输，它可以消除 20％ 以上的 malloc。\x3c\/p\x3e\n\x3cp\x3e此时，我根据大小对所有的内存分配操作进行排序，并检查所有最小的分配操作。一个突出的部分是在 \x3ccode\x3ecurl_multi_wait()\x3c\/code\x3e 中，它是一个典型的在 curl 传输主循环中被反复调用的函数。对于大多数典型情况，我将其转换为\x3ca href=\x22https:\/\/github.com\/curl\/curl\/commit\/5f1163517e1597339d\x22\x3e使用堆栈\x3c\/a\x3e。在大量重复的调用函数中避免 malloc 是一件好事。\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22#重新计数\x22\x3e\x3c\/a\x3e重新计数\x3c\/h3\x3e\n\x3cp\x3e现在，如上面的脚本所示，同样的 \x3ccode\x3ecurl localhost\x3c\/code\x3e 命令从 curl 7.53.1 的 115 次分配操作下降到 80 个分配操作，而没有牺牲任何东西。轻松地有 26％ 的改善。一点也不差！\x3c\/p\x3e\n\x3cp\x3e由于我修改了 \x3ccode\x3ecurl_multi_wait()\x3c\/code\x3e，我也想看看它实际上是如何改进一些稍微更高级一些的传输。我使用了 \x3ca href=\x22https:\/\/github.com\/curl\/curl\/commit\/5f1163517e1597339d\x22\x3emulti-double.c\x3c\/a\x3e 示例代码，添加了初始化内存记录的调用，让它使用 \x3ccode\x3ecurl_multi_wait()\x3c\/code\x3e，并且并行下载了这两个 URL：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs dts\x22\x3e\x3cspan class=\x22hljs-symbol\x22\x3ehttp:\x3c\/span\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/www.example.com\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-symbol\x22\x3ehttp:\x3c\/span\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/localhost\/512M\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e第二个文件是 512 兆字节的零，第一个文件是一个 600 字节的公共 html 页面。这是 \x3ca href=\x22https:\/\/gist.github.com\/bagder\/dc4a42cb561e791e470362da7ef731d3\x22\x3ecount-malloc.c 代码\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3e首先，我使用 7.53.1 来测试上面的例子，并使用 \x3ccode\x3ememanalyze\x3c\/code\x3e 脚本检查：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs groovy\x22\x3e\x3cspan class=\x22hljs-string\x22\x3eMallocs:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e33901\x3c\/span\x3e\n\x3cspan class=\x22hljs-string\x22\x3eReallocs:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e\n\x3cspan class=\x22hljs-string\x22\x3eCallocs:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e24\x3c\/span\x3e\n\x3cspan class=\x22hljs-string\x22\x3eStrdups:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e31\x3c\/span\x3e\n\x3cspan class=\x22hljs-string\x22\x3eWcsdups:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n\x3cspan class=\x22hljs-string\x22\x3eFrees:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e33956\x3c\/span\x3e\n\x3cspan class=\x22hljs-string\x22\x3eAllocations:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e33961\x3c\/span\x3e\nMaximum \x3cspan class=\x22hljs-string\x22\x3eallocated:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e160385\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e好了，所以它总共使用了 160KB 的内存，分配操作次数超过 33900 次。而它下载超过 512 兆字节的数据，所以它每 15KB 数据有一次 malloc。是好是坏？\x3c\/p\x3e\n\x3cp\x3e回到 git master，现在是 7.54.1-DEV 的版本 - 因为我们不太确定当我们发布下一个版本时会变成哪个版本号。它可能是 7.54.1 或 7.55.0，它还尚未确定。我离题了，我再次运行相同修改的 multi-double.c 示例，再次对内存日志运行 memanalyze，报告来了：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs groovy\x22\x3e\x3cspan class=\x22hljs-string\x22\x3eMallocs:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e69\x3c\/span\x3e\n\x3cspan class=\x22hljs-string\x22\x3eReallocs:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e\n\x3cspan class=\x22hljs-string\x22\x3eCallocs:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e24\x3c\/span\x3e\n\x3cspan class=\x22hljs-string\x22\x3eStrdups:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e31\x3c\/span\x3e\n\x3cspan class=\x22hljs-string\x22\x3eWcsdups:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n\x3cspan class=\x22hljs-string\x22\x3eFrees:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e124\x3c\/span\x3e\n\x3cspan class=\x22hljs-string\x22\x3eAllocations:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e129\x3c\/span\x3e\nMaximum \x3cspan class=\x22hljs-string\x22\x3eallocated:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e153247\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e我不敢置信地反复看了两遍。发生什么了吗？为了仔细检查，我最好再运行一次。无论我运行多少次，结果还是一样的。\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22#33961-vs-129\x22\x3e\x3c\/a\x3e33961 vs 129\x3c\/h3\x3e\n\x3cp\x3e在典型的传输中 \x3ccode\x3ecurl_multi_wait()\x3c\/code\x3e 被调用了很多次，并且在传输过程中至少要正常进行一次内存分配操作，因此删除那个单一的微小分配操作对计数器有非常大的影响。正常的传输也会做一些将数据移入或移出链表和散列操作，但是它们现在也大都是无 malloc 的。简单地说：剩余的分配操作不会在传输循环中执行，所以它们的重要性不大。\x3c\/p\x3e\n\x3cp\x3e以前的 curl 是当前示例分配操作数量的 263 倍。换句话说：新的是旧的分配操作数量的 0.37％ 。\x3c\/p\x3e\n\x3cp\x3e另外还有一点好处，新的内存分配量更少，总共减少了 7KB（4.3％）。\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22#malloc-重要吗\x22\x3e\x3c\/a\x3emalloc 重要吗？\x3c\/h3\x3e\n\x3cp\x3e在几个 G 内存的时代里，在传输中有几个 malloc 真的对于普通人有显著的区别吗？对 512MB 数据进行的 33832 个额外的 malloc 有什么影响？\x3c\/p\x3e\n\x3cp\x3e为了衡量这些变化的影响，我决定比较 localhost 的 HTTP 传输，看看是否可以看到任何速度差异。localhost 对于这个测试是很好的，因为没有网络速度限制，更快的 curl 下载也越快。服务器端也会相同的快\/慢，因为我将使用相同的测试集进行这两个测试。\x3c\/p\x3e\n\x3cp\x3e我相同方式构建了 curl 7.53.1 和 curl 7.54.1-DEV，并运行这个命令：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs groovy\x22\x3ecurl \x3cspan class=\x22hljs-string\x22\x3ehttp:\x3c\/span\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/localhost\/80GB -o \/dev\/null\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e下载的 80GB 的数据会尽可能快地写到空设备中。\x3c\/p\x3e\n\x3cp\x3e我获得的确切数字可能不是很有用，因为它将取决于机器中的 CPU、使用的 HTTP 服务器、构建 curl 时的优化级别等，但是相对数字仍然应该是高度相关的。新代码对决旧代码！\x3c\/p\x3e\n\x3cp\x3e7.54.1-DEV 反复地表现出更快 30％！我的早期版本是 2200MB\/秒增加到当前版本的超过 2900 MB\/秒。\x3c\/p\x3e\n\x3cp\x3e这里的要点当然不是说它很容易在我的机器上使用单一内核以超过 20GB\/秒的速度来进行 HTTP 传输，因为实际上很少有用户可以通过 curl 做到这样快速的传输。关键在于 curl 现在每个字节的传输使用更少的 CPU，这将使更多的 CPU 转移到系统的其余部分来执行任何需要做的事情。或者如果设备是便携式设备，那么可以省电。\x3c\/p\x3e\n\x3cp\x3e关于 malloc 的成本：512MB 测试中，我使用旧代码发生了 33832 次或更多的分配。旧代码以大约 2200MB\/秒的速率进行 HTTP 传输。这等于每秒 145827 次 malloc - 现在它们被消除了！600 MB\/秒的改进意味着每秒钟 curl 中每个减少的 malloc 操作能额外换来多传输 4300 字节。\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22#去掉这些-malloc-难吗\x22\x3e\x3c\/a\x3e去掉这些 malloc 难吗？\x3c\/h3\x3e\n\x3cp\x3e一点也不难，非常简单。然而，有趣的是，在这个旧项目中，仍然有这样的改进空间。我有这个想法已经好几年了，我很高兴我终于花点时间来实现。感谢我们的测试套件，我可以有相当大的信心做这个“激烈的”内部变化，而不会引入太可怕的回归问题。由于我们的 API 很好地隐藏了内部，所以这种变化可以完全不改变任何旧的或新的应用程序……\x3c\/p\x3e\n\x3cp\x3e（是的，我还没在版本中发布该变更，所以这还有风险，我有点后悔我的“这很容易”的声明……）\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22#注意数字\x22\x3e\x3c\/a\x3e注意数字\x3c\/h3\x3e\n\x3cp\x3ecurl 的 git 仓库从 7.53.1 到今天已经有 213 个提交。即使我没有别的想法，可能还会有一次或多次的提交，而不仅仅是内存分配对性能的影响。\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22#还有吗\x22\x3e\x3c\/a\x3e还有吗？\x3c\/h3\x3e\n\x3cp\x3e还有其他类似的情况么？\x3c\/p\x3e\n\x3cp\x3e也许。我们不会做很多性能测量或比较，所以谁知道呢，我们也许会做更多的愚蠢事情，我们可以收手并做得更好。有一个事情是我一直想做，但是从来没有做，就是添加所使用的内存\/malloc 和 curl 执行速度的每日“监视” ，以便更好地跟踪我们在这些方面不知不觉的回归问题。\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22#补遗423\x22\x3e\x3c\/a\x3e补遗，4\/23\x3c\/h3\x3e\n\x3cp\x3e（关于我在 hacker news、Reddit 和其它地方读到的关于这篇文章的评论）\x3c\/p\x3e\n\x3cp\x3e有些人让我再次运行那个 80GB 的下载，给出时间。我运行了三次新代码和旧代码，其运行“中值”如下：\x3c\/p\x3e\n\x3cp\x3e旧代码：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs routeros\x22\x3ereal    0m36.705s\x3cspan class=\x22hljs-built_in\x22\x3e\nuser \x3c\/span\x3e   0m20.176s\nsys     0m16.072s\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e新代码：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs routeros\x22\x3ereal    0m29.032s\x3cspan class=\x22hljs-built_in\x22\x3e\nuser \x3c\/span\x3e   0m12.196s\nsys     0m12.820s\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e承载这个 80GB 文件的服务器是标准的 Apache 2.4.25，文件存储在 SSD 上，我的机器的 CPU 是 i7 3770K 3.50GHz 。\x3c\/p\x3e\n\x3cp\x3e有些人也提到 \x3ccode\x3ealloca()\x3c\/code\x3e 作为该补丁之一也是个解决方案，但是 \x3ccode\x3ealloca()\x3c\/code\x3e 移植性不够，只能作为一个孤立的解决方案，这意味着如果我们要使用它的话，需要写一堆丑陋的 \x3ccode\x3e#ifdef\x3c\/code\x3e。\x3c\/p\x3e\n\x3chr\x3e\n\x3cp\x3evia: \x3ca href=\x22https:\/\/daniel.haxx.se\/blog\/2017\/04\/22\/fewer-mallocs-in-curl\/\x22\x3ehttps:\/\/daniel.haxx.se\/blog\/2017\/04\/22\/fewer-mallocs-in-curl\/\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e作者：\x3ca href=\x22https:\/\/daniel.haxx.se\/blog\/author\/daniel\/\x22\x3eDANIEL STENBERG\x3c\/a\x3e 译者：\x3ca href=\x22https:\/\/github.com\/geekpi\x22\x3egeekpi\x3c\/a\x3e 校对：\x3ca href=\x22https:\/\/github.com\/wxy\x22\x3ewxy\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e本文由 \x3ca href=\x22https:\/\/github.com\/LCTT\/TranslateProject\x22\x3eLCTT\x3c\/a\x3e 原创编译，\x3ca href=\x22https:\/\/linux.cn\/\x22\x3eLinux中国\x3c\/a\x3e 荣誉推出\x3c\/p\x3e\n\n          \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>减少 curl 中内存分配操作（malloc）</p><h2 id="原文链接">原文链接</h2><p><a href="https://www.zcfy.cc/article/fewer-mallocs-in-curl">https://www.zcfy.cc/article/fewer-mallocs-in-curl</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/q6ydalwzuci/" target="_blank">https://alili.tech/archive/q6ydalwzuci/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>