<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="Angular 4.x 路由快速入门"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>Angular 4.x 路由快速入门 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/hpnk8c00qxc/",
				"appid": "1613049289050283", 
				"title": "Angular 4.x 路由快速入门 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-15T02:30:12"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/qovmemzww5h/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/7l1o9ut8tnx/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fhpnk8c00qxc%2f&text=Angular%204.x%20%e8%b7%af%e7%94%b1%e5%bf%ab%e9%80%9f%e5%85%a5%e9%97%a8"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fhpnk8c00qxc%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fhpnk8c00qxc%2f&text=Angular%204.x%20%e8%b7%af%e7%94%b1%e5%bf%ab%e9%80%9f%e5%85%a5%e9%97%a8"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fhpnk8c00qxc%2f&title=Angular%204.x%20%e8%b7%af%e7%94%b1%e5%bf%ab%e9%80%9f%e5%85%a5%e9%97%a8"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fhpnk8c00qxc%2f&is_video=false&description=Angular%204.x%20%e8%b7%af%e7%94%b1%e5%bf%ab%e9%80%9f%e5%85%a5%e9%97%a8"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=Angular%204.x%20%e8%b7%af%e7%94%b1%e5%bf%ab%e9%80%9f%e5%85%a5%e9%97%a8&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fhpnk8c00qxc%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fhpnk8c00qxc%2f&title=Angular%204.x%20%e8%b7%af%e7%94%b1%e5%bf%ab%e9%80%9f%e5%85%a5%e9%97%a8"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fhpnk8c00qxc%2f&title=Angular%204.x%20%e8%b7%af%e7%94%b1%e5%bf%ab%e9%80%9f%e5%85%a5%e9%97%a8"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fhpnk8c00qxc%2f&title=Angular%204.x%20%e8%b7%af%e7%94%b1%e5%bf%ab%e9%80%9f%e5%85%a5%e9%97%a8"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fhpnk8c00qxc%2f&title=Angular%204.x%20%e8%b7%af%e7%94%b1%e5%bf%ab%e9%80%9f%e5%85%a5%e9%97%a8"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">Angular 4.x 路由快速入门</h1><div class="meta"><div class="postdate"><time datetime="2019-01-15" itemprop="datePublished">2019-01-15</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e建了个群有兴趣的朋友可以加一下 QQ 群：Angular 修仙之路(1)群 - 153742079 (已满)，请加 Angular 修仙之路(2)群 - 648681235。\x3c\/blockquote\x3e\n\x3cp\x3e路由是 Angular 应用程序的核心，它加载与所请求路由相关联的组件，以及获取特定路由的相关数据。这允许我们通过控制不同的路由，获取不同的数据，从而渲染不同的页面。\x3c\/p\x3e\n\x3cp\x3e接下来我们将按照以下目录的内容，介绍 Angular 的路由。具体目录如下：\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e目录\x3c\/h2\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cp\x3eInstalling the router\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3eBase href\x3c\/li\x3e\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3eUsing the router\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eRouterModule.forRoot\x3c\/li\x3e\n\x3cli\x3eRouterModule.forChild\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3eConfiguring a route\x3c\/li\x3e\n\x3cli\x3eDisplaying routes\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3eFuther configuration\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eDynamic routes\x3c\/li\x3e\n\x3cli\x3eChild routes\x3c\/li\x3e\n\x3cli\x3eComponent-less routes\x3c\/li\x3e\n\x3cli\x3eloadChildren\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3eRouter directives\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3erouterLink\x3c\/li\x3e\n\x3cli\x3erouterLinkActive\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3eRouter API\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3eInstalling the router\x3c\/h2\x3e\n\x3cp\x3e首先第一件事，我们需要安装 Angular Router。你可以通过运行以下任一操作来执行此操作：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22yarn add @angular\/router\n# OR\nnpm i --save @angular\/router\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode class=\x22shell\x22\x3eyarn add @angular\/router\n\x3cspan class=\x22hljs-comment\x22\x3e# OR\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3enpm\x3c\/span\x3e i --save @angular\/router\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上命令执行后，将会自动下载 \x3ccode\x3e@angular\/router\x3c\/code\x3e 模块到 \x3ccode\x3enode_modules\x3c\/code\x3e 文件夹中。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3eBase href\x3c\/h3\x3e\n\x3cp\x3e我们需要做的最后一件事，是将 \x3ccode\x3e\x26lt;base\x26gt;\x3c\/code\x3e 标签添加到我们的 \x3ccode\x3eindex.html\x3c\/code\x3e 文件中。路由需要根据这个来确定应用程序的根目录。例如，当我们转到 \x3ccode\x3ehttp:\/\/example.com\/page1\x3c\/code\x3e 时，如果我们没有定义应用程序的基础路径，路由将无法知道我们的应用的托管地址是 \x3ccode\x3ehttp:\/\/example.com\x3c\/code\x3e 还是 \x3ccode\x3ehttp:\/\/example.com\/page1\x3c\/code\x3e 。\x3c\/p\x3e\n\x3cp\x3e这件事操作起来很简单，只需打开项目中的 \x3ccode\x3eindex.html\x3c\/code\x3e 文件，添加相应的 \x3ccode\x3e\x26lt;base\x26gt;\x3c\/code\x3e 标签，具体如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3c!doctype html\x3e\n\x3chtml\x3e\n  \x3chead\x3e\n    \x3cbase href=\x26quot;\/\x26quot;\x3e\n    \x3ctitle\x3eApplication\x3c\/title\x3e\n  \x3c\/head\x3e\n  \x3cbody\x3e\n    \x3capp-root\x3e\x3c\/app-root\x3e\n  \x3c\/body\x3e\n\x3c\/html\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22xml hljs\x22\x3e\x3ccode class=\x22html\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3e\x26lt;!doctype html\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ehtml\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ehead\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ebase\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ehref\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22\/\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3etitle\x3c\/span\x3e\x26gt;\x3c\/span\x3eApplication\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3etitle\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ehead\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ebody\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eapp-root\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eapp-root\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ebody\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ehtml\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上配置信息告诉 Angular 路由，应用程序的根目录是 \x3ccode\x3e\/\x3c\/code\x3e 。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3eUsing the router\x3c\/h2\x3e\n\x3cp\x3e要使用路由，我们需要在 \x3ccode\x3eAppModule\x3c\/code\x3e 模块中，导入 \x3ccode\x3eRouterModule \x3c\/code\x3e。具体如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import { NgModule } from \x27@angular\/core\x27;\nimport { BrowserModule } from \x27@angular\/platform-browser\x27;\nimport { RouterModule } from \x27@angular\/router\x27;\n\nimport { AppComponent } from \x27.\/app.component\x27;\n\n@NgModule({\n  imports: [\n    BrowserModule,\n    RouterModule\n  ],\n  bootstrap: [\n    AppComponent\n  ],\n  declarations: [\n    AppComponent\n  ]\n})\nexport class AppModule {}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { NgModule } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27@angular\/core\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { BrowserModule } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27@angular\/platform-browser\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { RouterModule } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27@angular\/router\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { AppComponent } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/app.component\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-meta\x22\x3e@NgModule\x3c\/span\x3e({\n  imports: [\n    BrowserModule,\n    RouterModule\n  ],\n  bootstrap: [\n    AppComponent\n  ],\n  declarations: [\n    AppComponent\n  ]\n})\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e AppModule {}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e此时我们的路由还不能正常工作，因为我们还未配置应用程序路由的相关信息。\x3ccode\x3eRouterModule\x3c\/code\x3e 对象为我们提供了两个静态的方法：\x3ccode\x3eforRoot()\x3c\/code\x3e 和 \x3ccode\x3eforChild()\x3c\/code\x3e 来配置路由信息。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3eRouterModule.forRoot()\x3c\/h3\x3e\n\x3cp\x3eRouterModule.forRoot() 方法用于在主模块中定义主要的路由信息，通过调用该方法使得我们的主模块可以访问路由模块中定义的所有指令。接下来我们来看一下如何使用 \x3ccode\x3eforRoot()\x3c\/code\x3e ：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ ...\nimport { Routes, RouterModule } from \x27@angular\/router\x27;\n\nexport const ROUTES: Routes = [];\n\n@NgModule({\n  imports: [\n    BrowserModule,\n    RouterModule.forRoot(ROUTES)\n  ],\n  \/\/ ...\n})\nexport class AppModule {}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { Routes, RouterModule } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27@angular\/router\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e ROUTES: Routes = [];\n\n\x3cspan class=\x22hljs-meta\x22\x3e@NgModule\x3c\/span\x3e({\n  imports: [\n    BrowserModule,\n    RouterModule.forRoot(ROUTES)\n  ],\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n})\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e AppModule {}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们通过使用 \x3ccode\x3econst\x3c\/code\x3e 定义路由的配置信息，然后把它作为参数调用 \x3ccode\x3eRouterModule.forRoot()\x3c\/code\x3e 方法，而不是直接使用 \x3ccode\x3eRouterModule.forRoot([...])\x3c\/code\x3e 这种方式，这样做的好处是方便我们在需要的时候导出 \x3ccode\x3eROUTES\x3c\/code\x3e 到其它模块中。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3eRouterModule.forChild()\x3c\/h3\x3e\n\x3cp\x3eRouterModule.forChild() 与 Router.forRoot() 方法类似，但它只能应用在特性模块中。\x3c\/p\x3e\n\x3cblockquote\x3e友情提示：根模块中使用 \x3ccode\x3eforRoot()\x3c\/code\x3e，子模块中使用 \x3ccode\x3eforChild()\x3c\/code\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e这个功能非常强大，因为我们不必在一个地方（我们的主模块）定义所有路由信息。反之，我们可以在特性模块中定义模块特有的路由信息，并在必要的时候将它们导入我们主模块。\x3ccode\x3eRouterModule.forChild()\x3c\/code\x3e 的使用方法如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import { NgModule } from \x27@angular\/core\x27;\nimport { CommonModule } from \x27@angular\/common\x27;\nimport { Routes, RouterModule } from \x27@angular\/router\x27;\n\nexport const ROUTES: Routes = [];\n\n@NgModule({\n  imports: [\n    CommonModule,\n    RouterModule.forChild(ROUTES)\n  ],\n  \/\/ ...\n})\nexport class ChildModule {}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { NgModule } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27@angular\/core\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { CommonModule } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27@angular\/common\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { Routes, RouterModule } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27@angular\/router\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e ROUTES: Routes = [];\n\n\x3cspan class=\x22hljs-meta\x22\x3e@NgModule\x3c\/span\x3e({\n  imports: [\n    CommonModule,\n    RouterModule.forChild(ROUTES)\n  ],\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n})\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e ChildModule {}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e通过以上示例，我们知道在主模块和特性模块中，路由配置对象的类型是一样的，区别只是主模块和特性模块中需调用不同的方法，来配置模块路由。接下来我们来介绍一下如何配置 \x3ccode\x3eROUTES\x3c\/code\x3e 对象。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3eConfiguring a route\x3c\/h2\x3e\n\x3cp\x3e我们定义的所有路由都是作为 \x3ccode\x3eROUTES\x3c\/code\x3e 数组中的对象。首先，为我们的主页定义一个路由：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import { Routes, RouterModule } from \x27@angular\/router\x27;\n\nimport { HomeComponent } from \x27.\/home\/home.component\x27;\n\nexport const ROUTES: Routes = [\n  { path: \x27\x27, component: HomeComponent }\n];\n\n@NgModule({\n  imports: [\n    BrowserModule,\n    RouterModule.forRoot(ROUTES)\n  ],\n  \/\/ ...\n})\nexport class AppModule {}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { Routes, RouterModule } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27@angular\/router\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { HomeComponent } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/home\/home.component\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e ROUTES: Routes = [\n  { path: \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e, component: HomeComponent }\n];\n\n\x3cspan class=\x22hljs-meta\x22\x3e@NgModule\x3c\/span\x3e({\n  imports: [\n    BrowserModule,\n    RouterModule.forRoot(ROUTES)\n  ],\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n})\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e AppModule {}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e示例中我们通过 \x3ccode\x3epath\x3c\/code\x3e 属性定义路由的匹配路径，而 \x3ccode\x3ecomponent\x3c\/code\x3e 属性用于定义路由匹配时需要加载的组件。\x3c\/p\x3e\n\x3cblockquote\x3e友情提示：我们使用 \x3ccode\x3epath: \x27\x27\x3c\/code\x3e 来匹配空的路径，例如：\x3ccode\x3ehttps:\/\/yourdomain.com\x3c\/code\x3e\n\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3eDisplaying routes\x3c\/h2\x3e\n\x3cp\x3e配置完路由信息后，下一步是使用一个名为 \x3ccode\x3erouter-outlet\x3c\/code\x3e 的指令告诉 Angular 在哪里加载组件。当 Angular 路由匹配到响应路径，并成功找到需要加载的组件时，它将动态创建对应的组件，并将其作为兄弟元素，插入到 \x3ccode\x3erouter-outlet\x3c\/code\x3e 元素之后。\x3c\/p\x3e\n\x3cp\x3e在我们 \x3ccode\x3eAppComponent\x3c\/code\x3e 组件中，我们可以在任意位置插入 \x3ccode\x3erouter-outlet\x3c\/code\x3e 指令：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import { Component } from \x27@angular\/core\x27;\n\n@Component({\n  selector: \x27app-root\x27,\n  template: `\n    \x3cdiv class=\x26quot;app\x26quot;\x3e\n      \x3ch3\x3eOur app\x3c\/h3\x3e\n      \x3crouter-outlet\x3e\x3c\/router-outlet\x3e\n    \x3c\/div\x3e\n  `\n})\nexport class AppComponent {}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { Component } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27@angular\/core\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-meta\x22\x3e@Component\x3c\/span\x3e({\n  selector: \x3cspan class=\x22hljs-string\x22\x3e\x27app-root\x27\x3c\/span\x3e,\n  template: \x3cspan class=\x22hljs-string\x22\x3e`\n    \x26lt;div class=\x22app\x22\x26gt;\n      \x26lt;h3\x26gt;Our app\x26lt;\/h3\x26gt;\n      \x26lt;router-outlet\x26gt;\x26lt;\/router-outlet\x26gt;\n    \x26lt;\/div\x26gt;\n  `\x3c\/span\x3e\n})\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e AppComponent {}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们现在已经建立了应用程序的主路由，我们可以进一步了解路由的其它配置选项。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3eFurther configuration\x3c\/h2\x3e\n\x3cp\x3e到目前为止我们已经介绍的内容只是一个开始 ，接下来我们来看看其它一些选项和功能。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3eDynamic routes\x3c\/h3\x3e\n\x3cp\x3e如果路由始终是静态的，那没有多大的用处。例如 \x3ccode\x3epath: \x27\x27\x3c\/code\x3e 是加载我们 \x3ccode\x3eHomeComponent\x3c\/code\x3e 组件的静态路由。我们将介绍动态路由，基于动态路由我们可以根据不同的路由参数，渲染不同的页面。\x3c\/p\x3e\n\x3cp\x3e例如，如果我们想要在个人资料页面根据不同的用户名显示不同的用户信息，我们可以使用以下方式定义路由：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import { HomeComponent } from \x27.\/home\/home.component\x27;\nimport { ProfileComponent } from \x27.\/profile\/profile.component\x27;\n\nexport const ROUTES: Routes = [\n  { path: \x27\x27, component: HomeComponent },\n  { path: \x27\/profile\/:username\x27, component: ProfileComponent }\n];\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { HomeComponent } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/home\/home.component\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { ProfileComponent } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/profile\/profile.component\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e ROUTES: Routes = [\n  { path: \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e, component: HomeComponent },\n  { path: \x3cspan class=\x22hljs-string\x22\x3e\x27\/profile\/:username\x27\x3c\/span\x3e, component: ProfileComponent }\n];\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里的关键点是 \x3ccode\x3e:\x3c\/code\x3e ，它告诉 Angular 路由，\x3ccode\x3e:username\x3c\/code\x3e 是路由参数，而不是 URL 中实际的部分。\x3c\/p\x3e\n\x3cblockquote\x3e友情提示：如果没有使用 \x3ccode\x3e:\x3c\/code\x3e ，它将作为静态路由，仅匹配 \x3ccode\x3e\/profile\/username\x3c\/code\x3e 路径\x3c\/blockquote\x3e\n\x3cp\x3e现在我们已经建立一个动态路由，此时最重要的事情就是如何获取路由参数。要访问当前路由的相关信息，我们需要先从 \x3ccode\x3e@angular\/router\x3c\/code\x3e 模块中导入 \x3ccode\x3eActivatedRoute\x3c\/code\x3e ，然后在组件类的构造函数中注入该对象，最后通过订阅该对象的 \x3ccode\x3eparams\x3c\/code\x3e 属性，来获取路由参数，具体示例如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import { Component, OnInit } from \x27@angular\/core\x27;\nimport { ActivatedRoute } from \x27@angular\/router\x27;\n\n@Component({\n  selector: \x27profile-page\x27,\n  template: `\n    \x3cdiv class=\x26quot;profile\x26quot;\x3e\n      \x3ch3\x3e\x22{{\x22 username \x22}}\x22\x3c\/h3\x3e\n    \x3c\/div\x3e\n  `\n})\nexport class SettingsComponent implements OnInit {\n  username: string;\n  constructor(private route: ActivatedRoute) {}\n  ngOnInit() {\n    this.route.params.subscribe((params) =\x3e this.username = params.username);\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { Component, OnInit } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27@angular\/core\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { ActivatedRoute } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27@angular\/router\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-meta\x22\x3e@Component\x3c\/span\x3e({\n  selector: \x3cspan class=\x22hljs-string\x22\x3e\x27profile-page\x27\x3c\/span\x3e,\n  template: \x3cspan class=\x22hljs-string\x22\x3e`\n    \x26lt;div class=\x22profile\x22\x26gt;\n      \x26lt;h3\x26gt;\x22{{\x22 username \x22}}\x22\x26lt;\/h3\x26gt;\n    \x26lt;\/div\x26gt;\n  `\x3c\/span\x3e\n})\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e SettingsComponent \x3cspan class=\x22hljs-keyword\x22\x3eimplements\x3c\/span\x3e OnInit {\n  username: \x3cspan class=\x22hljs-built_in\x22\x3estring\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eprivate\x3c\/span\x3e route: ActivatedRoute\x3c\/span\x3e) {}\n  ngOnInit() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.route.params.subscribe(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eparams\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.username = params.username);\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e介绍完动态路由，我们来探讨一下如何创建 \x3ccode\x3echild routes\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3eChild routes\x3c\/h3\x3e\n\x3cp\x3e实际上每个路由都支持子路由，假设在我们 \x3ccode\x3e\/settings\x3c\/code\x3e 设置页面下有 \x3ccode\x3e\/settings\/profile\x3c\/code\x3e 和 \x3ccode\x3e\/settings\/password\x3c\/code\x3e 两个页面，分别表示个人资料页和修改密码页。\x3c\/p\x3e\n\x3cp\x3e我们可能希望我们的 \x3ccode\x3e\/ settings\x3c\/code\x3e 页面拥有自己的组件，然后在设置页面组件中显示 \x3ccode\x3e\/ settings\/profile\x3c\/code\x3e 和 \x3ccode\x3e\/ settings\/password\x3c\/code\x3e 页面。我们可以这样做：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import { SettingsComponent } from \x27.\/settings\/settings.component\x27;\nimport { ProfileSettingsComponent } from \x27.\/settings\/profile\/profile.component\x27;\nimport { PasswordSettingsComponent } from \x27.\/settings\/password\/password.component\x27;\n\nexport const ROUTES: Routes = [\n  { \n    path: \x27settings\x27, \n    component: SettingsComponent,\n    children: [\n      { path: \x27profile\x27, component: ProfileSettingsComponent },\n      { path: \x27password\x27, component: PasswordSettingsComponent }\n    ]\n  }\n];\n\n@NgModule({\n  imports: [\n    BrowserModule,\n    RouterModule.forRoot(ROUTES)\n  ],\n})\nexport class AppModule {}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { SettingsComponent } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/settings\/settings.component\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { ProfileSettingsComponent } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/settings\/profile\/profile.component\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { PasswordSettingsComponent } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/settings\/password\/password.component\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e ROUTES: Routes = [\n  { \n    path: \x3cspan class=\x22hljs-string\x22\x3e\x27settings\x27\x3c\/span\x3e, \n    component: SettingsComponent,\n    children: [\n      { path: \x3cspan class=\x22hljs-string\x22\x3e\x27profile\x27\x3c\/span\x3e, component: ProfileSettingsComponent },\n      { path: \x3cspan class=\x22hljs-string\x22\x3e\x27password\x27\x3c\/span\x3e, component: PasswordSettingsComponent }\n    ]\n  }\n];\n\n\x3cspan class=\x22hljs-meta\x22\x3e@NgModule\x3c\/span\x3e({\n  imports: [\n    BrowserModule,\n    RouterModule.forRoot(ROUTES)\n  ],\n})\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e AppModule {}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在这里，我们在 \x3ccode\x3esetttings\x3c\/code\x3e 路由中定义了两个子路由，它们将继承父路由的路径，因此修改密码页面的路由匹配地址是 \x3ccode\x3e\/settings\/password\x3c\/code\x3e ，依此类推。\x3c\/p\x3e\n\x3cp\x3e接下来，我们需要做的最后一件事是在我们的 \x3ccode\x3eSettingsComponent\x3c\/code\x3e 组件中添加 \x3ccode\x3erouter-outlet\x3c\/code\x3e 指令，因为我们要在设置页面中呈现子路由。如果我们没有在 \x3ccode\x3eSettingsComponent\x3c\/code\x3e 组件中添加 \x3ccode\x3erouter-outlet\x3c\/code\x3e 指令，尽管 \x3ccode\x3e\/settings\/password\x3c\/code\x3e 匹配修改密码页面的路由地址，但修改密码页面将无法正常显示。具体代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import { Component } from \x27@angular\/core\x27;\n\n@Component({\n  selector: \x27settings-page\x27,\n  template: `\n    \x3cdiv class=\x26quot;settings\x26quot;\x3e\n      \x3csettings-header\x3e\x3c\/settings-header\x3e\n      \x3csettings-sidebar\x3e\x3c\/settings-sidebar\x3e\n      \x3crouter-outlet\x3e\x3c\/router-outlet\x3e\n    \x3c\/div\x3e\n  `\n})\nexport class SettingsComponent {}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { Component } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27@angular\/core\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-meta\x22\x3e@Component\x3c\/span\x3e({\n  selector: \x3cspan class=\x22hljs-string\x22\x3e\x27settings-page\x27\x3c\/span\x3e,\n  template: \x3cspan class=\x22hljs-string\x22\x3e`\n    \x26lt;div class=\x22settings\x22\x26gt;\n      \x26lt;settings-header\x26gt;\x26lt;\/settings-header\x26gt;\n      \x26lt;settings-sidebar\x26gt;\x26lt;\/settings-sidebar\x26gt;\n      \x26lt;router-outlet\x26gt;\x26lt;\/router-outlet\x26gt;\n    \x26lt;\/div\x26gt;\n  `\x3c\/span\x3e\n})\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e SettingsComponent {}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader11\x22\x3eComponent-less routes\x3c\/h3\x3e\n\x3cp\x3e另一个很有用的路由功能是 \x3ccode\x3ecomponent-less\x3c\/code\x3e 路由。使用 \x3ccode\x3ecomponent-less\x3c\/code\x3e 路由允许我们将路由组合在一起，并让它们共享路由配置信息和 outlet。\x3c\/p\x3e\n\x3cp\x3e例如，我们可以定义 \x3ccode\x3esetttings\x3c\/code\x3e 路由而不需要使用 \x3ccode\x3eSettingsComponent\x3c\/code\x3e 组件：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import { ProfileSettingsComponent } from \x27.\/settings\/profile\/profile.component\x27;\nimport { PasswordSettingsComponent } from \x27.\/settings\/password\/password.component\x27;\n\nexport const ROUTES: Routes = [\n  {\n    path: \x27settings\x27,\n    children: [\n      { path: \x27profile\x27, component: ProfileSettingsComponent },\n      { path: \x27password\x27, component: PasswordSettingsComponent }\n    ]\n  }\n];\n\n@NgModule({\n  imports: [\n    BrowserModule,\n    RouterModule.forRoot(ROUTES)\n  ],\n})\nexport class AppModule {}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { ProfileSettingsComponent } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/settings\/profile\/profile.component\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { PasswordSettingsComponent } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/settings\/password\/password.component\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e ROUTES: Routes = [\n  {\n    path: \x3cspan class=\x22hljs-string\x22\x3e\x27settings\x27\x3c\/span\x3e,\n    children: [\n      { path: \x3cspan class=\x22hljs-string\x22\x3e\x27profile\x27\x3c\/span\x3e, component: ProfileSettingsComponent },\n      { path: \x3cspan class=\x22hljs-string\x22\x3e\x27password\x27\x3c\/span\x3e, component: PasswordSettingsComponent }\n    ]\n  }\n];\n\n\x3cspan class=\x22hljs-meta\x22\x3e@NgModule\x3c\/span\x3e({\n  imports: [\n    BrowserModule,\n    RouterModule.forRoot(ROUTES)\n  ],\n})\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e AppModule {}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e此时， \x3ccode\x3e\/settings\/profile\x3c\/code\x3e 和 \x3ccode\x3e\/settings\/password\x3c\/code\x3e 路由定义的内容，将显示在 \x3ccode\x3eAppComponent\x3c\/code\x3e 组件的 \x3ccode\x3erouter-outlet\x3c\/code\x3e 元素中。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader12\x22\x3eloadChildren\x3c\/h3\x3e\n\x3cp\x3e我们也可以告诉路由从另一个模块中获取子路由。这将我们谈论的两个想法联系在一起 - 我们可以指定另一个模块中定义的子路由，以及通过将这些子路由设置到特定的路径下，来充分利用 \x3ccode\x3ecomponent-less\x3c\/code\x3e 路由的功能。 \x3c\/p\x3e\n\x3cp\x3e让我们创建一个 \x3ccode\x3e    SettingsModule\x3c\/code\x3e 模块，用来保存所有 \x3ccode\x3esetttings\x3c\/code\x3e 相关的路由信息：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import { NgModule } from \x27@angular\/core\x27;\nimport { CommonModule } from \x27@angular\/common\x27;\nimport { Routes, RouterModule } from \x27@angular\/router\x27;\n\nexport const ROUTES: Routes = [\n  {\n    path: \x27\x27,\n    component: SettingsComponent,\n    children: [\n      { path: \x27profile\x27, component: ProfileSettingsComponent },\n      { path: \x27password\x27, component: PasswordSettingsComponent }\n    ]\n  }\n];\n\n@NgModule({\n  imports: [\n    CommonModule,\n    RouterModule.forChild(ROUTES)\n  ],\n})\nexport class SettingsModule {}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { NgModule } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27@angular\/core\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { CommonModule } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27@angular\/common\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { Routes, RouterModule } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27@angular\/router\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e ROUTES: Routes = [\n  {\n    path: \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e,\n    component: SettingsComponent,\n    children: [\n      { path: \x3cspan class=\x22hljs-string\x22\x3e\x27profile\x27\x3c\/span\x3e, component: ProfileSettingsComponent },\n      { path: \x3cspan class=\x22hljs-string\x22\x3e\x27password\x27\x3c\/span\x3e, component: PasswordSettingsComponent }\n    ]\n  }\n];\n\n\x3cspan class=\x22hljs-meta\x22\x3e@NgModule\x3c\/span\x3e({\n  imports: [\n    CommonModule,\n    RouterModule.forChild(ROUTES)\n  ],\n})\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e SettingsModule {}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e需要注意的是，在 \x3ccode\x3eSettingsModule\x3c\/code\x3e 模块中我们使用 \x3ccode\x3eforChild()\x3c\/code\x3e 方法，因为 \x3ccode\x3eSettingsModule\x3c\/code\x3e 不是我们应用的主模块。    \x3c\/p\x3e\n\x3cp\x3e另一个主要的区别是我们将 \x3ccode\x3eSettingsModule\x3c\/code\x3e 模块的主路径设置为空路径 (\x27\x27)。因为如果我们路径设置为 \x3ccode\x3e\/settings\x3c\/code\x3e ，它将匹配 \x3ccode\x3e\/settings\/settings\x3c\/code\x3e ，很明显这不是我们想要的结果。通过指定一个空的路径，它就会匹配 \x3ccode\x3e\/settings\x3c\/code\x3e 路径，这就是我们想要的结果。\x3c\/p\x3e\n\x3cp\x3e那么 \x3ccode\x3e\/settings\x3c\/code\x3e 路由信息，需要在哪里配置？答案是在 \x3ccode\x3eAppModule\x3c\/code\x3e 中。这时我们就需要用到 \x3ccode\x3eloadChildren\x3c\/code\x3e 属性，具体如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export const ROUTES: Routes = [\n  {\n    path: \x27settings\x27,\n    loadChildren: \x27.\/settings\/settings.module#SettingsModule\x27\n  }\n];\n\n@NgModule({\n  imports: [\n    BrowserModule,\n    RouterModule.forRoot(ROUTES)\n  ],\n  \/\/ ...\n})\nexport class AppModule {}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e ROUTES: Routes = [\n  {\n    path: \x3cspan class=\x22hljs-string\x22\x3e\x27settings\x27\x3c\/span\x3e,\n    loadChildren: \x3cspan class=\x22hljs-string\x22\x3e\x27.\/settings\/settings.module#SettingsModule\x27\x3c\/span\x3e\n  }\n];\n\n\x3cspan class=\x22hljs-meta\x22\x3e@NgModule\x3c\/span\x3e({\n  imports: [\n    BrowserModule,\n    RouterModule.forRoot(ROUTES)\n  ],\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n})\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e AppModule {}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e需要注意的是，我们没有将 \x3ccode\x3eSettingsModule\x3c\/code\x3e 导入到我们的 \x3ccode\x3eAppModule\x3c\/code\x3e 中，而是通过 \x3ccode\x3eloadChildren\x3c\/code\x3e 属性，告诉 Angular 路由依据 \x3ccode\x3eloadChildren\x3c\/code\x3e 属性配置的路径去加载 \x3ccode\x3eSettingsModule\x3c\/code\x3e 模块。这就是模块懒加载功能的具体应用，当用户访问 \x3ccode\x3e\/settings\/**\x3c\/code\x3e 路径的时候，才会加载对应的 \x3ccode\x3eSettingsModule\x3c\/code\x3e 模块，这减少了应用启动时加载资源的大小。\x3c\/p\x3e\n\x3cp\x3e另外我们传递一个字符串作为 \x3ccode\x3eloadChildren\x3c\/code\x3e 的属性值，该字符串由三部分组成：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e需要导入模块的相对路径\x3c\/li\x3e\n\x3cli\x3e\n\x3ccode\x3e#\x3c\/code\x3e 分隔符\x3c\/li\x3e\n\x3cli\x3e导出模块类的名称\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e了解完路由的一些高级选项和功能，接下来我们来介绍路由指令。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader13\x22\x3eRouter Directives\x3c\/h2\x3e\n\x3cp\x3e除了 \x3ccode\x3erouter-outlet\x3c\/code\x3e 指令，路由模块中还提供了一些其它指令。让我们来看看它们如何与我们之前介绍的内容结合使用。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader14\x22\x3erouterLink\x3c\/h3\x3e\n\x3cp\x3e为了让我们链接到已设置的路由，我们需要使用 \x3ccode\x3erouterLink\x3c\/code\x3e 指令，具体示例如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cnav\x3e\n  \x3ca routerLink=\x26quot;\/\x26quot;\x3eHome\x3c\/a\x3e\n  \x3ca routerLink=\x26quot;\/settings\/password\x26quot;\x3eChange password\x3c\/a\x3e\n  \x3ca routerLink=\x26quot;\/settings\/profile\x26quot;\x3eProfile Settings\x3c\/a\x3e\n\x3c\/nav\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22xml hljs\x22\x3e\x3ccode class=\x22html\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3enav\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ea\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3erouterLink\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22\/\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3eHome\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ea\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ea\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3erouterLink\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22\/settings\/password\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3eChange password\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ea\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ea\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3erouterLink\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22\/settings\/profile\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3eProfile Settings\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ea\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3enav\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当我们点击以上的任意链接时，页面不会被重新加载。反之，我们的路径将在 URL 地址栏中显示，随后进行后续视图更新，以匹配 \x3ccode\x3erouterLink\x3c\/code\x3e 中设置的值。\x3c\/p\x3e\n\x3cblockquote\x3e友情提示：我们也可以将 \x3ccode\x3erouterLink\x3c\/code\x3e 的属性值，改成数组形式，以便我们传递特定的路由信息\x3c\/blockquote\x3e\n\x3cp\x3e如果我们想要链接到动态的路由地址，且该地址有一个 \x3ccode\x3eusername\x3c\/code\x3e 的路由变量，则我们可以按照以下方式配置 \x3ccode\x3erouterLink\x3c\/code\x3e 对应的属性值：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3ca [routerLink]=\x26quot;[\x27\/profile\x27, username]\x26quot;\x3e\n  Go to \x22{{\x22 username \x22}}\x22\x27s profile.\n\x3c\/a\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22xml hljs\x22\x3e\x3ccode class=\x22html\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ea\x3c\/span\x3e [\x3cspan class=\x22hljs-attr\x22\x3erouterLink\x3c\/span\x3e]=\x3cspan class=\x22hljs-string\x22\x3e\x22[\x27\/profile\x27, username]\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  Go to \x22{{\x22 username \x22}}\x22\x27s profile.\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ea\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader15\x22\x3erouterLinkActive\x3c\/h3\x3e\n\x3cp\x3e在实际开发中，我们需要让用户知道哪个路由处于激活状态，通常情况下我们通过向激活的链接添加一个 class 来实现该功能。为了解决上述问题，Angular 路由模块为我们提供了 \x3ccode\x3erouterLinkActive\x3c\/code\x3e 指令，该指令的使用示例如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cnav\x3e\n  \x3ca routerLink=\x26quot;\/settings\x26quot; routerLinkActive=\x26quot;active\x26quot;\x3eHome\x3c\/a\x3e\n  \x3ca routerLink=\x26quot;\/settings\/password\x26quot; routerLinkActive=\x26quot;active\x26quot;\x3eChange password\x3c\/a\x3e\n  \x3ca routerLink=\x26quot;\/settings\/profile\x26quot; routerLinkActive=\x26quot;active\x26quot;\x3eProfile Settings\x3c\/a\x3e\n\x3c\/nav\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x26lt;nav\x26gt;\n  \x26lt;a routerLink=\x3cspan class=\x22hljs-string\x22\x3e\x22\/settings\x22\x3c\/span\x3e routerLinkActive=\x3cspan class=\x22hljs-string\x22\x3e\x22active\x22\x3c\/span\x3e\x26gt;Home\x26lt;\x3cspan class=\x22hljs-regexp\x22\x3e\/a\x26gt;\n  \x26lt;a routerLink=\x22\/\x3c\/span\x3esettings\/password\x3cspan class=\x22hljs-string\x22\x3e\x22 routerLinkActive=\x22\x3c\/span\x3eactive\x3cspan class=\x22hljs-string\x22\x3e\x22\x26gt;Change password\x26lt;\/a\x26gt;\n  \x26lt;a routerLink=\x22\x3c\/span\x3e\/settings\/profile\x3cspan class=\x22hljs-string\x22\x3e\x22 routerLinkActive=\x22\x3c\/span\x3eactive\x3cspan class=\x22hljs-string\x22\x3e\x22\x26gt;Profile Settings\x26lt;\/a\x26gt;\n\x26lt;\/nav\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e通过使用 \x3ccode\x3erouterLinkActive\x3c\/code\x3e 指令，当 \x3ccode\x3ea\x3c\/code\x3e 元素对应的路由处于激活状态时，\x3ccode\x3eactive\x3c\/code\x3e 类将会自动添加到 \x3ccode\x3ea\x3c\/code\x3e 元素上。\x3c\/p\x3e\n\x3cp\x3e最后，我们来简单介绍一下 Router API。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader16\x22\x3eRouter API\x3c\/h2\x3e\n\x3cp\x3e我们可以通过路由还提供的 API 实现与 \x3ccode\x3erouterLink\x3c\/code\x3e 相同的功能。要使用 Router API，我们需要在组件类中注入 \x3ccode\x3eRouter\x3c\/code\x3e 对象，具体如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import { Component } from \x27@angular\/core\x27;\nimport { Router } from \x27@angular\/router\x27;\n\n@Component({\n  selector: \x27app-root\x27,\n  template: `\n    \x3cdiv class=\x26quot;app\x26quot;\x3e\n      \x3ch3\x3eOur app\x3c\/h3\x3e\n      \x3crouter-outlet\x3e\x3c\/router-outlet\x3e\n    \x3c\/div\x3e\n  `\n})\nexport class AppComponent {\n  constructor(private router: Router) {}\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { Component } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27@angular\/core\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { Router } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27@angular\/router\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-meta\x22\x3e@Component\x3c\/span\x3e({\n  selector: \x3cspan class=\x22hljs-string\x22\x3e\x27app-root\x27\x3c\/span\x3e,\n  template: \x3cspan class=\x22hljs-string\x22\x3e`\n    \x26lt;div class=\x22app\x22\x26gt;\n      \x26lt;h3\x26gt;Our app\x26lt;\/h3\x26gt;\n      \x26lt;router-outlet\x26gt;\x26lt;\/router-outlet\x26gt;\n    \x26lt;\/div\x26gt;\n  `\x3c\/span\x3e\n})\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e AppComponent {\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eprivate\x3c\/span\x3e router: Router\x3c\/span\x3e) {}\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e组件类中注入的 \x3ccode\x3erouter\x3c\/code\x3e 对象中有一个 \x3ccode\x3enavigate()\x3c\/code\x3e 方法，该方法支持的参数类型与 \x3ccode\x3erouterLink\x3c\/code\x3e 指令一样，当调用该方法后，页面将会自动跳转到对应的路由地址。具体使用示例如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import { Component, OnInit } from \x27@angular\/core\x27;\nimport { Router } from \x27@angular\/router\x27;\n\n@Component({\n  selector: \x27app-root\x27,\n  template: `\n    \x3cdiv class=\x26quot;app\x26quot;\x3e\n      \x3ch3\x3eOur app\x3c\/h3\x3e\n      \x3crouter-outlet\x3e\x3c\/router-outlet\x3e\n    \x3c\/div\x3e\n  `\n})\nexport class AppComponent implements OnInit {\n  constructor(private router: Router) {}\n  ngOnInit() {\n    setTimeout(() =\x3e {\n      this.router.navigate([\x27\/settings\x27]);\n    }, 5000);\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { Component, OnInit } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27@angular\/core\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { Router } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27@angular\/router\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-meta\x22\x3e@Component\x3c\/span\x3e({\n  selector: \x3cspan class=\x22hljs-string\x22\x3e\x27app-root\x27\x3c\/span\x3e,\n  template: \x3cspan class=\x22hljs-string\x22\x3e`\n    \x26lt;div class=\x22app\x22\x26gt;\n      \x26lt;h3\x26gt;Our app\x26lt;\/h3\x26gt;\n      \x26lt;router-outlet\x26gt;\x26lt;\/router-outlet\x26gt;\n    \x26lt;\/div\x26gt;\n  `\x3c\/span\x3e\n})\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e AppComponent \x3cspan class=\x22hljs-keyword\x22\x3eimplements\x3c\/span\x3e OnInit {\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eprivate\x3c\/span\x3e router: Router\x3c\/span\x3e) {}\n  ngOnInit() {\n    setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.router.navigate([\x3cspan class=\x22hljs-string\x22\x3e\x27\/settings\x27\x3c\/span\x3e]);\n    }, \x3cspan class=\x22hljs-number\x22\x3e5000\x3c\/span\x3e);\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e若以上代码成功运行，用户界面将在 5 秒后被重定向到 \x3ccode\x3e\/settings\x3c\/code\x3e 页面。这个方法非常有用，例如当检测到用户尚未登录时，自动重定向到登录页面。\x3c\/p\x3e\n\x3cp\x3e另一个使用示例是演示页面跳转时如何传递数据，具体如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import { Component, OnInit } from \x27@angular\/core\x27;\nimport { Router } from \x27@angular\/router\x27;\n\n@Component({\n  selector: \x27app-root\x27,\n  template: `\n    \x3cdiv class=\x26quot;app\x26quot;\x3e\n      \x3ch3\x3eUsers\x3c\/h3\x3e\n      \x3cdiv *ngFor=\x26quot;let user of users\x26quot;\x3e\n        \x3cuser-component \n          [user]=\x26quot;user\x26quot;\n          (select)=\x26quot;handleSelect($event)\x26quot;\x3e\n        \x3c\/user-component\x3e\n      \x3c\/div\x3e\n      \x3crouter-outlet\x3e\x3c\/router-outlet\x3e\n    \x3c\/div\x3e\n  `\n})\nexport class AppComponent implements OnInit {\n  users: Username[] = [\n    { name: \x27toddmotto\x27, id: 0 },\n    { name: \x27travisbarker\x27, id: 1 },\n    { name: \x27tomdelonge\x27, id: 2 }\n  ];\n  \n  constructor(private router: Router) {}\n  \n  handleSelect(event) {\n    this.router.navigate([\x27\/profile\x27, event.name]);\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { Component, OnInit } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27@angular\/core\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { Router } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27@angular\/router\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-meta\x22\x3e@Component\x3c\/span\x3e({\n  selector: \x3cspan class=\x22hljs-string\x22\x3e\x27app-root\x27\x3c\/span\x3e,\n  template: \x3cspan class=\x22hljs-string\x22\x3e`\n    \x26lt;div class=\x22app\x22\x26gt;\n      \x26lt;h3\x26gt;Users\x26lt;\/h3\x26gt;\n      \x26lt;div *ngFor=\x22let user of users\x22\x26gt;\n        \x26lt;user-component \n          [user]=\x22user\x22\n          (select)=\x22handleSelect($event)\x22\x26gt;\n        \x26lt;\/user-component\x26gt;\n      \x26lt;\/div\x26gt;\n      \x26lt;router-outlet\x26gt;\x26lt;\/router-outlet\x26gt;\n    \x26lt;\/div\x26gt;\n  `\x3c\/span\x3e\n})\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e AppComponent \x3cspan class=\x22hljs-keyword\x22\x3eimplements\x3c\/span\x3e OnInit {\n  users: Username[] = [\n    { name: \x3cspan class=\x22hljs-string\x22\x3e\x27toddmotto\x27\x3c\/span\x3e, id: \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e },\n    { name: \x3cspan class=\x22hljs-string\x22\x3e\x27travisbarker\x27\x3c\/span\x3e, id: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e },\n    { name: \x3cspan class=\x22hljs-string\x22\x3e\x27tomdelonge\x27\x3c\/span\x3e, id: \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e }\n  ];\n  \n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eprivate\x3c\/span\x3e router: Router\x3c\/span\x3e) {}\n  \n  handleSelect(event) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.router.navigate([\x3cspan class=\x22hljs-string\x22\x3e\x27\/profile\x27\x3c\/span\x3e, event.name]);\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eAngular 路由的功能非常强大，既可以使用指令方式也可以使用命令式 API，希望本文可以帮助你尽快入门，若要进一步了解路由详细信息，请访问 - \x3ca href=\x22https:\/\/angular.io\/docs\/ts\/latest\/guide\/router.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eAngular Router 官文文档\x3c\/a\x3e。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader17\x22\x3e我有话说\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader18\x22\x3e除了使用 \x3ccode\x3enavigate()\x3c\/code\x3e 方法外还有没有其它方法可以实现页面导航？\x3c\/h3\x3e\n\x3cp\x3eAngular Router API 为我们提供了 \x3ccode\x3enavigate()\x3c\/code\x3e 和 \x3ccode\x3enavigateByUrl()\x3c\/code\x3e 方法来实现页面导航。那为什么会有两个不同的方法呢？\x3c\/p\x3e\n\x3cp\x3e使用 \x3ccode\x3erouter.navigateByUrl()\x3c\/code\x3e 方法与直接改变地址栏上的 URL 地址一样，我们使用了一个新的 URL 地址。然而 \x3ccode\x3erouter.navigate()\x3c\/code\x3e 方法基于一系列输入参数，产生一个新的 URL 地址。为了更好的区分它们之间的差异，我们来看个例子，假设当前的 URL 地址是：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/inbox\/11\/message\/22(popup:compose)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs groovy\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-regexp\x22\x3e\/inbox\/\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e11\x3c\/span\x3e\x3cspan class=\x22hljs-regexp\x22\x3e\/message\/\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e22\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3epopup:\x3c\/span\x3ecompose)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当我们调用 \x3ccode\x3erouter.navigateByUrl(\x27\/inbox\/33\/message\/44\x27)\x3c\/code\x3e  方法后，此时的 URL 地址将变成 \x3ccode\x3e\/inbox\/33\/message\/44\x3c\/code\x3e 。但如果我们是调用 \x3ccode\x3erouter.navigate(\x27\/inbox\/33\/message\/44\x27)\x3c\/code\x3e 方法，当前的 URL 地址将变成 \x3ccode\x3e\/inbox\/33\/message\/44(popup:compose)\x3c\/code\x3e 。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader19\x22\x3e参考资源\x3c\/h2\x3e\n\x3cul\x3e\x3cli\x3e\x3ca href=\x22https:\/\/toddmotto.com\/angular-component-router\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eToddd - Getting started with Angular\x27s Router\x3c\/a\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>Angular 4.x 路由快速入门</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000009265310">https://segmentfault.com/a/1190000009265310</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/hpnk8c00qxc/" target="_blank">https://alili.tech/archive/hpnk8c00qxc/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>