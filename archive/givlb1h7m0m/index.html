<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="vue源码解读－component机制"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>vue源码解读－component机制 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/givlb1h7m0m/",
				"appid": "1613049289050283", 
				"title": "vue源码解读－component机制 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-12T02:30:25"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/i010qmbp6i/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/9y1nxcikk24/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fgivlb1h7m0m%2f&text=vue%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb%ef%bc%8dcomponent%e6%9c%ba%e5%88%b6"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fgivlb1h7m0m%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fgivlb1h7m0m%2f&text=vue%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb%ef%bc%8dcomponent%e6%9c%ba%e5%88%b6"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fgivlb1h7m0m%2f&title=vue%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb%ef%bc%8dcomponent%e6%9c%ba%e5%88%b6"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fgivlb1h7m0m%2f&is_video=false&description=vue%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb%ef%bc%8dcomponent%e6%9c%ba%e5%88%b6"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=vue%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb%ef%bc%8dcomponent%e6%9c%ba%e5%88%b6&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fgivlb1h7m0m%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fgivlb1h7m0m%2f&title=vue%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb%ef%bc%8dcomponent%e6%9c%ba%e5%88%b6"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fgivlb1h7m0m%2f&title=vue%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb%ef%bc%8dcomponent%e6%9c%ba%e5%88%b6"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fgivlb1h7m0m%2f&title=vue%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb%ef%bc%8dcomponent%e6%9c%ba%e5%88%b6"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fgivlb1h7m0m%2f&title=vue%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb%ef%bc%8dcomponent%e6%9c%ba%e5%88%b6"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">vue源码解读－component机制</h1><div class="meta"><div class="postdate"><time datetime="2019-01-12" itemprop="datePublished">2019-01-12</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e身为原来的jquery，angular使用者。后面接触了react和vue。渐渐的喜欢上了vue。抱着学习的态度呀。看看源码。果然菜要付出代价。一步步单步调试。头好疼。看到哪里记到哪里。来一点点心得。错误的地方请帮我指出来。谢谢。最近看的是vue component部分。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22先上一段最简单的代码，来剖析component机制：\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs vhdl\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e先上一段最简单的代码，来剖析\x3cspan class=\x22hljs-keyword\x22\x3ecomponent\x3c\/span\x3e机制：\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cdiv id=\x26quot;app\x26quot;\x3e\n  \x3cdiv\x3e\x22{{\x22a\x22}}\x22\x3c\/div\x3e\n  \x3cinput v-model=\x26quot;heihei\x26quot;\x3e\n  \x3cbutton v-on:click=\x26quot;click1\x26quot;\x3e\n  click1\n  \x3c\/button\x3e\n  \x3cmy-component\x3e\n  \x3cdiv slot=\x27dudu\x27\x3e111\x3c\/div\x3e\n  \x3cChild\x3e\x22{{\x22a\x22}}\x22\x3c\/Child\x3e\n  \x3c\/my-component\x3e\n  \x3cbutton @click.stop=\x26quot;click2\x26quot;\x3e\n  click2\n  \x3c\/button\x3e\n\x3c\/div\x3e\n\x3c\/body\x3e\n\x3cscript src=\x26quot;vue.js\x26quot;\x3e\x3c\/script\x3e\n\x3cscript type=\x26quot;text\/javascript\x26quot;\x3e\nvar Child = {\n  template: \x27\x3cdiv\x3eA custom component!\x3c\/div\x3e\x27\n} \nVue.component(\x27my-component\x27, {\n  name: \x27my-component\x27,\n  template: \x27\x3cdiv\x3eA custom component!\x3cChild\x3e\x3c\/Child\x3e\x3cslot\x3e\x3c\/slot\x3e\x3c\/div\x3e\x27,\n  components: {\n    Child:Child\n  },\n  created(){\n    console.log(this);\n  },\n  mounted(){\n    console.log(this);\n  }\n})\n    new Vue({\n  el: \x27#app\x27,\n  data: function () {\n    return {\n      heihei:{name:3333},\n      a:1\n    }\n  },\n  components: {\n    Child:Child\n  },\n  created(){\n  \n  },\n  methods: {\n    click1: function(){\n      console.log(this);\n    },\n    click2: function(){\n      alert(\x27click2\x27)\n    }\n  }\n})\n\x3c\/script\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs django\x22\x3e\x3ccode\x3e\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eid\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22app\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\x3cspan class=\x22hljs-template-variable\x22\x3e\x22{{\x22a\x22}}\x22\x3c\/span\x3e\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3einput\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ev-model\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22heihei\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ev-on:click\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22click1\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  click1\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3emy-component\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eslot\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x27dudu\x27\x3c\/span\x3e\x26gt;\x3c\/span\x3e111\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eChild\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\x3cspan class=\x22hljs-template-variable\x22\x3e\x22{{\x22a\x22}}\x22\x3c\/span\x3e\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eChild\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3emy-component\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e @\x3cspan class=\x22hljs-attr\x22\x3eclick.stop\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22click2\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  click2\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ebody\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3esrc\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22vue.js\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22undefined\x22\x3e\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22text\/javascript\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22javascript\x22\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Child = {\n  \x3cspan class=\x22hljs-attr\x22\x3etemplate\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27\x26lt;div\x26gt;A custom component!\x26lt;\/div\x26gt;\x27\x3c\/span\x3e\n} \nVue.component(\x3cspan class=\x22hljs-string\x22\x3e\x27my-component\x27\x3c\/span\x3e, {\n  \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27my-component\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3etemplate\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27\x26lt;div\x26gt;A custom component!\x26lt;Child\x26gt;\x26lt;\/Child\x26gt;\x26lt;slot\x26gt;\x26lt;\/slot\x26gt;\x26lt;\/div\x26gt;\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3ecomponents\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-attr\x22\x3eChild\x3c\/span\x3e:Child\n  },\n  created(){\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n  },\n  mounted(){\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n  }\n})\n    \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Vue({\n  \x3cspan class=\x22hljs-attr\x22\x3eel\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27#app\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3edata\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-attr\x22\x3eheihei\x3c\/span\x3e:{\x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e:\x3cspan class=\x22hljs-number\x22\x3e3333\x3c\/span\x3e},\n      \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e:\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n    }\n  },\n  \x3cspan class=\x22hljs-attr\x22\x3ecomponents\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-attr\x22\x3eChild\x3c\/span\x3e:Child\n  },\n  created(){\n  \n  },\n  \x3cspan class=\x22hljs-attr\x22\x3emethods\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-attr\x22\x3eclick1\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n      \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n    },\n    \x3cspan class=\x22hljs-attr\x22\x3eclick2\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n      alert(\x3cspan class=\x22hljs-string\x22\x3e\x27click2\x27\x3c\/span\x3e)\n    }\n  }\n})\n\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们按照浏览器的思维逐行来。执行到脚本时。首先执行了\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Vue.component(\x27my-component\x27, {\n  name: \x27my-component\x27,\n  template: \x27\x3cdiv\x3eA custom component!\x3cChild\x3e\x3c\/Child\x3e\x3cslot\x3e\x3c\/slot\x3e\x3c\/div\x3e\x27,\n  components: {\n    Child:Child\n  },\n  created(){\n    console.log(this);\n  },\n  mounted(){\n    console.log(this);\n  }\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs less\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3eVue\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.component\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27my-component\x27\x3c\/span\x3e, {\n  \x3cspan class=\x22hljs-attribute\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27my-component\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attribute\x22\x3etemplate\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27\x26lt;div\x26gt;A custom component!\x26lt;Child\x26gt;\x26lt;\/Child\x26gt;\x26lt;slot\x26gt;\x26lt;\/slot\x26gt;\x26lt;\/div\x26gt;\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attribute\x22\x3ecomponents\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-attribute\x22\x3eChild\x3c\/span\x3e:Child\n  },\n  \x3cspan class=\x22hljs-selector-tag\x22\x3ecreated\x3c\/span\x3e(){\n    \x3cspan class=\x22hljs-selector-tag\x22\x3econsole\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.log\x3c\/span\x3e(this);\n  },\n  \x3cspan class=\x22hljs-selector-tag\x22\x3emounted\x3c\/span\x3e(){\n    \x3cspan class=\x22hljs-selector-tag\x22\x3econsole\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.log\x3c\/span\x3e(this);\n  }\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们来看看这个函数经历了什么：\x3cbr\x3evue.js初始化的时候。调用了initGlobalAPI(vue),为vue挂上了工具函数vue.component\x3cbr\x3e经过initGlobalAPI（vue)中的initAssetRegisters (Vue) 后。变为\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22vue.component = function (\n      id,\n      definition\n    ) {\n      if (!definition) {\n        return this.options[type \x2b \x27s\x27][id]\n      } else {\n        \/* istanbul ignore if *\/\n        {\n          if (type === \x27component\x27 \x26amp;\x26amp; config.isReservedTag(id)) {\n            warn(\n              \x27Do not use built-in or reserved HTML elements as component \x27 \x2b\n              \x27id: \x27 \x2b id\n            );\n          }\n        }\n        if (type === \x27component\x27 \x26amp;\x26amp; isPlainObject(definition)) {\n          definition.name = definition.name || id;\n          definition = this.options._base.extend(definition);\n        }\n        if (type === \x27directive\x27 \x26amp;\x26amp; typeof definition === \x27function\x27) {\n          definition = { bind: definition, update: definition };\n        }\n        this.options[type \x2b \x27s\x27][id] = definition;／／全局的组件或者指令和过滤器。统一挂在vue.options上。等待init的时候利用策略合并侵入实例。供实例使用\n        return definition\n      }\n    };\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs ada\x22\x3e\x3ccode\x3evue.component = \x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3e\x3c\/span\x3e(\n      id,\n      definition\n    ) {\n      if (!definition) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3ethis.options[type\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27s\x27\x3c\/span\x3e][id]\n      } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        \/* istanbul ignore \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e *\/\n        {\n          \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3e=== \x3c\/span\x3e\x3cspan class=\x22hljs-symbol\x22\x3e\x27component\x3c\/span\x3e\x27 \x26amp;\x26amp; config.isReservedTag(id)) {\n            warn(\n              \x3cspan class=\x22hljs-symbol\x22\x3e\x27Do\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enot\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3euse\x3c\/span\x3e built-\x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eor\x3c\/span\x3e reserved HTML elements as component \x27 \x2b\n              \x3cspan class=\x22hljs-symbol\x22\x3e\x27id\x3c\/span\x3e: \x27 \x2b id\n            );\n          }\n        }\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3e=== \x3c\/span\x3e\x3cspan class=\x22hljs-symbol\x22\x3e\x27component\x3c\/span\x3e\x27 \x26amp;\x26amp; isPlainObject(definition)) {\n          definition.name = definition.name || id;\n          definition = this.options._base.extend(definition);\n        }\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3e=== \x3c\/span\x3e\x3cspan class=\x22hljs-symbol\x22\x3e\x27directive\x3c\/span\x3e\x27 \x26amp;\x26amp; typeof definition === \x3cspan class=\x22hljs-symbol\x22\x3e\x27function\x3c\/span\x3e\x27) {\n          definition = { bind: definition, update: definition };\n        }\n        this.options[\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3e\x2b \x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e\x27s\x27\x3c\/span\x3e][id] = definition;／／全局的组件或者指令和过滤器。统一挂在vue.options上。等待init的时候利用策略合并侵入实例。供实例使用\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e definition\n      }\n    };\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3ethis.options._base在initGlobalAPI（vue)中为Vue.options._base = Vue;\x3cbr\x3eso vue.component调用了vue.extend。找到了源头。我们来好好看看这个vue.extend这个function。代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Vue.extend = function (extendOptions) {\n    extendOptions = extendOptions || {};\n    var Super = this;\n    var SuperId = Super.cid;\n    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n    if (cachedCtors[SuperId]) {\n      return cachedCtors[SuperId]／／如果组件已经被缓存在extendOptions上则直接取出\n    }\n\n    var name = extendOptions.name || Super.options.name;\n    {\n      if (!\/^[a-zA-Z][\\w-]*$\/.test(name)) {\n        warn(\n          \x27Invalid component name: \x26quot;\x27 \x2b name \x2b \x27\x26quot;. Component names \x27 \x2b\n          \x27can only contain alphanumeric characters and the hyphen, \x27 \x2b\n          \x27and must start with a letter.\x27／／校验组件名\n        );\n      }\n    }\n\n    var Sub = function VueComponent (options) {\n      this._init(options);\n    };\n    Sub.prototype = Object.create(Super.prototype);\n    Sub.prototype.constructor = Sub;／／将vue上原型的方法挂在Sub.prototype中，Sub的实例同时也继承了vue.prototype上的所有属性和方法。\n    Sub.cid = cid\x2b\x2b;\n    Sub.options = mergeOptions(\n      Super.options,\n      extendOptions／／通过vue的合并策略合并添加项到新的构造器上\n    );\n    Sub[\x27super\x27] = Super;缓存父构造器\n\n    \/\/ For props and computed properties, we define the proxy getters on\n    \/\/ the Vue instances at extension time, on the extended prototype. This\n    \/\/ avoids Object.defineProperty calls for each instance created.\n    if (Sub.options.props) {\n      initProps$1(Sub);\n    }\n    if (Sub.options.computed) {   ／／处理props和computed相关响应式配置项\n      initComputed$1(Sub);\n    }\n\n    \/\/ allow further extension\/mixin\/plugin usage\n    Sub.extend = Super.extend;\n    Sub.mixin = Super.mixin;\n    Sub.use = Super.use;\n\n    \/\/ create asset registers, so extended classes\n    \/\/ can have their private assets too.              ／／在新的构造器上挂上vue的工具方法\n    ASSET_TYPES.forEach(function (type) {\n      Sub[type] = Super[type];\n    });\n    \/\/ enable recursive self-lookup\n    if (name) {\n      Sub.options.components[name] = Sub;\n    }\n\n    \/\/ keep a reference to the super options at extension time.\n    \/\/ later at instantiation we can check if Super\x27s options have\n    \/\/ been updated.\n    Sub.superOptions = Super.options;\n    Sub.extendOptions = extendOptions;\n    Sub.sealedOptions = extend({}, Sub.options);\n\n    \/\/ cache constructor\n    cachedCtors[SuperId] = Sub;\/\/缓存组件构造器在extendOptions上\n    return Sub\n  };\n}\n\nfunction initProps$1 (Comp) {\n  var props = Comp.options.props;\n  for (var key in props) {\n    proxy(Comp.prototype, \x26quot;_props\x26quot;, key);\n  }\n}\n\nfunction initComputed$1 (Comp) {\n  var computed = Comp.options.computed;\n  for (var key in computed) {\n    defineComputed(Comp.prototype, key, computed[key]);\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3eVue.extend = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eextendOptions\x3c\/span\x3e) \x3c\/span\x3e{\n    extendOptions = extendOptions || {};\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Super = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e SuperId = Super.cid;\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (cachedCtors[SuperId]) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e cachedCtors[SuperId]／／如果组件已经被缓存在extendOptions上则直接取出\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e name = extendOptions.name || Super.options.name;\n    {\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!\x3cspan class=\x22hljs-regexp\x22\x3e\/^[a-zA-Z][\\w-]*$\/\x3c\/span\x3e.test(name)) {\n        warn(\n          \x3cspan class=\x22hljs-string\x22\x3e\x27Invalid component name: \x22\x27\x3c\/span\x3e \x2b name \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27\x22. Component names \x27\x3c\/span\x3e \x2b\n          \x3cspan class=\x22hljs-string\x22\x3e\x27can only contain alphanumeric characters and the hyphen, \x27\x3c\/span\x3e \x2b\n          \x3cspan class=\x22hljs-string\x22\x3e\x27and must start with a letter.\x27\x3c\/span\x3e／／校验组件名\n        );\n      }\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Sub = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eVueComponent\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eoptions\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._init(options);\n    };\n    Sub.prototype = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.create(Super.prototype);\n    Sub.prototype.constructor = Sub;／／将vue上原型的方法挂在Sub.prototype中，Sub的实例同时也继承了vue.prototype上的所有属性和方法。\n    Sub.cid = cid\x2b\x2b;\n    Sub.options = mergeOptions(\n      Super.options,\n      extendOptions／／通过vue的合并策略合并添加项到新的构造器上\n    );\n    Sub[\x3cspan class=\x22hljs-string\x22\x3e\x27super\x27\x3c\/span\x3e] = Super;缓存父构造器\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ For props and computed properties, we define the proxy getters on\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ the Vue instances at extension time, on the extended prototype. This\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ avoids Object.defineProperty calls for each instance created.\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (Sub.options.props) {\n      initProps$\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e(Sub);\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (Sub.options.computed) {   ／／处理props和computed相关响应式配置项\n      initComputed$\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e(Sub);\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ allow further extension\/mixin\/plugin usage\x3c\/span\x3e\n    Sub.extend = Super.extend;\n    Sub.mixin = Super.mixin;\n    Sub.use = Super.use;\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ create asset registers, so extended classes\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ can have their private assets too.              ／／在新的构造器上挂上vue的工具方法\x3c\/span\x3e\n    ASSET_TYPES.forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3etype\x3c\/span\x3e) \x3c\/span\x3e{\n      Sub[type] = Super[type];\n    });\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ enable recursive self-lookup\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (name) {\n      Sub.options.components[name] = Sub;\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ keep a reference to the super options at extension time.\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ later at instantiation we can check if Super\x27s options have\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ been updated.\x3c\/span\x3e\n    Sub.superOptions = Super.options;\n    Sub.extendOptions = extendOptions;\n    Sub.sealedOptions = extend({}, Sub.options);\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ cache constructor\x3c\/span\x3e\n    cachedCtors[SuperId] = Sub;\x3cspan class=\x22hljs-comment\x22\x3e\/\/缓存组件构造器在extendOptions上\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e Sub\n  };\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3einitProps$1\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eComp\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e props = Comp.options.props;\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e key \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e props) {\n    proxy(Comp.prototype, \x3cspan class=\x22hljs-string\x22\x3e\x22_props\x22\x3c\/span\x3e, key);\n  }\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3einitComputed$1\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eComp\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e computed = Comp.options.computed;\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e key \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e computed) {\n    defineComputed(Comp.prototype, key, computed[key]);\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e总的来说vue.extend是返回了一个带有附加配置相的新的vue的构造器。在函数中，构造器叫做Sub，等待render时候初始化。\x3cbr\x3e经过vue.component的调用。vue增加了一个全局组件my-component;此时vue.options.component如下图：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVOUw4?w=732\x26amp;h=228\x22 src=\x22https:\/\/static.alili.tech\/img\/bVOUw4?w=732\x26amp;h=228\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e前三个是vue内置的三个组件，在initgloabalapi的时候初始化。\x3cbr\x3e至此全局组件创建完成。全局组件放置在最底层。在以后的策略合并里会在子组件中的component项的__proto__中。\x3c\/p\x3e\n\x3chr\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e通过组件的递归创建渲染来看vue整体的生命周期（理解vue如何巧妙构建应用）\x3c\/h2\x3e\n\x3cp\x3e上图：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVOWLQ?w=311\x26amp;h=274\x22 src=\x22https:\/\/static.alili.tech\/img\/bVOWLQ?w=311\x26amp;h=274\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3evue官方的生命周期图，其实也就是vue组件的构成的生命周期。沿着new Vue()我们来大概看看这些生命周期在什么阶段\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Vue.prototype._init = function (options) {\n    var vm = this;\n    \/\/ a uid\n    vm._uid = uid$1\x2b\x2b;\n\n    var startTag, endTag;\n    \/* istanbul ignore if *\/\n    if (\x26quot;development\x26quot; !== \x27production\x27 \x26amp;\x26amp; config.performance \x26amp;\x26amp; mark) {\n      startTag = \x26quot;vue-perf-init:\x26quot; \x2b (vm._uid);\n      endTag = \x26quot;vue-perf-end:\x26quot; \x2b (vm._uid);\n      mark(startTag);\n    }\n\n    \/\/ a flag to avoid this being observed\n    vm._isVue = true;\n    \/\/ merge options\n    if (options \x26amp;\x26amp; options._isComponent) {\n      \/\/ optimize internal component instantiation\n      \/\/ since dynamic options merging is pretty slow, and none of the\n      \/\/ internal component options needs special treatment.\n      initInternalComponent(vm, options);\/\/内部组件调用此快捷方法\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\/\/策略合并，每项属性都有对应的合并规则\n        options || {},\n        vm\n      );\n    }\n    \/* istanbul ignore else *\/\n    {\n      initProxy(vm);／／属性代理，即vm.xx = vm.data.xx\n    }\n    \/\/ expose real self\n    vm._self = vm;\n    initLifecycle(vm);\/\/初始化生命周期状态变量，建立子父关系初始值，如$children，$parent.\n    initEvents(vm);\/\/\x26nbsp;初始化事件\n    initRender(vm);\/\/初始化render核心函数_$createElement和$slots $scopedSlots等\n    callHook(vm, \x27beforeCreate\x27);\n    initInjections(vm); \/\/ resolve injections before data\/props\n    initState(vm);\/\/利用数据劫持做响应式\n    initProvide(vm); \/\/resolve provide after data\/props\n    callHook(vm, \x27created\x27);\n\n    \/* istanbul ignore if *\/\n    if (\x26quot;development\x26quot; !== \x27production\x27 \x26amp;\x26amp; config.performance \x26amp;\x26amp; mark) {\n      vm._name = formatComponentName(vm, false);\n      mark(endTag);\n      measure(((vm._name) \x2b \x26quot; init\x26quot;), startTag, endTag);\n    }\n\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el);\/\/如果有el配置相则主动挂载。触发之后的compile.render\n    }\n  };\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs gradle\x22\x3e\x3ccode\x3eVue.prototype._init = function (\x3cspan class=\x22hljs-keyword\x22\x3eoptions\x3c\/span\x3e) {\n    var vm = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ a uid\x3c\/span\x3e\n    vm._uid = uid$\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\x2b\x2b;\n\n    var startTag, endTag;\n    \x3cspan class=\x22hljs-comment\x22\x3e\/* istanbul ignore if *\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-string\x22\x3e\x22development\x22\x3c\/span\x3e !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e \x26amp;\x26amp; config.performance \x26amp;\x26amp; mark) {\n      startTag = \x3cspan class=\x22hljs-string\x22\x3e\x22vue-perf-init:\x22\x3c\/span\x3e \x2b (vm._uid);\n      endTag = \x3cspan class=\x22hljs-string\x22\x3e\x22vue-perf-end:\x22\x3c\/span\x3e \x2b (vm._uid);\n      mark(startTag);\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ a flag to avoid this being observed\x3c\/span\x3e\n    vm._isVue = \x3cspan class=\x22hljs-keyword\x22\x3etrue\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ merge options\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3eoptions\x3c\/span\x3e \x26amp;\x26amp; \x3cspan class=\x22hljs-keyword\x22\x3eoptions\x3c\/span\x3e._isComponent) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ optimize internal component instantiation\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ since dynamic options merging is pretty slow, and none of the\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ internal component options needs special treatment.\x3c\/span\x3e\n      initInternalComponent(vm, \x3cspan class=\x22hljs-keyword\x22\x3eoptions\x3c\/span\x3e);\x3cspan class=\x22hljs-comment\x22\x3e\/\/内部组件调用此快捷方法\x3c\/span\x3e\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      vm.$\x3cspan class=\x22hljs-keyword\x22\x3eoptions\x3c\/span\x3e = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\x3cspan class=\x22hljs-comment\x22\x3e\/\/策略合并，每项属性都有对应的合并规则\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eoptions\x3c\/span\x3e || {},\n        vm\n      );\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/* istanbul ignore else *\/\x3c\/span\x3e\n    {\n      initProxy(vm);／／属性代理，即vm.xx = vm.data.xx\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ expose real self\x3c\/span\x3e\n    vm._self = vm;\n    initLifecycle(vm);\x3cspan class=\x22hljs-comment\x22\x3e\/\/初始化生命周期状态变量，建立子父关系初始值，如$children，$parent.\x3c\/span\x3e\n    initEvents(vm);\x3cspan class=\x22hljs-comment\x22\x3e\/\/\x26nbsp;初始化事件\x3c\/span\x3e\n    initRender(vm);\x3cspan class=\x22hljs-comment\x22\x3e\/\/初始化render核心函数_$createElement和$slots $scopedSlots等\x3c\/span\x3e\n    callHook(vm, \x3cspan class=\x22hljs-string\x22\x3e\x27beforeCreate\x27\x3c\/span\x3e);\n    initInjections(vm); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ resolve injections before data\/props\x3c\/span\x3e\n    initState(vm);\x3cspan class=\x22hljs-comment\x22\x3e\/\/利用数据劫持做响应式\x3c\/span\x3e\n    initProvide(vm); \x3cspan class=\x22hljs-comment\x22\x3e\/\/resolve provide after data\/props\x3c\/span\x3e\n    callHook(vm, \x3cspan class=\x22hljs-string\x22\x3e\x27created\x27\x3c\/span\x3e);\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/* istanbul ignore if *\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-string\x22\x3e\x22development\x22\x3c\/span\x3e !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e \x26amp;\x26amp; config.performance \x26amp;\x26amp; mark) {\n      vm._name = formatComponentName(vm, \x3cspan class=\x22hljs-keyword\x22\x3efalse\x3c\/span\x3e);\n      mark(endTag);\n      measure(((vm._name) \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22 init\x22\x3c\/span\x3e), startTag, endTag);\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (vm.$\x3cspan class=\x22hljs-keyword\x22\x3eoptions\x3c\/span\x3e.el) {\n      vm.$mount(vm.$\x3cspan class=\x22hljs-keyword\x22\x3eoptions\x3c\/span\x3e.el);\x3cspan class=\x22hljs-comment\x22\x3e\/\/如果有el配置相则主动挂载。触发之后的compile.render\x3c\/span\x3e\n    }\n  };\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e介绍了大概的_init函数，我们继续往下看程序的运行。完成了vue.component()之后。开始执行new vue()，创建实例。\x3cbr\x3e对照_init函数。我们知道它分别进行了对传入参数的合并。初始化实例参数。创建响应的响应式。最后挂载：vm.$mount(vm.$options.el);\x3cbr\x3e简单说说挂载。好吧。我们还是往方法里面看，挂载的时候发生了什么：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ public mount method\nVue$3.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el \x26amp;\x26amp; inBrowser ? query(el) : undefined;\n  return mountComponent(this, el, hydrating)\n};\n\nvar mount = Vue$3.prototype.$mount\/\/缓存mount,用来触发render\nVue$3.prototype.$mount = function (\/\/核心mount用来构建render函数\n  el,\n  hydrating\n) {\n  el = el \x26amp;\x26amp; query(el);\n\n  \/* istanbul ignore if *\/\n  if (el === document.body || el === document.documentElement) {\n    \x26quot;development\x26quot; !== \x27production\x27 \x26amp;\x26amp; warn(\n      \x26quot;Do not mount Vue to \x3chtml\x3e or \x3cbody\x3e - mount to normal elements instead.\x26quot;／／检测，排除不可挂载的元素\n    );\n    return this\n  }\n\n  var options = this.$options;\n  \/\/ resolve template\/el and convert to render function\n  if (!options.render) {\n    var template = options.template;／／假如输入的是template模版时。\n    if (template) {\n      if (typeof template === \x27string\x27) {\n        if (template.charAt(0) === \x27#\x27) {\n          template = idToTemplate(template);\n          \/* istanbul ignore if *\/\n          if (\x26quot;development\x26quot; !== \x27production\x27 \x26amp;\x26amp; !template) {\n            warn(\n              (\x26quot;Template element not found or is empty: \x26quot; \x2b (options.template)),\n              this\n            );\n          }\n        }\n      } else if (template.nodeType) {\n        template = template.innerHTML;\/\/输入的是dom节点时\n      } else {\n        {\n          warn(\x27invalid template option:\x27 \x2b template, this);\n        }\n        return this\n      }\n    } else if (el) {\n      template = getOuterHTML(el);／／如果是一个id，如此次初始化挂载的id=app，会取到id=app的html\n    }\n    if (template) {\n      \/* istanbul ignore if *\/\n      if (\x26quot;development\x26quot; !== \x27production\x27 \x26amp;\x26amp; config.performance \x26amp;\x26amp; mark) {\n        mark(\x27compile\x27);\n      }\n\n      var ref = compileToFunctions(template, {\n        shouldDecodeNewlines: shouldDecodeNewlines,／／核心compile函数。用于生成render函数。这里不细说\n        delimiters: options.delimiters\n      }, this);\n      var render = ref.render;\n      var staticRenderFns = ref.staticRenderFns;\n      options.render = render;／／挂载render到实例options中。待调用\n      options.staticRenderFns = staticRenderFns;／／静态的元素区分开。提升性能，后续虚拟dom树比较时，不会比较静态节点\n\n      \/* istanbul ignore if *\/\n      if (\x26quot;development\x26quot; !== \x27production\x27 \x26amp;\x26amp; config.performance \x26amp;\x26amp; mark) {\n        mark(\x27compile end\x27);\n        measure(((this._name) \x2b \x26quot; compile\x26quot;), \x27compile\x27, \x27compile end\x27);\n      }\n    }\n  }\n  return mount.call(this, el, hydrating)／／利用缓存的mount调用准备好的render\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs arduino\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ public mount method\x3c\/span\x3e\nVue$\x3cspan class=\x22hljs-number\x22\x3e3.\x3c\/span\x3eprototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el \x26amp;\x26amp; inBrowser ? query(el) : undefined;\n  \x3cspan class=\x22hljs-built_in\x22\x3ereturn\x3c\/span\x3e mountComponent(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, el, hydrating)\n};\n\nvar mount = Vue$\x3cspan class=\x22hljs-number\x22\x3e3.\x3c\/span\x3eprototype.$mount\x3cspan class=\x22hljs-comment\x22\x3e\/\/缓存mount,用来触发render\x3c\/span\x3e\nVue$\x3cspan class=\x22hljs-number\x22\x3e3.\x3c\/span\x3eprototype.$mount = function (\x3cspan class=\x22hljs-comment\x22\x3e\/\/核心mount用来构建render函数\x3c\/span\x3e\n  el,\n  hydrating\n) {\n  el = el \x26amp;\x26amp; query(el);\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/* istanbul ignore if *\/\x3c\/span\x3e\n  \x3cspan class=\x22hljs-built_in\x22\x3eif\x3c\/span\x3e (el === document.body || el === document.documentElement) {\n    \x3cspan class=\x22hljs-string\x22\x3e\x22development\x22\x3c\/span\x3e !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e \x26amp;\x26amp; warn(\n      \x3cspan class=\x22hljs-string\x22\x3e\x22Do not mount Vue to \x26lt;html\x26gt; or \x26lt;body\x26gt; - mount to normal elements instead.\x22\x3c\/span\x3e／／检测，排除不可挂载的元素\n    );\n    \x3cspan class=\x22hljs-built_in\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e\n  }\n\n  var options = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$options;\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ resolve template\/el and convert to render function\x3c\/span\x3e\n  \x3cspan class=\x22hljs-built_in\x22\x3eif\x3c\/span\x3e (!options.render) {\n    var \x3cspan class=\x22hljs-keyword\x22\x3etemplate\x3c\/span\x3e = options.\x3cspan class=\x22hljs-keyword\x22\x3etemplate\x3c\/span\x3e;／／假如输入的是\x3cspan class=\x22hljs-keyword\x22\x3etemplate\x3c\/span\x3e模版时。\n    \x3cspan class=\x22hljs-built_in\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etemplate\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-built_in\x22\x3eif\x3c\/span\x3e (typeof \x3cspan class=\x22hljs-keyword\x22\x3etemplate\x3c\/span\x3e === \x3cspan class=\x22hljs-string\x22\x3e\x27string\x27\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-built_in\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etemplate\x3c\/span\x3e.charAt(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) === \x3cspan class=\x22hljs-string\x22\x3e\x27#\x27\x3c\/span\x3e) {\n          \x3cspan class=\x22hljs-keyword\x22\x3etemplate\x3c\/span\x3e = idToTemplate(\x3cspan class=\x22hljs-keyword\x22\x3etemplate\x3c\/span\x3e);\n          \x3cspan class=\x22hljs-comment\x22\x3e\/* istanbul ignore if *\/\x3c\/span\x3e\n          \x3cspan class=\x22hljs-built_in\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-string\x22\x3e\x22development\x22\x3c\/span\x3e !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e \x26amp;\x26amp; !\x3cspan class=\x22hljs-keyword\x22\x3etemplate\x3c\/span\x3e) {\n            warn(\n              (\x3cspan class=\x22hljs-string\x22\x3e\x22Template element not found or is empty: \x22\x3c\/span\x3e \x2b (options.\x3cspan class=\x22hljs-keyword\x22\x3etemplate\x3c\/span\x3e)),\n              \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e\n            );\n          }\n        }\n      } \x3cspan class=\x22hljs-built_in\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etemplate\x3c\/span\x3e.nodeType) {\n        \x3cspan class=\x22hljs-keyword\x22\x3etemplate\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3etemplate\x3c\/span\x3e.innerHTML;\x3cspan class=\x22hljs-comment\x22\x3e\/\/输入的是dom节点时\x3c\/span\x3e\n      } \x3cspan class=\x22hljs-built_in\x22\x3eelse\x3c\/span\x3e {\n        {\n          warn(\x3cspan class=\x22hljs-string\x22\x3e\x27invalid template option:\x27\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-keyword\x22\x3etemplate\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n        }\n        \x3cspan class=\x22hljs-built_in\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e\n      }\n    } \x3cspan class=\x22hljs-built_in\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eif\x3c\/span\x3e (el) {\n      \x3cspan class=\x22hljs-keyword\x22\x3etemplate\x3c\/span\x3e = getOuterHTML(el);／／如果是一个id，如此次初始化挂载的id=app，会取到id=app的html\n    }\n    \x3cspan class=\x22hljs-built_in\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etemplate\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/* istanbul ignore if *\/\x3c\/span\x3e\n      \x3cspan class=\x22hljs-built_in\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-string\x22\x3e\x22development\x22\x3c\/span\x3e !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e \x26amp;\x26amp; \x3cspan class=\x22hljs-built_in\x22\x3econfig\x3c\/span\x3e.performance \x26amp;\x26amp; mark) {\n        mark(\x3cspan class=\x22hljs-string\x22\x3e\x27compile\x27\x3c\/span\x3e);\n      }\n\n      var ref = compileToFunctions(\x3cspan class=\x22hljs-keyword\x22\x3etemplate\x3c\/span\x3e, {\n        shouldDecodeNewlines: shouldDecodeNewlines,／／核心compile函数。用于生成render函数。这里不细说\n        delimiters: options.delimiters\n      }, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n      var render = ref.render;\n      var staticRenderFns = ref.staticRenderFns;\n      options.render = render;／／挂载render到实例options中。待调用\n      options.staticRenderFns = staticRenderFns;／／静态的元素区分开。提升性能，后续虚拟dom树比较时，不会比较静态节点\n\n      \x3cspan class=\x22hljs-comment\x22\x3e\/* istanbul ignore if *\/\x3c\/span\x3e\n      \x3cspan class=\x22hljs-built_in\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-string\x22\x3e\x22development\x22\x3c\/span\x3e !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e \x26amp;\x26amp; \x3cspan class=\x22hljs-built_in\x22\x3econfig\x3c\/span\x3e.performance \x26amp;\x26amp; mark) {\n        mark(\x3cspan class=\x22hljs-string\x22\x3e\x27compile end\x27\x3c\/span\x3e);\n        measure(((\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._name) \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22 compile\x22\x3c\/span\x3e), \x3cspan class=\x22hljs-string\x22\x3e\x27compile\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27compile end\x27\x3c\/span\x3e);\n      }\n    }\n  }\n  \x3cspan class=\x22hljs-built_in\x22\x3ereturn\x3c\/span\x3e mount.call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, el, hydrating)／／利用缓存的mount调用准备好的render\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e$mount方法的核心其实就是准备好组件的render函数。这里最核心的一个方法就是：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var ref = compileToFunctions(template, {\n        shouldDecodeNewlines: shouldDecodeNewlines,／／核心compile函数。用于生成render函数。这里不细说\n        delimiters: options.delimiters\n      }, this);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs cs\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eref\x3c\/span\x3e = compileToFunctions(template, {\n        shouldDecodeNewlines: shouldDecodeNewlines,／／核心compile函数。用于生成render函数。这里不细说\n        delimiters: options.delimiters\n      }, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3ecompileToFunctions这个函数中主要做了两件事：\x3cbr\x3e1:对模版进行compile（按标签解析,生成ast（抽象语法树）\x3cbr\x3e2:利用generate(ast, options),生成render函数语法\x3c\/p\x3e\n\x3cp\x3e我们来看看最后实例生成的render函数：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVOWLR?w=357\x26amp;h=277\x22 src=\x22https:\/\/static.alili.tech\/img\/bVOWLR?w=357\x26amp;h=277\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e没有错就是这个样子，很有感觉。生成的render函数保存在options中，等待调用\x3c\/p\x3e\n\x3cp\x3e好吧。开始调用吧。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22mount.call(this, el, hydrating)＝》mountComponent(this, el, hydrating)＝》updateComponent = function () {\n      vm._update(vm._render(), hydrating);\n    };＝》vm._watcher = new Watcher(vm, updateComponent, noop);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3emount.call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, el, hydrating)＝》mountComponent(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, el, hydrating)＝》updateComponent = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n      vm._update(vm._render(), hydrating);\n    };＝》vm._watcher = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Watcher(vm, updateComponent, noop);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3enew Watcher中会主动调用updateComponent去touch依赖（给页面中引用过的data中的变量假如监听）正式调用render函数。既然都说了。那就来看看render函数：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Vue.prototype._render = function () {\n    var vm = this;\n    var ref = vm.$options;\n    var render = ref.render;\n    var staticRenderFns = ref.staticRenderFns;\n    var _parentVnode = ref._parentVnode;\n\n    if (vm._isMounted) {\n      \/\/ clone slot nodes on re-renders\n      for (var key in vm.$slots) {\n        vm.$slots[key] = cloneVNodes(vm.$slots[key]);\n      }\n    }\n\n    vm.$scopedSlots = (_parentVnode \x26amp;\x26amp; _parentVnode.data.scopedSlots) || emptyObject;\n\n    if (staticRenderFns \x26amp;\x26amp; !vm._staticTrees) {\n      vm._staticTrees = [];\n    }\n    \/\/ set parent vnode. this allows render functions to have access\n    \/\/ to the data on the placeholder node.\n    vm.$vnode = _parentVnode;\n    \/\/ render self\n    var vnode;\n    try {\n      vnode = render.call(vm._renderProxy, vm.$createElement);\/\/核心函数，调用render\n    } catch (e) {\n      handleError(e, vm, \x26quot;render function\x26quot;);\n      \/\/ return error render result,\n      \/\/ or previous vnode to prevent render error causing blank component\n      \/* istanbul ignore else *\/\n      {\n        vnode = vm.$options.renderError\n          ? vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)\n          : vm._vnode;\n      }\n    }\n    \/\/ return empty vnode in case the render function errored out\n    if (!(vnode instanceof VNode)) {\n      if (\x26quot;development\x26quot; !== \x27production\x27 \x26amp;\x26amp; Array.isArray(vnode)) {\n        warn(\n          \x27Multiple root nodes returned from render function. Render function \x27 \x2b\n          \x27should return a single root node.\x27,\n          vm\n        );\n      }\n      vnode = createEmptyVNode();\n    }\n    \/\/ set parent\n    vnode.parent = _parentVnode;\n    return vnode\n  };\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs php\x22\x3e\x3ccode\x3eVue.prototype._render = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e vm = this;\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e ref = vm.$options;\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e render = ref.render;\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e staticRenderFns = ref.staticRenderFns;\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e _parentVnode = ref._parentVnode;\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (vm._isMounted) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ clone slot nodes on re-renders\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e key in vm.$slots) {\n        vm.$slots[key] = cloneVNodes(vm.$slots[key]);\n      }\n    }\n\n    vm.$scopedSlots = (_parentVnode \x26amp;\x26amp; _parentVnode.data.scopedSlots) || emptyObject;\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (staticRenderFns \x26amp;\x26amp; !vm._staticTrees) {\n      vm._staticTrees = [];\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ set parent vnode. this allows render functions to have access\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ to the data on the placeholder node.\x3c\/span\x3e\n    vm.$vnode = _parentVnode;\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ render self\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e vnode;\n    \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n      vnode = render.call(vm._renderProxy, vm.$createElement);\x3cspan class=\x22hljs-comment\x22\x3e\/\/核心函数，调用render\x3c\/span\x3e\n    } \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e (e) {\n      handleError(e, vm, \x3cspan class=\x22hljs-string\x22\x3e\x22render function\x22\x3c\/span\x3e);\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ return error render result,\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ or previous vnode to prevent render error causing blank component\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/* istanbul ignore else *\/\x3c\/span\x3e\n      {\n        vnode = vm.$options.renderError\n          ? vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)\n          : vm._vnode;\n      }\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ return empty vnode in case the render function errored out\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!(vnode \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e VNode)) {\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-string\x22\x3e\x22development\x22\x3c\/span\x3e !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e \x26amp;\x26amp; \x3cspan class=\x22hljs-keyword\x22\x3eArray\x3c\/span\x3e.isArray(vnode)) {\n        warn(\n          \x3cspan class=\x22hljs-string\x22\x3e\x27Multiple root nodes returned from render function. Render function \x27\x3c\/span\x3e \x2b\n          \x3cspan class=\x22hljs-string\x22\x3e\x27should return a single root node.\x27\x3c\/span\x3e,\n          vm\n        );\n      }\n      vnode = createEmptyVNode();\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ set parent\x3c\/span\x3e\n    vnode.\x3cspan class=\x22hljs-keyword\x22\x3eparent\x3c\/span\x3e = _parentVnode;\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e vnode\n  };\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e_render()间接调用了vnode = render.call(vm._renderProxy, vm.$createElement);\x3c\/p\x3e\n\x3cp\x3e然后结合render函数。看看发生了什么。vm.$createElement是核心的创建虚拟dom的函数。\x3c\/p\x3e\n\x3cp\x3e继续看看核心构建虚拟dom函数：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function createElement (\n  context,\n  tag,\n  data,\n  children,\/\/children是该元素下的所有子元素\n  normalizationType,\n  alwaysNormalize\n) {\n  if (Array.isArray(data) || isPrimitive(data)) {\n    normalizationType = children;\n    children = data;\n    data = undefined;\n  }\n  if (isTrue(alwaysNormalize)) {\n    normalizationType = ALWAYS_NORMALIZE;\n  }\n  return _createElement(context, tag, data, children, normalizationType)\n}\n\nfunction _createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType\n) {\n  if (isDef(data) \x26amp;\x26amp; isDef((data).__ob__)) {\n    \x26quot;development\x26quot; !== \x27production\x27 \x26amp;\x26amp; warn(\n      \x26quot;Avoid using observed data object as vnode data: \x26quot; \x2b (JSON.stringify(data)) \x2b \x26quot;\\n\x26quot; \x2b\n      \x27Always create fresh vnode data objects in each render!\x27,\n      context\n    );\n    return createEmptyVNode()\n  }\n  if (!tag) {\n    \/\/ in case of component :is set to falsy value\n    return createEmptyVNode()\n  }\n  \/\/ support single function children as default scoped slot\n  if (Array.isArray(children) \x26amp;\x26amp;\n      typeof children[0] === \x27function\x27) {\n    data = data || {};\n    data.scopedSlots = { default: children[0] };\n    children.length = 0;\n  }\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children);\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children);\n  }\n  var vnode, ns;\n  if (typeof tag === \x27string\x27) {\n    var Ctor;\n    ns = config.getTagNamespace(tag);\n    if (config.isReservedTag(tag)) {\n      \/\/ platform built-in elements\n      vnode = new VNode(\n        config.parsePlatformTagName(tag), data, children,\n        undefined, undefined, context\n      );\n    } else if (isDef(Ctor = resolveAsset(context.$options, \x27components\x27, tag))) {假如是组件则从上下文中取出组件的构造相关参数\n      \/\/ component\n      vnode = createComponent(Ctor, data, context, children, tag);\n    } else {\n      \/\/ unknown or unlisted namespaced elements\n      \/\/ check at runtime because it may get assigned a namespace when its\n      \/\/ parent normalizes children\n      vnode = new VNode(\n        tag, data, children,\n        undefined, undefined, context\n      );\n    }\n  } else {\n    \/\/ direct component options \/ constructor\n    vnode = createComponent(tag, data, context, children);\n  }\n  if (vnode !== undefined) {\n    if (ns) { applyNS(vnode, ns); }\n    return vnode\n  } else {\n    return createEmptyVNode()\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3efunction createElement (\n  context,\n  tag,\n  \x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e,\n  children,\x3cspan class=\x22hljs-comment\x22\x3e\/\/children是该元素下的所有子元素\x3c\/span\x3e\n  normalizationType,\n  alwaysNormalize\n) {\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (Array.isArray(\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e) || isPrimitive(\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e)) {\n    normalizationType = children;\n    children = \x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e = undefined;\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isTrue(alwaysNormalize)) {\n    normalizationType = ALWAYS_NORMALIZE;\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e _createElement(context, tag, \x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e, children, normalizationType)\n}\n\nfunction _createElement (\n  context,\n  tag,\n  \x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e,\n  children,\n  normalizationType\n) {\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isDef(\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e) \x26amp;\x26amp; isDef((\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e).__ob__)) {\n    \x3cspan class=\x22hljs-string\x22\x3e\x22development\x22\x3c\/span\x3e !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e \x26amp;\x26amp; warn(\n      \x3cspan class=\x22hljs-string\x22\x3e\x22Avoid using observed data object as vnode data: \x22\x3c\/span\x3e \x2b (JSON.stringify(\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e)) \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22\\n\x22\x3c\/span\x3e \x2b\n      \x3cspan class=\x22hljs-string\x22\x3e\x27Always create fresh vnode data objects in each render!\x27\x3c\/span\x3e,\n      context\n    );\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e createEmptyVNode()\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!tag) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ in case of component :is set to falsy value\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e createEmptyVNode()\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ support single function children as default scoped slot\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (Array.isArray(children) \x26amp;\x26amp;\n      typeof children[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e] === \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e || {};\n    \x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e.scopedSlots = { \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e: children[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e] };\n    children.length = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children);\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children);\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e vnode, ns;\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (typeof tag === \x3cspan class=\x22hljs-string\x22\x3e\x27string\x27\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Ctor;\n    ns = config.getTagNamespace(tag);\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (config.isReservedTag(tag)) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ platform built-in elements\x3c\/span\x3e\n      vnode = new VNode(\n        config.parsePlatformTagName(tag), \x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e, children,\n        undefined, undefined, context\n      );\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isDef(Ctor = resolveAsset(context.$options, \x3cspan class=\x22hljs-string\x22\x3e\x27components\x27\x3c\/span\x3e, tag))) {假如是组件则从上下文中取出组件的构造相关参数\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ component\x3c\/span\x3e\n      vnode = createComponent(Ctor, \x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e, context, children, tag);\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ unknown or unlisted namespaced elements\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ check at runtime because it may get assigned a namespace when its\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ parent normalizes children\x3c\/span\x3e\n      vnode = new VNode(\n        tag, \x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e, children,\n        undefined, undefined, context\n      );\n    }\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ direct component options \/ constructor\x3c\/span\x3e\n    vnode = createComponent(tag, \x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e, context, children);\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (vnode !== undefined) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (ns) { applyNS(vnode, ns); }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e vnode\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e createEmptyVNode()\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里其实我们不难看出vue在构造虚拟dom时。递归的去调用createElement去生成虚拟dom树。当children是组件或者是普通元素时。做不同的处理。这里我们关注的是。当子元素是组建时。这里调用了 \x3cbr\x3evnode = createComponent(tag, data, context, children);\x3cbr\x3e细心的人可以在去看看这个函数做了什么。简单来说这个函数将组件的构造参数取出来，放置在元素的componentOptions上。供后续创建真实dom时。标记该元素是组件。递归初始化。\x3cbr\x3e跳过这些沉重的。我们直接看看我们的这个html生成的最终的虚拟dom长什么样。如下：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVOWLQ?w=311\x26amp;h=274\x22 src=\x22https:\/\/static.alili.tech\/img\/bVOWLQ?w=311\x26amp;h=274\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e我们在来看看我们的my-component组件长什么样子：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVOWLR?w=357\x26amp;h=277\x22 src=\x22https:\/\/static.alili.tech\/img\/bVOWLR?w=357\x26amp;h=277\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3ecomponentOptios上存着初始化组件需要的参数。\x3c\/p\x3e\n\x3cp\x3e构建好虚拟dom后。vue进入update阶段：\x3cbr\x3e这个阶段vue会判断先前有无该元素。是否为第一次渲染。假如是第一次。那么直接创建。如果不是有先前的ovnode,则比较差异。最小化更新。看看具体函数：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22nction lifecycleMixin (Vue) {\n  Vue.prototype._update = function (vnode, hydrating) {\n    var vm = this;\n    if (vm._isMounted) {\n      callHook(vm, \x27beforeUpdate\x27);\n    }\n    var prevEl = vm.$el;\n    var prevVnode = vm._vnode;\/\/取出缓存的久的虚拟dom\n    var prevActiveInstance = activeInstance;\n    activeInstance = vm;\n    vm._vnode = vnode;\/\/缓存当前vnode，供下次更新使用\n    \/\/ Vue.prototype.__patch__ is injected in entry points\n    \/\/ based on the rendering backend used.\n    if (!prevVnode) {\/\/假如第一次渲染。直接创建\n      \/\/ initial render\n      vm.$el = vm.__patch__(\n        vm.$el, vnode, hydrating, false \/* removeOnly *\/,\n        vm.$options._parentElm,\n        vm.$options._refElm\n      );\n    } else {\n      \/\/ updates\n      vm.$el = vm.__patch__(prevVnode, vnode);\/\/更新时。会比较差异\n    }\n    activeInstance = prevActiveInstance;\n    \/\/ update __vue__ reference\n    if (prevEl) {\n      prevEl.__vue__ = null;\n    }\n    if (vm.$el) {\n      vm.$el.__vue__ = vm;\n    }\n    \/\/ if parent is an HOC, update its $el as well\n    if (vm.$vnode \x26amp;\x26amp; vm.$parent \x26amp;\x26amp; vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el;\n    }\n    \/\/ updated hook is called by the scheduler to ensure that children are\n    \/\/ updated in a parent\x27s updated hook.\n  };\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs php\x22\x3e\x3ccode\x3enction lifecycleMixin (Vue) {\n  Vue.prototype._update = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(vnode, hydrating)\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e vm = this;\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (vm._isMounted) {\n      callHook(vm, \x3cspan class=\x22hljs-string\x22\x3e\x27beforeUpdate\x27\x3c\/span\x3e);\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e prevEl = vm.$el;\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e prevVnode = vm._vnode;\x3cspan class=\x22hljs-comment\x22\x3e\/\/取出缓存的久的虚拟dom\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e prevActiveInstance = activeInstance;\n    activeInstance = vm;\n    vm._vnode = vnode;\x3cspan class=\x22hljs-comment\x22\x3e\/\/缓存当前vnode，供下次更新使用\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Vue.prototype.__patch__ is injected in entry points\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ based on the rendering backend used.\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!prevVnode) {\x3cspan class=\x22hljs-comment\x22\x3e\/\/假如第一次渲染。直接创建\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ initial render\x3c\/span\x3e\n      vm.$el = vm.__patch__(\n        vm.$el, vnode, hydrating, \x3cspan class=\x22hljs-keyword\x22\x3efalse\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/* removeOnly *\/\x3c\/span\x3e,\n        vm.$options._parentElm,\n        vm.$options._refElm\n      );\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ updates\x3c\/span\x3e\n      vm.$el = vm.__patch__(prevVnode, vnode);\x3cspan class=\x22hljs-comment\x22\x3e\/\/更新时。会比较差异\x3c\/span\x3e\n    }\n    activeInstance = prevActiveInstance;\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ update __vue__ reference\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (prevEl) {\n      prevEl.__vue__ = \x3cspan class=\x22hljs-keyword\x22\x3enull\x3c\/span\x3e;\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (vm.$el) {\n      vm.$el.__vue__ = vm;\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ if parent is an HOC, update its $el as well\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (vm.$vnode \x26amp;\x26amp; vm.$parent \x26amp;\x26amp; vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el;\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ updated hook is called by the scheduler to ensure that children are\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ updated in a parent\x27s updated hook.\x3c\/span\x3e\n  };\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e__patch__函数我们就不细看了。算了看一下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\n  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {\n    if (isUndef(vnode)) {\n      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }\n      return\n    }\n\n    var isInitialPatch = false;\n    var insertedVnodeQueue = [];\n\n    if (isUndef(oldVnode)) {\n      \/\/ empty mount (likely as component), create new root element\n      isInitialPatch = true;\/\/假如第一次渲染。直接创建\n      createElm(vnode, insertedVnodeQueue, parentElm, refElm);\n    } else {\n      var isRealElement = isDef(oldVnode.nodeType);\n      if (!isRealElement \x26amp;\x26amp; sameVnode(oldVnode, vnode)) {／／假如更新并且前后虚拟dom相似，这里相似有自己的一个算法。比如tag,key必需一致。才会去diff比较\n        \/\/ patch existing root node\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);\n      } else {\n        if (isRealElement) {\n          \/\/ mounting to a real element\n          \/\/ check if this is server-rendered content and if we can perform\n          \/\/ a successful hydration.\n          if (oldVnode.nodeType === 1 \x26amp;\x26amp; oldVnode.hasAttribute(SSR_ATTR)) {\n            oldVnode.removeAttribute(SSR_ATTR);\n            hydrating = true;\n          }\n          if (isTrue(hydrating)) {\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n              invokeInsertHook(vnode, insertedVnodeQueue, true);\n              return oldVnode\n            } else {\n              warn(\n                \x27The client-side rendered virtual DOM tree is not matching \x27 \x2b\n                \x27server-rendered content. This is likely caused by incorrect \x27 \x2b\n                \x27HTML markup, for example nesting block-level elements inside \x27 \x2b\n                \x27\x3cp\x3e, or missing \x3ctbody\x3e. Bailing hydration and performing \x27 \x2b\n                \x27full client-side render.\x27\n              );\n            }\n          }\n          \/\/ either not server-rendered, or hydration failed.\n          \/\/ create an empty node and replace it\n          oldVnode = emptyNodeAt(oldVnode);\n        }\n        \/\/ replacing existing element\n        var oldElm = oldVnode.elm;\n        var parentElm$1 = nodeOps.parentNode(oldElm);\n        createElm(\n          vnode,\n          insertedVnodeQueue,\n          \/\/ extremely rare edge case: do not insert if old element is in a\n          \/\/ leaving transition. Only happens when combining transition \x2b\n          \/\/ keep-alive \x2b HOCs. (#4590)\n          oldElm._leaveCb ? null : parentElm$1,\n          nodeOps.nextSibling(oldElm)\n        );\n\n        if (isDef(vnode.parent)) {\n          \/\/ component root element replaced.\n          \/\/ update parent placeholder node element, recursively\n          var ancestor = vnode.parent;\n          while (ancestor) {\n            ancestor.elm = vnode.elm;\n            ancestor = ancestor.parent;\n          }\n          if (isPatchable(vnode)) {\n            for (var i = 0; i \x3c cbs.create.length; \x2b\x2bi) {\n              cbs.create[i](emptyNode, vnode.parent);\n            }\n          }\n        }\n\n        if (isDef(parentElm$1)) {\n          removeVnodes(parentElm$1, [oldVnode], 0, 0);\n        } else if (isDef(oldVnode.tag)) {\n          invokeDestroyHook(oldVnode);\n        }\n      }\n    }\n\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n    return vnode.elm\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs php\x22\x3e\x3ccode\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3epatch\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(oldVnode, vnode, hydrating, removeOnly, parentElm, refElm)\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isUndef(vnode)) {\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e isInitialPatch = \x3cspan class=\x22hljs-keyword\x22\x3efalse\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e insertedVnodeQueue = [];\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isUndef(oldVnode)) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ empty mount (likely as component), create new root element\x3c\/span\x3e\n      isInitialPatch = \x3cspan class=\x22hljs-keyword\x22\x3etrue\x3c\/span\x3e;\x3cspan class=\x22hljs-comment\x22\x3e\/\/假如第一次渲染。直接创建\x3c\/span\x3e\n      createElm(vnode, insertedVnodeQueue, parentElm, refElm);\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e isRealElement = isDef(oldVnode.nodeType);\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!isRealElement \x26amp;\x26amp; sameVnode(oldVnode, vnode)) {／／假如更新并且前后虚拟dom相似，这里相似有自己的一个算法。比如tag,key必需一致。才会去diff比较\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ patch existing root node\x3c\/span\x3e\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);\n      } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isRealElement) {\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ mounting to a real element\x3c\/span\x3e\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ check if this is server-rendered content and if we can perform\x3c\/span\x3e\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ a successful hydration.\x3c\/span\x3e\n          \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (oldVnode.nodeType === \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e \x26amp;\x26amp; oldVnode.hasAttribute(SSR_ATTR)) {\n            oldVnode.removeAttribute(SSR_ATTR);\n            hydrating = \x3cspan class=\x22hljs-keyword\x22\x3etrue\x3c\/span\x3e;\n          }\n          \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isTrue(hydrating)) {\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n              invokeInsertHook(vnode, insertedVnodeQueue, \x3cspan class=\x22hljs-keyword\x22\x3etrue\x3c\/span\x3e);\n              \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e oldVnode\n            } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n              warn(\n                \x3cspan class=\x22hljs-string\x22\x3e\x27The client-side rendered virtual DOM tree is not matching \x27\x3c\/span\x3e \x2b\n                \x3cspan class=\x22hljs-string\x22\x3e\x27server-rendered content. This is likely caused by incorrect \x27\x3c\/span\x3e \x2b\n                \x3cspan class=\x22hljs-string\x22\x3e\x27HTML markup, for example nesting block-level elements inside \x27\x3c\/span\x3e \x2b\n                \x3cspan class=\x22hljs-string\x22\x3e\x27\x26lt;p\x26gt;, or missing \x26lt;tbody\x26gt;. Bailing hydration and performing \x27\x3c\/span\x3e \x2b\n                \x3cspan class=\x22hljs-string\x22\x3e\x27full client-side render.\x27\x3c\/span\x3e\n              );\n            }\n          }\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ either not server-rendered, or hydration failed.\x3c\/span\x3e\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ create an empty node and replace it\x3c\/span\x3e\n          oldVnode = emptyNodeAt(oldVnode);\n        }\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ replacing existing element\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e oldElm = oldVnode.elm;\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e parentElm$\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e = nodeOps.parentNode(oldElm);\n        createElm(\n          vnode,\n          insertedVnodeQueue,\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ extremely rare edge case: do not insert if old element is in a\x3c\/span\x3e\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ leaving transition. Only happens when combining transition \x2b\x3c\/span\x3e\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ keep-alive \x2b HOCs. (#4590)\x3c\/span\x3e\n          oldElm._leaveCb ? \x3cspan class=\x22hljs-keyword\x22\x3enull\x3c\/span\x3e : parentElm$\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\n          nodeOps.nextSibling(oldElm)\n        );\n\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isDef(vnode.\x3cspan class=\x22hljs-keyword\x22\x3eparent\x3c\/span\x3e)) {\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ component root element replaced.\x3c\/span\x3e\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ update parent placeholder node element, recursively\x3c\/span\x3e\n          \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e ancestor = vnode.\x3cspan class=\x22hljs-keyword\x22\x3eparent\x3c\/span\x3e;\n          \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (ancestor) {\n            ancestor.elm = vnode.elm;\n            ancestor = ancestor.\x3cspan class=\x22hljs-keyword\x22\x3eparent\x3c\/span\x3e;\n          }\n          \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isPatchable(vnode)) {\n            \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; cbs.create.length; \x2b\x2bi) {\n              cbs.create[i](emptyNode, vnode.\x3cspan class=\x22hljs-keyword\x22\x3eparent\x3c\/span\x3e);\n            }\n          }\n        }\n\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isDef(parentElm$\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e)) {\n          removeVnodes(parentElm$\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, [oldVnode], \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isDef(oldVnode.tag)) {\n          invokeDestroyHook(oldVnode);\n        }\n      }\n    }\n\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e vnode.elm\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3epatch方法中核心的是createElm：看懂这个函数非常重要代码如下\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function createElm (vnode, insertedVnodeQueue, parentElm, refElm, nested) {\n    vnode.isRootInsert = !nested; \/\/ for transition enter check\n    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\/\/根据之前保存的componentoptions来识别是否为组件。若是。则进这个逻辑\n      return\n    }\n\n    var data = vnode.data;\n    var children = vnode.children;\n    var tag = vnode.tag;\n    if (isDef(tag)) {\n      {\n        if (data \x26amp;\x26amp; data.pre) {\n          inPre\x2b\x2b;\n        }\n        if (\n          !inPre \x26amp;\x26amp;\n          !vnode.ns \x26amp;\x26amp;\n          !(config.ignoredElements.length \x26amp;\x26amp; config.ignoredElements.indexOf(tag) \x3e -1) \x26amp;\x26amp;\n          config.isUnknownElement(tag)\n        ) {\n          warn(\n            \x27Unknown custom element: \x3c\x27 \x2b tag \x2b \x27\x3e - did you \x27 \x2b\n            \x27register the component correctly? For recursive components, \x27 \x2b\n            \x27make sure to provide the \x26quot;name\x26quot; option.\x27,\n            vnode.context\n          );\n        }\n      }\n      vnode.elm = vnode.ns\n        ? nodeOps.createElementNS(vnode.ns, tag)\n        : nodeOps.createElement(tag, vnode);\n      setScope(vnode);\n\n      \/* istanbul ignore if *\/\n      {\n        createChildren(vnode, children, insertedVnodeQueue);\n        if (isDef(data)) {\n          invokeCreateHooks(vnode, insertedVnodeQueue);\n        }\n        insert(parentElm, vnode.elm, refElm);\n      }\n\n      if (\x26quot;development\x26quot; !== \x27production\x27 \x26amp;\x26amp; data \x26amp;\x26amp; data.pre) {\n        inPre--;\n      }\n    } else if (isTrue(vnode.isComment)) {\n      vnode.elm = nodeOps.createComment(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    } else {\n      vnode.elm = nodeOps.createTextNode(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    }\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lasso\x22\x3e\x3ccode\x3efunction createElm (vnode, insertedVnodeQueue, parentElm, refElm, nested) {\n    vnode.isRootInsert = !nested; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ for transition enter check\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\x3cspan class=\x22hljs-comment\x22\x3e\/\/根据之前保存的componentoptions来识别是否为组件。若是。则进这个逻辑\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n    }\n\n    \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3edata\x3c\/span\x3e = vnode.\x3cspan class=\x22hljs-built_in\x22\x3edata\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e children = vnode.children;\n    \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3etag\x3c\/span\x3e = vnode.\x3cspan class=\x22hljs-built_in\x22\x3etag\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isDef(\x3cspan class=\x22hljs-built_in\x22\x3etag\x3c\/span\x3e)) {\n      {\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3edata\x3c\/span\x3e \x26amp;\x26amp; \x3cspan class=\x22hljs-built_in\x22\x3edata\x3c\/span\x3e.pre) {\n          inPre\x2b\x2b;\n        }\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\n          !inPre \x26amp;\x26amp;\n          !vnode.ns \x26amp;\x26amp;\n          !(config.ignoredElements.length \x26amp;\x26amp; config.ignoredElements.indexOf(\x3cspan class=\x22hljs-built_in\x22\x3etag\x3c\/span\x3e) \x26gt; \x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e) \x26amp;\x26amp;\n          config.isUnknownElement(\x3cspan class=\x22hljs-built_in\x22\x3etag\x3c\/span\x3e)\n        ) {\n          warn(\n            \x3cspan class=\x22hljs-string\x22\x3e\x27Unknown custom element: \x26lt;\x27\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-built_in\x22\x3etag\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27\x26gt; - did you \x27\x3c\/span\x3e \x2b\n            \x3cspan class=\x22hljs-string\x22\x3e\x27register the component correctly? For recursive components, \x27\x3c\/span\x3e \x2b\n            \x3cspan class=\x22hljs-string\x22\x3e\x27make sure to provide the \x22name\x22 option.\x27\x3c\/span\x3e,\n            vnode.context\n          );\n        }\n      }\n      vnode.elm = vnode.ns\n        ? nodeOps.createElementNS(vnode.ns, \x3cspan class=\x22hljs-built_in\x22\x3etag\x3c\/span\x3e)\n        : nodeOps.createElement(\x3cspan class=\x22hljs-built_in\x22\x3etag\x3c\/span\x3e, vnode);\n      setScope(vnode);\n\n      \x3cspan class=\x22hljs-comment\x22\x3e\/* istanbul ignore if *\/\x3c\/span\x3e\n      {\n        createChildren(vnode, children, insertedVnodeQueue);\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isDef(\x3cspan class=\x22hljs-built_in\x22\x3edata\x3c\/span\x3e)) {\n          invokeCreateHooks(vnode, insertedVnodeQueue);\n        }\n        insert(parentElm, vnode.elm, refElm);\n      }\n\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-string\x22\x3e\x22development\x22\x3c\/span\x3e !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e \x26amp;\x26amp; \x3cspan class=\x22hljs-built_in\x22\x3edata\x3c\/span\x3e \x26amp;\x26amp; \x3cspan class=\x22hljs-built_in\x22\x3edata\x3c\/span\x3e.pre) {\n        inPre--;\n      }\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isTrue(vnode.isComment)) {\n      vnode.elm = nodeOps.createComment(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      vnode.elm = nodeOps.createTextNode(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    }\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们这边还是先关注自己的组件部分。当children是组件元素时，很显然调用了createComponent(vnode, insertedVnodeQueue, parentElm, refElm)；\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var componentVNodeHooks = {\n  init: function init (\n    vnode,\n    hydrating,\n    parentElm,\n    refElm\n  ) {\n    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {\n      var child = vnode.componentInstance = createComponentInstanceForVnode(\n        vnode,\n        activeInstance,\n        parentElm,\/\/调用了组件内部的_init方法递归创建子组件。正式进入子组件的生命周期\n        refElm\n      );\n      child.$mount(hydrating ? vnode.elm : undefined, hydrating);触发子组件的挂载。出发子组件的编译和render。又重新来一遍／直到子组件完全渲染好。再开始creelem下一个child\n    } else if (vnode.data.keepAlive) {\n      \/\/ kept-alive components, treat as a patch\n      var mountedNode = vnode; \/\/ work around flow\n      componentVNodeHooks.prepatch(mountedNode, mountedNode);\n    }\n  },\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e componentVNodeHooks = {\n  init: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3einit\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(\n    vnode,\n    hydrating,\n    parentElm,\n    refElm\n  )\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e child = vnode.componentInstance = createComponentInstanceForVnode(\n        vnode,\n        activeInstance,\n        parentElm,\x3cspan class=\x22hljs-comment\x22\x3e\/\/调用了组件内部的_init方法递归创建子组件。正式进入子组件的生命周期\x3c\/span\x3e\n        refElm\n      );\n      child.$mount(hydrating ? vnode.elm : \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e, hydrating);触发子组件的挂载。出发子组件的编译和render。又重新来一遍／直到子组件完全渲染好。再开始creelem下一个child\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (vnode.data.keepAlive) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ kept-alive components, treat as a patch\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e mountedNode = vnode; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ work around flow\x3c\/span\x3e\n      componentVNodeHooks.prepatch(mountedNode, mountedNode);\n    }\n  },\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里就是递归创建子组件的核心部分.\x3c\/p\x3e\n\x3cp\x3e总结： 第一次写这个vue。失败了。切模块切的不够细。组件机制感觉用了好多东西。这个面太大了。自己讲的时候也不知道该细讲还是。。。\x3c\/p\x3e\n\x3cp\x3e总的来说：vue在创建虚拟dom的时候，如果元素是组件。则准备好组件的构造参数。包括模版和数据等等。组件中的元素如slot，和child放在组件元素的children下。供后面的内容分发用组件中的元素也是在父组件的作用域内编译的。看—_render（）函数就知道。然后在vue需要将虚拟dom变为真实dom时。遇到组件元素时。开始递归初始化。直到把组件compile,render构建完后。开始构建下一个元素。最后添加到真实id=app上。并且把旧的删了。哈哈。随便写了\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>vue源码解读－component机制</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000009721209">https://segmentfault.com/a/1190000009721209</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/givlb1h7m0m/" target="_blank">https://alili.tech/archive/givlb1h7m0m/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>