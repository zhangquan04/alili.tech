<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="webpack多页应用架构系列（十六）：善用浏览器缓存，该去则去，该留则留"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>webpack多页应用架构系列（十六）：善用浏览器缓存，该去则去，该留则留 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/agqzr18xmja/",
				"appid": "1613049289050283", 
				"title": "webpack多页应用架构系列（十六）：善用浏览器缓存，该去则去，该留则留 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-07T02:30:11"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/27myrgw826f/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/fjyi00opro/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fagqzr18xmja%2f&text=webpack%e5%a4%9a%e9%a1%b5%e5%ba%94%e7%94%a8%e6%9e%b6%e6%9e%84%e7%b3%bb%e5%88%97%ef%bc%88%e5%8d%81%e5%85%ad%ef%bc%89%ef%bc%9a%e5%96%84%e7%94%a8%e6%b5%8f%e8%a7%88%e5%99%a8%e7%bc%93%e5%ad%98%ef%bc%8c%e8%af%a5%e5%8e%bb%e5%88%99%e5%8e%bb%ef%bc%8c%e8%af%a5%e7%95%99%e5%88%99%e7%95%99"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fagqzr18xmja%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fagqzr18xmja%2f&text=webpack%e5%a4%9a%e9%a1%b5%e5%ba%94%e7%94%a8%e6%9e%b6%e6%9e%84%e7%b3%bb%e5%88%97%ef%bc%88%e5%8d%81%e5%85%ad%ef%bc%89%ef%bc%9a%e5%96%84%e7%94%a8%e6%b5%8f%e8%a7%88%e5%99%a8%e7%bc%93%e5%ad%98%ef%bc%8c%e8%af%a5%e5%8e%bb%e5%88%99%e5%8e%bb%ef%bc%8c%e8%af%a5%e7%95%99%e5%88%99%e7%95%99"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fagqzr18xmja%2f&title=webpack%e5%a4%9a%e9%a1%b5%e5%ba%94%e7%94%a8%e6%9e%b6%e6%9e%84%e7%b3%bb%e5%88%97%ef%bc%88%e5%8d%81%e5%85%ad%ef%bc%89%ef%bc%9a%e5%96%84%e7%94%a8%e6%b5%8f%e8%a7%88%e5%99%a8%e7%bc%93%e5%ad%98%ef%bc%8c%e8%af%a5%e5%8e%bb%e5%88%99%e5%8e%bb%ef%bc%8c%e8%af%a5%e7%95%99%e5%88%99%e7%95%99"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fagqzr18xmja%2f&is_video=false&description=webpack%e5%a4%9a%e9%a1%b5%e5%ba%94%e7%94%a8%e6%9e%b6%e6%9e%84%e7%b3%bb%e5%88%97%ef%bc%88%e5%8d%81%e5%85%ad%ef%bc%89%ef%bc%9a%e5%96%84%e7%94%a8%e6%b5%8f%e8%a7%88%e5%99%a8%e7%bc%93%e5%ad%98%ef%bc%8c%e8%af%a5%e5%8e%bb%e5%88%99%e5%8e%bb%ef%bc%8c%e8%af%a5%e7%95%99%e5%88%99%e7%95%99"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=webpack%e5%a4%9a%e9%a1%b5%e5%ba%94%e7%94%a8%e6%9e%b6%e6%9e%84%e7%b3%bb%e5%88%97%ef%bc%88%e5%8d%81%e5%85%ad%ef%bc%89%ef%bc%9a%e5%96%84%e7%94%a8%e6%b5%8f%e8%a7%88%e5%99%a8%e7%bc%93%e5%ad%98%ef%bc%8c%e8%af%a5%e5%8e%bb%e5%88%99%e5%8e%bb%ef%bc%8c%e8%af%a5%e7%95%99%e5%88%99%e7%95%99&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fagqzr18xmja%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fagqzr18xmja%2f&title=webpack%e5%a4%9a%e9%a1%b5%e5%ba%94%e7%94%a8%e6%9e%b6%e6%9e%84%e7%b3%bb%e5%88%97%ef%bc%88%e5%8d%81%e5%85%ad%ef%bc%89%ef%bc%9a%e5%96%84%e7%94%a8%e6%b5%8f%e8%a7%88%e5%99%a8%e7%bc%93%e5%ad%98%ef%bc%8c%e8%af%a5%e5%8e%bb%e5%88%99%e5%8e%bb%ef%bc%8c%e8%af%a5%e7%95%99%e5%88%99%e7%95%99"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fagqzr18xmja%2f&title=webpack%e5%a4%9a%e9%a1%b5%e5%ba%94%e7%94%a8%e6%9e%b6%e6%9e%84%e7%b3%bb%e5%88%97%ef%bc%88%e5%8d%81%e5%85%ad%ef%bc%89%ef%bc%9a%e5%96%84%e7%94%a8%e6%b5%8f%e8%a7%88%e5%99%a8%e7%bc%93%e5%ad%98%ef%bc%8c%e8%af%a5%e5%8e%bb%e5%88%99%e5%8e%bb%ef%bc%8c%e8%af%a5%e7%95%99%e5%88%99%e7%95%99"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fagqzr18xmja%2f&title=webpack%e5%a4%9a%e9%a1%b5%e5%ba%94%e7%94%a8%e6%9e%b6%e6%9e%84%e7%b3%bb%e5%88%97%ef%bc%88%e5%8d%81%e5%85%ad%ef%bc%89%ef%bc%9a%e5%96%84%e7%94%a8%e6%b5%8f%e8%a7%88%e5%99%a8%e7%bc%93%e5%ad%98%ef%bc%8c%e8%af%a5%e5%8e%bb%e5%88%99%e5%8e%bb%ef%bc%8c%e8%af%a5%e7%95%99%e5%88%99%e7%95%99"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fagqzr18xmja%2f&title=webpack%e5%a4%9a%e9%a1%b5%e5%ba%94%e7%94%a8%e6%9e%b6%e6%9e%84%e7%b3%bb%e5%88%97%ef%bc%88%e5%8d%81%e5%85%ad%ef%bc%89%ef%bc%9a%e5%96%84%e7%94%a8%e6%b5%8f%e8%a7%88%e5%99%a8%e7%bc%93%e5%ad%98%ef%bc%8c%e8%af%a5%e5%8e%bb%e5%88%99%e5%8e%bb%ef%bc%8c%e8%af%a5%e7%95%99%e5%88%99%e7%95%99"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">webpack多页应用架构系列（十六）：善用浏览器缓存，该去则去，该留则留</h1><div class="meta"><div class="postdate"><time datetime="2019-01-07" itemprop="datePublished">2019-01-07</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e本文首发于\x3cem\x3eArray_Huang\x3c\/em\x3e的技术博客——\x3ccode\x3e实用至上\x3c\/code\x3e，非经作者同意，请勿转载。\x3cbr\x3e原文地址：\x3ccode\x3ehttps:\/\/segmentfault.com\/a\/1190000010317802\x3c\/code\x3e\x3cbr\x3e如果您对本系列文章感兴趣，欢迎关注订阅这里：\x3ca href=\x22https:\/\/segmentfault.com\/blog\/array_huang\x22\x3e\x3ccode\x3ehttps:\/\/segmentfault.com\/blog\/array_huang\x3c\/code\x3e\x3c\/a\x3e\n\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e前言\x3c\/h2\x3e\n\x3cp\x3e一个成熟的项目，自然离不开迭代更新；那么在部署前端这一块，我们免不了总是要顾及到浏览器缓存的，本文将介绍如何在 webpack (架构)的帮助下，妥善处理好浏览器缓存。\x3c\/p\x3e\n\x3cp\x3e实际上，我很早以前就想写这一part了，只是苦于当时我所掌握的方案不如人意，便不敢献丑了；而自从\x3cbr\x3e webpack 升级到 v2 版本后，以及第三方plugin的日益丰富，我们也有了更多的手段来处理cache。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e浏览器缓存简单介绍\x3c\/h2\x3e\n\x3cp\x3e下面来简单介绍一下浏览器缓存，以及为何我要在标题中强调“该去则去，该留则留”。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e浏览器缓存是啥？\x3c\/h3\x3e\n\x3cp\x3e浏览器缓存(Browser Cache)，是浏览器为了节省网络带宽、加快网站访问速度而推出的一项功能。浏览器缓存的运行机制是这样的：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e用户使用浏览器第一次访问某网站页面，该页面上引入了各种各样的静态资源（js\/css\/图片\/字体……），浏览器会把这些静态资源，甚至是页面本身(html文件)，都一一储存到本地。\x3c\/li\x3e\n\x3cli\x3e用户在后续的访问中，如果需要再次请求同样的静态资源（根据 url 进行匹配），且静态资源没有过期（服务器端有一系列判别资源是否过期的策略，比如\x3ccode\x3eCache-Control\x3c\/code\x3e、\x3ccode\x3ePragma\x3c\/code\x3e、\x3ccode\x3eETag\x3c\/code\x3e、\x3ccode\x3eExpires\x3c\/code\x3e、\x3ccode\x3eLast-Modified\x3c\/code\x3e），则直接使用前面本地储存的资源，而不需要重复请求。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e由于webpack只负责构建生成网站前端的静态资源，不涉及服务器，因此本文不讨论以\x3cem\x3eHTTP Header\x3c\/em\x3e为基础的缓存控制策略；那我们讨论什么呢？\x3c\/p\x3e\n\x3cp\x3e很简单，由于浏览器是根据静态资源的\x3cstrong\x3eurl\x3c\/strong\x3e来判断该静态资源是否已有缓存，而静态资源的文件目录又是相对固定的，那么重点明显就在于静态资源的\x3cstrong\x3e文件名\x3c\/strong\x3e了；我们就通过操控静态资源的文件名，来决定静态资源的“去留”。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e浏览器缓存，该留不留会怎么样？\x3c\/h3\x3e\n\x3cp\x3e每次部署上线新版本，静态资源的文件名若有变化，则浏览器判断是第一次读取这个静态资源；那么，即便这个静态资源的内容跟上一版的完全一致，浏览器也要重新下载这个静态资源，浪费网络带宽、拖慢页面加载速度。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e浏览器缓存，该去不去会怎么样？\x3c\/h3\x3e\n\x3cp\x3e每次部署上线新版本，静态资源的文件名若没有变化，则浏览器判断可加载之前缓存下来的静态资源；那么，即便这个静态资源的内容跟上一版的有所变化，浏览器也察觉不到，使用了老版本的静态资源。那这会造成什么样的影响呢？可大可小，小至用户看到的依然是老版的资源，达不到上线更新版本的目的；大至造成网站运行报错、布局错位等问题。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e如何通过操控静态资源的文件名达到控制浏览器缓存的目的呢？\x3c\/h2\x3e\n\x3cp\x3e在webpack关于文件名命名的配置中，存在一系列的变量（或者理解成命名规则也可），通过这些变量，我们可以根据所要生成的文件的具体情况来进行命名，而不必预设好一个固定的名称。在缓存处理这一块，我们主要用到\x3ccode\x3e[hash]\x3c\/code\x3e和\x3ccode\x3e[chunkhash]\x3c\/code\x3e这两个变量。关于这两个变量的介绍，我在之前的文章 —— \x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000006863968#articleHeader5\x22 target=\x22_blank\x22\x3e《webpack配置常用部分有哪些？》\x3c\/a\x3e就已经解释过是什么意思了，这里就不再累述。\x3c\/p\x3e\n\x3cp\x3e这里总结下\x3ccode\x3e[hash]\x3c\/code\x3e和\x3ccode\x3e[chunkhash]\x3c\/code\x3e这两个变量的用法：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e用\x3ccode\x3e[hash]\x3c\/code\x3e的话，由于每次使用 webpack 构建代码的时候，此 hash 字符串都会更新，因此相当于\x3cstrong\x3e强制刷新浏览器缓存\x3c\/strong\x3e。\x3c\/li\x3e\n\x3cli\x3e用\x3ccode\x3e[chunkhash]\x3c\/code\x3e的话，则会根据具体 chunk 的内容来形成一个 hash 字符串来插入到文件名上；换句说， chunk 的内容不变，该 chunk 所对应生成出来的文件的文件名也不会变，由此，\x3cstrong\x3e浏览器缓存便能得以继续利用\x3c\/strong\x3e。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3e有哪些资源是需要兼顾浏览器缓存的？\x3c\/h2\x3e\n\x3cp\x3e理论上来说，除了HTML文件外（HTML文件的路径需要保持相对固定，只能从服务器端入手），webpack生成的所有文件都需要处理好浏览器缓存的问题。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3ejs\x3c\/h3\x3e\n\x3cp\x3e在 webpack 架构下，js文件也有不同类型，因此也需要不同的配置：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e入口文件(Entry)：在webpack配置中的\x3ccode\x3eoutput.filename\x3c\/code\x3e参数中，让生成的文件名中带上\x3ccode\x3e[chunkhash]\x3c\/code\x3e即可。\x3c\/li\x3e\n\x3cli\x3e异步加载的chunk：\x3ccode\x3eoutput.chunkFilename\x3c\/code\x3e参数，操作同上。\x3c\/li\x3e\n\x3cli\x3e通过\x3ccode\x3eCommonsChunkPlugin\x3c\/code\x3e生成的文件：在\x3ccode\x3eCommonsChunkPlugin\x3c\/code\x3e的配置参数中有\x3ccode\x3efilename\x3c\/code\x3e这一项，操作同上。但需要注意的是，如果你使用\x3ccode\x3e[chunkhash]\x3c\/code\x3e的话，webpack 构建的时候可是会报错的哦；那可咋办呢，用\x3ccode\x3e[hash]\x3c\/code\x3e的话，这\x3ccode\x3ecommon chunk\x3c\/code\x3e不就每次上线新版本都强制刷新了吗？这其实是因为，webpack 的 runtime \x26amp;\x26amp; manifest 会统一保存在你的\x3ccode\x3ecommon chunk\x3c\/code\x3e里，解决的方法，就请看下面关于“webpack 的 runtime \x26amp;\x26amp; manifest”的部分了。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3ecss\x3c\/h3\x3e\n\x3cp\x3e对于css来说，如果你是用\x3ccode\x3estyle-loader\x3c\/code\x3e直接把css内联到\x3ccode\x3e\x26lt;head\x26gt;\x3c\/code\x3e里的，那么，你管好引入该css的js文件的浏览器缓存就好了。\x3c\/p\x3e\n\x3cp\x3e而如果你是使用\x3ccode\x3eextract-text-webpack-plugin\x3c\/code\x3e把css独立打包成css文件的，那么在文件名的配置上，\x3cdel\x3e同样加上\x3ccode\x3e[chunkhash]\x3c\/code\x3e即可\x3c\/del\x3e加上\x3ccode\x3e[contenthash]\x3c\/code\x3e即可(感谢@FLYiNg_hbt 提醒)。这个\x3ccode\x3e[contenthash]\x3c\/code\x3e是什么东西呢？其实就是\x3ccode\x3eextract-text-webpack-plugin\x3c\/code\x3e为了与\x3ccode\x3e[chunkhash]\x3c\/code\x3e区分开，而自定义的一个命名规则，其实际含义跟\x3ccode\x3e[chunkhash]\x3c\/code\x3e可以说是一致的，只是\x3ccode\x3e[chunkhash]\x3c\/code\x3e已被占用作为 chunk 的内容 hash 字符串了，继续用\x3ccode\x3e[chunkhash]\x3c\/code\x3e会造成\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000010317802#articleHeader13\x22\x3e下述问题\x3c\/a\x3e。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3e图片、字体文件等静态资源\x3c\/h3\x3e\n\x3cp\x3e如\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000006907701\x22 target=\x22_blank\x22\x3e《听说webpack连图片和字体也能打包？》\x3c\/a\x3e里介绍的，处理这类静态资源一般使用\x3ccode\x3eurl-loader\x3c\/code\x3e或\x3ccode\x3efile-loader\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e对于\x3ccode\x3eurl-loader\x3c\/code\x3e来说，就不需要关心浏览器缓存了，因为它是把静态资源转化成 dataurl 了，而并非独立的文件。\x3c\/p\x3e\n\x3cp\x3e而对于\x3ccode\x3efile-loader\x3c\/code\x3e来说，同样是在文件名的配置上加上\x3ccode\x3e[chunkhash]\x3c\/code\x3e即可。另外需要注意的是，\x3ccode\x3eurl-loader\x3c\/code\x3e一般搭配有降级到\x3ccode\x3efile-loader\x3c\/code\x3e的配置（使用loader加载的文件大于一个你设定的值就降级到使用\x3ccode\x3efile-loader\x3c\/code\x3e来加载），同样需要在文件名的配置上加上\x3ccode\x3e[chunkhash]\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3ewebpack 的\x3ccode\x3eruntime \x26amp;\x26amp; manifest\x3c\/code\x3e\n\x3c\/h3\x3e\n\x3cp\x3e所谓的runtime，就是帮助 webpack 编译构建后的打包文件在浏览器运行的一些辅助代码段，换句话说，打包后的文件，除了你自己的源码和npm库外，还有 webpack 提供的一点辅助代码段。\x3c\/p\x3e\n\x3cp\x3e而 manifest，则是 webpack 用以查找 chunk 真实路径所使用的一份关系表，简单来说，就是\x3cstrong\x3e chunk 名\x3c\/strong\x3e对应\x3cstrong\x3e chunk 路径\x3c\/strong\x3e的关系表。manifest 一般来说会被藏到 runtime 里，因此我们查看 runtime 的时候，虽然能找得到 manifest，但一般都不那么直观，形如下面这一段（仅\x3ccode\x3ecommon chunk\x3c\/code\x3e部分）：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22u.type = \x26quot;text\/javascript\x26quot;, u.charset = \x26quot;utf-8\x26quot;, u.async = !0, u.timeout = 12e4, n.nc \x26amp;\x26amp; u.setAttribute(\x26quot;nonce\x26quot;, n.nc), u.src = n.p \x2b \x26quot;\x26quot; \x2b e \x2b \x26quot;.\x26quot; \x2b {\n    0: \x26quot;e6d1dff43f64d01297d3\x26quot;,\n    1: \x26quot;7ad996b8cbd7556a3e56\x26quot;,\n    2: \x26quot;c55991cf244b3d833c32\x26quot;,\n    3: \x26quot;ecbcdaa771c68c97ac38\x26quot;,\n    4: \x26quot;6565e12e7bad74df24c3\x26quot;,\n    5: \x26quot;9f2774b4601839780fc6\x26quot;\n}[e] \x2b \x26quot;.bundle.js\x26quot;;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eu.type = \x3cspan class=\x22hljs-string\x22\x3e\x22text\/javascript\x22\x3c\/span\x3e, u.charset = \x3cspan class=\x22hljs-string\x22\x3e\x22utf-8\x22\x3c\/span\x3e, u.async = !\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, u.timeout = \x3cspan class=\x22hljs-number\x22\x3e12e4\x3c\/span\x3e, n.nc \x26amp;\x26amp; u.setAttribute(\x3cspan class=\x22hljs-string\x22\x3e\x22nonce\x22\x3c\/span\x3e, n.nc), u.src = n.p \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22\x22\x3c\/span\x3e \x2b e \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22.\x22\x3c\/span\x3e \x2b {\n    \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22e6d1dff43f64d01297d3\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x227ad996b8cbd7556a3e56\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22c55991cf244b3d833c32\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22ecbcdaa771c68c97ac38\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x226565e12e7bad74df24c3\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x229f2774b4601839780fc6\x22\x3c\/span\x3e\n}[e] \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22.bundle.js\x22\x3c\/span\x3e;\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e\n\x3ccode\x3eruntime \x26amp;\x26amp; manifest\x3c\/code\x3e被打包到哪里去了？\x3c\/h4\x3e\n\x3cp\x3e那么，这\x3ccode\x3eruntime \x26amp;\x26amp; manifest\x3c\/code\x3e的代码段，会被放到哪里呢？一般来说，如果没有使用\x3ccode\x3eCommonsChunkPlugin\x3c\/code\x3e生成\x3ccode\x3ecommon chunk\x3c\/code\x3e，\x3ccode\x3eruntime \x26amp;\x26amp; manifest\x3c\/code\x3e会被放在以入口文件为首的chunk（俗称“大包”）里，如果是我们这种多页（又称多入口）应用，则会每个大包一份\x3ccode\x3eruntime \x26amp;\x26amp; manifest\x3c\/code\x3e；这夸张的冗余我们自然是不能忍的，那么\x3cbr\x3e用上\x3ccode\x3eCommonsChunkPlugin\x3c\/code\x3e后，\x3ccode\x3eruntime \x26amp;\x26amp; manifest\x3c\/code\x3e就会统一迁到\x3ccode\x3ecommon chunk\x3c\/code\x3e了。\x3c\/p\x3e\n\x3ch4\x3e\n\x3ccode\x3eruntime \x26amp;\x26amp; manifest\x3c\/code\x3e给\x3ccode\x3ecommon chunk\x3c\/code\x3e带来的缓存危机\x3c\/h4\x3e\n\x3cp\x3e虽说把\x3ccode\x3eruntime \x26amp;\x26amp; manifest\x3c\/code\x3e迁到\x3ccode\x3ecommon chunk\x3c\/code\x3e后，代码冗余的问题算是解决了，但却造成另一问题：由于我们在上述的静态资源的文件名命名上都采用了\x3ccode\x3e[chunkhash]\x3c\/code\x3e的方案，因此也使得只要我们稍一改动源代码，就会有起码一个 chunk 的命名会产生变化，这就会导致我们的\x3ccode\x3eruntime \x26amp;\x26amp; manifest\x3c\/code\x3e也产生变化，从而导致我们的\x3ccode\x3ecommon chunk\x3c\/code\x3e也发生变化，这或许就是 webpack 规定含有\x3ccode\x3eruntime \x26amp;\x26amp; manifest\x3c\/code\x3e的\x3ccode\x3ecommon chunk\x3c\/code\x3e不能使用\x3ccode\x3e[chunkhash]\x3c\/code\x3e的原因吧（反正chunkhash肯定会变的，还不如不用呢是不是）。\x3c\/p\x3e\n\x3cp\x3e要解决上述问题（这问题很严重啊我摔，\x3ccode\x3ecommon chunk\x3c\/code\x3e怎么能用不上缓存啊，这可是最大的chunk啊），我们就需要把\x3ccode\x3eruntime \x26amp;\x26amp; manifest\x3c\/code\x3e给独立出去。方法也很简单，在用来打包\x3ccode\x3ecommon chunk\x3c\/code\x3e的\x3ccode\x3eCommonsChunkPlugin\x3c\/code\x3e后，再加一\x3ccode\x3eCommonsChunkPlugin\x3c\/code\x3e：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  \/* 抽取出所有通用的部分 *\/\n  new webpack.optimize.CommonsChunkPlugin({\n    name: \x27commons\/commons\x27,      \/\/ 需要注意的是，chunk的name不能相同！！！\n    filename: \x27[name]\/bundle.[chunkhash].js\x27, \/\/ 由于runtime独立出去了，这里便可以使用[chunkhash]了\n    minChunks: 4,\n  }),\n  \/* 抽取出webpack的runtime代码，避免稍微修改一下入口文件就会改动commonChunk，导致原本有效的浏览器缓存失效 *\/\n  new webpack.optimize.CommonsChunkPlugin({\n    name: \x27webpack-runtime\x27,\n    filename: \x27commons\/commons\/webpack-runtime.[hash].js\x27, \/\/ 注意runtime只能用[hash]\n  }),\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e  \x3cspan class=\x22hljs-comment\x22\x3e\/* 抽取出所有通用的部分 *\/\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e webpack.optimize.CommonsChunkPlugin({\n    \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27commons\/commons\x27\x3c\/span\x3e,      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 需要注意的是，chunk的name不能相同！！！\x3c\/span\x3e\n    filename: \x3cspan class=\x22hljs-string\x22\x3e\x27[name]\/bundle.[chunkhash].js\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 由于runtime独立出去了，这里便可以使用[chunkhash]了\x3c\/span\x3e\n    minChunks: \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e,\n  }),\n  \x3cspan class=\x22hljs-comment\x22\x3e\/* 抽取出webpack的runtime代码，避免稍微修改一下入口文件就会改动commonChunk，导致原本有效的浏览器缓存失效 *\/\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e webpack.optimize.CommonsChunkPlugin({\n    \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27webpack-runtime\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3efilename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27commons\/commons\/webpack-runtime.[hash].js\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 注意runtime只能用[hash]\x3c\/span\x3e\n  }),\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样一来，\x3ccode\x3eruntime \x26amp;\x26amp; manifest\x3c\/code\x3e代码段就会被打包到这个名为\x3ccode\x3ewebpack-runtime\x3c\/code\x3e的 chunk 里了。这是什么原理呢？据说是在使用\x3ccode\x3eCommonsChunkPlugin\x3c\/code\x3e的情况下， webpack 会把\x3ccode\x3eruntime \x26amp;\x26amp; manifest\x3c\/code\x3e打包到最后面的一个\x3ccode\x3eCommonsChunkPlugin\x3c\/code\x3e生成的 chunk 里，而如果这个chunk没有其它代码，那么自然就达到了把\x3ccode\x3eruntime \x26amp;\x26amp; manifest\x3c\/code\x3e独立出去的目的了。\x3c\/p\x3e\n\x3cp\x3e需要注意的是，如果你用了\x3ccode\x3ehtml-webpack-plugin\x3c\/code\x3e来生成html页面，记得要把这\x3ccode\x3eruntime \x26amp;\x26amp; manifest\x3c\/code\x3e的 chunk 插入到html页面上，不然页面报错了可不怪我哦。\x3c\/p\x3e\n\x3cp\x3e至此，由于\x3ccode\x3eruntime \x26amp;\x26amp; manifest\x3c\/code\x3e独立出去成一个chunk了，于是\x3ccode\x3ecommon chunk\x3c\/code\x3e的命名便可以使用\x3ccode\x3e[chunkhash]\x3c\/code\x3e了，也就是说，\x3ccode\x3ecommon chunk\x3c\/code\x3e现在也能做到公共模块内容有更新了，才更新文件名；另一方面，这个独立出去的 \x3ccode\x3eruntime \x26amp;\x26amp; manifest\x3c\/code\x3e chunk，是每次 webpack 打包构建的时候都会更新了。\x3c\/p\x3e\n\x3ch4\x3e有必要把 manifest 从 \x3ccode\x3eruntime \x26amp;\x26amp; manifest\x3c\/code\x3e chunk 中独立出去吗？\x3c\/h4\x3e\n\x3cp\x3e是的，不用惊讶，的确是有这么一个骚操作。\x3c\/p\x3e\n\x3cp\x3e把 manifest 独立出去的理由是这样的：manifest 独立出去后，runtime 的部分基本上就不会有变动了；到这里，我们就知道，\x3ccode\x3eruntime \x26amp;\x26amp; manifest\x3c\/code\x3e里实际上就是 manifest 在变；因此把 manifest 独立出去，也是进一步地利用浏览器缓存（可以把 runtime 的缓存保留下来）。\x3c\/p\x3e\n\x3cp\x3e具体是怎么做的呢？主流有俩方案：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e利用\x3ca href=\x22https:\/\/github.com\/soundcloud\/chunk-manifest-webpack-plugin\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3echunk-manifest-webpack-plugin\x3c\/a\x3e把 manifest 生成一个json文件，然后由 webpack 异步加载。\x3c\/li\x3e\n\x3cli\x3e如果你是用\x3ccode\x3ehtml-webpack-plugin\x3c\/code\x3e来生成html页面的话，还可以利用\x3ca href=\x22https:\/\/github.com\/jouni-kantola\/inline-chunk-manifest-html-webpack-plugin\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3einline-chunk-manifest-html-webpack-plugin\x3c\/a\x3e（\x3ccode\x3ehtml-webpack-plugin\x3c\/code\x3e作者推荐）来把manifest直接输出到html页面上，这样就能省一个 Http 请求了。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e我试用过第二种方案，好使，但最终还是放弃了，为什么呢？\x3c\/p\x3e\n\x3cp\x3e把 manifest 独立出去后，只剩下 runtime 的 chunk 的命名还是只能用\x3ccode\x3e[hash]\x3c\/code\x3e，而不能利用\x3ccode\x3e[chunkhash]\x3c\/code\x3e，这就导致我们根本没法利用浏览器缓存。后来，我又想出一个折衷的办法，连\x3ccode\x3e[hash]\x3c\/code\x3e也不要了，直接写死一个文件名；这样的话，的确浏览器缓存就能保存下来了。但后来我还是反转了自己，这种方法虽然能留下浏览器缓存，却做不到“该去则去”。或许大家会有疑问，你不是说 runtime 不会变的吗，那留下缓存有什么关系呀？是的，在同一 webpack 环境下 runtime 的确不会变，但难保 webpack 环境改变后，这runtime会怎么样呀。比如说 webpack 的版本升级了、 webpack 的配置改了、loader \x26amp; plugin 的版本升级了，在这些情况下，谁敢保证 runtime 永远不会变啊？这 runtime 一用错了过期的缓存，那很可能整个系统都会崩溃的啊，这个险我实在是冒不起，所以只能作罢。\x3c\/p\x3e\n\x3cp\x3e不过我看了下\x3ca href=\x22https:\/\/github.com\/Array-Huang\/webpack-seed\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eArray-Huang\/webpack-seed\x3c\/a\x3e的\x3ccode\x3eruntime \x26amp;\x26amp; manifest\x3c\/code\x3e chunk，也才 2kb 而已嘛，你们管好自己的强迫症和代码洁癖好吗？！\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader11\x22\x3e缓存问题杂项\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader12\x22\x3e模块id带来的缓存问题\x3c\/h3\x3e\n\x3cp\x3ewebpack 处理模块(module)间依赖关系时，需要给各个模块定一个 id 以作标识。webpack 默认的 id 命名规则是根据模块引入的顺序，赋予一个整数(1、2、3……)。当你在源码中任意增添或删减一个模块的依赖，都会对整个\x3cbr\x3e id 序列造成极大的影响，可谓是“牵一发而动全身”了。那么这对我们的浏览器缓存会有什么样直接的影响呢？影响就是会造成，各个chunk中都不一定有实质的变化，但引用的依赖模块id却都变了，这明显就会造成 chunk 的文件名的变动，从而影响浏览器缓存。\x3c\/p\x3e\n\x3cp\x3ewebpack 官方文档里推荐我们使用一个已内置进 webpack2 里的 plugin：\x3ccode\x3eHashedModuleIdsPlugin\x3c\/code\x3e，这个 plugin 的官方文档在\x3ca href=\x22https:\/\/webpack.js.org\/plugins\/hashed-module-ids-plugin\/#components\/sidebar\/sidebar.jsx\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e这里\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3ewebpack1 时代便有一个\x3ccode\x3eNamedModulesPlugin\x3c\/code\x3e，它的原理是直接使用模块的相对路径作为模块的 id，这样只要模块的相对路径，模块 id 也就不会变了。那么这个\x3ccode\x3eHashedModuleIdsPlugin\x3c\/code\x3e对比起\x3ccode\x3eNamedModulesPlugin\x3c\/code\x3e来说又有什么进步呢？\x3c\/p\x3e\n\x3cp\x3e是这样的，由于模块的相对路径有可能会很长，那么就会占用大量的空间，这一点是一直为社区所诟病的；但这个\x3ccode\x3eHashedModuleIdsPlugin\x3c\/code\x3e是根据模块的相对路径生成(默认使用md5算法)一个长度可配置（默认截取4位）的字符串作为模块的 id，那么它占用的空间就很小了，大家也就可以安心服用了。\x3c\/p\x3e\n\x3cblockquote\x3eTo generate identifiers that are preserved over builds, webpack supplies the NamedModulesPlugin (recommended for development) and HashedModuleIdsPlugin (recommended for production).\x3c\/blockquote\x3e\n\x3cp\x3e从上可知，官方是推荐开发环境用\x3ccode\x3eNamedModulesPlugin\x3c\/code\x3e，而生产环境用\x3ccode\x3eHashedModuleIdsPlugin\x3c\/code\x3e的，原因似乎是与热更新(hmr)有关；不过就我看来，仅在生产环境用\x3ccode\x3eHashedModuleIdsPlugin\x3c\/code\x3e就行了，开发环境还管啥浏览器缓存啊，俺开 chrome dev-tool 设置了不用任何浏览器缓存的。\x3c\/p\x3e\n\x3cp\x3e用法也挺简单的，直接加到\x3ccode\x3eplugin\x3c\/code\x3e参数就成了：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22plugins: {\n  \/\/ 其它plugin\n  new webpack.HashedModuleIdsPlugin(),  \n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eplugins: {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 其它plugin\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e webpack.HashedModuleIdsPlugin(),  \n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader13\x22\x3e由某些 plugin 造成的文件改动监测失败\x3c\/h3\x3e\n\x3cp\x3e有些 plugin 会生成独立的 chunk 文件，比如\x3ccode\x3eCommonsChunkPlugin\x3c\/code\x3e或\x3ccode\x3eExtractTextPlugin\x3c\/code\x3e（从js中提取出css代码段并生成独立的css文件） 。\x3c\/p\x3e\n\x3cp\x3e这些 plugin 在生成 chunk 的文件名时，可能没料想到后续还会有其它 plugin （比如用来混淆代码的\x3ccode\x3eUglifyJsPlugin\x3c\/code\x3e）会对代码进行修改，因此，由此生成的 chunk 文件名，并不能完全反映文件内容的变化。\x3c\/p\x3e\n\x3cp\x3e另外，\x3ccode\x3eExtractTextPlugin\x3c\/code\x3e有个比较严重的问题，那就是它生成文件名所用的\x3ccode\x3e[chunkhash]\x3c\/code\x3e是直接取自于引用该css代码段的 js chunk ；换句话说，如果我只是修改 css 代码段，而不动 js 代码，那么最后生成出来的css文件名依然没有变化，这可算是非常严重的浏览器缓存“该去不去”问题了。\x3cbr\x3e2017-07-26 改动：改用\x3ccode\x3e[contenthash]\x3c\/code\x3e便不会出现此问题，上见\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000010317802#articleHeader8\x22\x3ecss部分\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e有一款 plugin 能解决以上问题：\x3ca href=\x22https:\/\/github.com\/scinos\/webpack-plugin-hash-output\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ewebpack-plugin-hash-output\x3c\/a\x3e。\x3c\/p\x3e\n\x3cblockquote\x3eThere are other webpack plugins for hashing out there. But when they run, they don\x27t \x22see\x22 the final form of the code, because they run before plugins like webpack.optimize.UglifyJsPlugin. In other words, if you change webpack.optimize.UglifyJsPlugin config, your hashes won\x27t change, creating potential conflicts with cached resources.\x3cp\x3eThe main difference is that webpack-plugin-hash-output runs in the last compilation step. So any change in webpack or any other plugin that actually changes the output, will be \x22seen\x22 by this plugin, and therefore that change will be reflected in the hash.\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e简单来说，就是这个\x3ccode\x3ewebpack-plugin-hash-output\x3c\/code\x3e会在 webpack 编译的最后阶段，重新对所有的文件取文件内容的 md5 值，这就保证了文件内容的变化一定会反映在文件名上了。\x3c\/p\x3e\n\x3cp\x3e用法也比较简单：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22plugins: {\n  \/\/ 其它plugin\n  new HashOutput({\n    manifestFiles: \x27webpack-runtime\x27, \/\/ 指定包含 manifest 在内的 chunk\n  }),\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eplugins: {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 其它plugin\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e HashOutput({\n    \x3cspan class=\x22hljs-attr\x22\x3emanifestFiles\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27webpack-runtime\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 指定包含 manifest 在内的 chunk\x3c\/span\x3e\n  }),\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader14\x22\x3e总结\x3c\/h2\x3e\n\x3cp\x3e浏览器缓存很重要，很重要，很重要，出问题了怕不是要给领导追着打。另外，这一块的细节特别多，必须方方面面都顾到，不然哪一方面出了纰漏就全局泡汤。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader15\x22\x3e示例代码\x3c\/h2\x3e\n\x3cp\x3e诸位看本系列文章，搭配我在Github上的脚手架项目食用更佳哦（笑）：\x3ca href=\x22https:\/\/github.com\/Array-Huang\/webpack-seed\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eArray-Huang\/webpack-seed\x3c\/a\x3e（\x3ccode\x3ehttps:\/\/github.com\/Array-Huang\/webpack-seed\x3c\/code\x3e）。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader16\x22\x3e附系列文章目录（同步更新）\x3c\/h2\x3e\n\x3cul\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000006843916\x22\x3ewebpack多页应用架构系列（一）：一步一步解决架构痛点\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000006863968\x22 target=\x22_blank\x22\x3ewebpack多页应用架构系列（二）：webpack配置常用部分有哪些？\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000006871991\x22\x3ewebpack多页应用架构系列（三）：怎么打包公共代码才能避免重复？\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000006887523\x22 target=\x22_blank\x22\x3ewebpack多页应用架构系列（四）：老式jQuery插件还不能丢，怎么兼容？\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000006897458\x22\x3ewebpack多页应用架构系列（五）：听说webpack连less\/css也能打包？\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000006907701\x22 target=\x22_blank\x22\x3ewebpack多页应用架构系列（六）：听说webpack连图片和字体也能打包？\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000006952432\x22\x3ewebpack多页应用架构系列（七）：开发环境、生产环境傻傻分不清楚？\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000006992218\x22 target=\x22_blank\x22\x3ewebpack多页应用架构系列（八）：教练我要写ES6！webpack怎么整合Babel？\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000007030775\x22\x3ewebpack多页应用架构系列（九）：总有刁民想害朕！ESLint为你阻击垃圾代码\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000007043716\x22 target=\x22_blank\x22\x3ewebpack多页应用架构系列（十）：如何打造一个自定义的bootstrap\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000007104372\x22\x3ewebpack多页应用架构系列（十一）：预打包Dll，实现webpack音速编译\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000007126268\x22 target=\x22_blank\x22\x3ewebpack多页应用架构系列（十二）：利用webpack生成HTML普通网页\x26amp;页面模板\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000007159115\x22\x3ewebpack多页应用架构系列（十三）：构建一个简单的模板布局系统\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000007301770\x22 target=\x22_blank\x22\x3ewebpack多页应用架构系列（十四）：No复制粘贴！多项目共用基础设施\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000008203380\x22\x3ewebpack多页应用架构系列（十五）：论前端如何在后端渲染开发模式下夹缝生存\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000010317802\x22 target=\x22_blank\x22\x3ewebpack多页应用架构系列（十六）：善用浏览器缓存，该去则去，该留则留\x3c\/a\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cblockquote\x3e本文首发于\x3cem\x3eArray_Huang\x3c\/em\x3e的技术博客——\x3ccode\x3e实用至上\x3c\/code\x3e，非经作者同意，请勿转载。\x3cbr\x3e原文地址：\x3ccode\x3ehttps:\/\/segmentfault.com\/a\/1190000010317802\x3c\/code\x3e\x3cbr\x3e如果您对本系列文章感兴趣，欢迎关注订阅这里：\x3ca href=\x22https:\/\/segmentfault.com\/blog\/array_huang\x22\x3e\x3ccode\x3ehttps:\/\/segmentfault.com\/blog\/array_huang\x3c\/code\x3e\x3c\/a\x3e\n\x3c\/blockquote\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>webpack多页应用架构系列（十六）：善用浏览器缓存，该去则去，该留则留</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000010317802">https://segmentfault.com/a/1190000010317802</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/agqzr18xmja/" target="_blank">https://alili.tech/archive/agqzr18xmja/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>