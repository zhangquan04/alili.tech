<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="并发服务器（四）：libuv"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>并发服务器（四）：libuv | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/vu5d363lynh/",
				"appid": "1613049289050283", 
				"title": "并发服务器（四）：libuv | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-21T02:30:06"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/xqmia1o0poq/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/walps7xlkn/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fvu5d363lynh%2f&text=%e5%b9%b6%e5%8f%91%e6%9c%8d%e5%8a%a1%e5%99%a8%ef%bc%88%e5%9b%9b%ef%bc%89%ef%bc%9alibuv"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fvu5d363lynh%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fvu5d363lynh%2f&text=%e5%b9%b6%e5%8f%91%e6%9c%8d%e5%8a%a1%e5%99%a8%ef%bc%88%e5%9b%9b%ef%bc%89%ef%bc%9alibuv"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fvu5d363lynh%2f&title=%e5%b9%b6%e5%8f%91%e6%9c%8d%e5%8a%a1%e5%99%a8%ef%bc%88%e5%9b%9b%ef%bc%89%ef%bc%9alibuv"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fvu5d363lynh%2f&is_video=false&description=%e5%b9%b6%e5%8f%91%e6%9c%8d%e5%8a%a1%e5%99%a8%ef%bc%88%e5%9b%9b%ef%bc%89%ef%bc%9alibuv"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e5%b9%b6%e5%8f%91%e6%9c%8d%e5%8a%a1%e5%99%a8%ef%bc%88%e5%9b%9b%ef%bc%89%ef%bc%9alibuv&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fvu5d363lynh%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fvu5d363lynh%2f&title=%e5%b9%b6%e5%8f%91%e6%9c%8d%e5%8a%a1%e5%99%a8%ef%bc%88%e5%9b%9b%ef%bc%89%ef%bc%9alibuv"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fvu5d363lynh%2f&title=%e5%b9%b6%e5%8f%91%e6%9c%8d%e5%8a%a1%e5%99%a8%ef%bc%88%e5%9b%9b%ef%bc%89%ef%bc%9alibuv"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fvu5d363lynh%2f&title=%e5%b9%b6%e5%8f%91%e6%9c%8d%e5%8a%a1%e5%99%a8%ef%bc%88%e5%9b%9b%ef%bc%89%ef%bc%9alibuv"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fvu5d363lynh%2f&title=%e5%b9%b6%e5%8f%91%e6%9c%8d%e5%8a%a1%e5%99%a8%ef%bc%88%e5%9b%9b%ef%bc%89%ef%bc%9alibuv"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">并发服务器（四）：libuv</h1><div class="meta"><div class="postdate"><time datetime="2019-01-21" itemprop="datePublished">2019-01-21</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n            \x3ch1\x3e\x3ca href=\x22#并发服务器四libuv\x22\x3e\x3c\/a\x3e并发服务器（四）：libuv\x3c\/h1\x3e\n\x3cp\x3e这是并发网络服务器系列文章的第四部分。在这一部分中，我们将使用 libuv 再次重写我们的服务器，并且也会讨论关于使用一个线程池在回调中去处理耗时任务。最终，我们去看一下底层的 libuv，花一点时间去学习如何用异步 API 对文件系统阻塞操作进行封装。\x3c\/p\x3e\n\x3cp\x3e本系列的所有文章：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/linux.cn\/article-8993-1.html\x22\x3e第一节 - 简介\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/linux.cn\/article-9002-1.html\x22\x3e第二节 - 线程\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/linux.cn\/article-9117-1.html\x22\x3e第三节 - 事件驱动\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22http:\/\/eli.thegreenplace.net\/2017\/concurrent-servers-part-4-libuv\/\x22\x3e第四节 - libuv\x3c\/a\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3\x3e\x3ca href=\x22#使用-libuv-抽象出事件驱动循环\x22\x3e\x3c\/a\x3e使用 libuv 抽象出事件驱动循环\x3c\/h3\x3e\n\x3cp\x3e在 \x3ca href=\x22https:\/\/linux.cn\/article-9117-1.html\x22\x3e第三节\x3c\/a\x3e 中，我们看到了基于 \x3ccode\x3eselect\x3c\/code\x3e 和 \x3ccode\x3eepoll\x3c\/code\x3e 的服务器的相似之处，并且，我说过，在它们之间抽象出细微的差别是件很有吸引力的事。许多库已经做到了这些，所以在这一部分中我将去选一个并使用它。我选的这个库是 \x3ca href=\x22http:\/\/libuv.org\/\x22\x3elibuv\x3c\/a\x3e，它最初设计用于 Node.js 底层的可移植平台层，并且，后来发现在其它的项目中也有使用。libuv 是用 C 写的，因此，它具有很高的可移植性，非常适用嵌入到像 JavaScript 和 Python 这样的高级语言中。\x3c\/p\x3e\n\x3cp\x3e虽然 libuv 为了抽象出底层平台细节已经变成了一个相当大的框架，但它仍然是以 \x3cem\x3e事件循环\x3c\/em\x3e 思想为中心的。在我们第三部分的事件驱动服务器中，事件循环是显式定义在 \x3ccode\x3emain\x3c\/code\x3e 函数中的；当使用 libuv 时，该循环通常隐藏在库自身中，而用户代码仅需要注册事件句柄（作为一个回调函数）和运行这个循环。此外，libuv 会在给定的平台上使用更快的事件循环实现，对于 Linux 它是 \x3ccode\x3eepoll\x3c\/code\x3e，等等。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/camo.githubusercontent.com\/93541ce88666ad9ceb4d8bcd0529c37000dbfd8d\/68747470733a2f2f656c692e746865677265656e706c6163652e6e65742f696d616765732f323031372f6c696275766c6f6f702e706e67\x22\x3e\x3cimg src=\x22https:\/\/p0.ssl.qhimg.com\/t01aa01812b505286b6.png\x22 alt=\x22libuv loop\x22\x3e\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3elibuv 支持多路事件循环，因此事件循环在库中是非常重要的；它有一个句柄 —— \x3ccode\x3euv_loop_t\x3c\/code\x3e，以及创建\/杀死\/启动\/停止循环的函数。也就是说，在这篇文章中，我将仅需要使用 “默认的” 循环，libuv 可通过 \x3ccode\x3euv_default_loop()\x3c\/code\x3e 提供它；多路循环大多用于多线程事件驱动的服务器，这是一个更高级别的话题，我将留在这一系列文章的以后部分。\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22#使用-libuv-的并发服务器\x22\x3e\x3c\/a\x3e使用 libuv 的并发服务器\x3c\/h3\x3e\n\x3cp\x3e为了对 libuv 有一个更深的印象，让我们跳转到我们的可靠协议的服务器，它通过我们的这个系列已经有了一个强大的重新实现。这个服务器的结构与第三部分中的基于 \x3ccode\x3eselect\x3c\/code\x3e 和 \x3ccode\x3eepoll\x3c\/code\x3e 的服务器有一些相似之处，因为，它也依赖回调。完整的 \x3ca href=\x22https:\/\/github.com\/eliben\/code-for-blog\/blob\/master\/2017\/async-socket-server\/uv-server.c\x22\x3e示例代码在这里\x3c\/a\x3e；我们开始设置这个服务器的套接字绑定到一个本地端口：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs perl\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eint\x3c\/span\x3e portnum = \x3cspan class=\x22hljs-number\x22\x3e9090\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (argc \x26gt;= \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e) {\n  portnum = atoi(argv[\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e]);\n}\n\x3cspan class=\x22hljs-keyword\x22\x3eprintf\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22Serving on port %d\\n\x22\x3c\/span\x3e, portnum);\n\n\x3cspan class=\x22hljs-keyword\x22\x3eint\x3c\/span\x3e rc;\nuv_tcp_t server_stream;\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ((rc = uv_tcp_init(uv_default_loop(), \x26amp;server_stream)) \x26lt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n  \x3cspan class=\x22hljs-keyword\x22\x3edie\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22uv_tcp_init failed: %s\x22\x3c\/span\x3e, uv_strerror(rc));\n}\n\nstruct sockaddr_in server_address;\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ((rc = uv_ip4_addr(\x3cspan class=\x22hljs-string\x22\x3e\x220.0.0.0\x22\x3c\/span\x3e, portnum, \x26amp;server_address)) \x26lt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n  \x3cspan class=\x22hljs-keyword\x22\x3edie\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22uv_ip4_addr failed: %s\x22\x3c\/span\x3e, uv_strerror(rc));\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ((rc = uv_tcp_bind(\x26amp;server_stream, (const struct sockaddr*)\x26amp;server_address, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e)) \x26lt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n  \x3cspan class=\x22hljs-keyword\x22\x3edie\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22uv_tcp_bind failed: %s\x22\x3c\/span\x3e, uv_strerror(rc));\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e除了它被封装进 libuv API 中之外，你看到的是一个相当标准的套接字。在它的返回中，我们取得了一个可工作于任何 libuv 支持的平台上的可移植接口。\x3c\/p\x3e\n\x3cp\x3e这些代码也展示了很认真负责的错误处理；多数的 libuv 函数返回一个整数状态，返回一个负数意味着出现了一个错误。在我们的服务器中，我们把这些错误看做致命问题进行处理，但也可以设想一个更优雅的错误恢复。\x3c\/p\x3e\n\x3cp\x3e现在，那个套接字已经绑定，是时候去监听它了。这里我们运行首个回调注册：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs cpp\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Listen on the socket for new peers to connect. When a new peer connects,\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ the on_peer_connected callback will be invoked.\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ((rc = uv_listen((\x3cspan class=\x22hljs-keyword\x22\x3euv_stream_t\x3c\/span\x3e*)\x26amp;server_stream, N_BACKLOG, on_peer_connected)) \x26lt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n  die(\x3cspan class=\x22hljs-string\x22\x3e\x22uv_listen failed: %s\x22\x3c\/span\x3e, uv_strerror(rc));\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e\x3ccode\x3euv_listen\x3c\/code\x3e 注册一个事件回调，当新的对端连接到这个套接字时将会调用事件循环。我们的回调在这里被称为 \x3ccode\x3eon_peer_connected\x3c\/code\x3e，我们一会儿将去查看它。\x3c\/p\x3e\n\x3cp\x3e最终，\x3ccode\x3emain\x3c\/code\x3e 运行这个 libuv 循环，直到它被停止（\x3ccode\x3euv_run\x3c\/code\x3e 仅在循环被停止或者发生错误时返回）。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs ceylon\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Run the libuv event loop.\x3c\/span\x3e\nuv\x3cspan class=\x22hljs-number\x22\x3e_\x3c\/span\x3erun(uv\x3cspan class=\x22hljs-number\x22\x3e_\x3c\/span\x3e\x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e_\x3c\/span\x3eloop(), UV\x3cspan class=\x22hljs-number\x22\x3e_\x3c\/span\x3eRUN\x3cspan class=\x22hljs-number\x22\x3e_\x3c\/span\x3eDEFAULT);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ If uv_run returned, close the default loop before exiting.\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e uv\x3cspan class=\x22hljs-number\x22\x3e_\x3c\/span\x3eloop\x3cspan class=\x22hljs-number\x22\x3e_\x3c\/span\x3eclose(uv\x3cspan class=\x22hljs-number\x22\x3e_\x3c\/span\x3e\x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e_\x3c\/span\x3eloop());\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e注意，在运行事件循环之前，只有一个回调是通过 \x3ccode\x3emain\x3c\/code\x3e 注册的；我们稍后将看到怎么去添加更多的回调。在事件循环的整个运行过程中，添加和删除回调并不是一个问题 —— 事实上，大多数服务器就是这么写的。\x3c\/p\x3e\n\x3cp\x3e这是一个 \x3ccode\x3eon_peer_connected\x3c\/code\x3e，它处理到服务器的新的客户端连接：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs cpp\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eon_peer_connected\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(\x3cspan class=\x22hljs-keyword\x22\x3euv_stream_t\x3c\/span\x3e* server_stream, \x3cspan class=\x22hljs-keyword\x22\x3eint\x3c\/span\x3e status)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (status \x26lt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-built_in\x22\x3efprintf\x3c\/span\x3e(\x3cspan class=\x22hljs-built_in\x22\x3estderr\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22Peer connection error: %s\\n\x22\x3c\/span\x3e, uv_strerror(status));\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ client will represent this peer; it\x27s allocated on the heap and only\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ released when the client disconnects. The client holds a pointer to\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ peer_state_t in its data field; this peer state tracks the protocol state\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ with this client throughout interaction.\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3euv_tcp_t\x3c\/span\x3e* client = (\x3cspan class=\x22hljs-keyword\x22\x3euv_tcp_t\x3c\/span\x3e*)xmalloc(\x3cspan class=\x22hljs-keyword\x22\x3esizeof\x3c\/span\x3e(*client));\n  \x3cspan class=\x22hljs-keyword\x22\x3eint\x3c\/span\x3e rc;\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ((rc = uv_tcp_init(uv_default_loop(), client)) \x26lt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n    die(\x3cspan class=\x22hljs-string\x22\x3e\x22uv_tcp_init failed: %s\x22\x3c\/span\x3e, uv_strerror(rc));\n  }\n  client-\x26gt;data = \x3cspan class=\x22hljs-literal\x22\x3eNULL\x3c\/span\x3e;\n\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (uv_accept(server_stream, (\x3cspan class=\x22hljs-keyword\x22\x3euv_stream_t\x3c\/span\x3e*)client) == \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3estruct\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3esockaddr_storage\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3epeername\x3c\/span\x3e;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eint\x3c\/span\x3e namelen = \x3cspan class=\x22hljs-keyword\x22\x3esizeof\x3c\/span\x3e(peername);\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ((rc = uv_tcp_getpeername(client, (struct sockaddr*)\x26amp;peername,\n                                 \x26amp;namelen)) \x26lt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n      die(\x3cspan class=\x22hljs-string\x22\x3e\x22uv_tcp_getpeername failed: %s\x22\x3c\/span\x3e, uv_strerror(rc));\n    }\n    report_peer_connected((\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e struct sockaddr_in*)\x26amp;peername, namelen);\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Initialize the peer state for a new client: we start by sending the peer\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ the initial \x27*\x27 ack.\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3epeer_state_t\x3c\/span\x3e* peerstate = (\x3cspan class=\x22hljs-keyword\x22\x3epeer_state_t\x3c\/span\x3e*)xmalloc(\x3cspan class=\x22hljs-keyword\x22\x3esizeof\x3c\/span\x3e(*peerstate));\n    peerstate-\x26gt;state = INITIAL_ACK;\n    peerstate-\x26gt;sendbuf[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e] = \x3cspan class=\x22hljs-string\x22\x3e\x27*\x27\x3c\/span\x3e;\n    peerstate-\x26gt;sendbuf_end = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n    peerstate-\x26gt;client = client;\n    client-\x26gt;data = peerstate;\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Enqueue the write request to send the ack; when it\x27s done,\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ on_wrote_init_ack will be called. The peer state is passed to the write\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ request via the data pointer; the write request does not own this peer\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ state - it\x27s owned by the client handle.\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3euv_buf_t\x3c\/span\x3e writebuf = uv_buf_init(peerstate-\x26gt;sendbuf, peerstate-\x26gt;sendbuf_end);\n    \x3cspan class=\x22hljs-keyword\x22\x3euv_write_t\x3c\/span\x3e* req = (\x3cspan class=\x22hljs-keyword\x22\x3euv_write_t\x3c\/span\x3e*)xmalloc(\x3cspan class=\x22hljs-keyword\x22\x3esizeof\x3c\/span\x3e(*req));\n    req-\x26gt;data = peerstate;\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ((rc = uv_write(req, (\x3cspan class=\x22hljs-keyword\x22\x3euv_stream_t\x3c\/span\x3e*)client, \x26amp;writebuf, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\n                       on_wrote_init_ack)) \x26lt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n      die(\x3cspan class=\x22hljs-string\x22\x3e\x22uv_write failed: %s\x22\x3c\/span\x3e, uv_strerror(rc));\n    }\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n    uv_close((\x3cspan class=\x22hljs-keyword\x22\x3euv_handle_t\x3c\/span\x3e*)client, on_client_closed);\n  }\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e这些代码都有很好的注释，但是，这里有一些重要的 libuv 语法我想去强调一下：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e传入自定义数据到回调中：因为 C 语言还没有闭包，这可能是个挑战，libuv 在它的所有的处理类型中有一个 \x3ccode\x3evoid* data\x3c\/code\x3e 字段；这些字段可以被用于传递用户数据。例如，注意 \x3ccode\x3eclient-\x26gt;data\x3c\/code\x3e 是如何指向到一个 \x3ccode\x3epeer_state_t\x3c\/code\x3e 结构上，以便于 \x3ccode\x3euv_write\x3c\/code\x3e 和 \x3ccode\x3euv_read_start\x3c\/code\x3e 注册的回调可以知道它们正在处理的是哪个客户端的数据。\x3c\/li\x3e\n\x3cli\x3e内存管理：在带有垃圾回收的语言中进行事件驱动编程是非常容易的，因为，回调通常运行在一个与它们注册的地方完全不同的栈帧中，使得基于栈的内存管理很困难。它总是需要传递堆分配的数据到 libuv 回调中（当所有回调运行时，除了 \x3ccode\x3emain\x3c\/code\x3e，其它的都运行在栈上），并且，为了避免泄漏，许多情况下都要求这些数据去安全释放（\x3ccode\x3efree()\x3c\/code\x3e）。这些都是些需要实践的内容 ^注1 。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e这个服务器上对端的状态如下：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs routeros\x22\x3etypedef struct {\n  ProcessingState state;\n  char sendbuf[SENDBUF_SIZE];\n  int sendbuf_end;\n  uv_tcp_t*\x3cspan class=\x22hljs-built_in\x22\x3e client;\n\x3c\/span\x3e} peer_state_t;\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e它与第三部分中的状态非常类似；我们不再需要 \x3ccode\x3esendptr\x3c\/code\x3e，因为，在调用 “done writing” 回调之前，\x3ccode\x3euv_write\x3c\/code\x3e 将确保发送它提供的整个缓冲。我们也为其它的回调使用保持了一个到客户端的指针。这里是 \x3ccode\x3eon_wrote_init_ack\x3c\/code\x3e：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs cpp\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eon_wrote_init_ack\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(\x3cspan class=\x22hljs-keyword\x22\x3euv_write_t\x3c\/span\x3e* req, \x3cspan class=\x22hljs-keyword\x22\x3eint\x3c\/span\x3e status)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (status) {\n    die(\x3cspan class=\x22hljs-string\x22\x3e\x22Write error: %s\\n\x22\x3c\/span\x3e, uv_strerror(status));\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3epeer_state_t\x3c\/span\x3e* peerstate = (\x3cspan class=\x22hljs-keyword\x22\x3epeer_state_t\x3c\/span\x3e*)req-\x26gt;data;\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Flip the peer state to WAIT_FOR_MSG, and start listening for incoming data\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ from this peer.\x3c\/span\x3e\n  peerstate-\x26gt;state = WAIT_FOR_MSG;\n  peerstate-\x26gt;sendbuf_end = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n\n  \x3cspan class=\x22hljs-keyword\x22\x3eint\x3c\/span\x3e rc;\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ((rc = uv_read_start((\x3cspan class=\x22hljs-keyword\x22\x3euv_stream_t\x3c\/span\x3e*)peerstate-\x26gt;client, on_alloc_buffer,\n                          on_peer_read)) \x26lt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n    die(\x3cspan class=\x22hljs-string\x22\x3e\x22uv_read_start failed: %s\x22\x3c\/span\x3e, uv_strerror(rc));\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Note: the write request doesn\x27t own the peer state, hence we only free the\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ request itself, not the state.\x3c\/span\x3e\n  \x3cspan class=\x22hljs-built_in\x22\x3efree\x3c\/span\x3e(req);\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e然后，我们确信知道了这个初始的 \x3ccode\x3e\x27*\x27\x3c\/code\x3e 已经被发送到对端，我们通过调用 \x3ccode\x3euv_read_start\x3c\/code\x3e 去监听从这个对端来的入站数据，它注册一个将被事件循环调用的回调（\x3ccode\x3eon_peer_read\x3c\/code\x3e），不论什么时候，事件循环都在套接字上接收来自客户端的调用：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs xl\x22\x3evoid on_peer_read(uv_stream_t* client, ssize_t nread, const uv_buf_t* buf) {\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (nread \x26lt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (nread != uv_eof) {\n      fprintf(stderr, \x3cspan class=\x22hljs-string\x22\x3e\x22read error: %s\\n\x22\x3c\/span\x3e, uv_strerror(nread));\n    }\n    uv_close((uv_handle_t*)client, on_client_closed);\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (nread == \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ from the documentation of uv_read_cb: nread might be 0, which does not\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ indicate an error or eof. this is equivalent to eagain or ewouldblock\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ under read(2).\x3c\/span\x3e\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ nread \x26gt; 0\x3c\/span\x3e\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3eassert\x3c\/span\x3e(buf-\x26gt;\x3c\/span\x3elen \x26gt;= nread);\n\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3epeer_state_t\x3c\/span\x3e* peerstate = (peer_state_t*)client-\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3eif\x3c\/span\x3e (peerstate-\x26gt;\x3c\/span\x3estate == initial_ack) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ if the initial ack hasn\x27t been sent for some reason, ignore whatever\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ the client sends in.\x3c\/span\x3e\n      \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3efree\x3c\/span\x3e(buf-\x26gt;\x3c\/span\x3ebase);\n      return;\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ run the protocol state machine.\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (int i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; nread; \x2b\x2bi) {\n      \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3eswitch\x3c\/span\x3e (peerstate-\x26gt;\x3c\/span\x3estate) {\n      case initial_ack:\n        assert(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e \x26amp;\x26amp; \x3cspan class=\x22hljs-string\x22\x3e\x22can\x27t reach here\x22\x3c\/span\x3e);\n        break;\n      case wait_for_msg:\n        \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3eif\x3c\/span\x3e (buf-\x26gt;\x3c\/span\x3ebase[i] == \x3cspan class=\x22hljs-string\x22\x3e\x27^\x27\x3c\/span\x3e) {\n          \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3epeerstate\x3c\/span\x3e-\x26gt;\x3c\/span\x3estate = in_msg;\n        }\n        break;\n      case in_msg:\n        \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3eif\x3c\/span\x3e (buf-\x26gt;\x3c\/span\x3ebase[i] == \x3cspan class=\x22hljs-string\x22\x3e\x27$\x27\x3c\/span\x3e) {\n          \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3epeerstate\x3c\/span\x3e-\x26gt;\x3c\/span\x3estate = wait_for_msg;\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n          \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3eassert\x3c\/span\x3e(peerstate-\x26gt;\x3c\/span\x3esendbuf_end \x26lt; sendbuf_size);\n          \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3epeerstate\x3c\/span\x3e-\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3esendbuf\x3c\/span\x3e[peerstate-\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3esendbuf_end\x3c\/span\x3e\x2b\x2b] = buf-\x26gt;\x3c\/span\x3ebase[i] \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n        }\n        break;\n      }\n    }\n\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3eif\x3c\/span\x3e (peerstate-\x26gt;\x3c\/span\x3esendbuf_end \x26gt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ we have data to send. the write buffer will point to the buffer stored\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ in the peer state for this client.\x3c\/span\x3e\n      uv_buf_t writebuf =\n          \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3euv_buf_init\x3c\/span\x3e(peerstate-\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3esendbuf\x3c\/span\x3e, peerstate-\x26gt;\x3c\/span\x3esendbuf_end);\n      uv_write_t* writereq = (uv_write_t*)xmalloc(sizeof(*writereq));\n      \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3ewritereq\x3c\/span\x3e-\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e = peerstate;\n      int rc;\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ((rc = uv_write(writereq, (uv_stream_t*)client, \x26amp;writebuf, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\n                         on_wrote_buf)) \x26lt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n        die(\x3cspan class=\x22hljs-string\x22\x3e\x22uv_write failed: %s\x22\x3c\/span\x3e, uv_strerror(rc));\n      }\n    }\n  }\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3efree\x3c\/span\x3e(buf-\x26gt;\x3c\/span\x3ebase);\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e这个服务器的运行时行为非常类似于第三部分的事件驱动服务器：所有的客户端都在一个单个的线程中并发处理。并且类似的，一些特定的行为必须在服务器代码中维护：服务器的逻辑实现为一个集成的回调，并且长周期运行是禁止的，因为它会阻塞事件循环。这一点也很类似。让我们进一步探索这个问题。\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22#在事件驱动循环中的长周期运行的操作\x22\x3e\x3c\/a\x3e在事件驱动循环中的长周期运行的操作\x3c\/h3\x3e\n\x3cp\x3e单线程的事件驱动代码使它先天就容易受到一些常见问题的影响：长周期运行的代码会阻塞整个循环。参见如下的程序：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs cpp\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eon_timer\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(\x3cspan class=\x22hljs-keyword\x22\x3euv_timer_t\x3c\/span\x3e* timer)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3euint64_t\x3c\/span\x3e timestamp = uv_hrtime();\n  \x3cspan class=\x22hljs-built_in\x22\x3eprintf\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22on_timer [%\x22\x3c\/span\x3e PRIu64 \x3cspan class=\x22hljs-string\x22\x3e\x22 ms]\\n\x22\x3c\/span\x3e, (timestamp \/ \x3cspan class=\x22hljs-number\x22\x3e1000000\x3c\/span\x3e) % \x3cspan class=\x22hljs-number\x22\x3e100000\x3c\/span\x3e);\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22Work\x22\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (random() % \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e == \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-built_in\x22\x3eprintf\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22Sleeping...\\n\x22\x3c\/span\x3e);\n    sleep(\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e);\n  }\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eint\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emain\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(\x3cspan class=\x22hljs-keyword\x22\x3eint\x3c\/span\x3e argc, \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3echar\x3c\/span\x3e** argv)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3euv_timer_t\x3c\/span\x3e timer;\n  uv_timer_init(uv_default_loop(), \x26amp;timer);\n  uv_timer_start(\x26amp;timer, on_timer, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e uv_run(uv_default_loop(), UV_RUN_DEFAULT);\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e它用一个单个注册的回调运行一个 libuv 事件循环：\x3ccode\x3eon_timer\x3c\/code\x3e，它被每秒钟循环调用一次。回调报告一个时间戳，并且，偶尔通过睡眠 3 秒去模拟一个长周期运行。这是运行示例：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs prolog\x22\x3e$ .\/uv-timer-sleep-demo\non_timer [\x3cspan class=\x22hljs-number\x22\x3e4840\x3c\/span\x3e ms]\non_timer [\x3cspan class=\x22hljs-number\x22\x3e5842\x3c\/span\x3e ms]\non_timer [\x3cspan class=\x22hljs-number\x22\x3e6843\x3c\/span\x3e ms]\non_timer [\x3cspan class=\x22hljs-number\x22\x3e7844\x3c\/span\x3e ms]\n\x3cspan class=\x22hljs-symbol\x22\x3eSleeping\x3c\/span\x3e...\non_timer [\x3cspan class=\x22hljs-number\x22\x3e11845\x3c\/span\x3e ms]\non_timer [\x3cspan class=\x22hljs-number\x22\x3e12846\x3c\/span\x3e ms]\n\x3cspan class=\x22hljs-symbol\x22\x3eSleeping\x3c\/span\x3e...\non_timer [\x3cspan class=\x22hljs-number\x22\x3e16847\x3c\/span\x3e ms]\non_timer [\x3cspan class=\x22hljs-number\x22\x3e17849\x3c\/span\x3e ms]\non_timer [\x3cspan class=\x22hljs-number\x22\x3e18850\x3c\/span\x3e ms]\n...\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e\x3ccode\x3eon_timer\x3c\/code\x3e 忠实地每秒执行一次，直到随机出现的睡眠为止。在那个时间点，\x3ccode\x3eon_timer\x3c\/code\x3e 不再被调用，直到睡眠时间结束；事实上，\x3cem\x3e没有其它的回调\x3c\/em\x3e  会在这个时间帧中被调用。这个睡眠调用阻塞了当前线程，它正是被调用的线程，并且也是事件循环使用的线程。当这个线程被阻塞后，事件循环也被阻塞。\x3c\/p\x3e\n\x3cp\x3e这个示例演示了在事件驱动的调用中为什么回调不能被阻塞是多少的重要。并且，同样适用于 Node.js 服务器、客户端侧的 Javascript、大多数的 GUI 编程框架、以及许多其它的异步编程模型。\x3c\/p\x3e\n\x3cp\x3e但是，有时候运行耗时的任务是不可避免的。并不是所有任务都有一个异步 API；例如，我们可能使用一些仅有同步 API 的库去处理，或者，正在执行一个可能的长周期计算。我们如何用事件驱动编程去结合这些代码？线程可以帮到你！\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22#转换-阻塞调用为异步调用的线程\x22\x3e\x3c\/a\x3e“转换” 阻塞调用为异步调用的线程\x3c\/h3\x3e\n\x3cp\x3e一个线程池可以用于转换阻塞调用为异步调用，通过与事件循环并行运行，并且当任务完成时去由它去公布事件。以阻塞函数 \x3ccode\x3edo_work()\x3c\/code\x3e 为例，这里介绍了它是怎么运行的：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e不在一个回调中直接调用 \x3ccode\x3edo_work()\x3c\/code\x3e ，而是将它打包进一个 “任务”，让线程池去运行这个任务。当任务完成时，我们也为循环去调用它注册一个回调；我们称它为 \x3ccode\x3eon_work_done()\x3c\/code\x3e。\x3c\/li\x3e\n\x3cli\x3e在这个时间点，我们的回调就可以返回了，而事件循环保持运行；在同一时间点，线程池中的有一个线程运行这个任务。\x3c\/li\x3e\n\x3cli\x3e一旦任务运行完成，通知主线程（指正在运行事件循环的线程），并且事件循环调用 \x3ccode\x3eon_work_done()\x3c\/code\x3e。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e让我们看一下，使用 libuv 的工作调度 API，是怎么去解决我们前面的计时器\/睡眠示例中展示的问题的：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs cpp\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eon_after_work\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(\x3cspan class=\x22hljs-keyword\x22\x3euv_work_t\x3c\/span\x3e* req, \x3cspan class=\x22hljs-keyword\x22\x3eint\x3c\/span\x3e status)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3efree\x3c\/span\x3e(req);\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eon_work\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(\x3cspan class=\x22hljs-keyword\x22\x3euv_work_t\x3c\/span\x3e* req)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22Work\x22\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (random() % \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e == \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-built_in\x22\x3eprintf\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22Sleeping...\\n\x22\x3c\/span\x3e);\n    sleep(\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e);\n  }\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eon_timer\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(\x3cspan class=\x22hljs-keyword\x22\x3euv_timer_t\x3c\/span\x3e* timer)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3euint64_t\x3c\/span\x3e timestamp = uv_hrtime();\n  \x3cspan class=\x22hljs-built_in\x22\x3eprintf\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22on_timer [%\x22\x3c\/span\x3e PRIu64 \x3cspan class=\x22hljs-string\x22\x3e\x22 ms]\\n\x22\x3c\/span\x3e, (timestamp \/ \x3cspan class=\x22hljs-number\x22\x3e1000000\x3c\/span\x3e) % \x3cspan class=\x22hljs-number\x22\x3e100000\x3c\/span\x3e);\n\n  \x3cspan class=\x22hljs-keyword\x22\x3euv_work_t\x3c\/span\x3e* work_req = (\x3cspan class=\x22hljs-keyword\x22\x3euv_work_t\x3c\/span\x3e*)\x3cspan class=\x22hljs-built_in\x22\x3emalloc\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3esizeof\x3c\/span\x3e(*work_req));\n  uv_queue_work(uv_default_loop(), work_req, on_work, on_after_work);\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eint\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emain\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(\x3cspan class=\x22hljs-keyword\x22\x3eint\x3c\/span\x3e argc, \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3echar\x3c\/span\x3e** argv)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3euv_timer_t\x3c\/span\x3e timer;\n  uv_timer_init(uv_default_loop(), \x26amp;timer);\n  uv_timer_start(\x26amp;timer, on_timer, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e uv_run(uv_default_loop(), UV_RUN_DEFAULT);\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e通过一个 \x3ccode\x3ework_req\x3c\/code\x3e ^注2 类型的句柄，我们进入一个任务队列，代替在 \x3ccode\x3eon_timer\x3c\/code\x3e 上直接调用 sleep，这个函数在任务中（\x3ccode\x3eon_work\x3c\/code\x3e）运行，并且，一旦任务完成（\x3ccode\x3eon_after_work\x3c\/code\x3e），这个函数被调用一次。\x3ccode\x3eon_work\x3c\/code\x3e 是指 “work”（阻塞中的\/耗时的操作）进行的地方。注意在这两个回调传递到 \x3ccode\x3euv_queue_work\x3c\/code\x3e 时的一个关键区别：\x3ccode\x3eon_work\x3c\/code\x3e 运行在线程池中，而 \x3ccode\x3eon_after_work\x3c\/code\x3e 运行在事件循环中的主线程上 —— 就好像是其它的回调一样。\x3c\/p\x3e\n\x3cp\x3e让我们看一下这种方式的运行：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs prolog\x22\x3e$ .\/uv-timer-work-demo\non_timer [\x3cspan class=\x22hljs-number\x22\x3e89571\x3c\/span\x3e ms]\non_timer [\x3cspan class=\x22hljs-number\x22\x3e90572\x3c\/span\x3e ms]\non_timer [\x3cspan class=\x22hljs-number\x22\x3e91573\x3c\/span\x3e ms]\non_timer [\x3cspan class=\x22hljs-number\x22\x3e92575\x3c\/span\x3e ms]\n\x3cspan class=\x22hljs-symbol\x22\x3eSleeping\x3c\/span\x3e...\non_timer [\x3cspan class=\x22hljs-number\x22\x3e93576\x3c\/span\x3e ms]\non_timer [\x3cspan class=\x22hljs-number\x22\x3e94577\x3c\/span\x3e ms]\n\x3cspan class=\x22hljs-symbol\x22\x3eSleeping\x3c\/span\x3e...\non_timer [\x3cspan class=\x22hljs-number\x22\x3e95577\x3c\/span\x3e ms]\non_timer [\x3cspan class=\x22hljs-number\x22\x3e96578\x3c\/span\x3e ms]\non_timer [\x3cspan class=\x22hljs-number\x22\x3e97578\x3c\/span\x3e ms]\n...\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e即便在 sleep 函数被调用时，定时器也每秒钟滴答一下，睡眠现在运行在一个单独的线程中，并且不会阻塞事件循环。\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22#一个用于练习的素数测试服务器\x22\x3e\x3c\/a\x3e一个用于练习的素数测试服务器\x3c\/h3\x3e\n\x3cp\x3e因为通过睡眠去模拟工作并不是件让人兴奋的事，我有一个事先准备好的更综合的一个示例 —— 一个基于套接字接受来自客户端的数字的服务器，检查这个数字是否是素数，然后去返回一个 “prime\x22 或者 “composite”。完整的 \x3ca href=\x22https:\/\/github.com\/eliben\/code-for-blog\/blob\/master\/2017\/async-socket-server\/uv-isprime-server.c\x22\x3e服务器代码在这里\x3c\/a\x3e —— 我不在这里粘贴了，因为它太长了，更希望读者在一些自己的练习中去体会它。\x3c\/p\x3e\n\x3cp\x3e这个服务器使用了一个原生的素数测试算法，因此，对于大的素数可能花很长时间才返回一个回答。在我的机器中，对于 2305843009213693951，它花了 ~5 秒钟去计算，但是，你的方法可能不同。\x3c\/p\x3e\n\x3cp\x3e练习 1：服务器有一个设置（通过一个名为 \x3ccode\x3eMODE\x3c\/code\x3e 的环境变量）要么在套接字回调（意味着在主线程上）中运行素数测试，要么在 libuv 工作队列中。当多个客户端同时连接时，使用这个设置来观察服务器的行为。当它计算一个大的任务时，在阻塞模式中，服务器将不回复其它客户端，而在非阻塞模式中，它会回复。\x3c\/p\x3e\n\x3cp\x3e练习 2：libuv 有一个缺省大小的线程池，并且线程池的大小可以通过环境变量配置。你可以通过使用多个客户端去实验找出它的缺省值是多少？找到线程池缺省值后，使用不同的设置去看一下，在重负载下怎么去影响服务器的响应能力。\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22#在非阻塞文件系统中使用工作队列\x22\x3e\x3c\/a\x3e在非阻塞文件系统中使用工作队列\x3c\/h3\x3e\n\x3cp\x3e对于只是呆板的演示和 CPU 密集型的计算来说，将可能的阻塞操作委托给一个线程池并不是明智的；libuv 在它的文件系统 API 中本身就大量使用了这种能力。通过这种方式，libuv 使用一个异步 API，以一个轻便的方式显示出它强大的文件系统的处理能力。\x3c\/p\x3e\n\x3cp\x3e让我们使用 \x3ccode\x3euv_fs_read()\x3c\/code\x3e，例如，这个函数从一个文件中（表示为一个 \x3ccode\x3euv_fs_t\x3c\/code\x3e 句柄）读取一个文件到一个缓冲中 ^注3，并且当读取完成后调用一个回调。换句话说，\x3ccode\x3euv_fs_read()\x3c\/code\x3e 总是立即返回，即使是文件在一个类似 NFS 的系统上，而数据到达缓冲区可能需要一些时间。换句话说，这个 API 与这种方式中其它的 libuv API 是异步的。这是怎么工作的呢？\x3c\/p\x3e\n\x3cp\x3e在这一点上，我们看一下 libuv 的底层；内部实际上非常简单，并且它是一个很好的练习。作为一个可移植的库，libuv 对于 Windows 和 Unix 系统在它的许多函数上有不同的实现。我们去看一下在 libuv 源树中的 \x3ccode\x3esrc\/unix\/fs.c\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e这是 \x3ccode\x3euv_fs_read\x3c\/code\x3e 的代码：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs xl\x22\x3eint uv_fs_read(uv_loop_t* \x3cspan class=\x22hljs-keyword\x22\x3eloop\x3c\/span\x3e, uv_fs_t* req,\n               uv_file file,\n               const uv_buf_t bufs[],\n               unsigned int nbufs,\n               int64_t off,\n               uv_fs_cb cb) {\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (bufs == NULL || nbufs == \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e)\n    return -EINVAL;\n\n  INIT(READ);\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3ereq\x3c\/span\x3e-\x26gt;\x3c\/span\x3efile = file;\n\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3ereq\x3c\/span\x3e-\x26gt;\x3c\/span\x3enbufs = nbufs;\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3ereq\x3c\/span\x3e-\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3ebufs\x3c\/span\x3e = req-\x26gt;\x3c\/span\x3ebufsml;\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3eif\x3c\/span\x3e (nbufs \x26gt; ARRAY_SIZE(req-\x26gt;\x3c\/span\x3ebufsml))\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3ereq\x3c\/span\x3e-\x26gt;\x3c\/span\x3ebufs = uv__malloc(nbufs * sizeof(*bufs));\n\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3eif\x3c\/span\x3e (req-\x26gt;\x3c\/span\x3ebufs == NULL) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (cb != NULL)\n      uv__req_unregister(\x3cspan class=\x22hljs-keyword\x22\x3eloop\x3c\/span\x3e, req);\n    return -ENOMEM;\n  }\n\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3ememcpy\x3c\/span\x3e(req-\x26gt;\x3c\/span\x3ebufs, bufs, nbufs * sizeof(*bufs));\n\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3ereq\x3c\/span\x3e-\x26gt;\x3c\/span\x3eoff = off;\n  POST;\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e第一次看可能觉得很困难，因为它延缓真实的工作到 \x3ccode\x3eINIT\x3c\/code\x3e 和 \x3ccode\x3ePOST\x3c\/code\x3e 宏中，以及为 \x3ccode\x3ePOST\x3c\/code\x3e 设置了一些本地变量。这样做可以避免了文件中的许多重复代码。\x3c\/p\x3e\n\x3cp\x3e这是 \x3ccode\x3eINIT\x3c\/code\x3e 宏：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs xl\x22\x3e#define INIT(subtype)                                                         \\\n  \x3cspan class=\x22hljs-keyword\x22\x3edo\x3c\/span\x3e {                                                                        \\\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3ereq\x3c\/span\x3e-\x26gt;\x3c\/span\x3etype = UV_FS;                                                        \\\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (cb != NULL)                                                           \\\n      uv__req_init(\x3cspan class=\x22hljs-keyword\x22\x3eloop\x3c\/span\x3e, req, UV_FS);                                         \\\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3ereq\x3c\/span\x3e-\x26gt;\x3c\/span\x3efs_type = UV_FS_ ## subtype;                                         \\\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3ereq\x3c\/span\x3e-\x26gt;\x3c\/span\x3eresult = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;                                                          \\\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3ereq\x3c\/span\x3e-\x26gt;\x3c\/span\x3eptr = NULL;                                                          \\\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3ereq\x3c\/span\x3e-\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-keyword\x22\x3eloop\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3eloop\x3c\/span\x3e;                                                         \\\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3ereq\x3c\/span\x3e-\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-built_in\x22\x3epath\x3c\/span\x3e = NULL;                                                         \\\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3ereq\x3c\/span\x3e-\x26gt;\x3c\/span\x3enew_path = NULL;                                                     \\\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3ereq\x3c\/span\x3e-\x26gt;\x3c\/span\x3ecb = cb;                                                             \\\n  }                                                                           \\\n  \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e)\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e它设置了请求，并且更重要的是，设置 \x3ccode\x3ereq-\x26gt;fs_type\x3c\/code\x3e 域为真实的 FS 请求类型。因为 \x3ccode\x3euv_fs_read\x3c\/code\x3e 调用 \x3ccode\x3eINIT(READ)\x3c\/code\x3e，它意味着 \x3ccode\x3ereq-\x26gt;fs_type\x3c\/code\x3e 被分配一个常数 \x3ccode\x3eUV_FS_READ\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e这是 \x3ccode\x3ePOST\x3c\/code\x3e 宏：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs livescript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e#define POST                                                                  \\\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3edo\x3c\/span\x3e {                                                                        \x3cspan class=\x22hljs-string\x22\x3e\\\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (cb != NULL) {                                                         \x3cspan class=\x22hljs-string\x22\x3e\\\x3c\/span\x3e\n      uv__work_submit(\x3cspan class=\x22hljs-keyword\x22\x3eloop\x3c\/span\x3e, \x26amp;req-\x26gt;work_req, uv__fs_work, uv__fs_done);        \x3cspan class=\x22hljs-string\x22\x3e\\\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;                                                               \x3cspan class=\x22hljs-string\x22\x3e\\\x3c\/span\x3e\n    }                                                                         \x3cspan class=\x22hljs-string\x22\x3e\\\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {                                                                    \x3cspan class=\x22hljs-string\x22\x3e\\\x3c\/span\x3e\n      uv__fs_work(\x26amp;req-\x26gt;work_req);                                            \x3cspan class=\x22hljs-string\x22\x3e\\\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e req-\x26gt;result;                                                     \x3cspan class=\x22hljs-string\x22\x3e\\\x3c\/span\x3e\n    }                                                                         \x3cspan class=\x22hljs-string\x22\x3e\\\x3c\/span\x3e\n  }                                                                           \x3cspan class=\x22hljs-string\x22\x3e\\\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e)\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e它做什么取决于回调是否为 \x3ccode\x3eNULL\x3c\/code\x3e。在 libuv 文件系统 API 中，一个 \x3ccode\x3eNULL\x3c\/code\x3e 回调意味着我们真实地希望去执行一个 _同步_ 操作。在这种情况下，\x3ccode\x3ePOST\x3c\/code\x3e 直接调用 \x3ccode\x3euv__fs_work\x3c\/code\x3e（我们需要了解一下这个函数的功能），而对于一个非 \x3ccode\x3eNULL\x3c\/code\x3e 回调，它把 \x3ccode\x3euv__fs_work\x3c\/code\x3e 作为一个工作项提交到工作队列（指的是线程池），然后，注册 \x3ccode\x3euv__fs_done\x3c\/code\x3e 作为回调；该函数执行一些登记并调用用户提供的回调。\x3c\/p\x3e\n\x3cp\x3e如果我们去看 \x3ccode\x3euv__fs_work\x3c\/code\x3e 的代码，我们将看到它使用很多宏按照需求将工作分发到实际的文件系统调用。在我们的案例中，对于 \x3ccode\x3eUV_FS_READ\x3c\/code\x3e 这个调用将被 \x3ccode\x3euv__fs_read\x3c\/code\x3e 生成，它（最终）使用普通的 POSIX API 去读取。这个函数可以在一个 _阻塞_ 方式中很安全地实现。因为，它通过异步 API 调用时被置于一个线程池中。\x3c\/p\x3e\n\x3cp\x3e在 Node.js 中，\x3ccode\x3efs.readFile\x3c\/code\x3e 函数是映射到 \x3ccode\x3euv_fs_read\x3c\/code\x3e 上。因此，可以在一个非阻塞模式中读取文件，甚至是当底层文件系统 API 是阻塞方式时。\x3c\/p\x3e\n\x3chr\x3e\n\x3cul\x3e\n\x3cli\x3e注1： 为确保服务器不泄露内存，我在一个启用泄露检查的 Valgrind 中运行它。因为服务器经常是被设计为永久运行，这是一个挑战；为克服这个问题，我在服务器上添加了一个 “kill 开关” —— 一个从客户端接收的特定序列，以使它可以停止事件循环并退出。这个代码在 \x3ccode\x3etheon_wrote_buf\x3c\/code\x3e 句柄中。\x3c\/li\x3e\n\x3cli\x3e注2： 在这里我们不过多地使用 \x3ccode\x3ework_req\x3c\/code\x3e；讨论的素数测试服务器接下来将展示怎么被用于去传递上下文信息到回调中。\x3c\/li\x3e\n\x3cli\x3e注3： \x3ccode\x3euv_fs_read()\x3c\/code\x3e 提供了一个类似于 \x3ccode\x3epreadv\x3c\/code\x3e Linux 系统调用的通用 API：它使用多缓冲区用于排序，并且支持一个到文件中的偏移。基于我们讨论的目的可以忽略这些特性。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3chr\x3e\n\x3cp\x3evia: \x3ca href=\x22https:\/\/eli.thegreenplace.net\/2017\/concurrent-servers-part-4-libuv\/\x22\x3ehttps:\/\/eli.thegreenplace.net\/2017\/concurrent-servers-part-4-libuv\/\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e作者：\x3ca href=\x22https:\/\/eli.thegreenplace.net\/\x22\x3eEli Bendersky\x3c\/a\x3e 译者：\x3ca href=\x22https:\/\/github.com\/qhwdw\x22\x3eqhwdw\x3c\/a\x3e 校对：\x3ca href=\x22https:\/\/github.com\/wxy\x22\x3ewxy\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e本文由 \x3ca href=\x22https:\/\/github.com\/LCTT\/TranslateProject\x22\x3eLCTT\x3c\/a\x3e 原创编译，\x3ca href=\x22https:\/\/linux.cn\/\x22\x3eLinux中国\x3c\/a\x3e 荣誉推出\x3c\/p\x3e\n\n          \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>并发服务器（四）：libuv</p><h2 id="原文链接">原文链接</h2><p><a href="https://www.zcfy.cc/article/concurrent-servers-part-4-libuv">https://www.zcfy.cc/article/concurrent-servers-part-4-libuv</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/vu5d363lynh/" target="_blank">https://alili.tech/archive/vu5d363lynh/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>