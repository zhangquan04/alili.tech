<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="vue2.0源码解读之选项合并策略 optionMergeStrategies"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>vue2.0源码解读之选项合并策略 optionMergeStrategies | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/qkbhncttwlb/",
				"appid": "1613049289050283", 
				"title": "vue2.0源码解读之选项合并策略 optionMergeStrategies | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-02T02:30:11"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/dvp03aedwli/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/fwut2x6q1s/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fqkbhncttwlb%2f&text=vue2.0%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb%e4%b9%8b%e9%80%89%e9%a1%b9%e5%90%88%e5%b9%b6%e7%ad%96%e7%95%a5%20optionMergeStrategies"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fqkbhncttwlb%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fqkbhncttwlb%2f&text=vue2.0%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb%e4%b9%8b%e9%80%89%e9%a1%b9%e5%90%88%e5%b9%b6%e7%ad%96%e7%95%a5%20optionMergeStrategies"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fqkbhncttwlb%2f&title=vue2.0%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb%e4%b9%8b%e9%80%89%e9%a1%b9%e5%90%88%e5%b9%b6%e7%ad%96%e7%95%a5%20optionMergeStrategies"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fqkbhncttwlb%2f&is_video=false&description=vue2.0%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb%e4%b9%8b%e9%80%89%e9%a1%b9%e5%90%88%e5%b9%b6%e7%ad%96%e7%95%a5%20optionMergeStrategies"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=vue2.0%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb%e4%b9%8b%e9%80%89%e9%a1%b9%e5%90%88%e5%b9%b6%e7%ad%96%e7%95%a5%20optionMergeStrategies&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fqkbhncttwlb%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fqkbhncttwlb%2f&title=vue2.0%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb%e4%b9%8b%e9%80%89%e9%a1%b9%e5%90%88%e5%b9%b6%e7%ad%96%e7%95%a5%20optionMergeStrategies"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fqkbhncttwlb%2f&title=vue2.0%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb%e4%b9%8b%e9%80%89%e9%a1%b9%e5%90%88%e5%b9%b6%e7%ad%96%e7%95%a5%20optionMergeStrategies"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fqkbhncttwlb%2f&title=vue2.0%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb%e4%b9%8b%e9%80%89%e9%a1%b9%e5%90%88%e5%b9%b6%e7%ad%96%e7%95%a5%20optionMergeStrategies"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fqkbhncttwlb%2f&title=vue2.0%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb%e4%b9%8b%e9%80%89%e9%a1%b9%e5%90%88%e5%b9%b6%e7%ad%96%e7%95%a5%20optionMergeStrategies"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">vue2.0源码解读之选项合并策略 optionMergeStrategies</h1><div class="meta"><div class="postdate"><time datetime="2019-02-02" itemprop="datePublished">2019-02-02</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e\x3cp\x3e转载请注明出处 \x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000007087912\x22\x3ehttps:\/\/segmentfault.com\/a\/11...\x3c\/a\x3e\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e差不多看了快三周的 Vue 源码，决定写一些东西，记录一下收获，毕竟时间一长，好久不看总会忘的，今天就看看 \x3ccode\x3eoptionMergeStrategies\x3c\/code\x3e。写这篇文章时，Vue 已经发布了2.0.1正式版，但这里讲解的源码是 2.0.0-rc6 ,但基本没什么区别。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eoptionMergeStrategies\x3c\/code\x3e 主要用于 \x3ccode\x3emixin\x3c\/code\x3e 以及 \x3ccode\x3eVue.extend()\x3c\/code\x3e 方法时对于子组件和父组件如果有相同的属性(option)时的合并策略。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3edefaultStrat\x3c\/h2\x3e\n\x3cp\x3e这里先看看默认的合并策略，毕竟之后要用到很多次的。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var defaultStrat = function (parentVal, childVal) {\n  return childVal === undefined\n    ? parentVal\n    : childVal\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e defaultStrat = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eparentVal, childVal\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e childVal === \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e\n    ? parentVal\n    : childVal\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e源代码很简单，传入两个参数 \x3ccode\x3eparentVal\x3c\/code\x3e, \x3ccode\x3echildVal\x3c\/code\x3e 分别对应于父组件和子组件的选项，合并的策略就是，子组件的选项不存在，才会使用父组件的选项，如果子组件的选项存在，使用子组件自身的。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3eoptions.el  options.propsData\x3c\/h2\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option \n * value into the final value.\n * \n * config.optionMergeStrategies: Object.create(null)\n *\/\n \n \/\/ config 是一个全局对象，对应于Vue.config\n \/\/ config.optionMergeStrategies 初始化时是一个空对象\n \/\/ config.optionMergeStrategies = Object.create(null)\nvar strats = config.optionMergeStrategies \n\n\/**\n * Options with restrictions\n *\/\nif (\x26quot;development\x26quot; !== \x27production\x27) {\n  strats.el = strats.propsData = function (parent, child, vm, key) {\n      \/\/ 如果 vm 不存在，报错： key属性用在vm实例上\n    if (!vm) {\n      warn(\n        \x26quot;option \\\x26quot;\x26quot; \x2b key \x2b \x26quot;\\\x26quot; can only be used during instance \x26quot; \x2b\n        \x27creation with the `new` keyword.\x27\n      )\n    }\n    return defaultStrat(parent, child)\n  }\n\n  strats.name = function (parent, child, vm) {\n    if (vm \x26amp;\x26amp; child) {\n      warn(\n        \x27options \x26quot;name\x26quot; can only be used as a component definition option, \x27 \x2b\n        \x27not during instance creation.\x27\n      )\n    }\n    return defaultStrat(parent, child)\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option \n * value into the final value.\n * \n * config.optionMergeStrategies: Object.create(null)\n *\/\x3c\/span\x3e\n \n \x3cspan class=\x22hljs-comment\x22\x3e\/\/ config 是一个全局对象，对应于Vue.config\x3c\/span\x3e\n \x3cspan class=\x22hljs-comment\x22\x3e\/\/ config.optionMergeStrategies 初始化时是一个空对象\x3c\/span\x3e\n \x3cspan class=\x22hljs-comment\x22\x3e\/\/ config.optionMergeStrategies = Object.create(null)\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e strats = config.optionMergeStrategies \n\n\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * Options with restrictions\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-string\x22\x3e\x22development\x22\x3c\/span\x3e !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e) {\n  strats.el = strats.propsData = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eparent, child, vm, key\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果 vm 不存在，报错： key属性用在vm实例上\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!vm) {\n      warn(\n        \x3cspan class=\x22hljs-string\x22\x3e\x22option \\\x22\x22\x3c\/span\x3e \x2b key \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22\\\x22 can only be used during instance \x22\x3c\/span\x3e \x2b\n        \x3cspan class=\x22hljs-string\x22\x3e\x27creation with the `new` keyword.\x27\x3c\/span\x3e\n      )\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e defaultStrat(parent, child)\n  }\n\n  strats.name = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eparent, child, vm\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (vm \x26amp;\x26amp; child) {\n      warn(\n        \x3cspan class=\x22hljs-string\x22\x3e\x27options \x22name\x22 can only be used as a component definition option, \x27\x3c\/span\x3e \x2b\n        \x3cspan class=\x22hljs-string\x22\x3e\x27not during instance creation.\x27\x3c\/span\x3e\n      )\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e defaultStrat(parent, child)\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面可以看出，\x3ccode\x3eel\x3c\/code\x3e , \x3ccode\x3epropsData\x3c\/code\x3e 和 \x3ccode\x3ename\x3c\/code\x3e 的合并策略就是默认的合并策略，即以子组件的选项为主，子组件的选项不存在时，才使用父组件的。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3eoptions.hook\x3c\/h2\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function mergeHook (\n  parentVal,\n  childVal \n) {\n  return childVal\n    ? parentVal \/\/ 如果 childVal存在\n      ? parentVal.concat(childVal) \/\/ 如果parentVal存在，直接合并\n      : Array.isArray(childVal) \/\/ 如果parentVal不存在\n        ? childVal  \/\/ 如果chilidVal是数组，直接返回\n        : [childVal] \/\/ 包装成一个数组返回\n    : parentVal  \/\/ 如果childVal 不存在 直接返回parentVal \n}\n\/\/ strats中添加属性，属性名为生命周期各个钩子\nconfig._lifecycleHooks.forEach(function (hook) {\n  strats[hook] = mergeHook \/\/ 设置每一个钩子函数的合并策略\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs php\x22\x3e\x3ccode class=\x22javscript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emergeHook\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(\n  parentVal,\n  childVal \n)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e childVal\n    ? parentVal \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果 childVal存在\x3c\/span\x3e\n      ? parentVal.concat(childVal) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果parentVal存在，直接合并\x3c\/span\x3e\n      : \x3cspan class=\x22hljs-keyword\x22\x3eArray\x3c\/span\x3e.isArray(childVal) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果parentVal不存在\x3c\/span\x3e\n        ? childVal  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果chilidVal是数组，直接返回\x3c\/span\x3e\n        : [childVal] \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 包装成一个数组返回\x3c\/span\x3e\n    : parentVal  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果childVal 不存在 直接返回parentVal \x3c\/span\x3e\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ strats中添加属性，属性名为生命周期各个钩子\x3c\/span\x3e\nconfig._lifecycleHooks.\x3cspan class=\x22hljs-keyword\x22\x3eforEach\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(hook)\x3c\/span\x3e \x3c\/span\x3e{\n  strats[hook] = mergeHook \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 设置每一个钩子函数的合并策略\x3c\/span\x3e\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果父组件和子组件都设置了钩子函数选项，那么 它们会合并到一个数组里，而且父组件的钩子函数会先执行，最后返回一个合并后的数组。具体见源码里的注释。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3eoptions.components  options.directives  options.filters\x3c\/h2\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/**\n * Assets \/\/ components,directives,filters\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n *\/\nfunction mergeAssets (parentVal, childVal) { \/\/ parentVal: Object childVal: Object\n  var res = Object.create(parentVal || null) \/\/ 原型委托\n  return childVal\n    ? extend(res, childVal)\n    : res\n}\n\nconfig._assetTypes.forEach(function (type) {\n  strats[type \x2b \x27s\x27] = mergeAssets\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * Assets \/\/ components,directives,filters\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emergeAssets\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eparentVal, childVal\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-comment\x22\x3e\/\/ parentVal: Object childVal: Object\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e res = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.create(parentVal || \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 原型委托\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e childVal\n    ? extend(res, childVal)\n    : res\n}\n\nconfig._assetTypes.forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3etype\x3c\/span\x3e) \x3c\/span\x3e{\n  strats[type \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27s\x27\x3c\/span\x3e] = mergeAssets\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e对于 \x3ccode\x3eassets\x3c\/code\x3e 也就是 \x3ccode\x3ecomponents\x3c\/code\x3e, \x3ccode\x3edirectives\x3c\/code\x3e, \x3ccode\x3efilters\x3c\/code\x3e 合并的策略就是返回一个合并后的新对象，新对象的自有属性全部来自 \x3ccode\x3echildVal\x3c\/code\x3e, 但是通过\x3cstrong\x3e原型链委托\x3c\/strong\x3e在了 \x3ccode\x3eparentVal\x3c\/code\x3e 上。\x3c\/p\x3e\n\x3cp\x3e这里顺便提提在一个对象里查找属性的规则。举个例子，当查找一个属性时，如 obj[a] ,如果 obj 没有 a 这个属性，那么将会在 obj 对象的原型里找，如果还没有，在原型的原型上找，直到原型链的尽头，如果还没有找到，返回 undefined。\x3c\/p\x3e\n\x3cp\x3e因此这里同样一个道理，在 res 对象里查找某个 component 或 directive , 首先会找 childVal里的，如果没有，才会沿着原型链向上，找 parentVal中对应的属性。事实上，和 defaultStrat 一个道理。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3eoptions.props  options.methods  options.computed\x3c\/h2\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22strats.props =\nstrats.methods =\nstrats.computed = function (parentVal, childVal) { \/\/ parentVal: Object childVal: Object\n  if (!childVal) return parentVal\n  if (!parentVal) return childVal\n  var ret = Object.create(null)\n  extend(ret, parentVal)\n  extend(ret, childVal)  \/\/  child的会覆盖parent的\n  return ret\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3estrats.props =\nstrats.methods =\nstrats.computed = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eparentVal, childVal\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-comment\x22\x3e\/\/ parentVal: Object childVal: Object\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!childVal) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e parentVal\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!parentVal) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e childVal\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e ret = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.create(\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e)\n  extend(ret, parentVal)\n  extend(ret, childVal)  \x3cspan class=\x22hljs-comment\x22\x3e\/\/  child的会覆盖parent的\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e ret\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e同样来看源码，函数解构同样返回一个新的 res 对象，同样适用了 extend 方法拓展了 res 对象。但是要注意的是，先拓展的是 parentVal 对象，然后再拓展 childVal对象，这就意味着当拓展 chilidVal 对象的时候，如果 childVal中有 parentVal 的同名属性时，将会直接覆盖掉。这里顺便贴一下 extend  方法的源码\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/**\n * Mix properties into target object.\n *\/\nfunction extend (to, _from) {\n  for (var key in _from) {\n    to[key] = _from[key]\n  }\n  return to \n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * Mix properties into target object.\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eextend\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eto, _from\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e key \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e _from) {\n    to[key] = _from[key]\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e to \n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3eoptions.watch\x3c\/h2\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/**\n * Watchers.\n *\n * Watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n * 不应该重写（覆盖）,应该保存在一个数组里\n *\/\nstrats.watch = function (parentVal, childVal) { \n  \/* istanbul ignore if *\/\n  if (!childVal) return parentVal\n  if (!parentVal) return childVal\n  var ret = {}\n  extend(ret, parentVal) \/\/ ret首先获得parentVal的全部属性\n  for (var key in childVal) {\n    var parent = ret[key] \/\/ 子组件的某个watcher在父组件中的值\n    var child = childVal[key]\n    if (parent \x26amp;\x26amp; !Array.isArray(parent)) {\n      parent = [parent] \/\/ 如果parent不是一个数组，将其包装成一个数组\n    }\n    ret[key] = parent\n      ? parent.concat(child) \/\/ parent在前，child在后\n      : [child] \/\/ 如果在父组件中不存在，以数组的形式存储子组件的watcher\n  }\n  return ret\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * Watchers.\n *\n * Watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n * 不应该重写（覆盖）,应该保存在一个数组里\n *\/\x3c\/span\x3e\nstrats.watch = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eparentVal, childVal\x3c\/span\x3e) \x3c\/span\x3e{ \n  \x3cspan class=\x22hljs-comment\x22\x3e\/* istanbul ignore if *\/\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!childVal) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e parentVal\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!parentVal) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e childVal\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e ret = {}\n  extend(ret, parentVal) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ret首先获得parentVal的全部属性\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e key \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e childVal) {\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e parent = ret[key] \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 子组件的某个watcher在父组件中的值\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e child = childVal[key]\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (parent \x26amp;\x26amp; !\x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.isArray(parent)) {\n      parent = [parent] \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果parent不是一个数组，将其包装成一个数组\x3c\/span\x3e\n    }\n    ret[key] = parent\n      ? parent.concat(child) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ parent在前，child在后\x3c\/span\x3e\n      : [child] \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果在父组件中不存在，以数组的形式存储子组件的watcher\x3c\/span\x3e\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e ret\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e子组件和父组件的watchers不应该覆盖，而是应该把它们都合并在一个数组里。这里同样是父组件的在前，子组件的在后。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3eoptions.data\x3c\/h2\x3e\n\x3cp\x3edata 是个重头戏，也是整个合并策略中最复杂的，这是因为，在组件中data是以函数的形式存在的。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/*\n *\n *\/\nstrats.data = function (\n  parentVal,\n  childVal,\n  vm \/\/ 如果传入了vm，那么它表示的是组件的根实例\n) {\n  if (!vm) { \/\/ 如果没传入\n    \/\/ in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal\n    }\n    if (typeof childVal !== \x27function\x27) {  \/\/ 在组件中定义data 必须是一个函数\n      \x26quot;development\x26quot; !== \x27production\x27 \x26amp;\x26amp; warn(\n        \x27The \x26quot;data\x26quot; option should be a function \x27 \x2b\n        \x27that returns a per-instance value in component \x27 \x2b\n        \x27definitions.\x27,\n        vm\n      )\n      return parentVal \/\/ 报完错，返回parentVal的data\n    }\n    if (!parentVal) {\n      return childVal \/\/ parentVal不存在，返回 childVal的data\n    }\n    \/\/ when parentVal \x26amp; childVal are both present,\n    \/\/ we need to return a function that returns the\n    \/\/ merged result of both functions... no need to\n    \/\/ check if parentVal is a function here because\n    \/\/ it has to be a function to pass previous merges.\n    \/\/ 这里返回的应该是一个函数，函数返回结果是合并后的data对象\n    return function mergedDataFn () {\n      return mergeData(\n        childVal.call(this),\n        parentVal.call(this)\n      )\n    }\n  } else if (parentVal || childVal) { \/\/ 如果提供了vm实例\n    return function mergedInstanceDataFn () { \/\/ 同样返回一个函数\n      \/\/ instance merge\n      var instanceData = typeof childVal === \x27function\x27\n        ? childVal.call(vm)\n        : childVal\n      var defaultData = typeof parentVal === \x27function\x27\n        ? parentVal.call(vm)\n        : undefined \/\/ 如果parentVal不是函数，则抛弃。\n      if (instanceData) {\n        return mergeData(instanceData, defaultData)\n      } else {\n        return defaultData\n      }\n    }\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode class=\x22javacript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/*\n *\n *\/\x3c\/span\x3e\nstrats.data = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(\n  parentVal,\n  childVal,\n  vm \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果传入了vm，那么它表示的是组件的根实例\x3c\/span\x3e\n)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!vm) { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果没传入\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ in a Vue.extend merge, both should be functions\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!childVal) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e parentVal\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e childVal !== \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e) {  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 在组件中定义data 必须是一个函数\x3c\/span\x3e\n      \x3cspan class=\x22hljs-string\x22\x3e\x22development\x22\x3c\/span\x3e !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e \x26amp;\x26amp; warn(\n        \x3cspan class=\x22hljs-string\x22\x3e\x27The \x22data\x22 option should be a function \x27\x3c\/span\x3e \x2b\n        \x3cspan class=\x22hljs-string\x22\x3e\x27that returns a per-instance value in component \x27\x3c\/span\x3e \x2b\n        \x3cspan class=\x22hljs-string\x22\x3e\x27definitions.\x27\x3c\/span\x3e,\n        vm\n      )\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e parentVal \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 报完错，返回parentVal的data\x3c\/span\x3e\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!parentVal) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e childVal \x3cspan class=\x22hljs-comment\x22\x3e\/\/ parentVal不存在，返回 childVal的data\x3c\/span\x3e\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ when parentVal \x26amp; childVal are both present,\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ we need to return a function that returns the\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ merged result of both functions... no need to\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ check if parentVal is a function here because\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ it has to be a function to pass previous merges.\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里返回的应该是一个函数，函数返回结果是合并后的data对象\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emergedDataFn\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e mergeData(\n        childVal.call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e),\n        parentVal.call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e)\n      )\n    }\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (parentVal || childVal) { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果提供了vm实例\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emergedInstanceDataFn\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{ \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 同样返回一个函数\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ instance merge\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e instanceData = \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e childVal === \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e\n        ? childVal.call(vm)\n        : childVal\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e defaultData = \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e parentVal === \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e\n        ? parentVal.call(vm)\n        : \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果parentVal不是函数，则抛弃。\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (instanceData) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e mergeData(instanceData, defaultData)\n      } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e defaultData\n      }\n    }\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/**\n * Helper that recursively merges two data objects together.\n * 合并规则：\n * 1. 如果from中的某个属性to中有，保留to中的，什么都不做。\n * 2. 如果to中没有，赋值。\n * 3. 如果to中和from中的某个属性值都是对象，递归调用。\n *\/\nfunction mergeData (to, from) { \n  var key, toVal, fromVal\n  for (key in from) {\n    toVal = to[key]\n    fromVal = from[key]\n    if (!hasOwn(to, key)) {\n      set(to, key, fromVal) \/\/ 设置to[key] = fromVal\n    } else if (isObject(toVal) \x26amp;\x26amp; isObject(fromVal)) {\n      mergeData(toVal, fromVal)  \/\/ 如果对应的值都是对象，则递归合并。\n    }\n  }\n  return to\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * Helper that recursively merges two data objects together.\n * 合并规则：\n * 1. 如果from中的某个属性to中有，保留to中的，什么都不做。\n * 2. 如果to中没有，赋值。\n * 3. 如果to中和from中的某个属性值都是对象，递归调用。\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emergeData\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eto, from\x3c\/span\x3e) \x3c\/span\x3e{ \n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e key, toVal, fromVal\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (key \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e) {\n    toVal = to[key]\n    fromVal = \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e[key]\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!hasOwn(to, key)) {\n      set(to, key, fromVal) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 设置to[key] = fromVal\x3c\/span\x3e\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isObject(toVal) \x26amp;\x26amp; isObject(fromVal)) {\n      mergeData(toVal, fromVal)  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果对应的值都是对象，则递归合并。\x3c\/span\x3e\n    }\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e to\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e代码中注释都写得很清楚了，这里就不多说了。 Vue 中对于 data 属性的合并就是执行 parentVal 和 childVal 的函数，然后再合并函数返回的对象。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3e自定义合并策略\x3c\/h2\x3e\n\x3cp\x3e以上所说的都是 Vue 自定义的合并的策略，当然你也可以自定义某个选项的合并策略。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Vue.config.optionMergeStrategies.myOption = function (toVal, fromVal) {\n  \/\/ return mergedVal\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eVue.config.optionMergeStrategies.myOption = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3etoVal, fromVal\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ return mergedVal\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e比如想要修改 watch的合并策略\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Vue.config.optionMergeStrategies.watch = function (toVal, fromVal) {\n  \/\/ return mergedVal\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eVue.config.optionMergeStrategies.watch = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3etoVal, fromVal\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ return mergedVal\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e至于传入的函数参数，可以参考之前讲解的源码。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e全文完\x3c\/p\x3e\x3c\/blockquote\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>vue2.0源码解读之选项合并策略 optionMergeStrategies</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000007087912">https://segmentfault.com/a/1190000007087912</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/qkbhncttwlb/" target="_blank">https://alili.tech/archive/qkbhncttwlb/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>