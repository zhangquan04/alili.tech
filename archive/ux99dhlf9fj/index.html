<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="JavaScript中this的运行机制及爬坑指南"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>JavaScript中this的运行机制及爬坑指南 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/ux99dhlf9fj/",
				"appid": "1613049289050283", 
				"title": "JavaScript中this的运行机制及爬坑指南 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-24T02:30:11"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/5g14c034ihw/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/b5thnqii2yf/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fux99dhlf9fj%2f&text=JavaScript%e4%b8%adthis%e7%9a%84%e8%bf%90%e8%a1%8c%e6%9c%ba%e5%88%b6%e5%8f%8a%e7%88%ac%e5%9d%91%e6%8c%87%e5%8d%97"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fux99dhlf9fj%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fux99dhlf9fj%2f&text=JavaScript%e4%b8%adthis%e7%9a%84%e8%bf%90%e8%a1%8c%e6%9c%ba%e5%88%b6%e5%8f%8a%e7%88%ac%e5%9d%91%e6%8c%87%e5%8d%97"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fux99dhlf9fj%2f&title=JavaScript%e4%b8%adthis%e7%9a%84%e8%bf%90%e8%a1%8c%e6%9c%ba%e5%88%b6%e5%8f%8a%e7%88%ac%e5%9d%91%e6%8c%87%e5%8d%97"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fux99dhlf9fj%2f&is_video=false&description=JavaScript%e4%b8%adthis%e7%9a%84%e8%bf%90%e8%a1%8c%e6%9c%ba%e5%88%b6%e5%8f%8a%e7%88%ac%e5%9d%91%e6%8c%87%e5%8d%97"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=JavaScript%e4%b8%adthis%e7%9a%84%e8%bf%90%e8%a1%8c%e6%9c%ba%e5%88%b6%e5%8f%8a%e7%88%ac%e5%9d%91%e6%8c%87%e5%8d%97&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fux99dhlf9fj%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fux99dhlf9fj%2f&title=JavaScript%e4%b8%adthis%e7%9a%84%e8%bf%90%e8%a1%8c%e6%9c%ba%e5%88%b6%e5%8f%8a%e7%88%ac%e5%9d%91%e6%8c%87%e5%8d%97"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fux99dhlf9fj%2f&title=JavaScript%e4%b8%adthis%e7%9a%84%e8%bf%90%e8%a1%8c%e6%9c%ba%e5%88%b6%e5%8f%8a%e7%88%ac%e5%9d%91%e6%8c%87%e5%8d%97"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fux99dhlf9fj%2f&title=JavaScript%e4%b8%adthis%e7%9a%84%e8%bf%90%e8%a1%8c%e6%9c%ba%e5%88%b6%e5%8f%8a%e7%88%ac%e5%9d%91%e6%8c%87%e5%8d%97"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fux99dhlf9fj%2f&title=JavaScript%e4%b8%adthis%e7%9a%84%e8%bf%90%e8%a1%8c%e6%9c%ba%e5%88%b6%e5%8f%8a%e7%88%ac%e5%9d%91%e6%8c%87%e5%8d%97"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">JavaScript中this的运行机制及爬坑指南</h1><div class="meta"><div class="postdate"><time datetime="2019-01-24" itemprop="datePublished">2019-01-24</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n            \x3cp\x3e在 JavaScript 中，this 这个特殊的变量是相对比较复杂的，因为 this 不仅仅用在面向对象环境中，在其他任何地方也是可用的。 本篇博文中会解释 this 是如何工作的以及使用中可能导致问题的地方，最后奉上最佳实践。\x3c\/p\x3e\n\x3cp\x3e为了更好理解 this，将 this 使用的场景分成三类：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3e在函数内部\x3c\/strong\x3e this 一个额外的，通常是隐含的参数。\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3e在函数外部（顶级作用域中）：\x3c\/strong\x3e 这指的是浏览器中的全局对象或者 Node.js 中一个模块的输出。\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3e在传递给eval()的字符串中：\x3c\/strong\x3e eval() 或者获取 this 当前值值，或者将其设置为全局对象，取决于 this 是直接调用还是间接调用。\x3c\/p\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e我们来看看每个类别。\x3c\/p\x3e\n\x3ch2\x3ethis 在函数中\x3c\/h2\x3e\n\x3cp\x3e这是最常用的 this 使用方式，函数通过扮演三种不同的角色来表示 JavaScript 中的所有可调用结构体：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e普通函数（this 在非严格模式下为全局对象，在严格模式下为undefined）\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e构造函数（this 指向新创建的实例）\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e方法（this 是指方法调用的接收者）\x3c\/p\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e在函数中，this 通常被认为是一个额外的，隐含的参数。\x3c\/p\x3e\n\x3ch3\x3ethis 在普通函数中\x3c\/h3\x3e\n\x3cp\x3e在普通函数中，this 的值取决于\x3ca href=\x22http:\/\/speakingjs.com\/es5\/ch07.html#strict_mode\x22\x3e模式\x3c\/a\x3e：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e非严格模式： this 是指向\x3ca href=\x22http:\/\/speakingjs.com\/es5\/ch16.html#global_object\x22\x3e全局对象\x3c\/a\x3e （在浏览器中为window对象）。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e        \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3esloppyFunc\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n            \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e === \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\n        }\n        sloppyFunc();\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cul\x3e\n\x3cli\x3e严格模式： this 的值为 undefined。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e        \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3estrictFunc\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n\x3cspan class=\x22hljs-meta\x22\x3e            \x27use strict\x27\x3c\/span\x3e;\n            \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e === \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\n        }\n        strictFunc();\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e也就是说，this 是一个设定了默认值（window或undefined）的隐式参数。 但是，可以通过 call() 或 apply() 进行函数调用，并明确指定this的值：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs autoit\x22\x3e    function \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunc\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(arg1, arg2)\x3c\/span\x3e {\x3c\/span\x3e\n        console.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(this)\x3cspan class=\x22hljs-comment\x22\x3e; \/\/ a\x3c\/span\x3e\n        console.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(arg1)\x3cspan class=\x22hljs-comment\x22\x3e; \/\/ b\x3c\/span\x3e\n        console.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(arg2)\x3cspan class=\x22hljs-comment\x22\x3e; \/\/ c\x3c\/span\x3e\n    }\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunc\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3ecall\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27a\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27b\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27c\x27\x3c\/span\x3e)\x3c\/span\x3e; \/\/ \x3cspan class=\x22hljs-params\x22\x3e(this, arg1, arg2)\x3c\/span\x3e\x3c\/span\x3e\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunc\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eapply\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27a\x27\x3c\/span\x3e, [\x3cspan class=\x22hljs-string\x22\x3e\x27b\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27c\x27\x3c\/span\x3e])\x3c\/span\x3e; \/\/ \x3cspan class=\x22hljs-params\x22\x3e(this, arrayWithArgs)\x3c\/span\x3e\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3ch3\x3ethis 在构造函数中\x3c\/h3\x3e\n\x3cp\x3e如果通过new运算符调用函数，则函数将成为构造函数。 该运算符创建一个新的对象，并通过它通过this传递给构造函数：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e savedThis;\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eConstr\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        savedThis = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e inst = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Constr();\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(savedThis === inst); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e在JavaScript中实现，new运算符大致如下所示（更精确的实现\x3ca href=\x22http:\/\/speakingjs.com\/es5\/ch17.html#_the_new_operator_implemented_in_javascript\x22\x3e稍微复杂一点\x3c\/a\x3e）：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3enewOperator\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eConstr, arrayWithArgs\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e thisValue = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.create(Constr.prototype);\n        Constr.apply(thisValue, arrayWithArgs);\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e thisValue;\n    }\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3ch3\x3ethis 在方法中\x3c\/h3\x3e\n\x3cp\x3e在方法中，类似于传统的面向对象的语言：this指向\x3cem\x3e接受者\x3c\/em\x3e，方法被调用的对象。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj = {\n        \x3cspan class=\x22hljs-attr\x22\x3emethod\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n            \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e === obj); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\n        }\n    }\n    obj.method();\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3ch2\x3ethis 在顶级作用域中\x3c\/h2\x3e\n\x3cp\x3e在浏览器中，顶层作用域是全局作用域，它指向\x3ca href=\x22http:\/\/speakingjs.com\/es5\/ch16.html#global_object\x22\x3eglobal object\x3c\/a\x3e（如window）：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs coffeescript\x22\x3e        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e === \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e); \x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e在Node.js中，通常在模块中执行代码。 因此，顶级作用域是一个特殊的\x3cem\x3e模块作用域\x3c\/em\x3e：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs coffeescript\x22\x3e    \x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e `\x3cspan class=\x22javascript\x22\x3eglobal\x3c\/span\x3e` (不是 `\x3cspan class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e\x3c\/span\x3e`) 指全局对象:\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(Math === \x3cspan class=\x22hljs-built_in\x22\x3eglobal\x3c\/span\x3e.Math); \x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n\n    \x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e `\x3cspan class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e\x3c\/span\x3e` 不指向全局对象:\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e !== \x3cspan class=\x22hljs-built_in\x22\x3eglobal\x3c\/span\x3e); \x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n    \x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e `\x3cspan class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e\x3c\/span\x3e` refers to a \x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e’s exports:\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e === \x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports); \x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3ch2\x3ethis 在 eval() 中\x3c\/h2\x3e\n\x3cp\x3eeval() 可以被_直接\x3cem\x3e（通过真正的函数调用）或\x3c\/em\x3e间接_（通过其他方式）。 详细解释在\x3ca href=\x22http:\/\/speakingjs.com\/es5\/ch23.html#_indirect_eval_evaluates_in_global_scope\x22\x3e这里\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3e如果间接调用evaleval() ，则this指向\x3ca href=\x22http:\/\/speakingjs.com\/es5\/ch16.html#global_object\x22\x3e全局对象\x3c\/a\x3e：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs clojure\x22\x3e    (\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,eval)(\x3cspan class=\x22hljs-name\x22\x3e\x27this\x3c\/span\x3e === window\x27)\n    \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e否则，如果直接调用eval() ，则this与eval()的环境中保持一致。 例如：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 普通函数\x3c\/span\x3e\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3esloppyFunc\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-built_in\x22\x3eeval\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27this\x27\x3c\/span\x3e) === \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\n    }\n    sloppyFunc();\n\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3estrictFunc\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n\x3cspan class=\x22hljs-meta\x22\x3e        \x27use strict\x27\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-built_in\x22\x3eeval\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27this\x27\x3c\/span\x3e) === \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\n    }\n    strictFunc();\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 构造器\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e savedThis;\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eConstr\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        savedThis = \x3cspan class=\x22hljs-built_in\x22\x3eeval\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27this\x27\x3c\/span\x3e);\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e inst = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Constr();\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(savedThis === inst); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 方法\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj = {\n        \x3cspan class=\x22hljs-attr\x22\x3emethod\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n            \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-built_in\x22\x3eeval\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27this\x27\x3c\/span\x3e) === obj); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\n        }\n    }\n    obj.method();\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3ch2\x3e与this相关的陷阱\x3c\/h2\x3e\n\x3cp\x3e有三个你需要知道的与this相关的陷阱。请注意，在各种情况下，\x3ca href=\x22http:\/\/speakingjs.com\/es5\/ch07.html#strict_mode\x22\x3e严格模式\x3c\/a\x3e更安全，因为this在普通函数中为undefined，并且会在出现问题时警告。\x3c\/p\x3e\n\x3ch3\x3e陷阱：忘记new操作符\x3c\/h3\x3e\n\x3cp\x3e如果你调用一个构造函数时忘记了new操作符，那么你意外地将this用在一个普通的函数。this会没有正确的值。 在非严格模式下，this指向window对象，你将创建全局变量：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePoint\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ex, y\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.x = x;\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.y = y;\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e p = Point(\x3cspan class=\x22hljs-number\x22\x3e7\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 忘记new!\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(p === \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建了全局变量：\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(x); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 7\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(y); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 5\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e幸运的，在严格模式下会得到警告（this === undefined）：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePoint\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ex, y\x3c\/span\x3e) \x3c\/span\x3e{\n\x3cspan class=\x22hljs-meta\x22\x3e        \x27use strict\x27\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.x = x;\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.y = y;\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e p = Point(\x3cspan class=\x22hljs-number\x22\x3e7\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ TypeError: Cannot set property \x27x\x27 of undefined\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3ch3\x3e陷阱：不正确地提取方法\x3c\/h3\x3e\n\x3cp\x3e如果获取方法的值（不是调用它），则可以将该方法转换为函数。 调用该值将导致函数调用，而不是方法调用。 当将方法作为函数或方法调用的参数传递时，可能会发生这种提取。 实际例子包括setTimeout()和事件注册处理程序。 我将使用函数callItt() 来模拟此用例：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs swift\x22\x3e    \x3cspan class=\x22hljs-comment\x22\x3e\/**类似setTimeout() 和 setImmediate() *\/\x3c\/span\x3e\n    function callIt(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunc\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunc\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e;\n    }\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e如果在非严格模式下把一个方法作为函数来调用，那么this将指向\x3ca href=\x22http:\/\/speakingjs.com\/es5\/ch16.html#global_object\x22\x3e全局对象\x3c\/a\x3e并创建全局变量：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e counter = {\n        \x3cspan class=\x22hljs-attr\x22\x3ecount\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Sloppy-mode method\x3c\/span\x3e\n        inc: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.count\x2b\x2b;\n        }\n    }\n\n    callIt(counter.inc);\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Didn’t work:\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(counter.count); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 0\x3c\/span\x3e\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Instead, a global variable has been created\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ (NaN is result of applying \x2b\x2b to undefined):\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(count);  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ NaN\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e如果在严格模式下把一个方法作为函数来调用，this为undefined。 同时会得到一个警告：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e counter = {\n        \x3cspan class=\x22hljs-attr\x22\x3ecount\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Strict-mode method\x3c\/span\x3e\n        inc: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n\x3cspan class=\x22hljs-meta\x22\x3e            \x27use strict\x27\x3c\/span\x3e;\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.count\x2b\x2b;\n        }\n    }\n\n    callIt(counter.inc);\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ TypeError: Cannot read property \x27count\x27 of undefined\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(counter.count);\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e修正方法是使用[bind()]（\x3ca href=\x22http:\/\/speakingjs.com\/es5\/ch17.html#Function.prototype.bind）：\x22\x3ehttp:\/\/speakingjs.com\/es5\/ch17.html#Function.prototype.bind）：\x3c\/a\x3e\nThe fix is to use \x3ca href=\x22http:\/\/speakingjs.com\/es5\/ch17.html#Function.prototype.bind\x22\x3ebind()\x3c\/a\x3e:\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e counter = {\n        \x3cspan class=\x22hljs-attr\x22\x3ecount\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3einc\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.count\x2b\x2b;\n        }\n    }\n\n    callIt(counter.inc.bind(counter));\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 成功了!\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(counter.count); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 1\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3ebind()创建了一个新的函数，它总是接收一个指向counter的this。\x3c\/p\x3e\n\x3ch3\x3e陷阱：shadowing this\x3c\/h3\x3e\n\x3cp\x3e当在一个方法中使用普通函数时，很容易忘记前者具有其自己this（即使其不需要this）。 因此，你不能从前者引用该方法的this，因为该this会被遮蔽。 让我们看看出现问题的例子：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj = {\n        \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Jane\x27\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3efriends\x3c\/span\x3e: [ \x3cspan class=\x22hljs-string\x22\x3e\x27Tarzan\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27Cheeta\x27\x3c\/span\x3e ],\n        \x3cspan class=\x22hljs-attr\x22\x3eloop\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n\x3cspan class=\x22hljs-meta\x22\x3e            \x27use strict\x27\x3c\/span\x3e;\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.friends.forEach(\n                \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3efriend\x3c\/span\x3e) \x3c\/span\x3e{\n                    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name\x2b\x3cspan class=\x22hljs-string\x22\x3e\x27 knows \x27\x3c\/span\x3e\x2bfriend);\n                }\n            );\n        }\n    };\n    obj.loop();\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ TypeError: Cannot read property \x27name\x27 of undefined\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e在前面的例子中，获取this.name失败，因为函数的this个是undefined，它与方法loop()的不同。 有三种方法可以修正this。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e修正1：\x3c\/strong\x3e that = this。 将它分配给一个没有被遮蔽的变量（另一个流行名称是self）并使用该变量。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e    loop: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n\x3cspan class=\x22hljs-meta\x22\x3e        \x27use strict\x27\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e that = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.friends.forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3efriend\x3c\/span\x3e) \x3c\/span\x3e{\n            \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(that.name\x2b\x3cspan class=\x22hljs-string\x22\x3e\x27 knows \x27\x3c\/span\x3e\x2bfriend);\n        });\n    }\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e\x3cstrong\x3e修正2：\x3c\/strong\x3e bind()。 使用bind()来创建一个this总是指向正确值的函数（在下面的例子中该方法的this）。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e    loop: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n\x3cspan class=\x22hljs-meta\x22\x3e        \x27use strict\x27\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.friends.forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3efriend\x3c\/span\x3e) \x3c\/span\x3e{\n            \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name\x2b\x3cspan class=\x22hljs-string\x22\x3e\x27 knows \x27\x3c\/span\x3e\x2bfriend);\n        }.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e));\n    }\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e\x3cstrong\x3e修正3：\x3c\/strong\x3e forEach的第二个参数。 此方法具有第二个参数，this值将作为此值传递给回调函数。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e    loop: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n\x3cspan class=\x22hljs-meta\x22\x3e        \x27use strict\x27\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.friends.forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3efriend\x3c\/span\x3e) \x3c\/span\x3e{\n            \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name\x2b\x3cspan class=\x22hljs-string\x22\x3e\x27 knows \x27\x3c\/span\x3e\x2bfriend);\n        }, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n    }\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3ch2\x3e最佳实践\x3c\/h2\x3e\n\x3cp\x3e从概念上讲，我认为普通函数没有它自己的this，并且想到上述修复是为了保持这种想法。 ECMAScript 6通过[\x3cem\x3e箭头函数\x3c\/em\x3e]（\x3ca href=\x22http:\/\/2ality.com\/2012\/04\/arrow-functions.html）支持这种方法\x22\x3ehttp:\/\/2ality.com\/2012\/04\/arrow-functions.html）支持这种方法\x3c\/a\x3e - 没有它们自己的this。 在这样的函数里面，你可以自由使用this，因为不会被屏蔽：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e    loop: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n\x3cspan class=\x22hljs-meta\x22\x3e        \x27use strict\x27\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ The parameter of forEach() is an arrow function\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.friends.forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3efriend\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ `this` is loop’s `this`\x3c\/span\x3e\n            \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name\x2b\x3cspan class=\x22hljs-string\x22\x3e\x27 knows \x27\x3c\/span\x3e\x2bfriend);\n        });\n    }\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e我不喜欢使用this作为普通函数的附加参数的API：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs actionscript\x22\x3e    beforeEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{  \n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.addMatchers({  \n            toBeInRange: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(start, end)\x3c\/span\x3e \x3c\/span\x3e{  \n                ...\n            }  \n        });  \n    });\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e将这样的隐含参数变成明确的参数使得事情更加明显，并且与箭头函数兼容。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs lisp\x22\x3e    beforeEach(\x3cspan class=\x22hljs-name\x22\x3eapi\x3c\/span\x3e =\x26gt; {\n        api.addMatchers({\n            toBeInRange(\x3cspan class=\x22hljs-name\x22\x3estart\x3c\/span\x3e, end) {\n                ...\n            }\n        })\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n    })\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\n          \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>JavaScript中this的运行机制及爬坑指南</p><h2 id="原文链接">原文链接</h2><p><a href="https://www.zcfy.cc/article/javascript-s-this-how-it-works-where-it-can-trip-you-up">https://www.zcfy.cc/article/javascript-s-this-how-it-works-where-it-can-trip-you-up</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/ux99dhlf9fj/" target="_blank">https://alili.tech/archive/ux99dhlf9fj/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>