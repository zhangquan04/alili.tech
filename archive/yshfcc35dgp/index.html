<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="浅析 React 生命周期"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>浅析 React 生命周期 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/yshfcc35dgp/",
				"appid": "1613049289050283", 
				"title": "浅析 React 生命周期 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-26T02:30:18"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/kua59l3f1qo/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/id4zuqtn0q/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fyshfcc35dgp%2f&text=%e6%b5%85%e6%9e%90%20React%20%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fyshfcc35dgp%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fyshfcc35dgp%2f&text=%e6%b5%85%e6%9e%90%20React%20%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fyshfcc35dgp%2f&title=%e6%b5%85%e6%9e%90%20React%20%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fyshfcc35dgp%2f&is_video=false&description=%e6%b5%85%e6%9e%90%20React%20%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e6%b5%85%e6%9e%90%20React%20%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fyshfcc35dgp%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fyshfcc35dgp%2f&title=%e6%b5%85%e6%9e%90%20React%20%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fyshfcc35dgp%2f&title=%e6%b5%85%e6%9e%90%20React%20%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fyshfcc35dgp%2f&title=%e6%b5%85%e6%9e%90%20React%20%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fyshfcc35dgp%2f&title=%e6%b5%85%e6%9e%90%20React%20%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">浅析 React 生命周期</h1><div class="meta"><div class="postdate"><time datetime="2019-01-26" itemprop="datePublished">2019-01-26</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch3 id=\x22articleHeader0\x22\x3eOverview\x3c\/h3\x3e\n\x3cp\x3e最近常有学习React相关的技术，写了几个React的小Demo，使用 \x3ccode\x3eReact\/Express\x3c\/code\x3e 技术栈。实在太小，羞于拿出来细说。React 的确是一个值得追随的技术。但React体系实在庞大，我目前仅略知一二。这里要挑出来说的，是React的\x3ca href=\x22https:\/\/facebook.github.io\/react\/docs\/react-component.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e生命周期\x3c\/a\x3e机制。Demo的学习过程中，对它的方便、易用之处实在是深有体会，在一些细节处也值得斟酌，在这里做一下记录，便于分享。\x3c\/p\x3e\n\x3cp\x3e如果你接触过React，大概对\x3ccode\x3erender\x3c\/code\x3e和\x3ccode\x3ecomponentWillMount\x3c\/code\x3e等，会相对的熟悉，因为它们再常用不过。但用归用，其中的一些理论上的细节，往往容易在使用的过程中被忽略，使我们多敲了不少代码，心很累的 : )\x3c\/p\x3e\n\x3cp\x3e通俗来讲，React 将组件 \x3ccode\x3ecomponent\x3c\/code\x3e 在web中的形成、修改和渲染等划分为若干个阶段，组成组件的生命周期。在一个完整的生命周期内，一个组件会经过若干个阶段，在特殊的阶段组件会调用一个特别的\x3ccode\x3elifecycle method\x3c\/code\x3e，即生命周期方法。如下：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3econstructor(props)\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3ecomponentWillMount()\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3erender()\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3ecomponentDidMount()\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ecomponentWillReceiveProps(nextProps)\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eshouldComponentUpdate(nextProps, nextState)\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ecomponentWillUpdate(nextProps, nextState)\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3erender( )*  \/\/理解上与3. render()略有不同，见下。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ecomponentDidUpdate(prevProps, prevState )\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ecomponentWillUnmount( )\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cblockquote\x3e\x3cp\x3e值得注意，这些生命周期是React 内置的，在特定条件下就会被调用。而开发者可以做的就是 \x3ccode\x3eoverride\x3c\/code\x3e（重载)这些方法，以实现想要的功能。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3econstructor\x3c\/h3\x3e\n\x3cblockquote\x3e\x3cp\x3e\x3ccode\x3econstructor(props)\x3c\/code\x3e，组件形成时调用。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3econstructor 函数可理解为组件的构造函数，从组件的类(class) 实例化一个组件实例。这个函数在组件形成时被调用，是所有生命周期函数中\x3ccode\x3e最先执行\x3c\/code\x3e的。在constructor函数内，如有必要，进行state的初始化以及绑定方法；否则可以省去constructor函数的声明。\x3c\/p\x3e\n\x3cp\x3e有以下几点在开发时值得注意:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3econstructor 函数内，在执行任何statement之前，必须是super() 函数，如果有参数须将参数带上。这点跟Java很像。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e在constructor 函数内，\x3ccode\x3ethis.props\x3c\/code\x3e 返回 \x3ccode\x3eundefined\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e不要在初试化state时引用props 里的值，否则每当props更新时，都需要在componentWillReceiveProps 函数内对state进行更新。（同时这也涉及到组件state选取的原则，如有需要请阅读\x3ca href=\x22https:\/\/facebook.github.io\/react\/docs\/thinking-in-react.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eThinking in React\x3c\/a\x3e）\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class App extends Component {\n  constructor(props) {\n    super(props);\/\/------------(1)\n    console.log(this.props);\/\/ undefined ------------(2)\n    \/\/initialize the state\n    this.state = {\n      value: \x27\x27,\n      color: props.initialColor  \/\/ 不可取  ------------(3)\n    }\n    \/\/bind methods\n    this.handleClick = this.handleClick.bind(this);\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eApp\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(props) {\n    \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(props);\x3cspan class=\x22hljs-comment\x22\x3e\/\/------------(1)\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props);\x3cspan class=\x22hljs-comment\x22\x3e\/\/ undefined ------------(2)\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/initialize the state\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = {\n      \x3cspan class=\x22hljs-attr\x22\x3evalue\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-attr\x22\x3ecolor\x3c\/span\x3e: props.initialColor  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 不可取  ------------(3)\x3c\/span\x3e\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/bind methods\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handleClick = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handleClick.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3ecomponentWillMount\x3c\/h3\x3e\n\x3cblockquote\x3e\x3cp\x3e\x3ccode\x3ecomponentWillMount()\x3c\/code\x3e，在组件首次渲染(\x3ccode\x3erender\x3c\/code\x3e)之前调用。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e\x3ccode\x3emount\x3c\/code\x3e有\x3ccode\x3e安装\x3c\/code\x3e之意，我们可以理解为\x3ccode\x3e组件首次被加载在web中\x3c\/code\x3e。因此每次页面加载\/刷新，或者某个组件第一次加载进入web时可以调用componentWillMount( ) 函数。举个例子，在首次进入文章列表时时，可在 componentWillMount 对所有文章进行查询。这样，在render之前，就能拿到所有文章的数据，以便在render中使用。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e在componentWillMount ( ) 函数内，若对\x3ccode\x3ethis.state\x3c\/code\x3e进行更新，无法触发重新渲染组件。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class PostList extends Component {\n  \/\/...\n  \/\/在componentWillMount 组件内获取所有博客列表\n  componentWillMount(){\n    axios.get(\x27\/posts\x27)\n         .then(res=\x3e{\n           \/\/...\n         });\n  }\n  \/\/在 render 函数内将拿到的博客列表 渲染在页面中\n  render(){\n    \/\/...\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePostList\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/...\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/在componentWillMount 组件内获取所有博客列表\x3c\/span\x3e\n  componentWillMount(){\n    axios.get(\x3cspan class=\x22hljs-string\x22\x3e\x27\/posts\x27\x3c\/span\x3e)\n         .then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eres\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n           \x3cspan class=\x22hljs-comment\x22\x3e\/\/...\x3c\/span\x3e\n         });\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/在 render 函数内将拿到的博客列表 渲染在页面中\x3c\/span\x3e\n  render(){\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/...\x3c\/span\x3e\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3eRender\x3c\/h3\x3e\n\x3cblockquote\x3e\x3cp\x3e\x3ccode\x3erender()\x3c\/code\x3e\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3erender 即 渲染函数，是编写组件代码时，唯一一个\x3ccode\x3e必须\x3c\/code\x3e的函数。该函数须有返回值，返回一个组件，即最终渲染出来的组件。在使用组件的class进行组件实例化时，得到的便是其返回值。\x3c\/p\x3e\n\x3cp\x3e返回值有两种类型：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e一个父标签，这个父标签内可以包含若干个子标签，在最外层标签必须只有一个。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3efalse\x3c\/code\x3e 或者 \x3ccode\x3enull\x3c\/code\x3e，代表不渲染任何DOM\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class App extends Component {\n  \/\/...\n  render(){\n    return (\n      \x3cdiv\x3e\n          \/\/...\n      \x3c\/div\x3e\n    )\n  }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode class=\x22jsx\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eApp\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/...\x3c\/span\x3e\n  render(){\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x26lt;div\x26gt;\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/...\x3c\/span\x3e\n      \x26lt;\/div\x26gt;\n    )\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e\n\x3cp\x3e\x3ccode\x3e注意:\x3c\/code\x3e在render函数中只做与返回组件相关的工作，勿在其中对\x3ccode\x3estate\x3c\/code\x3e进行操作，可以保证每次调用render函数，返回的组件都是相同的。否则将加大项目维护成本。\x3c\/p\x3e\n\x3cp\x3e另外，如果\x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e函数返回\x3ccode\x3efalse\x3c\/code\x3e，则不执行render函数。关于shouldComponentUpdate将在下面介绍。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3ecomponentDidMount\x3c\/h3\x3e\n\x3cblockquote\x3e\x3cp\x3e\x3ccode\x3ecomponentDidMount()\x3c\/code\x3e，一旦组件首次加载完成，便会调用\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e如果需要对渲染出来的DOM节点做任何操作，可以在此处进行。(\x3ccode\x3e提示\x3c\/code\x3e: this.refs 可获取真实DOM)。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e\x3ccode\x3e在该组件内设置state将会导致组件被重新渲染。\x3c\/code\x3e\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class App extends Component {\n  \/\/..\n  componentDidMount(){\n    \/\/将会触发组件重新渲染\n    this.setState({\n      value: \x27100\x27\n    })：\n    \/\/对节点进行操作\n      this.refs.div.appendChild(newChild);\n  }\n  \n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eApp\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/..\x3c\/span\x3e\n  componentDidMount(){\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/将会触发组件重新渲染\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({\n      \x3cspan class=\x22hljs-attr\x22\x3evalue\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27100\x27\x3c\/span\x3e\n    })：\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/对节点进行操作\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.refs.div.appendChild(newChild);\n  }\n  \n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面对 \x3ccode\x3eReact生命周期函数\x3c\/code\x3e中的\x3ccode\x3econstructor \x3c\/code\x3e\/ \x3ccode\x3ecomponentWillMount\x3c\/code\x3e \/ \x3ccode\x3erender\x3c\/code\x3e \/ \x3ccode\x3ecomponentDidMount\x3c\/code\x3e 四个函数进行了介绍。下面将继续介绍另外5个方法。在此之前，先总结一下，下面列表中列出的\x3ccode\x3e3.render()\x3c\/code\x3e与\x3ccode\x3e8.render()\x3c\/code\x3e的在逻辑上的区别和联系。先上一个列表。\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3econstructor(props)\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ecomponentWillMount( )\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3erender( )\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ecomponentDidMount( )\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3ecomponentWillReceiveProps(nextProps)\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eshouldComponentUpdate(nextProps, nextState)\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3ecomponentWillUpdate(nextProps, nextState)\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3erender()\x3c\/code\x3e*\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3ecomponentDidUpdate(prevProps, prevState)\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3ecomponentWillUnmount()\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e「两个」render( )方法的区别\x3c\/h3\x3e\n\x3cblockquote\x3e\x3cp\x3e3.render( ) 与 8.render( )*\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e实质上，这两个方法毫无区别。但这里为什么要提及它们之间的区别呢？其实，它们只是同一函数 render( ) 在组件生命周期的两个不同阶段的不同理解而已。\x3c\/p\x3e\n\x3cp\x3e前一个 render( ) 方法指在组件第一次被加载进入页面时，调用的 render( ) 方法；后一个则指除去第一次，之后调用的 render( ) 方法。\x3c\/p\x3e\n\x3cp\x3e因此，我们更愿意称第一次的 render( ) 方法为 \x3ccode\x3emount\x3c\/code\x3e( 安装 )，称后一个 render( ) 方法为 \x3ccode\x3ere-render\x3c\/code\x3e ( 重新渲染 ) 。这也是为什么组件首次 render 前后的方法名中带有\x3ccode\x3emount\x3c\/code\x3e一词的缘故了。\x3c\/p\x3e\n\x3cp\x3e这是 React 的伎俩，或者设计哲学吧。怎么认为都行，我认为很有趣?\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e\x3cem\x3e下面介绍的方法，都是围绕第二个 render( ) ，即重新渲染 re-render 展开的。\x3c\/em\x3e\x3c\/strong\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3ecomponentWillReceiveProps\x3c\/h3\x3e\n\x3cblockquote\x3e\x3cp\x3e\x3ccode\x3ecomponentWillReceiveProps(nextprops)\x3c\/code\x3e，\x3ccode\x3e已加载的组件\x3c\/code\x3e在 props 发生变化时调用。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e如果需要通过监听 props 的改变来修改 state 的值，则可以通过重载该函数实现。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3e需要注意\x3c\/code\x3e，在有些情况下，组件的 props 未发生改变也会调用该函数。因此如果在该函数内的逻辑，只是想捕获当前 props 与 接收的 nextProps 的不同来做出一些操作，则最好先将 props 与 nextProps 进行比较。\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3e1.在\x3ccode\x3emounting\x3c\/code\x3e阶段，即首次 render ，不调用 componentWillReceiveProps 方法。理解了两个 render( ) 的不同，便知道这里是为什么了。\x3c\/p\x3e\n\x3cp\x3e2.\x3ccode\x3ethis.setState({…})\x3c\/code\x3e 不触发 componentWillReceiveProps 方法。因为该方法只监听 this.props 的改变，不关心 this.state 值的变化。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class App extends Component {\n  componentWillReceiveProps(nextProps){\n    \/\/接收的颜色 与 当前颜色不同时\n    if (this.props.color !== nextProps.color){\n      ...\n    }\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eApp\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  componentWillReceiveProps(nextProps){\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/接收的颜色 与 当前颜色不同时\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.color !== nextProps.color){\n      ...\n    }\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3eshouldComponentUpdate\x3c\/h3\x3e\n\x3cblockquote\x3e\n\x3cp\x3e\x3ccode\x3eshouldComponentUpdate(nextProps, nextState)\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e返回 \x3ccode\x3etrue\x3c\/code\x3e or\x3ccode\x3efalse\x3c\/code\x3e\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e要不要更新(重新渲染)组件？浅显易懂。这个方法的返回值决定了，当 props 或者 state 值发生变化时，组件是否重新渲染。两种情况:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e返回\x3ccode\x3etrue\x3c\/code\x3e，重新渲染。紧接着，继续执行 \x3ccode\x3ecomponentWillUpdate()\x3c\/code\x3e → \x3ccode\x3erender()\x3c\/code\x3e → \x3ccode\x3ecomponentDidUpdate()\x3c\/code\x3e。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3efalse\x3c\/code\x3e，不重新渲染。不再执行任何生命周期函数函数（亦不执行该组件的 render( ) 函数）。但是，并不妨碍其子组件。也就是说，如果其子组件的 props 或 state 发生改变时，只会取决于那个组件的 shouleComponentUpdate ( ) 方法的返回值。道理虽懂，但遇到是可能会犯迷糊，因为开发中常常会遇见组件嵌套的情况，父子组件之间传递同一套 props 或 state，一来二去，谁更新谁不更新，容易迷糊，需要仔细咯。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cblockquote\x3e\x3col\x3e\n\x3cli\x3e\x3cp\x3e在绝大部分情况下，当 props 或 state 改变时，都是需要重新渲染组件的。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3e注意\x3c\/code\x3e，根据 \x3ca href=\x22https:\/\/facebook.github.io\/react\/docs\/react-component.html#shouldcomponentupdate\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eReact 官方 \x3c\/a\x3e的说法，就算 shouldComponentUpdate( ) 方法返回 \x3ccode\x3efalse\x3c\/code\x3e，组件也会重新渲染。需要随时注意官方文档的变化。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\x3c\/blockquote\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class PostList extends Component {\n  shouldComponentUpdate(nextProps, nextState){\n    \/\/return true;默认\n    return false;\/\/ 不更新组件\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePostList\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  shouldComponentUpdate(nextProps, nextState){\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/return true;默认\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 不更新组件\x3c\/span\x3e\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3ecomponentWillUpdate\x3c\/h3\x3e\n\x3cblockquote\x3e\x3cp\x3e\x3ccode\x3ecomponentWillUpdate(nextProps, nextState)\x3c\/code\x3e，当 shouldComponentUpdate( ) 方法返回 true 后调用。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e这个方法提供了一个为重新渲染作准备的机会，意思是要在这里，趁接下来的 render( ) 方法重新渲染之前，完成该完成的操作。这个方法在 mount 阶段不会被调用，只在 re-render 阶段被调用。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e\x3ccode\x3e注意\x3c\/code\x3e，不要在该方法内调用 \x3ccode\x3ethis.setState({…})\x3c\/code\x3e，如有需要，请在 componentWillReceiveProps( ) 方法中完成。养成良好的编程规范。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class App extends Component {\n  componentWillUpdate(nextProps, nextState){\n    var isLate = this.nextProps.isLate;\n    if(isLate){\n      \/\/...\n    } else {\n      \/\/...\n    }\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode class=\x22jsx\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eApp\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  componentWillUpdate(nextProps, nextState){\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e isLate = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.nextProps.isLate;\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(isLate){\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/...\x3c\/span\x3e\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/...\x3c\/span\x3e\n    }\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3ecomponentDidUpdate\x3c\/h3\x3e\n\x3cblockquote\x3e\x3cp\x3e\x3ccode\x3ecomponentDidUpdate(prevProps, preState)\x3c\/code\x3e，一旦组件首次更新（重新渲染）完成时调用。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e因此像 componentDidMount( ) 一样，如果需要对渲染出来的DOM节点做任何操作，可以在此处进行。(\x3ccode\x3e提示\x3c\/code\x3e: this.refs 可获取真实DOM)。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e\x3ccode\x3e在该组件内设置state将会导致组件被重新渲染。\x3c\/code\x3e\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class App extends Component {\n  \/\/..\n  componentDidUpdate(){\n    \/\/将会触发组件重新渲染\n    this.setState({\n      value: \x27100\x27\n    });\n    \/\/对节点进行操作\n    this.refs.div.appendChild(newChild);\n  }\n  \n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eApp\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/..\x3c\/span\x3e\n  componentDidUpdate(){\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/将会触发组件重新渲染\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({\n      \x3cspan class=\x22hljs-attr\x22\x3evalue\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27100\x27\x3c\/span\x3e\n    });\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/对节点进行操作\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.refs.div.appendChild(newChild);\n  }\n  \n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3ecomponentWillUnmount\x3c\/h3\x3e\n\x3cblockquote\x3e\x3cp\x3e\x3ccode\x3ecomponentWillUnmount()\x3c\/code\x3e，在组件即将被卸载(或销毁)之前调用。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e在这个方法中，适合做一些清理善后工作。例如清楚timer，取消网络请求，或者清除在 componentDidMount 或 componentDidUpdate 中生成的相关 DOM 节点。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader11\x22\x3e总结\x3c\/h3\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3emount\x3c\/code\x3e 与 \x3ccode\x3ere-render\x3c\/code\x3e 的是有区别的。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3emount\x3c\/code\x3e阶段使用\x3ca href=\x22https:\/\/fivesheep.me\/2017\/02\/10\/react-lifecycle\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e前一部分\x3c\/a\x3e的四个方法( \x3cstrong\x3e\x3cem\x3econstructor \/ componentWillMount \/ render \/ componentDidMount\x3c\/em\x3e\x3c\/strong\x3e)，围绕组件首次加载而调用；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/fivesheep.me\/2017\/02\/12\/react-lifecycle-2\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e后一部分\x3c\/a\x3e \x3ccode\x3ere-render\x3c\/code\x3e 相关的，使用 \x3cstrong\x3e\x3cem\x3ecomponentWillReceiveProps \/ shouldComponentUpdate \/ componentWillUpdate \/ render \/ componentDidUpdate\x3c\/em\x3e\x3c\/strong\x3e ，围绕组件重新渲染而调用。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e\x3cstrong\x3e\x3cem\x3e我总结了一张流程图和一个表格，以表示这些周期函数之间的关系，以及在何种情况下会调用这些函数。\x3c\/em\x3e\x3c\/strong\x3e\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e\x3ccode\x3e注意:\x3c\/code\x3ecomponentWillUnmount 方法未包含其中。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000008325026?w=1674\x26amp;h=1258\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000008325026?w=1674\x26amp;h=1258\x22 alt=\x22lifecycle\x22 title=\x22lifecycle\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ctable\x3e\n\x3cthead\x3e\x3ctr\x3e\n\x3cth align=\x22center\x22\x3e\x3ccode\x3emount\x3c\/code\x3e\x3c\/th\x3e\n\x3cth align=\x22center\x22\x3e\x3ccode\x3eprops 变化\x3c\/code\x3e\x3c\/th\x3e\n\x3cth align=\x22center\x22\x3e\x3ccode\x3estate 变化\x3c\/code\x3e\x3c\/th\x3e\n\x3c\/tr\x3e\x3c\/thead\x3e\n\x3ctbody\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e\x3cstrong\x3econstructor\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cstrong\x3ecomponentWillReceiveProps\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cstrong\x3eshouldComponentUpdate\x3c\/strong\x3e\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e\x3cstrong\x3ecomponentWillMount\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cstrong\x3eshouldComponentUpdate\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e(return true)  ⏬  \/  结束\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e\x3cstrong\x3erender\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e(return true)  ⏬  \/  结束\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cstrong\x3ecomponentWillUpdate\x3c\/strong\x3e\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e\x3cstrong\x3ecomponentDidMount\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cstrong\x3ecomponentWillUpdate\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cstrong\x3erender\x3c\/strong\x3e\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e\/\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cstrong\x3erender\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cstrong\x3ecomponentDidUpdate\x3c\/strong\x3e\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd align=\x22center\x22\x3e\/\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\x3cstrong\x3ecomponentDidUpdate\x3c\/strong\x3e\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e\/\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3c\/tbody\x3e\n\x3c\/table\x3e\n\x3cp\x3e\x3cstrong\x3e完。\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e文章为本人原创，原文见本人个博：\x3cbr\x3e\x3ca href=\x22https:\/\/fivesheep.me\/2017\/02\/10\/react-lifecycle\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e浅析「React」生命周期(一)\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22https:\/\/fivesheep.me\/2017\/02\/12\/react-lifecycle-2\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e浅析「React」生命周期(二)\x3c\/a\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>浅析 React 生命周期</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000008325023">https://segmentfault.com/a/1190000008325023</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/yshfcc35dgp/" target="_blank">https://alili.tech/archive/yshfcc35dgp/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>