<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="Electron &#43; Vue 实现一个代理客户端"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>Electron &#43; Vue 实现一个代理客户端 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/07h13yqreyrr/",
				"appid": "1613049289050283", 
				"title": "Electron &#43; Vue 实现一个代理客户端 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-17T02:30:25"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/ak2t5cukca/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/zmt3ura18li/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f07h13yqreyrr%2f&text=Electron%20%2b%20Vue%20%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa%e4%bb%a3%e7%90%86%e5%ae%a2%e6%88%b7%e7%ab%af"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f07h13yqreyrr%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f07h13yqreyrr%2f&text=Electron%20%2b%20Vue%20%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa%e4%bb%a3%e7%90%86%e5%ae%a2%e6%88%b7%e7%ab%af"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f07h13yqreyrr%2f&title=Electron%20%2b%20Vue%20%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa%e4%bb%a3%e7%90%86%e5%ae%a2%e6%88%b7%e7%ab%af"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f07h13yqreyrr%2f&is_video=false&description=Electron%20%2b%20Vue%20%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa%e4%bb%a3%e7%90%86%e5%ae%a2%e6%88%b7%e7%ab%af"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=Electron%20%2b%20Vue%20%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa%e4%bb%a3%e7%90%86%e5%ae%a2%e6%88%b7%e7%ab%af&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f07h13yqreyrr%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f07h13yqreyrr%2f&title=Electron%20%2b%20Vue%20%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa%e4%bb%a3%e7%90%86%e5%ae%a2%e6%88%b7%e7%ab%af"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f07h13yqreyrr%2f&title=Electron%20%2b%20Vue%20%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa%e4%bb%a3%e7%90%86%e5%ae%a2%e6%88%b7%e7%ab%af"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f07h13yqreyrr%2f&title=Electron%20%2b%20Vue%20%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa%e4%bb%a3%e7%90%86%e5%ae%a2%e6%88%b7%e7%ab%af"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f07h13yqreyrr%2f&title=Electron%20%2b%20Vue%20%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa%e4%bb%a3%e7%90%86%e5%ae%a2%e6%88%b7%e7%ab%af"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">Electron &#43; Vue 实现一个代理客户端</h1><div class="meta"><div class="postdate"><time datetime="2019-01-17" itemprop="datePublished">2019-01-17</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e\x3cp\x3e开源项目地址：\x3ca href=\x22https:\/\/github.com\/fwon\/electron-anyproxy\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e戳我\x3c\/a\x3e\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader0\x22\x3e原理\x3c\/h3\x3e\n\x3cp\x3e作为一个合格的前端工程师，你一定用过Fiddler或Charles之类的抓包工具。但是在Mac上做开发时，相关的抓包工具很多是收费的。当你费劲心思下载到了破解版，却还是难以忍受其丑陋的win风格界面和令人悲伤的闪退问题。有没有想过自己来实现一个代理客户端呢？其实这个真的可以有。\x3c\/p\x3e\n\x3ch4\x3e中间人\x3c\/h4\x3e\n\x3cp\x3e一个http代理服务器的原理很简单。有了Nodejs作为武器，创建一个代理服务器就是分分钟的事。具体可参见jerryQu写的两篇文章 \x3ca href=\x22https:\/\/imququ.com\/post\/web-proxy.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e《HTTP 代理原理及实现（一）》\x3c\/a\x3e \x3ca href=\x22https:\/\/imququ.com\/post\/web-proxy-2.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e《HTTP 代理原理及实现（二）》\x3c\/a\x3e 文章对HTTP代理的原理和实践讲得比较清楚。\x3c\/p\x3e\n\x3cp\x3e简单来讲就是要实现一个中间人，用户通过设置代理，网络请求就会通过中间人代理，再发往正式服务器。\x3c\/p\x3e\n\x3cp\x3e这种中间人的实现方式有两种。\x3c\/p\x3e\n\x3cp\x3e一种为普通的HTTP代理，通过Node.js开启一个HTTP服务，并将我们的浏览器或手机设置到该服务所在的ip和端口，那么HTTP流量就会经过该代理，从而实现数据的拦截。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/raw.githubusercontent.com\/fwon\/blog\/master\/assets\/electron-vue-1.png\x22 src=\x22https:\/\/static.alili.techhttps:\/\/raw.githubusercontent.com\/fwon\/blog\/master\/assets\/electron-vue-1.png\x22 alt=\x22pic\x22 title=\x22pic\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e对于非HTTP请求，比如HTTPS, 或其他应用层请求。可以通过在Node.js 中开启一个TCP服务，监听CONNECT请求，因为应用层也是基于传输层的，所以数据在到达应用层之前会首先经过传输层，从而我们能实现传输层数据监听。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/raw.githubusercontent.com\/fwon\/blog\/master\/assets\/electron-vue-2.png\x22 src=\x22https:\/\/static.alili.techhttps:\/\/raw.githubusercontent.com\/fwon\/blog\/master\/assets\/electron-vue-2.png\x22 alt=\x22pic\x22 title=\x22pic\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e但是对于CONNECT捕抓到的请求，无法获取到HTTP相关的信息，包括头信息等，这对一般的前端分析作用不大，那么想要真正监听HTTPS，还需要支持证书相关的验证。\x3c\/p\x3e\n\x3ch4\x3e证书\x3c\/h4\x3e\n\x3cp\x3e假设我们是通过浏览器设置代理进行抓包实验（或全局代理），在这个过程中我们主要关注的是浏览器和代理服务器之间的交互，这个过程大概如下：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e浏览器客户端发出了一个请求，该请求会首先经过代理服务器。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e代理服务器获取到客户端请求，知道了真实服务器的地址，它可能会做一些手脚，比如对请求数据进行修改，再发往真实服务器，获取到数据再返回给浏览器（利用这一点能实现跨域支持等）。或者代理服务器压根就不会请求真实服务器，而是直接伪造一份假数据给浏览器（利用这一点能实现接口mock）。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e浏览器接收到数据，并返回给用户，显示在页面。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e上面这三步在HTTP中会无比流畅，然而如果请求是HTTPS，浏览器会验证代理服务器的安全性。这里会涉及到TLS握手的过程，其中也包括了证书的验证。\x3c\/p\x3e\n\x3cp\x3e代理服务器返回HTTPS请求时，需要将对应请求域名的证书发给浏览器，浏览器再向本地的CA根证书验证域名证书的安全性。如果验证通过，则继续后续请求，验证失败浏览器会返回安全警告。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/raw.githubusercontent.com\/fwon\/blog\/master\/assets\/electron-vue-3.png\x22 src=\x22https:\/\/static.alili.techhttps:\/\/raw.githubusercontent.com\/fwon\/blog\/master\/assets\/electron-vue-3.png\x22 alt=\x22pic\x22 title=\x22pic\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e这里提到了两个证书，一个是域名证书，一个是CA根证书。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e域名证书\x3c\/strong\x3e 是每个支持HTTPS网站都需要有的一份证书，用于客户端验证该网站的安全性，而该证书通常是通过安全机构申请的，这个机构就是 \x3cstrong\x3eCA（Certificate Authority，证书颁发机构）\x3c\/strong\x3e。在每台用户计算机的操作系统或浏览器中，都会保存一份CA列表，也就是有多个根证书，不同CA分别包含了不同的域名证书，浏览器在获取到域名证书之后，会向CA根证书进行验证，如果验证通过则能正常收发请求。\x3c\/p\x3e\n\x3cp\x3e对于代理服务器来说，我们并没有合法的域名证书（证书只存在真实目标服务器，无法获取到），怎么让浏览器相信我们是个安全的代理（服务器）呢？答案是————伪造！\x3c\/p\x3e\n\x3cp\x3e没错，我们既要伪造域名证书，也要伪造根证书。其实根证书是可以自己签发的。下面两条命令首先生成了一个私钥，然后利用私钥生成crt证书，我们只要双击crt文件进行安装，并设置为信任，就成功建立了一个本地根证书。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22openssl genrsa -out private.pem 2048\nopenssl req -new -x509 -key private.pem -out public.crt -days 99999\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs cs\x22\x3e\x3ccode\x3eopenssl genrsa -\x3cspan class=\x22hljs-keyword\x22\x3eout\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eprivate\x3c\/span\x3e.pem \x3cspan class=\x22hljs-number\x22\x3e2048\x3c\/span\x3e\nopenssl req -\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e -x509 -key \x3cspan class=\x22hljs-keyword\x22\x3eprivate\x3c\/span\x3e.pem -\x3cspan class=\x22hljs-keyword\x22\x3eout\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3epublic\x3c\/span\x3e.crt -days \x3cspan class=\x22hljs-number\x22\x3e99999\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e利用根证书，我们能够签发更多的域名证书。证书是链式验证的，验证域名证书的时候，会往上验证CA根证书，由于CA根证书已经被我们本地信任了，所以浏览器也会信任该域名证书，成功返回代理服务器的数据。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/raw.githubusercontent.com\/fwon\/blog\/master\/assets\/electron-vue-4.png\x22 src=\x22https:\/\/static.alili.techhttps:\/\/raw.githubusercontent.com\/fwon\/blog\/master\/assets\/electron-vue-4.png\x22 alt=\x22pic\x22 title=\x22pic\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e具体的操作流程是这样的，首先利用Node.js 生成AnyProxy CA证书，并手动信任。浏览器往cn.vuejs.org发出请求，代理服务器拦截到请求，知道请求是发往cn.vuejs.org，在返回数据之前，利用AnyProxy证书动态签发cn.vuejs.org域名证书，放于本地（用于下次请求，这里省去了中间证书的步骤），同时将该域名证书返回给浏览器。那么浏览器在接受到cn.vuejs.org域名证书后，往证书链上寻找到根证书AnyProxy，并通过AnyProxy证书验证域名证书是否受信任，同时还要检查域名证书的有效性，包括过期时间等。由于域名证书是我们通过AnyProxy动态创建的，所以保证了其受信任和有效性。最后浏览器返回代理服务器结果。从而实现了HTTPS请求的抓取。\x3c\/p\x3e\n\x3cp\x3e具体的证书签发实现可参考 \x3ca href=\x22https:\/\/github.com\/digitalbazaar\/forge#x509\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eforge\x3c\/a\x3e 库，现在广泛使用的证书是X.509格式。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3eElectron\x3c\/h3\x3e\n\x3cp\x3e解决了证书问题，可以说已经完成了一大半的工作，那如何快速实现一个代理客户端呢？对于一个JSer来说，能利用Node.js来写是最好不过了。\x3c\/p\x3e\n\x3ch4\x3e简介\x3c\/h4\x3e\n\x3cp\x3eElectron大家应该不陌生了，它提供了一种解决方案，让我们能够利用Node.js 和 前端三宝 HTML \x2b JS \x2b CSS 来实现客户端软件。咋一听感觉像NW.js。经过一番了解，才知道其实NW.js可以算是Electron的前身了，都是出自同个作者之手，只不过该作者现在维护Electron去了，这其中涉及到一些产权的问题，感兴趣的可以围观一下知乎上\x3ca href=\x22https:\/\/www.zhihu.com\/question\/36292298\/answer\/102418523\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e原作者的回答\x3c\/a\x3e。关于Electron和NW.js的区别\x3ca href=\x22https:\/\/electron.atom.io\/docs\/development\/atom-shell-vs-node-webkit\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e官网上是这么说的\x3c\/a\x3e。简单讲就是Electron优化了NW.js中的一些不足。 秉着与时俱进的态度，我们当然要使用Electron。\x3c\/p\x3e\n\x3cp\x3e有了Electron作为容器，我们小前端就可以用HTML\x2bJS\x2bCSS来开发客户端了。就像开发前端页面一样柔顺。Electron的使用比较简单，提供的API也比较清晰。核心概念就是Main Process 和 Render Process。\x3c\/p\x3e\n\x3cp\x3e顾名思义Main Process是主进程，用于运行Electron的基本操作，如创建窗口，创建菜单等。Render Process是渲染进程，我们需要在渲染进程中创建软件界面，每个渲染进程对应的是一个窗口，主进程开启了多个窗口就会有多个渲染进程。\x3c\/p\x3e\n\x3cp\x3eElectron提供了IPC用于进程间通信。分别是ipcMain和ipcRender。该通信机制允许ipcRender向ipcMain发送信号请求，并通过ipcMain返回数据。反回来ipcMain无法向特定的ipcRender发起请求。而且通信间传递的消息会被格式化为JSON字符串，所以并不支持在两个进程间传递句柄方法等，也就是不支持上下文传递。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3eArguments will be serialized in JSON internally and hence no functions or prototype chain will be included.\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e假如要实现在渲染进程中点击一个按钮，则关闭客户端窗口，可以通过ipcRender发送一个信号给ipcMain, ipcMain接收到该信号后调用Electron的API关闭窗口。对于类似这种比较简单的指令操作，运用IPC实现就可以了，但是如果操作比较复杂，并且需要传递复杂数据类型，则用IPC就行不通了。\x3c\/p\x3e\n\x3cp\x3eElectron提供了另一个API \x3ca href=\x22https:\/\/electron.atom.io\/docs\/api\/remote\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eremote\x3c\/a\x3e，用于在Render Process中直接操作主进程的方法。这样就不需要移交Main Process处理，直接在前端页面中调用Electron的API。\x3c\/p\x3e\n\x3ch4\x3e打包\x3c\/h4\x3e\n\x3cp\x3e由于Electron本身包含了chromium和Node.js的代码, 所以不考虑项目本身体积，打包后的软件最小仍然有100M\x2b, 这也是Electron最为显著的缺点之一。所以基本体积是无法避免的，我们只能尽量减小其他开发文件的大小，避免将一些无关包文件也打包进去。\x3c\/p\x3e\n\x3cp\x3e为什么要强调这点呢？因为基于Node.js开发的项目往往会有一个庞大的node_modules文件夹，里面包含了一些开发和生产所用的包，也即对应package.json中的dependencies和devDependencies。而devDependencies中的包是不需要打包到软件的。这里推荐使用 \x3cstrong\x3eelectron-packager\x3c\/strong\x3e, 能自动排除dev依赖包，并支持自定义排除包文件夹。也可以打包出支持不同系统格式的软件。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e界面开发\x3c\/h3\x3e\n\x3cp\x3e界面开发采用传统前端页面开发方式，意味着你可以使用任何前端框架，利用Angular，Vue，React等框架来提升开发效率。\x3c\/p\x3e\n\x3cp\x3e这些框架都支持模块化，利用webpack等打包工具，webpack本身会提供require等模块加载的方法，在前端开发的时候能实现类似后端的模块动态加载。\x3c\/p\x3e\n\x3cp\x3e但是，当我们在Render Process中使用webpack进行开发，用require引入模块的时候就会出现冲突。因为require此时是webpack提供的一个引用本地文件的API，而不是Node.js的require, 导致我们无法通过require来引用Node.js的API，或者Electron的API。这有什么解决方案吗？\x3c\/p\x3e\n\x3cp\x3e这里提供一个简单的方法，我们将需要用到Node.js API和Electron API 的方法抽象到renderer.js, 从HTML中单独引入，也就避免了webpack对renderer.js进行处理。然后通过插件的方式引入到前端框架中，以Vue为例：\x3c\/p\x3e\n\x3cp\x3eindex.html\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cscript src=\x26quot;renderer.js\x26quot;\x3e\x3c\/script\x3e\x3c!--提供Render Process 方法 --\x3e\n\x3cscript src=\x26quot;.\/dist\/build.js\x26quot;\x3e\x3c\/script\x3e\x3c!--webpack 打包文件--\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22xml hljs\x22\x3e\x3ccode class=\x22html\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3esrc\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22renderer.js\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22undefined\x22\x3e\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-comment\x22\x3e\x26lt;!--提供Render Process 方法 --\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3esrc\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22.\/dist\/build.js\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22undefined\x22\x3e\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-comment\x22\x3e\x26lt;!--webpack 打包文件--\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3erenderer.js\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const electron = require(\x27electron\x27);\nconst remote = electron.remote;\nconst remoteApi = remote.require(\x27.\/api.js\x27);\n\nglobal.remoteApi = remoteApi;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e electron = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27electron\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e remote = electron.remote;\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e remoteApi = remote.require(\x3cspan class=\x22hljs-string\x22\x3e\x27.\/api.js\x27\x3c\/span\x3e);\n\nglobal.remoteApi = remoteApi;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eVue入口文件main.js\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Vue.use({\n    install (Vue, options) {\n        \/\/添加实例方法\n        Vue.prototype.$remoteApi = global.remoteApi;\n    }\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eVue.use({\n    install (Vue, options) {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/添加实例方法\x3c\/span\x3e\n        Vue.prototype.$remoteApi = global.remoteApi;\n    }\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在Vue组件中就可以直接通过\x3ccode\x3ethis.$remoteApi\x3c\/code\x3e调用基于Nodejs或Electron的接口了。这样就有效地分离了前端界面和客户端的代码，只要剥离了$remoteApi, 前端界面也可作为一个独立的项目进行开发。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e方案优缺点\x3c\/h3\x3e\n\x3cp\x3eElectron的这种实现方式也不是什么新鲜套路了，对于NW.js 有的大多数缺点Electron也有。\x3c\/p\x3e\n\x3cp\x3e其中一个通病就是性能问题，主要是渲染性能方面。基于webkit引擎来渲染UI界面，跟原生的系统UI还是有一定的差距。毕竟是基于DOM节点的渲染，每次节点的重排都是一次大的开销。这点只能通过在前端框架中来优化，比如利用Virtual DOM等相关技术。而视觉上的缺点则可以通过CSS做到竟可能接近原生控件。\x3c\/p\x3e\n\x3cp\x3e而对于JS的执行性能，v8表示hold得住。\x3c\/p\x3e\n\x3cp\x3e优点当然也比较明显，对比于Cocoa，Qt等传统桌面客户端技术，基于前端技术的实现成本较低（C\x2b\x2b牛请忽略）跨平台支持更好（框架都帮你做好了），且天然支持热更新。\x3c\/p\x3e\n\x3cp\x3e更重要的是，有这么多优秀软件帮你背书啊.....以下都是基于Electron开发。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/raw.githubusercontent.com\/fwon\/blog\/master\/assets\/electron-vue-5.png\x22 src=\x22https:\/\/static.alili.techhttps:\/\/raw.githubusercontent.com\/fwon\/blog\/master\/assets\/electron-vue-5.png\x22 alt=\x22pic\x22 title=\x22pic\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e当然，我并不是在安利Electron。毕竟别人能开发得这么原生态，你不一定行...  \x3c\/p\x3e\n\x3cp\x3e关键还是看技术，Electron是完全能够开发出中大型产品级的软件的。\x3c\/p\x3e\n\x3cp\x3e说了这么多，代码呢？\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/raw.githubusercontent.com\/fwon\/blog\/master\/assets\/electron-vue-6.jpg\x22 src=\x22https:\/\/static.alili.techhttps:\/\/raw.githubusercontent.com\/fwon\/blog\/master\/assets\/electron-vue-6.jpg\x22 alt=\x22pic\x22 title=\x22pic\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e能读到这里，感谢你的坚持！\x3c\/p\x3e\n\x3cp\x3e下面基于以上理论实现的代理客户端。目前支持以下功能：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e支持HTTP\/HTTPS请求抓取。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e支持网速模拟。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e支持请求拦截修改，实现跨域等功能。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e实现接口Mock，用于本地开发调试。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/raw.githubusercontent.com\/fwon\/blog\/master\/assets\/electron-anyproxy-1.png\x22 src=\x22https:\/\/static.alili.techhttps:\/\/raw.githubusercontent.com\/fwon\/blog\/master\/assets\/electron-anyproxy-1.png\x22 alt=\x22pic\x22 title=\x22pic\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/raw.githubusercontent.com\/fwon\/blog\/master\/assets\/electron-anyproxy-2.png\x22 src=\x22https:\/\/static.alili.techhttps:\/\/raw.githubusercontent.com\/fwon\/blog\/master\/assets\/electron-anyproxy-2.png\x22 alt=\x22pic\x22 title=\x22pic\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/raw.githubusercontent.com\/fwon\/blog\/master\/assets\/electron-anyproxy-3.png\x22 src=\x22https:\/\/static.alili.techhttps:\/\/raw.githubusercontent.com\/fwon\/blog\/master\/assets\/electron-anyproxy-3.png\x22 alt=\x22pic\x22 title=\x22pic\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/raw.githubusercontent.com\/fwon\/blog\/master\/assets\/electron-anyproxy-4.png\x22 src=\x22https:\/\/static.alili.techhttps:\/\/raw.githubusercontent.com\/fwon\/blog\/master\/assets\/electron-anyproxy-4.png\x22 alt=\x22pic\x22 title=\x22pic\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/fwon\/electron-anyproxy\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e项目地址\x3c\/a\x3e 欢迎试玩。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>Electron + Vue 实现一个代理客户端</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000008978174">https://segmentfault.com/a/1190000008978174</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/07h13yqreyrr/" target="_blank">https://alili.tech/archive/07h13yqreyrr/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>