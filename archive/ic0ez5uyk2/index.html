<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="[译] 你应了解的4种JS设计模式"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>[译] 你应了解的4种JS设计模式 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/ic0ez5uyk2/",
				"appid": "1613049289050283", 
				"title": "[译] 你应了解的4种JS设计模式 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-02T02:30:10"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/hexw6rkxow9/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/w8evjllqor/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fic0ez5uyk2%2f&text=%5b%e8%af%91%5d%20%e4%bd%a0%e5%ba%94%e4%ba%86%e8%a7%a3%e7%9a%844%e7%a7%8dJS%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fic0ez5uyk2%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fic0ez5uyk2%2f&text=%5b%e8%af%91%5d%20%e4%bd%a0%e5%ba%94%e4%ba%86%e8%a7%a3%e7%9a%844%e7%a7%8dJS%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fic0ez5uyk2%2f&title=%5b%e8%af%91%5d%20%e4%bd%a0%e5%ba%94%e4%ba%86%e8%a7%a3%e7%9a%844%e7%a7%8dJS%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fic0ez5uyk2%2f&is_video=false&description=%5b%e8%af%91%5d%20%e4%bd%a0%e5%ba%94%e4%ba%86%e8%a7%a3%e7%9a%844%e7%a7%8dJS%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%5b%e8%af%91%5d%20%e4%bd%a0%e5%ba%94%e4%ba%86%e8%a7%a3%e7%9a%844%e7%a7%8dJS%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fic0ez5uyk2%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fic0ez5uyk2%2f&title=%5b%e8%af%91%5d%20%e4%bd%a0%e5%ba%94%e4%ba%86%e8%a7%a3%e7%9a%844%e7%a7%8dJS%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fic0ez5uyk2%2f&title=%5b%e8%af%91%5d%20%e4%bd%a0%e5%ba%94%e4%ba%86%e8%a7%a3%e7%9a%844%e7%a7%8dJS%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fic0ez5uyk2%2f&title=%5b%e8%af%91%5d%20%e4%bd%a0%e5%ba%94%e4%ba%86%e8%a7%a3%e7%9a%844%e7%a7%8dJS%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fic0ez5uyk2%2f&title=%5b%e8%af%91%5d%20%e4%bd%a0%e5%ba%94%e4%ba%86%e8%a7%a3%e7%9a%844%e7%a7%8dJS%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">[译] 你应了解的4种JS设计模式</h1><div class="meta"><div class="postdate"><time datetime="2019-02-02" itemprop="datePublished">2019-02-02</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cul\x3e\x3cli\x3e\x3cp\x3e2016-10-07\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e每个JS开发者都力求写出可维护、复用性和可读性高的代码。随着应用不断扩大，代码组织的合理性也越来越重要。设计模式为特定环境下的常见问题提供了一个组织结构，对于克服这些挑战起到至关重要的作用。\x3c\/p\x3e\n\x3cp\x3eJavaScript 网页开发者在创建应用时，频繁地跟设计模式打交道（甚至在不知情的情况下）。\x3c\/p\x3e\n\x3cp\x3e尽管特定环境下有各种各样的设计模式，JS 开发者还是倾向于使用一些习惯性的模式。\x3c\/p\x3e\n\x3cp\x3e在这篇文章中，我将讨论这些常见的设计模式，展出优化代码库的方法，并深入解读JavaScript的内部构件。\x3c\/p\x3e\n\x3cp\x3e本文讨论的设计模式包括这几种:\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e模块设计模式\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e原型模式\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e观察者模式\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e单例模式\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e尽管每种模式都包含很多属性，这里我强调以下几点：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3e上下文\x3c\/strong\x3e: 设计模式的使用场景\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3e问题\x3c\/strong\x3e: 我们尝试解决的问题是什么?\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3e解决方法\x3c\/strong\x3e: 使用设计模式如何解决我们提出的问题?\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3e实施\x3c\/strong\x3e: 实施方案看起来怎样?\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e模块设计模式\x3c\/h2\x3e\n\x3cp\x3eJS模块化是使用最普遍的设计模式，用于保持特殊的代码块与其它组件之间互相独立。为支持结构良好的代码提供了松耦合。\x3c\/p\x3e\n\x3cp\x3e对于熟悉面向对象的开发者来说，模块就是JS的 “类”。封装是“类”的众多优点之一，可以确保它本身的状态和行为不被其它的类访问到。模块设计模式有公有和私有两种访问级别（除此之外，还有比较少为人知的保护级别、特权级别）。\x3c\/p\x3e\n\x3cp\x3e考虑到私有的作用域，模块应该是一个立即调用函数（IIFE) ，也就是说，它是一个保护其私有变量和方法的闭包。（然而，它返回的却不是一个函数，而是一个对象）。\x3cbr\x3e它的写法就是这样的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 (function() {\n\n    \/\/ declare private variables and\/or functions\n\n    return {\n      \/\/ declare public variables and\/or functions\n    }\n\n})(); \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs smali\x22\x3e\x3ccode\x3e (function() {\n\n    \/\/ declare\x3cspan class=\x22hljs-keyword\x22\x3e private\x3c\/span\x3e variables\x3cspan class=\x22hljs-built_in\x22\x3e and\/or \x3c\/span\x3efunctions\n\n   \x3cspan class=\x22hljs-built_in\x22\x3e return \x3c\/span\x3e{\n      \/\/ declare\x3cspan class=\x22hljs-keyword\x22\x3e public\x3c\/span\x3e variables\x3cspan class=\x22hljs-built_in\x22\x3e and\/or \x3c\/span\x3efunctions\n    }\n\n})(); \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们在返回一个对象之前，先初始化一下私有的变量和方法。由于作用域不同，闭包外面的代码是无法访问到闭包内的私有变量的。一起来看下更具体的实现方法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 var HTMLChanger = (function() {\n  var contents = \x27contents\x27\n\n  var changeHTML = function() {\n    var element = document.getElementById(\x27attribute-to-change\x27);\n    element.innerHTML = contents;\n  }\n\n  return {\n    callChangeHTML: function() {\n      changeHTML();\n      console.log(contents);\n    }\n  };\n\n})();\n\nHTMLChanger.callChangeHTML();       \/\/ Outputs: \x27contents\x27\nconsole.log(HTMLChanger.contents);  \/\/ undefined \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e HTMLChanger = (\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e contents = \x3cspan class=\x22hljs-string\x22\x3e\x27contents\x27\x3c\/span\x3e\n\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e changeHTML = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e element = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.getElementById(\x3cspan class=\x22hljs-string\x22\x3e\x27attribute-to-change\x27\x3c\/span\x3e);\n    element.innerHTML = contents;\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-attr\x22\x3ecallChangeHTML\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n      changeHTML();\n      \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(contents);\n    }\n  };\n\n})();\n\nHTMLChanger.callChangeHTML();       \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Outputs: \x27contents\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(HTMLChanger.contents);  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ undefined \x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e请注意 \x3ccode\x3ecallChangeHTML\x3c\/code\x3e 是在返回的对象中绑定的，因此可以访问到 \x3ccode\x3eHTMLChanger\x3c\/code\x3e 这个命名空间内的变量。然而，在模块外面，是不能访问到闭包里面的 \x3ccode\x3econtents\x3c\/code\x3e 的。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3e揭示性模块模式\x3c\/h3\x3e\n\x3cp\x3e模块模式的另一种变体称为 \x3cstrong\x3e揭示性模块模式\x3c\/strong\x3e，它主要是为了在保持封装性的同时，揭示在对象字面量中返回的特定的变量和方法。直接的实现方式类似这样：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 var Exposer = (function() {\n  var privateVariable = 10;\n\n  var privateMethod = function() {\n    console.log(\x27Inside a private method!\x27);\n    privateVariable\x2b\x2b;\n  }\n\n  var methodToExpose = function() {\n    console.log(\x27This is a method I want to expose!\x27);\n  }\n\n  var otherMethodIWantToExpose = function() {\n    privateMethod();\n  }\n\n  return {\n      first: methodToExpose,\n      second: otherMethodIWantToExpose\n  };\n})();\n\nExposer.first();        \/\/ Output: This is a method I want to expose!\nExposer.second();       \/\/ Output: Inside a private method!\nExposer.methodToExpose; \/\/ undefined \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Exposer = (\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e privateVariable = \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e;\n\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e privateMethod = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27Inside a private method!\x27\x3c\/span\x3e);\n    privateVariable\x2b\x2b;\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e methodToExpose = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27This is a method I want to expose!\x27\x3c\/span\x3e);\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e otherMethodIWantToExpose = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    privateMethod();\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-attr\x22\x3efirst\x3c\/span\x3e: methodToExpose,\n      \x3cspan class=\x22hljs-attr\x22\x3esecond\x3c\/span\x3e: otherMethodIWantToExpose\n  };\n})();\n\nExposer.first();        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Output: This is a method I want to expose!\x3c\/span\x3e\nExposer.second();       \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Output: Inside a private method!\x3c\/span\x3e\nExposer.methodToExpose; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ undefined \x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e尽管这样看起来更加简洁，但它是有明显不足的 -- 不能引用私有变量。这会给单元测试带来一定的挑战。类似地，公有行为也是不可重写的。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e原型设计模式\x3c\/h2\x3e\n\x3cp\x3eJS开发者要么把 \x3ccode\x3e原型\x3c\/code\x3e 和 \x3ccode\x3e原型继承\x3c\/code\x3e 相互混淆，要么在他们的代码里面直接使用原型。原型设计模式依赖于\x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/JavaScript\/Inheritance_and_the_prototype_chain\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eJavaScript原型继承\x3c\/a\x3e. 原型模式主要用于为高性能环境创建对象。\x3c\/p\x3e\n\x3cp\x3e被创建的对象是从传下来的原对象克隆（浅克隆）出来的。原型模式的一种使用场景，是执行一个扩展性的数据库操作来创建一个对象，把该对象用于应用的其他层面。如果其他流程需要用到这个对象，我们不需要大量地操作数据库，只要克隆一下之前创建的对象就可以了。与其实质性地操作数据库，不如从之前创建的对象克隆一个更具优势。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000007237289\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000007237289\x22 alt=\x22原型设计模式\x22 title=\x22原型设计模式\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/upload.wikimedia.org\/wikipedia\/commons\/1\/14\/Prototype_UML.svg\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\x3cem\x3eWikipedia\x3c\/em\x3e 原型设计模式图解\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3eUML 描述了原型交互是如何被用于克隆具体的代码实施方案的。\x3c\/p\x3e\n\x3cp\x3e要克隆一个对象，必须存在一个构造器来实例化第一个对象。接下来，通过使用 \x3cstrong\x3eprototype\x3c\/strong\x3e 的变量和方法来绑定对象的结构。一起来看下基本的示例：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 var TeslaModelS = function() {\n  this.numWheels    = 4;\n  this.manufacturer = \x27Tesla\x27;\n  this.make         = \x27Model S\x27;\n}\n\nTeslaModelS.prototype.go = function() {\n  \/\/ Rotate wheels\n}\n\nTeslaModelS.prototype.stop = function() {\n  \/\/ Apply brake pads\n} \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e TeslaModelS = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.numWheels    = \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.manufacturer = \x3cspan class=\x22hljs-string\x22\x3e\x27Tesla\x27\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.make         = \x3cspan class=\x22hljs-string\x22\x3e\x27Model S\x27\x3c\/span\x3e;\n}\n\nTeslaModelS.prototype.go = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Rotate wheels\x3c\/span\x3e\n}\n\nTeslaModelS.prototype.stop = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Apply brake pads\x3c\/span\x3e\n} \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e构造器 \x3ccode\x3eTeslaModelS \x3c\/code\x3e 允许创建一个简单的 TeslaModelS 对象。对于一个新创建的 TeslaModelS 对象，它将保持构造器初始化的状态。此外，它也很简单的持有 \x3cstrong\x3ego\x3c\/strong\x3e 和 \x3cstrong\x3estop\x3c\/strong\x3e 这两个方法，因为这两个方法是在 \x3cstrong\x3eprototype\x3c\/strong\x3e 声明的。在原型上拓展方法，还可以这样写：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 var TeslaModelS = function() {\n  this.numWheels    = 4;\n  this.manufacturer = \x27Tesla\x27;\n  this.make         = \x27Model S\x27;\n}\n\nTeslaModelS.prototype = {\n  go: function() {\n    \/\/ Rotate wheels\n  },\n  stop: function() {\n    \/\/ Apply brake pads\n  }\n} \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e TeslaModelS = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.numWheels    = \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.manufacturer = \x3cspan class=\x22hljs-string\x22\x3e\x27Tesla\x27\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.make         = \x3cspan class=\x22hljs-string\x22\x3e\x27Model S\x27\x3c\/span\x3e;\n}\n\nTeslaModelS.prototype = {\n  go: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Rotate wheels\x3c\/span\x3e\n  },\n  stop: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Apply brake pads\x3c\/span\x3e\n  }\n} \x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e揭示性原型模式\x3c\/h3\x3e\n\x3cp\x3e类似于模块模式，原型模式也有一个 \x3ccode\x3e揭示性模式\x3c\/code\x3e。\x3ccode\x3e揭示性原型模式\x3c\/code\x3e 通过返回一个对象字面量，对公有和私有的成员进行封装。\x3c\/p\x3e\n\x3cp\x3e由于我们返回的是一个对象，我们将在原型对象上添加 \x3ccode\x3efunction\x3c\/code\x3e 的前缀。通过对以上例子进行改写，我们可以选择在当前的 \x3ccode\x3eprototype\x3c\/code\x3e 暴露哪些方法或变量，以此来保护它们的访问层级。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 var TeslaModelS = function() {\n  this.numWheels    = 4;\n  this.manufacturer = \x27Tesla\x27;\n  this.make         = \x27Model S\x27;\n}\n\nTeslaModelS.prototype = function() {\n\n  var go = function() {\n    \/\/ Rotate wheels\n  };\n\n  var stop = function() {\n    \/\/ Apply brake pads\n  };\n\n  return {\n    pressBrakePedal: stop,\n    pressGasPedal: go\n  }\n\n}(); \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e TeslaModelS = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.numWheels    = \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.manufacturer = \x3cspan class=\x22hljs-string\x22\x3e\x27Tesla\x27\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.make         = \x3cspan class=\x22hljs-string\x22\x3e\x27Model S\x27\x3c\/span\x3e;\n}\n\nTeslaModelS.prototype = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e go = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Rotate wheels\x3c\/span\x3e\n  };\n\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e stop = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Apply brake pads\x3c\/span\x3e\n  };\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n    pressBrakePedal: stop,\n    pressGasPedal: go\n  }\n\n}(); \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e请注意 \x3ccode\x3estop\x3c\/code\x3e 和 \x3ccode\x3ego\x3c\/code\x3e 两个方法是被隔开的，因为他们在所返回的对象作用域之外。由于 JavaScript 本身支持原型继承，也就没必要重写基本的功能了。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e观察者设计模式\x3c\/h2\x3e\n\x3cp\x3e很多时候，当应用的一部分改变了，另一部分也需要相应更新。在 AngularJs 里面，如果 \x3ccode\x3e$scope\x3c\/code\x3e 被更新，就会触发一个事件去通知其他组件。结合观察这模式就是：如果一个对象改变了，它只要派发 \x3cstrong\x3ebroadcasts\x3c\/strong\x3e 事件通知依赖的对象它已经改变了则可。\x3c\/p\x3e\n\x3cp\x3e又一个典型的例子就是 \x3ccode\x3emodel-view-controller (MVC)\x3c\/code\x3e 架构了；当 \x3ccode\x3emodel\x3c\/code\x3e 改变时， 更新相应的 \x3ccode\x3eview\x3c\/code\x3e。这样做有一个好处，就是从 \x3ccode\x3emodel\x3c\/code\x3e 上解耦出 \x3ccode\x3eview\x3c\/code\x3e 来减少依赖。\x3c\/p\x3e\n\x3cp\x3e![观察这设计模式](\x26lt;html\x26gt;\x3cbr\x3e\x26lt;head\x26gt;\x26lt;title\x26gt;502 Bad Gateway\x26lt;\/title\x26gt;\x26lt;\/head\x26gt;\x3cbr\x3e\x26lt;body bgcolor=\x22white\x22\x26gt;\x3cbr\x3e\x26lt;center\x26gt;\x26lt;h1\x26gt;502 Bad Gateway\x26lt;\/h1\x26gt;\x26lt;\/center\x26gt;\x3cbr\x3e\x3c\/p\x3e\n\x3chr\x3e\x26lt;center\x26gt;nginx\/1.9.15\x26lt;\/center\x26gt;\x3cbr\x3e\x26lt;\/body\x26gt;\x3cbr\x3e\x26lt;\/html\x26gt;\x3cbr\x3e)\x3cp\x3e\x3ca href=\x22https:\/\/upload.wikimedia.org\/wikipedia\/commons\/thumb\/8\/8d\/Observer.svg\/1000px-Observer.svg.png\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eWikipedia 观察者设计模式\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e如 UML 图表所示，\x3ccode\x3esubject\x3c\/code\x3e、\x3ccode\x3eobserver\x3c\/code\x3e, and \x3ccode\x3econcrete objects\x3c\/code\x3e 是必不可少的。 \x3ccode\x3esubject\x3c\/code\x3e 包含对每个具体观察者的引用，以便传递改动信息。观察者本身是一个抽象的类，使得具体的观察者可以执行通讯方法。\x3c\/p\x3e\n\x3cp\x3e一起来看下 AngularJS 的示例，在事件管理上应用了观察这模式。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 \/\/ Controller 1\n$scope.$on(\x27nameChanged\x27, function(event, args) {\n    $scope.name = args.name;\n});\n\n...\n\n\/\/ Controller 2\n$scope.userNameChanged = function(name) {\n    $scope.$emit(\x27nameChanged\x27, {name: name});\n}; \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs php\x22\x3e\x3ccode\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Controller 1\x3c\/span\x3e\n$scope.$on(\x3cspan class=\x22hljs-string\x22\x3e\x27nameChanged\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(event, args)\x3c\/span\x3e \x3c\/span\x3e{\n    $scope.name = args.name;\n});\n\n...\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Controller 2\x3c\/span\x3e\n$scope.userNameChanged = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(name)\x3c\/span\x3e \x3c\/span\x3e{\n    $scope.$emit(\x3cspan class=\x22hljs-string\x22\x3e\x27nameChanged\x27\x3c\/span\x3e, {name: name});\n}; \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e使用观察者模式，重要的一点就是要区分独立的对象或者 \x3cstrong\x3esubject(主体)\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e在看到观察者模式众多优点的同时，我们必须注意到它的一个缺点：随着观察者数量的增加，应用的性能会大大降低。大家都比较熟悉的观察者就是 \x3cstrong\x3ewatchers\x3c\/strong\x3e 。 在AngularJS中，我们可以 \x3cstrong\x3ewatch\x3c\/strong\x3e 变量、方法和对象。\x3cstrong\x3e$digest\x3c\/strong\x3e 循环更新，当一个作用域内对象被修改时，它就把新的值告诉每个监听者。\x3c\/p\x3e\n\x3cp\x3e我们可以在JS中创建自己的主体和观察者。一起来看下下面的代码是如何运行的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 var Subject = function() {\n  this.observers = [];\n\n  return {\n    subscribeObserver: function(observer) {\n      this.observers.push(observer);\n    },\n    unsubscribeObserver: function(observer) {\n      var index = this.observers.indexOf(observer);\n      if(index \x3e -1) {\n        this.observers.splice(index, 1);\n      }\n    },\n    notifyObserver: function(observer) {\n      var index = this.observers.indexOf(observer);\n      if(index \x3e -1) {\n        this.observers[index].notify(index);\n      }\n    },\n    notifyAllObservers: function() {\n      for(var i = 0; i \x3c this.observers.length; i\x2b\x2b){\n        this.observers[i].notify(i);\n      };\n    }\n  };\n};\n\nvar Observer = function() {\n  return {\n    notify: function(index) {\n      console.log(\x26quot;Observer \x26quot; \x2b index \x2b \x26quot; is notified!\x26quot;);\n    }\n  }\n}\n\nvar subject = new Subject();\n\nvar observer1 = new Observer();\nvar observer2 = new Observer();\nvar observer3 = new Observer();\nvar observer4 = new Observer();\n\nsubject.subscribeObserver(observer1);\nsubject.subscribeObserver(observer2);\nsubject.subscribeObserver(observer3);\nsubject.subscribeObserver(observer4);\n\nsubject.notifyObserver(observer2); \/\/ Observer 2 is notified!\n\nsubject.notifyAllObservers();\n\/\/ Observer 1 is notified!\n\/\/ Observer 2 is notified!\n\/\/ Observer 3 is notified!\n\/\/ Observer 4 is notified! \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Subject = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.observers = [];\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-attr\x22\x3esubscribeObserver\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eobserver\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.observers.push(observer);\n    },\n    \x3cspan class=\x22hljs-attr\x22\x3eunsubscribeObserver\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eobserver\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e index = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.observers.indexOf(observer);\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(index \x26gt; \x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.observers.splice(index, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\n      }\n    },\n    \x3cspan class=\x22hljs-attr\x22\x3enotifyObserver\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eobserver\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e index = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.observers.indexOf(observer);\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(index \x26gt; \x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.observers[index].notify(index);\n      }\n    },\n    \x3cspan class=\x22hljs-attr\x22\x3enotifyAllObservers\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.observers.length; i\x2b\x2b){\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.observers[i].notify(i);\n      };\n    }\n  };\n};\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Observer = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-attr\x22\x3enotify\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eindex\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22Observer \x22\x3c\/span\x3e \x2b index \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22 is notified!\x22\x3c\/span\x3e);\n    }\n  }\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e subject = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Subject();\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e observer1 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Observer();\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e observer2 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Observer();\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e observer3 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Observer();\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e observer4 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Observer();\n\nsubject.subscribeObserver(observer1);\nsubject.subscribeObserver(observer2);\nsubject.subscribeObserver(observer3);\nsubject.subscribeObserver(observer4);\n\nsubject.notifyObserver(observer2); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Observer 2 is notified!\x3c\/span\x3e\n\nsubject.notifyAllObservers();\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Observer 1 is notified!\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Observer 2 is notified!\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Observer 3 is notified!\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Observer 4 is notified! \x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e发布、订阅模式\x3c\/h3\x3e\n\x3cp\x3e然而，发布、订阅模式是采用一个话题来绑定发布者和订阅者之间的关系，订阅者接收事件通知，发布者派发事件。该事件系统支持定义特殊应用的事件，可以传递包含订阅者本身需要的自定义参数。这样做主要是为了避免订阅者和发布者之间的依赖。\x3c\/p\x3e\n\x3cp\x3e这里有别于观察者模式的是，任何订阅者都可以通过恰当的事件处理器来注册并接受发布者广播的通知。\x3c\/p\x3e\n\x3cp\x3e很多开发者选择把 \x3ccode\x3e发布订阅模式\x3c\/code\x3e 和 \x3ccode\x3e观察者模式\x3c\/code\x3e 结合起来用，尽管他们最终的目标只有一个。发布订阅模式中的订阅者是通过一些通讯媒介被告知的，而观察者则是通过执行事件处理器来获得消息通知。\x3c\/p\x3e\n\x3cp\x3e在 AngularJs， 订阅者使用 \x3ccode\x3e$on(event、cbk)\x3c\/code\x3e 来订阅一个事件，发布者则使用\x3ccode\x3e$emit(‘event’, args)\x3c\/code\x3e 或者 \x3ccode\x3e$broadcast(‘event’, args)\x3c\/code\x3e 来发布一个事件。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3e单例模式\x3c\/h2\x3e\n\x3cp\x3e单例模式只允许实例化一个对象，但是相同的对象，会用很多个实例。单例模式制约着客户端创建多个对象。第一个对象创建后，就返回实例本身。\x3c\/p\x3e\n\x3cp\x3e单例模式比较少用，很难找到实际开发的例子。使用一个办公室打印机的例子吧。假设办公室有10个人，他们都用到打印机，10台电脑共享一部打印机（一个实例）。通过分享一部打印机，他们共享相同的资源。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 var printer = (function () {\n\n  var printerInstance;\n\n  function create () {\n\n    function print() {\n      \/\/ underlying printer mechanics\n    }\n\n    function turnOn() {\n      \/\/ warm up\n      \/\/ check for paper\n    }\n\n    return {\n      \/\/ public \x2b private states and behaviors\n      print: print,\n      turnOn: turnOn\n    };\n  }\n\n  return {\n    getInstance: function() {\n      if(!printerInstance) {\n        printerInstance = create();\n      }\n      return printerInstance;\n    }\n  };\n\n  function Singleton () {\n    if(!printerInstance) {\n      printerInstance = intialize();\n    }\n  };\n\n})(); \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs php\x22\x3e\x3ccode\x3e \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e printer = (\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e printerInstance;\n\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecreate\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eprint\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ underlying printer mechanics\x3c\/span\x3e\n    }\n\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eturnOn\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ warm up\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ check for paper\x3c\/span\x3e\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ public \x2b private states and behaviors\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3eprint\x3c\/span\x3e: \x3cspan class=\x22hljs-keyword\x22\x3eprint\x3c\/span\x3e,\n      turnOn: turnOn\n    };\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n    getInstance: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(!printerInstance) {\n        printerInstance = create();\n      }\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e printerInstance;\n    }\n  };\n\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eSingleton\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(!printerInstance) {\n      printerInstance = intialize();\n    }\n  };\n\n})(); \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3ecreate\x3c\/code\x3e 这个方法是私有的，因为我们不希望它被外部人员访问到，然而，\x3ccode\x3egetInstance\x3c\/code\x3e 方法是公有的。每个办公人员都可以实例化一个 \x3ccode\x3eprinter\x3c\/code\x3e，只需要这样调用一下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 `var officePrinter = printer.getInstance();` \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs clean\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e `var officePrinter = printer.getInstance();` \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e单例模式在 AngularJS 相当流行，最常见的是作为 \x3ccode\x3eservices\x3c\/code\x3e、\x3ccode\x3efactories\x3c\/code\x3e、和 \x3ccode\x3eproviders\x3c\/code\x3e。它们维护状态，提供资源访问，创建两个实例摆脱一个共享的\x3ccode\x3eservice\/factory\/provider\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e在多线程的应用中，当多个线程尝试去访问同个资源时，就会出现 \x3ccode\x3e竞争状态\x3c\/code\x3e。单例模式会受到竞争状态的干扰，比如在没有初始化实例的情况下，两个线程会创建两个对象，而不是返回一个实例。这与单例模式的目的是相悖的。因此，开发者在多线程应用里面使用单例模式时，必须清楚同步性。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3e总结\x3c\/h2\x3e\n\x3cp\x3e设计模式经常用于比较大型的应用，想知道哪种模式更具优势，来实践吧。\x3c\/p\x3e\n\x3cp\x3e在构建任何应用之前，都应该全面地考虑每个角色，以及它们之间存在的关系。在回顾 \x3ccode\x3e模块模式\x3c\/code\x3e、\x3ccode\x3e原型模式\x3c\/code\x3e、\x3ccode\x3e观察者模式\x3c\/code\x3e 和 \x3ccode\x3e单例模式\x3c\/code\x3e 之后，你应该能够区分它们，并且在实际开发中使用它们了。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>[译] 你应了解的4种JS设计模式</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000007231454">https://segmentfault.com/a/1190000007231454</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/ic0ez5uyk2/" target="_blank">https://alili.tech/archive/ic0ez5uyk2/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>