<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="vue2源码学习开胃菜——snabbdom源码学习（一）"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>vue2源码学习开胃菜——snabbdom源码学习（一） | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/jj4reknq0oe/",
				"appid": "1613049289050283", 
				"title": "vue2源码学习开胃菜——snabbdom源码学习（一） | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-17T02:30:25"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/vvx7lu683hc/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/tb15k5jdl4n/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fjj4reknq0oe%2f&text=vue2%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a0%e5%bc%80%e8%83%83%e8%8f%9c%e2%80%94%e2%80%94snabbdom%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a0%ef%bc%88%e4%b8%80%ef%bc%89"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fjj4reknq0oe%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fjj4reknq0oe%2f&text=vue2%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a0%e5%bc%80%e8%83%83%e8%8f%9c%e2%80%94%e2%80%94snabbdom%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a0%ef%bc%88%e4%b8%80%ef%bc%89"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fjj4reknq0oe%2f&title=vue2%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a0%e5%bc%80%e8%83%83%e8%8f%9c%e2%80%94%e2%80%94snabbdom%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a0%ef%bc%88%e4%b8%80%ef%bc%89"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fjj4reknq0oe%2f&is_video=false&description=vue2%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a0%e5%bc%80%e8%83%83%e8%8f%9c%e2%80%94%e2%80%94snabbdom%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a0%ef%bc%88%e4%b8%80%ef%bc%89"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=vue2%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a0%e5%bc%80%e8%83%83%e8%8f%9c%e2%80%94%e2%80%94snabbdom%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a0%ef%bc%88%e4%b8%80%ef%bc%89&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fjj4reknq0oe%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fjj4reknq0oe%2f&title=vue2%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a0%e5%bc%80%e8%83%83%e8%8f%9c%e2%80%94%e2%80%94snabbdom%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a0%ef%bc%88%e4%b8%80%ef%bc%89"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fjj4reknq0oe%2f&title=vue2%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a0%e5%bc%80%e8%83%83%e8%8f%9c%e2%80%94%e2%80%94snabbdom%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a0%ef%bc%88%e4%b8%80%ef%bc%89"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fjj4reknq0oe%2f&title=vue2%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a0%e5%bc%80%e8%83%83%e8%8f%9c%e2%80%94%e2%80%94snabbdom%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a0%ef%bc%88%e4%b8%80%ef%bc%89"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fjj4reknq0oe%2f&title=vue2%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a0%e5%bc%80%e8%83%83%e8%8f%9c%e2%80%94%e2%80%94snabbdom%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a0%ef%bc%88%e4%b8%80%ef%bc%89"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">vue2源码学习开胃菜——snabbdom源码学习（一）</h1><div class="meta"><div class="postdate"><time datetime="2019-01-17" itemprop="datePublished">2019-01-17</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch1 id=\x22articleHeader0\x22\x3e前言\x3c\/h1\x3e\n\x3cp\x3e最近在学习vue2.0的源码，刚开始看其vdom源码，着实找不到方向，因为其在vdom的实现上还加\x3cbr\x3e入了很多vue2.0本身的钩子，加大了阅读难度。于是看到第一行尤大说vue2.0的vdom是在snabbdom\x3cbr\x3e的基础上改过来的，而snabbdom只有不到300sloc，那不妨先从snabbdom入手，熟悉其中的原理，\x3cbr\x3e再配合vue2.0的vdom看，效果可能更好。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader1\x22\x3e什么是virtual-dom\x3c\/h1\x3e\n\x3cp\x3evirtual-dom可以看做一棵模拟了DOM树的JavaScript树，其主要是通过vnode,实现一个无\x3cbr\x3e状态的组件，当组件状态发生更新时，然后触发virtual-dom数据的变化，然后通过virtual-dom\x3cbr\x3e和真实DOM的比对，再对真实dom更新。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader2\x22\x3e为什么是virtual-dom\x3c\/h1\x3e\n\x3cp\x3e我们知道，当我们希望实现一个具有复杂状态的界面时，如果我们在每个可能发生变化的组件上都绑定\x3cbr\x3e事件，绑定字段数据，那么很快由于状态太多，我们需要维护的事件和字段将会越来越多，代码也会\x3cbr\x3e越来越复杂，于是，我们想我们可不可以将视图和状态分开来，只要视图发生变化，对应状态也发生\x3cbr\x3e变化，然后状态变化，我们再重绘整个视图就好了。这样的想法虽好，但是代价太高了，于是我们又\x3cbr\x3e想，能不能只更新状态发生变化的视图？于是virtual-dom应运而生，状态变化先反馈到vdom上，\x3cbr\x3evdom在找到最小更新视图，最后批量更新到真实DOM上，从而达到性能的提升。\x3c\/p\x3e\n\x3cp\x3e除此之外，从移植性上看，virtual-dom还对真实dom做了一次抽象，这意味着virtual-dom对应\x3cbr\x3e的可以不是浏览器的dom，而是不同设备的组件，极大的方便了多平台的使用。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader3\x22\x3esnabbdom目录结构\x3c\/h1\x3e\n\x3cp\x3e好了，说了这么多，我们先来看看snabbdom吧，我看的是这个版本的\x3ca href=\x22https:\/\/github.com\/snabbdom\/snabbdom\/tree\/8079ba78685b0f0e0e67891782c3e8fb9d54d5b8\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3esnabbdom\x3c\/a\x3e\x3cbr\x3e(心塞，typescript学的不深，看最新版的有点吃力，所以选了ts版本前的一个版本)。好了我们先\x3cbr\x3e看看snabbdom的主要目录结构。\x3c\/p\x3e\n\x3ctable\x3e\n\x3cthead\x3e\x3ctr\x3e\n\x3cth\x3e名称\x3c\/th\x3e\n\x3cth align=\x22center\x22\x3e类型\x3c\/th\x3e\n\x3cth align=\x22right\x22\x3e解释\x3c\/th\x3e\n\x3c\/tr\x3e\x3c\/thead\x3e\n\x3ctbody\x3e\n\x3ctr\x3e\n\x3ctd\x3edist\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e文件夹\x3c\/td\x3e\n\x3ctd align=\x22right\x22\x3e里面包含了snabddom打包后的文件\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eexamples\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e文件夹\x3c\/td\x3e\n\x3ctd align=\x22right\x22\x3e里面包含了使用snabbdom的例子\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3ehelpers\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e文件夹\x3c\/td\x3e\n\x3ctd align=\x22right\x22\x3e包含svg操作需要的工具\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3emodules\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e文件夹\x3c\/td\x3e\n\x3ctd align=\x22right\x22\x3e包含了对attribute，props，class，dataset，eventlistner，style，hero的操作\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eperf\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e文件夹\x3c\/td\x3e\n\x3ctd align=\x22right\x22\x3e性能测试\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3etest\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e文件夹\x3c\/td\x3e\n\x3ctd align=\x22right\x22\x3e测试\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eh\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e文件\x3c\/td\x3e\n\x3ctd align=\x22right\x22\x3e把状态转化为vnode\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3ehtmldomapi\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e文件\x3c\/td\x3e\n\x3ctd align=\x22right\x22\x3e原生dom操作的抽象\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3eis\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e文件\x3c\/td\x3e\n\x3ctd align=\x22right\x22\x3e判断类型\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3esnabbdom.bundle\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e文件\x3c\/td\x3e\n\x3ctd align=\x22right\x22\x3esnabbdom本身依赖打包\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3esnabbdom\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e文件\x3c\/td\x3e\n\x3ctd align=\x22right\x22\x3esnabbdom 核心，包含diff，patch等操作\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3ethunk\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e文件\x3c\/td\x3e\n\x3ctd align=\x22right\x22\x3esnabbdom下的thunk功能实现\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3evnode\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3e文件\x3c\/td\x3e\n\x3ctd align=\x22right\x22\x3e构造vnode\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3c\/tbody\x3e\n\x3c\/table\x3e\n\x3ch1 id=\x22articleHeader4\x22\x3esnabbdom源码之旅\x3c\/h1\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e第一站 vnode\x3c\/h2\x3e\n\x3cp\x3e首先，我们从最简单的vnode开始入手，vnode实现的功能非常简单，就是讲输入的数据转化为vnode\x3cbr\x3e对象的形式\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    \/\/VNode函数，用于将输入转化成VNode\n    \/**\n     *\n     * @param sel    选择器\n     * @param data    绑定的数据\n     * @param children    子节点数组\n     * @param text    当前text节点内容\n     * @param elm    对真实dom element的引用\n     * @returns \x22{{\x22sel: *, data: *, children: *, text: *, elm: *, key: undefined\x22}}\x22\n     *\/\n    module.exports = function ( sel, data, children, text, elm ) {\n        var key = data === undefined ? undefined : data.key;\n        return {\n            sel: sel, data: data, children: children,\n            text: text, elm: elm, key: key\n        };\n    };\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e    \x3cspan class=\x22hljs-comment\x22\x3e\/\/VNode函数，用于将输入转化成VNode\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/**\n     *\n     * @param sel    选择器\n     * @param data    绑定的数据\n     * @param children    子节点数组\n     * @param text    当前text节点内容\n     * @param elm    对真实dom element的引用\n     * @returns \x22{{\x22sel: *, data: *, children: *, text: *, elm: *, key: undefined\x22}}\x22\n     *\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e sel, data, children, text, elm \x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e key = data === \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e ? \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e : data.key;\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n            \x3cspan class=\x22hljs-attr\x22\x3esel\x3c\/span\x3e: sel, \x3cspan class=\x22hljs-attr\x22\x3edata\x3c\/span\x3e: data, \x3cspan class=\x22hljs-attr\x22\x3echildren\x3c\/span\x3e: children,\n            \x3cspan class=\x22hljs-attr\x22\x3etext\x3c\/span\x3e: text, \x3cspan class=\x22hljs-attr\x22\x3eelm\x3c\/span\x3e: elm, \x3cspan class=\x22hljs-attr\x22\x3ekey\x3c\/span\x3e: key\n        };\n    };\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3evnode主要有5大属性：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3esel 对应的是选择器,如\x27div\x27,\x27div#a\x27,\x27div#a.b.c\x27的形式\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3edata 对应的是vnode绑定的数据，可以有以下类型：attribute、props、eventlistner、\x3cbr\x3eclass、dataset、hook\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3echildren 子元素数组\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3etext 文本，代表该节点中的文本内容\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eelm 里面存储着对对应的真实dom element的引用\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ekey 用于不同vnode之间的比对\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3e第二站 h\x3c\/h2\x3e\n\x3cp\x3e说完vnode,就到h了，h也是一个包装函数，主要是在vnode上再做一层包装，实现功能如下\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e如果是svg，则为其添加命名空间\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e将children中的text包装成vnode形式\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var VNode = require ( \x27.\/vnode\x27 );\nvar is = require ( \x27.\/is\x27 );\n\/\/添加命名空间（svg才需要）\nfunction addNS ( data, children, sel ) {\n    data.ns = \x27http:\/\/www.w3.org\/2000\/svg\x27;\n\/\/如果选择器\n    if ( sel !== \x27foreignObject\x27 \x26amp;\x26amp; children !== undefined ) {\n        \/\/递归为子节点添加命名空间\n        for (var i = 0; i \x3c children.length; \x2b\x2bi) {\n            addNS ( children[ i ].data, children[ i ].children, children[ i ].sel );\n        }\n    }\n}\n\/\/将VNode渲染为VDOM\n\/**\n *\n * @param sel 选择器\n * @param b    数据\n * @param c    子节点\n * @returns \x22{{\x22sel, data, children, text, elm, key\x22}}\x22\n *\/\nmodule.exports = function h ( sel, b, c ) {\n    var data = {}, children, text, i;\n    \/\/如果存在子节点\n    if ( c !== undefined ) {\n        \/\/那么h的第二项就是data\n        data = b;\n        \/\/如果c是数组，那么存在子element节点\n        if ( is.array ( c ) ) {\n            children = c;\n        }\n        \/\/否则为子text节点\n        else if ( is.primitive ( c ) ) {\n            text = c;\n        }\n    }\n    \/\/如果c不存在，只存在b，那么说明需要渲染的vdom不存在data部分，只存在子节点部分\n    else if ( b !== undefined ) {\n        if ( is.array ( b ) ) {\n            children = b;\n        }\n        else if ( is.primitive ( b ) ) {\n            text = b;\n        }\n        else {\n            data = b;\n        }\n    }\n    if ( is.array ( children ) ) {\n        for (i = 0; i \x3c children.length; \x2b\x2bi) {\n            \/\/如果子节点数组中，存在节点是原始类型，说明该节点是text节点，因此我们将它渲染为一个只包含text的VNode\n            if ( is.primitive ( children[ i ] ) ) children[ i ] = VNode ( undefined, undefined, undefined, children[ i ] );\n        }\n    }\n    \/\/如果是svg，需要为节点添加命名空间\n    if ( sel[ 0 ] === \x27s\x27 \x26amp;\x26amp; sel[ 1 ] === \x27v\x27 \x26amp;\x26amp; sel[ 2 ] === \x27g\x27 ) {\n        addNS ( data, children, sel );\n    }\n    return VNode ( sel, data, children, text, undefined );\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e VNode = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e ( \x3cspan class=\x22hljs-string\x22\x3e\x27.\/vnode\x27\x3c\/span\x3e );\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e is = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e ( \x3cspan class=\x22hljs-string\x22\x3e\x27.\/is\x27\x3c\/span\x3e );\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/添加命名空间（svg才需要）\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eaddNS\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e data, children, sel \x3c\/span\x3e) \x3c\/span\x3e{\n    data.ns = \x3cspan class=\x22hljs-string\x22\x3e\x27http:\/\/www.w3.org\/2000\/svg\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/如果选择器\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( sel !== \x3cspan class=\x22hljs-string\x22\x3e\x27foreignObject\x27\x3c\/span\x3e \x26amp;\x26amp; children !== \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e ) {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/递归为子节点添加命名空间\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; children.length; \x2b\x2bi) {\n            addNS ( children[ i ].data, children[ i ].children, children[ i ].sel );\n        }\n    }\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/将VNode渲染为VDOM\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/**\n *\n * @param sel 选择器\n * @param b    数据\n * @param c    子节点\n * @returns \x22{{\x22sel, data, children, text, elm, key\x22}}\x22\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eh\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e sel, b, c \x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e data = {}, children, text, i;\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果存在子节点\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( c !== \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e ) {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/那么h的第二项就是data\x3c\/span\x3e\n        data = b;\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果c是数组，那么存在子element节点\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( is.array ( c ) ) {\n            children = c;\n        }\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/否则为子text节点\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( is.primitive ( c ) ) {\n            text = c;\n        }\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果c不存在，只存在b，那么说明需要渲染的vdom不存在data部分，只存在子节点部分\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( b !== \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e ) {\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( is.array ( b ) ) {\n            children = b;\n        }\n        \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( is.primitive ( b ) ) {\n            text = b;\n        }\n        \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n            data = b;\n        }\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( is.array ( children ) ) {\n        \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; children.length; \x2b\x2bi) {\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果子节点数组中，存在节点是原始类型，说明该节点是text节点，因此我们将它渲染为一个只包含text的VNode\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( is.primitive ( children[ i ] ) ) children[ i ] = VNode ( \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e, \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e, \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e, children[ i ] );\n        }\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果是svg，需要为节点添加命名空间\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( sel[ \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e ] === \x3cspan class=\x22hljs-string\x22\x3e\x27s\x27\x3c\/span\x3e \x26amp;\x26amp; sel[ \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e ] === \x3cspan class=\x22hljs-string\x22\x3e\x27v\x27\x3c\/span\x3e \x26amp;\x26amp; sel[ \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e ] === \x3cspan class=\x22hljs-string\x22\x3e\x27g\x27\x3c\/span\x3e ) {\n        addNS ( data, children, sel );\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e VNode ( sel, data, children, text, \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e );\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3e第三站 htmldomapi\x3c\/h2\x3e\n\x3cp\x3ehtmldomapi中提供了对原生dom操作的一层抽象，这里就不再阐述了\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3e第四站 modules\x3c\/h2\x3e\n\x3cp\x3emodules中主要包含attributes，class，props，dataset，eventlistener，hero，style\x3cbr\x3e这些模块，其中attributes,class,props,dataset,eventlistener,style这些模块是我们\x3cbr\x3e日常所需要的，也是snabbdom.bundle默认注入的也是这几个，这里就详细介绍这几个模块\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3eattributes\x3c\/h3\x3e\n\x3cp\x3e主要功能如下：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e从elm的属性中删除vnode中不存在的属性（包括那些boolean类属性，如果新vnode设置为false，同样删除）\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e如果oldvnode与vnode用同名属性，则在elm上更新对应属性值\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e如果vnode有新属性，则添加到elm中\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e如果存在命名空间，则用\x3ccode\x3esetAttributeNS\x3c\/code\x3e设置\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var NamespaceURIs = {\n  \x26quot;xlink\x26quot;: \x26quot;http:\/\/www.w3.org\/1999\/xlink\x26quot;\n};\n\nvar booleanAttrs = [\x26quot;allowfullscreen\x26quot;, \x26quot;async\x26quot;, \x26quot;autofocus\x26quot;, \x26quot;autoplay\x26quot;, \x26quot;checked\x26quot;, \x26quot;compact\x26quot;, \x26quot;controls\x26quot;, \x26quot;declare\x26quot;,\n                \x26quot;default\x26quot;, \x26quot;defaultchecked\x26quot;, \x26quot;defaultmuted\x26quot;, \x26quot;defaultselected\x26quot;, \x26quot;defer\x26quot;, \x26quot;disabled\x26quot;, \x26quot;draggable\x26quot;,\n                \x26quot;enabled\x26quot;, \x26quot;formnovalidate\x26quot;, \x26quot;hidden\x26quot;, \x26quot;indeterminate\x26quot;, \x26quot;inert\x26quot;, \x26quot;ismap\x26quot;, \x26quot;itemscope\x26quot;, \x26quot;loop\x26quot;, \x26quot;multiple\x26quot;,\n                \x26quot;muted\x26quot;, \x26quot;nohref\x26quot;, \x26quot;noresize\x26quot;, \x26quot;noshade\x26quot;, \x26quot;novalidate\x26quot;, \x26quot;nowrap\x26quot;, \x26quot;open\x26quot;, \x26quot;pauseonexit\x26quot;, \x26quot;readonly\x26quot;,\n                \x26quot;required\x26quot;, \x26quot;reversed\x26quot;, \x26quot;scoped\x26quot;, \x26quot;seamless\x26quot;, \x26quot;selected\x26quot;, \x26quot;sortable\x26quot;, \x26quot;spellcheck\x26quot;, \x26quot;translate\x26quot;,\n                \x26quot;truespeed\x26quot;, \x26quot;typemustmatch\x26quot;, \x26quot;visible\x26quot;];\n\nvar booleanAttrsDict = Object.create(null);\n\n\/\/创建属性字典，默认为true\nfor(var i=0, len = booleanAttrs.length; i \x3c len; i\x2b\x2b) {\n  booleanAttrsDict[booleanAttrs[i]] = true;\n}\n\nfunction updateAttrs(oldVnode, vnode) {\n  var key, cur, old, elm = vnode.elm,\n      oldAttrs = oldVnode.data.attrs, attrs = vnode.data.attrs, namespaceSplit;\n\n\n  \/\/如果旧节点和新节点都不包含属性，立刻返回\n  if (!oldAttrs \x26amp;\x26amp; !attrs) return;\n  oldAttrs = oldAttrs || {};\n  attrs = attrs || {};\n\n  \/\/ update modified attributes, add new attributes\n  \/\/更新改变了的属性，添加新的属性\n  for (key in attrs) {\n    cur = attrs[key];\n    old = oldAttrs[key];\n    \/\/如果旧的属性和新的属性不同\n    if (old !== cur) {\n    \/\/如果是boolean类属性，当vnode设置为falsy value时，直接删除，而不是更新值\n      if(!cur \x26amp;\x26amp; booleanAttrsDict[key])\n        elm.removeAttribute(key);\n      else {\n        \/\/否则更新属性值或者添加属性\n        \/\/如果存在命名空间\n        namespaceSplit = key.split(\x26quot;:\x26quot;);\n        if(namespaceSplit.length \x3e 1 \x26amp;\x26amp; NamespaceURIs.hasOwnProperty(namespaceSplit[0]))\n          elm.setAttributeNS(NamespaceURIs[namespaceSplit[0]], key, cur);\n        else\n          elm.setAttribute(key, cur);\n      }\n    }\n  }\n  \/\/remove removed attributes\n  \/\/ use `in` operator since the previous `for` iteration uses it (.i.e. add even attributes with undefined value)\n  \/\/ the other option is to remove all attributes with value == undefined\n  \/\/删除不在新节点属性中的旧节点的属性\n  for (key in oldAttrs) {\n    if (!(key in attrs)) {\n      elm.removeAttribute(key);\n    }\n  }\n}\n\nmodule.exports = {create: updateAttrs, update: updateAttrs};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e NamespaceURIs = {\n  \x3cspan class=\x22hljs-string\x22\x3e\x22xlink\x22\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22http:\/\/www.w3.org\/1999\/xlink\x22\x3c\/span\x3e\n};\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e booleanAttrs = [\x3cspan class=\x22hljs-string\x22\x3e\x22allowfullscreen\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22async\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22autofocus\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22autoplay\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22checked\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22compact\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22controls\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22declare\x22\x3c\/span\x3e,\n                \x3cspan class=\x22hljs-string\x22\x3e\x22default\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22defaultchecked\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22defaultmuted\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22defaultselected\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22defer\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22disabled\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22draggable\x22\x3c\/span\x3e,\n                \x3cspan class=\x22hljs-string\x22\x3e\x22enabled\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22formnovalidate\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22hidden\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22indeterminate\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22inert\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22ismap\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22itemscope\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22loop\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22multiple\x22\x3c\/span\x3e,\n                \x3cspan class=\x22hljs-string\x22\x3e\x22muted\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22nohref\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22noresize\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22noshade\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22novalidate\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22nowrap\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22open\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22pauseonexit\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22readonly\x22\x3c\/span\x3e,\n                \x3cspan class=\x22hljs-string\x22\x3e\x22required\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22reversed\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22scoped\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22seamless\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22selected\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22sortable\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22spellcheck\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22translate\x22\x3c\/span\x3e,\n                \x3cspan class=\x22hljs-string\x22\x3e\x22truespeed\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22typemustmatch\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22visible\x22\x3c\/span\x3e];\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e booleanAttrsDict = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.create(\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/创建属性字典，默认为true\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i=\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, len = booleanAttrs.length; i \x26lt; len; i\x2b\x2b) {\n  booleanAttrsDict[booleanAttrs[i]] = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eupdateAttrs\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eoldVnode, vnode\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e key, cur, old, elm = vnode.elm,\n      oldAttrs = oldVnode.data.attrs, attrs = vnode.data.attrs, namespaceSplit;\n\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果旧节点和新节点都不包含属性，立刻返回\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!oldAttrs \x26amp;\x26amp; !attrs) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n  oldAttrs = oldAttrs || {};\n  attrs = attrs || {};\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ update modified attributes, add new attributes\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/更新改变了的属性，添加新的属性\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (key \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e attrs) {\n    cur = attrs[key];\n    old = oldAttrs[key];\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果旧的属性和新的属性不同\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (old !== cur) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果是boolean类属性，当vnode设置为falsy value时，直接删除，而不是更新值\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(!cur \x26amp;\x26amp; booleanAttrsDict[key])\n        elm.removeAttribute(key);\n      \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/否则更新属性值或者添加属性\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果存在命名空间\x3c\/span\x3e\n        namespaceSplit = key.split(\x3cspan class=\x22hljs-string\x22\x3e\x22:\x22\x3c\/span\x3e);\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(namespaceSplit.length \x26gt; \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e \x26amp;\x26amp; NamespaceURIs.hasOwnProperty(namespaceSplit[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e]))\n          elm.setAttributeNS(NamespaceURIs[namespaceSplit[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e]], key, cur);\n        \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e\n          elm.setAttribute(key, cur);\n      }\n    }\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/remove removed attributes\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ use `in` operator since the previous `for` iteration uses it (.i.e. add even attributes with undefined value)\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ the other option is to remove all attributes with value == undefined\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/删除不在新节点属性中的旧节点的属性\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (key \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e oldAttrs) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!(key \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e attrs)) {\n      elm.removeAttribute(key);\n    }\n  }\n}\n\n\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = {\x3cspan class=\x22hljs-attr\x22\x3ecreate\x3c\/span\x3e: updateAttrs, \x3cspan class=\x22hljs-attr\x22\x3eupdate\x3c\/span\x3e: updateAttrs};\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3eclass\x3c\/h3\x3e\n\x3cp\x3e主要功能如下：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e从elm中删除vnode中不存在的或者值为false的类\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e将vnode中新的class添加到elm上去\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function updateClass(oldVnode, vnode) {\n  var cur, name, elm = vnode.elm,\n      oldClass = oldVnode.data.class,\n      klass = vnode.data.class;\n  \/\/如果旧节点和新节点都没有class，直接返回\n  if (!oldClass \x26amp;\x26amp; !klass) return;\n  oldClass = oldClass || {};\n  klass = klass || {};\n  \/\/从旧节点中删除新节点不存在的类\n  for (name in oldClass) {\n    if (!klass[name]) {\n      elm.classList.remove(name);\n    }\n  }\n  \/\/如果新节点中对应旧节点的类设置为false，则删除该类，如果新设置为true，则添加该类\n  for (name in klass) {\n    cur = klass[name];\n    if (cur !== oldClass[name]) {\n      elm.classList[cur ? \x27add\x27 : \x27remove\x27](name);\n    }\n  }\n}\n\nmodule.exports = {create: updateClass, update: updateClass};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eupdateClass\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eoldVnode, vnode\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e cur, name, elm = vnode.elm,\n      oldClass = oldVnode.data.class,\n      klass = vnode.data.class;\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果旧节点和新节点都没有class，直接返回\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!oldClass \x26amp;\x26amp; !klass) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n  oldClass = oldClass || {};\n  klass = klass || {};\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/从旧节点中删除新节点不存在的类\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (name \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e oldClass) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!klass[name]) {\n      elm.classList.remove(name);\n    }\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果新节点中对应旧节点的类设置为false，则删除该类，如果新设置为true，则添加该类\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (name \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e klass) {\n    cur = klass[name];\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (cur !== oldClass[name]) {\n      elm.classList[cur ? \x3cspan class=\x22hljs-string\x22\x3e\x27add\x27\x3c\/span\x3e : \x3cspan class=\x22hljs-string\x22\x3e\x27remove\x27\x3c\/span\x3e](name);\n    }\n  }\n}\n\n\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = {\x3cspan class=\x22hljs-attr\x22\x3ecreate\x3c\/span\x3e: updateClass, \x3cspan class=\x22hljs-attr\x22\x3eupdate\x3c\/span\x3e: updateClass};\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader11\x22\x3edataset\x3c\/h3\x3e\n\x3cp\x3e主要功能如下：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e从elm中删除vnode不存在的属性集中的属性\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e更新属性集中的属性值\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function updateDataset(oldVnode, vnode) {\n  var elm = vnode.elm,\n    oldDataset = oldVnode.data.dataset,\n    dataset = vnode.data.dataset,\n    key\n\n  \/\/如果新旧节点都没数据集，则直接返回\n  if (!oldDataset \x26amp;\x26amp; !dataset) return;\n  oldDataset = oldDataset || {};\n  dataset = dataset || {};\n \/\/删除旧节点中在新节点不存在的数据集\n  for (key in oldDataset) {\n    if (!dataset[key]) {\n      delete elm.dataset[key];\n    }\n  }\n  \/\/更新数据集\n  for (key in dataset) {\n    if (oldDataset[key] !== dataset[key]) {\n      elm.dataset[key] = dataset[key];\n    }\n  }\n}\n\nmodule.exports = {create: updateDataset, update: updateDataset}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eupdateDataset\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eoldVnode, vnode\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e elm = vnode.elm,\n    oldDataset = oldVnode.data.dataset,\n    dataset = vnode.data.dataset,\n    key\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果新旧节点都没数据集，则直接返回\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!oldDataset \x26amp;\x26amp; !dataset) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n  oldDataset = oldDataset || {};\n  dataset = dataset || {};\n \x3cspan class=\x22hljs-comment\x22\x3e\/\/删除旧节点中在新节点不存在的数据集\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (key \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e oldDataset) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!dataset[key]) {\n      \x3cspan class=\x22hljs-keyword\x22\x3edelete\x3c\/span\x3e elm.dataset[key];\n    }\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/更新数据集\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (key \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e dataset) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (oldDataset[key] !== dataset[key]) {\n      elm.dataset[key] = dataset[key];\n    }\n  }\n}\n\n\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = {\x3cspan class=\x22hljs-attr\x22\x3ecreate\x3c\/span\x3e: updateDataset, \x3cspan class=\x22hljs-attr\x22\x3eupdate\x3c\/span\x3e: updateDataset}\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader12\x22\x3eeventlistener\x3c\/h3\x3e\n\x3cp\x3esnabbdom中对事件处理做了一层包装，真实DOM的事件触发的是对vnode的操作,主要途径是:\x3c\/p\x3e\n\x3cp\x3ecreateListner =\x26gt; 返回handler作事件监听生成器 =\x26gt;handler上绑定vnode =\x26gt;将handler作真实DOM的事件处理器\x3cbr\x3e真实DOM事件触发后 =\x26gt; handler获得真实DOM的事件对象 =\x26gt; 将真实DOM事件对象传入handleEvent =\x26gt; handleEvent找到\x3cbr\x3e对应的vnode事件处理器，然后调用这个处理器从而修改vnode\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/snabbdom中对事件处理做了一层包装，真实DOM的事件触发的是对vnode的操作\n\/\/主要途径是\n\/\/ createListner =\x3e 返回handler作事件监听生成器 =\x3ehandler上绑定vnode =\x3e将handler作真实DOM的事件处理器\n\/\/真实DOM事件触发后 =\x3e handler获得真实DOM的事件对象 =\x3e 将真实DOM事件对象传入handleEvent =\x3e handleEvent找到\n\/\/对应的vnode事件处理器，然后调用这个处理器从而修改vnode\n\n\/\/对vnode进行事件处理\nfunction invokeHandler ( handler, vnode, event ) {\n    if ( typeof handler === \x26quot;function\x26quot; ) {\n        \/\/ call function handler\n        \/\/将事件处理器在vnode上调用\n        handler.call ( vnode, event, vnode );\n    }\n    \/\/存在事件绑定数据或者存在多事件处理器\n    else if ( typeof handler === \x26quot;object\x26quot; ) {\n\n        \/\/说明只有一个事件处理器\n        if ( typeof handler[ 0 ] === \x26quot;function\x26quot; ) {\n            \/\/如果绑定数据只有一个，则直接将数据用call的方式调用，提高性能\n            \/\/形如on:{click:[handler,1]}\n            if ( handler.length === 2 ) {\n                handler[ 0 ].call ( vnode, handler[ 1 ], event, vnode );\n            }\n            \/\/如果存在多个绑定数据，则要转化为数组，用apply的方式调用，而apply性能比call差\n            \/\/形如:on:{click:[handler,1,2,3]}\n            else {\n                var args = handler.slice ( 1 );\n                args.push ( event );\n                args.push ( vnode );\n                handler[ 0 ].apply ( vnode, args );\n            }\n        } else {\n            \/\/如果存在多个相同事件的不同处理器，则递归调用\n            \/\/如on：{click:[[handeler1,1],[handler,2]]}\n            for (var i = 0; i \x3c handler.length; i\x2b\x2b) {\n                invokeHandler ( handler[ i ] );\n            }\n        }\n    }\n}\n\n\/**\n *\n * @param event 真实dom的事件对象\n * @param vnode\n *\/\nfunction handleEvent ( event, vnode ) {\n    var name = event.type,\n        on = vnode.data.on;\n\n    \/\/ 如果找到对应的vnode事件处理器，则调用\n    if ( on \x26amp;\x26amp; on[ name ] ) {\n        invokeHandler ( on[ name ], vnode, event );\n    }\n}\n\/\/事件监听器生成器，用于处理真实DOM事件\nfunction createListener () {\n    return function handler ( event ) {\n        handleEvent ( event, handler.vnode );\n    }\n}\n\/\/更新事件监听\nfunction updateEventListeners ( oldVnode, vnode ) {\n    var oldOn = oldVnode.data.on,\n        oldListener = oldVnode.listener,\n        oldElm = oldVnode.elm,\n        on = vnode \x26amp;\x26amp; vnode.data.on,\n        elm = vnode \x26amp;\x26amp; vnode.elm,\n        name;\n\n    \/\/ optimization for reused immutable handlers\n    \/\/如果新旧事件监听器一样，则直接返回\n    if ( oldOn === on ) {\n        return;\n    }\n\n    \/\/ remove existing listeners which no longer used\n    \/\/如果新节点上没有事件监听，则将旧节点上的事件监听都删除\n    if ( oldOn \x26amp;\x26amp; oldListener ) {\n        \/\/ if element changed or deleted we remove all existing listeners unconditionally\n        if ( !on ) {\n            for (name in oldOn) {\n                \/\/ remove listener if element was changed or existing listeners removed\n                oldElm.removeEventListener ( name, oldListener, false );\n            }\n        } else {\n            \/\/删除旧节点中新节点不存在的事件监听\n            for (name in oldOn) {\n                \/\/ remove listener if existing listener removed\n                if ( !on[ name ] ) {\n                    oldElm.removeEventListener ( name, oldListener, false );\n                }\n            }\n        }\n    }\n\n    \/\/ add new listeners which has not already attached\n    if ( on ) {\n        \/\/ reuse existing listener or create new\n        \/\/如果oldvnode上已经有listener，则vnode直接复用，否则则新建事件处理器\n        var listener = vnode.listener = oldVnode.listener || createListener ();\n        \/\/ update vnode for listener\n        \/\/在事件处理器上绑定vnode\n        listener.vnode = vnode;\n\n        \/\/ if element changed or added we add all needed listeners unconditionally‘\n        \/\/如果oldvnode上没有事件处理器\n        if ( !oldOn ) {\n            for (name in on) {\n                \/\/ add listener if element was changed or new listeners added\n                \/\/直接将vnode上的事件处理器添加到elm上\n                elm.addEventListener ( name, listener, false );\n            }\n        } else {\n            for (name in on) {\n                \/\/ add listener if new listener added\n                \/\/否则添加oldvnode上没有的事件处理器\n                if ( !oldOn[ name ] ) {\n                    elm.addEventListener ( name, listener, false );\n                }\n            }\n        }\n    }\n}\n\nmodule.exports = {\n    create: updateEventListeners,\n    update: updateEventListeners,\n    destroy: updateEventListeners\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/snabbdom中对事件处理做了一层包装，真实DOM的事件触发的是对vnode的操作\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/主要途径是\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ createListner =\x26gt; 返回handler作事件监听生成器 =\x26gt;handler上绑定vnode =\x26gt;将handler作真实DOM的事件处理器\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/真实DOM事件触发后 =\x26gt; handler获得真实DOM的事件对象 =\x26gt; 将真实DOM事件对象传入handleEvent =\x26gt; handleEvent找到\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/对应的vnode事件处理器，然后调用这个处理器从而修改vnode\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/对vnode进行事件处理\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3einvokeHandler\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e handler, vnode, event \x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e handler === \x3cspan class=\x22hljs-string\x22\x3e\x22function\x22\x3c\/span\x3e ) {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ call function handler\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/将事件处理器在vnode上调用\x3c\/span\x3e\n        handler.call ( vnode, event, vnode );\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/存在事件绑定数据或者存在多事件处理器\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e handler === \x3cspan class=\x22hljs-string\x22\x3e\x22object\x22\x3c\/span\x3e ) {\n\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/说明只有一个事件处理器\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e handler[ \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e ] === \x3cspan class=\x22hljs-string\x22\x3e\x22function\x22\x3c\/span\x3e ) {\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果绑定数据只有一个，则直接将数据用call的方式调用，提高性能\x3c\/span\x3e\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/形如on:{click:[handler,1]}\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( handler.length === \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e ) {\n                handler[ \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e ].call ( vnode, handler[ \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e ], event, vnode );\n            }\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果存在多个绑定数据，则要转化为数组，用apply的方式调用，而apply性能比call差\x3c\/span\x3e\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/形如:on:{click:[handler,1,2,3]}\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n                \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e args = handler.slice ( \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e );\n                args.push ( event );\n                args.push ( vnode );\n                handler[ \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e ].apply ( vnode, args );\n            }\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果存在多个相同事件的不同处理器，则递归调用\x3c\/span\x3e\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/如on：{click:[[handeler1,1],[handler,2]]}\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; handler.length; i\x2b\x2b) {\n                invokeHandler ( handler[ i ] );\n            }\n        }\n    }\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/**\n *\n * @param event 真实dom的事件对象\n * @param vnode\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ehandleEvent\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e event, vnode \x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e name = event.type,\n        on = vnode.data.on;\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果找到对应的vnode事件处理器，则调用\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( on \x26amp;\x26amp; on[ name ] ) {\n        invokeHandler ( on[ name ], vnode, event );\n    }\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/事件监听器生成器，用于处理真实DOM事件\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecreateListener\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ehandler\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e event \x3c\/span\x3e) \x3c\/span\x3e{\n        handleEvent ( event, handler.vnode );\n    }\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/更新事件监听\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eupdateEventListeners\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e oldVnode, vnode \x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e oldOn = oldVnode.data.on,\n        oldListener = oldVnode.listener,\n        oldElm = oldVnode.elm,\n        on = vnode \x26amp;\x26amp; vnode.data.on,\n        elm = vnode \x26amp;\x26amp; vnode.elm,\n        name;\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ optimization for reused immutable handlers\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果新旧事件监听器一样，则直接返回\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( oldOn === on ) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ remove existing listeners which no longer used\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果新节点上没有事件监听，则将旧节点上的事件监听都删除\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( oldOn \x26amp;\x26amp; oldListener ) {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ if element changed or deleted we remove all existing listeners unconditionally\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( !on ) {\n            \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (name \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e oldOn) {\n                \x3cspan class=\x22hljs-comment\x22\x3e\/\/ remove listener if element was changed or existing listeners removed\x3c\/span\x3e\n                oldElm.removeEventListener ( name, oldListener, \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e );\n            }\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/删除旧节点中新节点不存在的事件监听\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (name \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e oldOn) {\n                \x3cspan class=\x22hljs-comment\x22\x3e\/\/ remove listener if existing listener removed\x3c\/span\x3e\n                \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( !on[ name ] ) {\n                    oldElm.removeEventListener ( name, oldListener, \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e );\n                }\n            }\n        }\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ add new listeners which has not already attached\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( on ) {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ reuse existing listener or create new\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果oldvnode上已经有listener，则vnode直接复用，否则则新建事件处理器\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e listener = vnode.listener = oldVnode.listener || createListener ();\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ update vnode for listener\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/在事件处理器上绑定vnode\x3c\/span\x3e\n        listener.vnode = vnode;\n\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ if element changed or added we add all needed listeners unconditionally‘\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果oldvnode上没有事件处理器\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( !oldOn ) {\n            \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (name \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e on) {\n                \x3cspan class=\x22hljs-comment\x22\x3e\/\/ add listener if element was changed or new listeners added\x3c\/span\x3e\n                \x3cspan class=\x22hljs-comment\x22\x3e\/\/直接将vnode上的事件处理器添加到elm上\x3c\/span\x3e\n                elm.addEventListener ( name, listener, \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e );\n            }\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n            \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (name \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e on) {\n                \x3cspan class=\x22hljs-comment\x22\x3e\/\/ add listener if new listener added\x3c\/span\x3e\n                \x3cspan class=\x22hljs-comment\x22\x3e\/\/否则添加oldvnode上没有的事件处理器\x3c\/span\x3e\n                \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( !oldOn[ name ] ) {\n                    elm.addEventListener ( name, listener, \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e );\n                }\n            }\n        }\n    }\n}\n\n\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = {\n    \x3cspan class=\x22hljs-attr\x22\x3ecreate\x3c\/span\x3e: updateEventListeners,\n    \x3cspan class=\x22hljs-attr\x22\x3eupdate\x3c\/span\x3e: updateEventListeners,\n    \x3cspan class=\x22hljs-attr\x22\x3edestroy\x3c\/span\x3e: updateEventListeners\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader13\x22\x3eprops\x3c\/h3\x3e\n\x3cp\x3e主要功能：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e从elm上删除vnode中不存在的属性\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e更新elm上的属性\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function updateProps(oldVnode, vnode) {\n  var key, cur, old, elm = vnode.elm,\n      oldProps = oldVnode.data.props, props = vnode.data.props;\n \/\/如果新旧节点都不存在属性，则直接返回\n  if (!oldProps \x26amp;\x26amp; !props) return;\n  oldProps = oldProps || {};\n  props = props || {};\n  \/\/删除旧节点中新节点没有的属性\n  for (key in oldProps) {\n    if (!props[key]) {\n      delete elm[key];\n    }\n  }\n  \/\/更新属性\n  for (key in props) {\n    cur = props[key];\n    old = oldProps[key];\n    \/\/如果新旧节点属性不同，且对比的属性不是value或者elm上对应属性和新属性也不同，那么就需要更新\n    if (old !== cur \x26amp;\x26amp; (key !== \x27value\x27 || elm[key] !== cur)) {\n      elm[key] = cur;\n    }\n  }\n}\n\nmodule.exports = {create: updateProps, update: updateProps};\n\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eupdateProps\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eoldVnode, vnode\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e key, cur, old, elm = vnode.elm,\n      oldProps = oldVnode.data.props, props = vnode.data.props;\n \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果新旧节点都不存在属性，则直接返回\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!oldProps \x26amp;\x26amp; !props) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n  oldProps = oldProps || {};\n  props = props || {};\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/删除旧节点中新节点没有的属性\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (key \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e oldProps) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!props[key]) {\n      \x3cspan class=\x22hljs-keyword\x22\x3edelete\x3c\/span\x3e elm[key];\n    }\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/更新属性\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (key \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e props) {\n    cur = props[key];\n    old = oldProps[key];\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果新旧节点属性不同，且对比的属性不是value或者elm上对应属性和新属性也不同，那么就需要更新\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (old !== cur \x26amp;\x26amp; (key !== \x3cspan class=\x22hljs-string\x22\x3e\x27value\x27\x3c\/span\x3e || elm[key] !== cur)) {\n      elm[key] = cur;\n    }\n  }\n}\n\n\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = {\x3cspan class=\x22hljs-attr\x22\x3ecreate\x3c\/span\x3e: updateProps, \x3cspan class=\x22hljs-attr\x22\x3eupdate\x3c\/span\x3e: updateProps};\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader14\x22\x3estyle\x3c\/h3\x3e\n\x3cp\x3e主要功能如下：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e将elm上存在于oldvnode中但不存在于vnode中不存在的style置空\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e如果vnode.style中的delayed与oldvnode的不同，则更新delayed的属性值，并在下一帧将elm的style设置为该值，从而实现动画过渡效果\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e非delayed和remove的style直接更新\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3evnode被destroy时，直接将对应style更新为vnode.data.style.destory的值\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3evnode被reomve时，如果style.remove不存在，直接调用全局remove钩子进入下一个remove过程\x3cbr\x3e如果style.remove存在，那么我们就需要设置remove动画过渡效果，等到过渡效果结束之后，才调用\x3cbr\x3e下一个remove过程\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/如果存在requestAnimationFrame，则直接使用，以优化性能，否则用setTimeout\nvar raf = (typeof window !== \x27undefined\x27 \x26amp;\x26amp; window.requestAnimationFrame) || setTimeout;\nvar nextFrame = function(fn) { raf(function() { raf(fn); }); };\n\n\/\/通过nextFrame来实现动画效果\nfunction setNextFrame(obj, prop, val) {\n  nextFrame(function() { obj[prop] = val; });\n}\n\nfunction updateStyle(oldVnode, vnode) {\n  var cur, name, elm = vnode.elm,\n      oldStyle = oldVnode.data.style,\n      style = vnode.data.style;\n  \/\/如果oldvnode和vnode都没有style，直接返回\n  if (!oldStyle \x26amp;\x26amp; !style) return;\n  oldStyle = oldStyle || {};\n  style = style || {};\n  var oldHasDel = \x27delayed\x27 in oldStyle;\n  \/\/遍历oldvnode的style\n  for (name in oldStyle) {\n    \/\/如果vnode中无该style，则置空\n    if (!style[name]) {\n      elm.style[name] = \x27\x27;\n    }\n  }\n  \/\/如果vnode的style中有delayed且与oldvnode中的不同，则在下一帧设置delayed的参数\n  for (name in style) {\n    cur = style[name];\n    if (name === \x27delayed\x27) {\n      for (name in style.delayed) {\n        cur = style.delayed[name];\n        if (!oldHasDel || cur !== oldStyle.delayed[name]) {\n          setNextFrame(elm.style, name, cur);\n        }\n      }\n    }\n    \/\/如果不是delayed和remove的style，且不同于oldvnode的值，则直接设置新值\n    else if (name !== \x27remove\x27 \x26amp;\x26amp; cur !== oldStyle[name]) {\n      elm.style[name] = cur;\n    }\n  }\n}\n\n\/\/设置节点被destory时的style\nfunction applyDestroyStyle(vnode) {\n  var style, name, elm = vnode.elm, s = vnode.data.style;\n  if (!s || !(style = s.destroy)) return;\n  for (name in style) {\n    elm.style[name] = style[name];\n  }\n}\n\/\/删除效果，当我们删除一个元素时，先回调用删除过度效果，过渡完才会将节点remove\nfunction applyRemoveStyle(vnode, rm) {\n  var s = vnode.data.style;\n  \/\/如果没有style或没有style.remove\n  if (!s || !s.remove) {\n    \/\/直接调用rm，即实际上是调用全局的remove钩子\n    rm();\n    return;\n  }\n  var name, elm = vnode.elm, idx, i = 0, maxDur = 0,\n      compStyle, style = s.remove, amount = 0, applied = [];\n  \/\/设置并记录remove动作后删除节点前的样式\n  for (name in style) {\n    applied.push(name);\n    elm.style[name] = style[name];\n  }\n  compStyle = getComputedStyle(elm);\n  \/\/拿到所有需要过渡的属性\n  var props = compStyle[\x27transition-property\x27].split(\x27, \x27);\n  \/\/对过渡属性计数，这里applied.length \x3e=amount，因为有些属性是不需要过渡的\n  for (; i \x3c props.length; \x2b\x2bi) {\n    if(applied.indexOf(props[i]) !== -1) amount\x2b\x2b;\n  }\n  \/\/当过渡效果的完成后，才remove节点，调用下一个remove过程\n  elm.addEventListener(\x27transitionend\x27, function(ev) {\n    if (ev.target === elm) --amount;\n    if (amount === 0) rm();\n  });\n}\n\nmodule.exports = {create: updateStyle, update: updateStyle, destroy: applyDestroyStyle, remove: applyRemoveStyle};\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/如果存在requestAnimationFrame，则直接使用，以优化性能，否则用setTimeout\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e raf = (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e !== \x3cspan class=\x22hljs-string\x22\x3e\x27undefined\x27\x3c\/span\x3e \x26amp;\x26amp; \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.requestAnimationFrame) || setTimeout;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e nextFrame = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3efn\x3c\/span\x3e) \x3c\/span\x3e{ raf(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{ raf(fn); }); };\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/通过nextFrame来实现动画效果\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3esetNextFrame\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eobj, prop, val\x3c\/span\x3e) \x3c\/span\x3e{\n  nextFrame(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{ obj[prop] = val; });\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eupdateStyle\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eoldVnode, vnode\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e cur, name, elm = vnode.elm,\n      oldStyle = oldVnode.data.style,\n      style = vnode.data.style;\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果oldvnode和vnode都没有style，直接返回\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!oldStyle \x26amp;\x26amp; !style) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n  oldStyle = oldStyle || {};\n  style = style || {};\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e oldHasDel = \x3cspan class=\x22hljs-string\x22\x3e\x27delayed\x27\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e oldStyle;\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/遍历oldvnode的style\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (name \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e oldStyle) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果vnode中无该style，则置空\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!style[name]) {\n      elm.style[name] = \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e;\n    }\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果vnode的style中有delayed且与oldvnode中的不同，则在下一帧设置delayed的参数\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (name \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e style) {\n    cur = style[name];\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (name === \x3cspan class=\x22hljs-string\x22\x3e\x27delayed\x27\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (name \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e style.delayed) {\n        cur = style.delayed[name];\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!oldHasDel || cur !== oldStyle.delayed[name]) {\n          setNextFrame(elm.style, name, cur);\n        }\n      }\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果不是delayed和remove的style，且不同于oldvnode的值，则直接设置新值\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (name !== \x3cspan class=\x22hljs-string\x22\x3e\x27remove\x27\x3c\/span\x3e \x26amp;\x26amp; cur !== oldStyle[name]) {\n      elm.style[name] = cur;\n    }\n  }\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/设置节点被destory时的style\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eapplyDestroyStyle\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3evnode\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e style, name, elm = vnode.elm, s = vnode.data.style;\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!s || !(style = s.destroy)) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (name \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e style) {\n    elm.style[name] = style[name];\n  }\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/删除效果，当我们删除一个元素时，先回调用删除过度效果，过渡完才会将节点remove\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eapplyRemoveStyle\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3evnode, rm\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e s = vnode.data.style;\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果没有style或没有style.remove\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!s || !s.remove) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/直接调用rm，即实际上是调用全局的remove钩子\x3c\/span\x3e\n    rm();\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e name, elm = vnode.elm, idx, i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, maxDur = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,\n      compStyle, style = s.remove, amount = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, applied = [];\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/设置并记录remove动作后删除节点前的样式\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (name \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e style) {\n    applied.push(name);\n    elm.style[name] = style[name];\n  }\n  compStyle = getComputedStyle(elm);\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/拿到所有需要过渡的属性\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e props = compStyle[\x3cspan class=\x22hljs-string\x22\x3e\x27transition-property\x27\x3c\/span\x3e].split(\x3cspan class=\x22hljs-string\x22\x3e\x27, \x27\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/对过渡属性计数，这里applied.length \x26gt;=amount，因为有些属性是不需要过渡的\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (; i \x26lt; props.length; \x2b\x2bi) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(applied.indexOf(props[i]) !== \x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e) amount\x2b\x2b;\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/当过渡效果的完成后，才remove节点，调用下一个remove过程\x3c\/span\x3e\n  elm.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27transitionend\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eev\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (ev.target === elm) --amount;\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (amount === \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) rm();\n  });\n}\n\n\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = {\x3cspan class=\x22hljs-attr\x22\x3ecreate\x3c\/span\x3e: updateStyle, \x3cspan class=\x22hljs-attr\x22\x3eupdate\x3c\/span\x3e: updateStyle, \x3cspan class=\x22hljs-attr\x22\x3edestroy\x3c\/span\x3e: applyDestroyStyle, \x3cspan class=\x22hljs-attr\x22\x3eremove\x3c\/span\x3e: applyRemoveStyle};\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader15\x22\x3e第五站 is\x3c\/h2\x3e\n\x3cp\x3e啃完modules这些大部头，总算有个比较好吃的甜品了，他主要功能就是判断是否为array类型或者原始类型\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/is工具库，用于判断是否为array或者原始类型\nmodule.exports = {\n  array: Array.isArray,\n  primitive: function(s) { return typeof s === \x27string\x27 || typeof s === \x27number\x27; },\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/is工具库，用于判断是否为array或者原始类型\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = {\n  \x3cspan class=\x22hljs-attr\x22\x3earray\x3c\/span\x3e: \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.isArray,\n  \x3cspan class=\x22hljs-attr\x22\x3eprimitive\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3es\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e s === \x3cspan class=\x22hljs-string\x22\x3e\x27string\x27\x3c\/span\x3e || \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e s === \x3cspan class=\x22hljs-string\x22\x3e\x27number\x27\x3c\/span\x3e; },\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader16\x22\x3e中途休息\x3c\/h2\x3e\n\x3cp\x3e看了这么多源码，估计也累了吧，毕竟一下完全理解可能有点难，不妨先休息一下，消化一下，下一章将会见到最大的boss——snabbdom本身！\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>vue2源码学习开胃菜——snabbdom源码学习（一）</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000009017324">https://segmentfault.com/a/1190000009017324</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/jj4reknq0oe/" target="_blank">https://alili.tech/archive/jj4reknq0oe/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>