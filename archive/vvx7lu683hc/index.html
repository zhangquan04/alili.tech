<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="vue2源码学习开胃菜——snabbdom源码学习（二）"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>vue2源码学习开胃菜——snabbdom源码学习（二） | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/vvx7lu683hc/",
				"appid": "1613049289050283", 
				"title": "vue2源码学习开胃菜——snabbdom源码学习（二） | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-17T02:30:25"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/xyndkboi83/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/jj4reknq0oe/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fvvx7lu683hc%2f&text=vue2%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a0%e5%bc%80%e8%83%83%e8%8f%9c%e2%80%94%e2%80%94snabbdom%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a0%ef%bc%88%e4%ba%8c%ef%bc%89"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fvvx7lu683hc%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fvvx7lu683hc%2f&text=vue2%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a0%e5%bc%80%e8%83%83%e8%8f%9c%e2%80%94%e2%80%94snabbdom%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a0%ef%bc%88%e4%ba%8c%ef%bc%89"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fvvx7lu683hc%2f&title=vue2%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a0%e5%bc%80%e8%83%83%e8%8f%9c%e2%80%94%e2%80%94snabbdom%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a0%ef%bc%88%e4%ba%8c%ef%bc%89"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fvvx7lu683hc%2f&is_video=false&description=vue2%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a0%e5%bc%80%e8%83%83%e8%8f%9c%e2%80%94%e2%80%94snabbdom%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a0%ef%bc%88%e4%ba%8c%ef%bc%89"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=vue2%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a0%e5%bc%80%e8%83%83%e8%8f%9c%e2%80%94%e2%80%94snabbdom%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a0%ef%bc%88%e4%ba%8c%ef%bc%89&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fvvx7lu683hc%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fvvx7lu683hc%2f&title=vue2%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a0%e5%bc%80%e8%83%83%e8%8f%9c%e2%80%94%e2%80%94snabbdom%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a0%ef%bc%88%e4%ba%8c%ef%bc%89"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fvvx7lu683hc%2f&title=vue2%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a0%e5%bc%80%e8%83%83%e8%8f%9c%e2%80%94%e2%80%94snabbdom%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a0%ef%bc%88%e4%ba%8c%ef%bc%89"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fvvx7lu683hc%2f&title=vue2%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a0%e5%bc%80%e8%83%83%e8%8f%9c%e2%80%94%e2%80%94snabbdom%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a0%ef%bc%88%e4%ba%8c%ef%bc%89"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fvvx7lu683hc%2f&title=vue2%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a0%e5%bc%80%e8%83%83%e8%8f%9c%e2%80%94%e2%80%94snabbdom%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a0%ef%bc%88%e4%ba%8c%ef%bc%89"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">vue2源码学习开胃菜——snabbdom源码学习（二）</h1><div class="meta"><div class="postdate"><time datetime="2019-01-17" itemprop="datePublished">2019-01-17</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch1 id=\x22articleHeader0\x22\x3e前言\x3c\/h1\x3e\n\x3cp\x3e在上一章我们学习了，modules,vnode,h,htmldomapi,is等模块，在这一篇我们将会学习到\x3cbr\x3esnabbdom的核心功能——patchVnode和updateChildren功能。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader1\x22\x3e继续我们的snabbdom源码之旅\x3c\/h1\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e最终章 snabbdom！\x3c\/h2\x3e\n\x3cp\x3e首先我们先从简单的部分开始，比如一些工具函数，我将逐个来讲解他们的用处\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3esameNode\x3c\/h3\x3e\n\x3cp\x3e这个函数主要用于比较oldvnode与vnode同层次节点的比较，如果同层次节点的key和sel都相同\x3cbr\x3e我们就可以保留这个节点，否则直接替换节点\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function sameVnode(vnode1, vnode2) {\n  return vnode1.key === vnode2.key \x26amp;\x26amp; vnode1.sel === vnode2.sel;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3esameVnode\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3evnode1, vnode2\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e vnode1.key === vnode2.key \x26amp;\x26amp; vnode1.sel === vnode2.sel;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3ecreateKeyToOldIdx\x3c\/h3\x3e\n\x3cp\x3e这个函数的功能十分简单，就是将oldvnode数组中位置对oldvnode.key的映射转换为oldvnode.key\x3cbr\x3e对位置的映射\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function createKeyToOldIdx(children, beginIdx, endIdx) {\n  var i, map = {}, key;\n  for (i = beginIdx; i \x3c= endIdx; \x2b\x2bi) {\n    key = children[i].key;\n    if (isDef(key)) map[key] = i;\n  }\n  return map;\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecreateKeyToOldIdx\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3echildren, beginIdx, endIdx\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i, map = {}, key;\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (i = beginIdx; i \x26lt;= endIdx; \x2b\x2bi) {\n    key = children[i].key;\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isDef(key)) map[key] = i;\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e map;\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3ehook\x3c\/h3\x3e\n\x3cp\x3esnabbdom在全局下有6种类型的钩子，触发这些钩子时，会调用对应的函数对节点的状态进行更改\x3cbr\x3e首先我们来看看有哪些钩子：\x3c\/p\x3e\n\x3ctable\x3e\n\x3cthead\x3e\x3ctr\x3e\n\x3cth\x3eName\x3c\/th\x3e\n\x3cth align=\x22center\x22\x3eTriggered when\x3c\/th\x3e\n\x3cth align=\x22right\x22\x3eArguments to callback\x3c\/th\x3e\n\x3c\/tr\x3e\x3c\/thead\x3e\n\x3ctbody\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3ccode\x3epre\x3c\/code\x3e\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3ethe patch process begins （patch开始时触发）\x3c\/td\x3e\n\x3ctd align=\x22right\x22\x3enone\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3ccode\x3einit\x3c\/code\x3e\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3ea vnode has been added  （vnode被创建时触发）\x3c\/td\x3e\n\x3ctd align=\x22right\x22\x3e\x3ccode\x3evnode\x3c\/code\x3e\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3ccode\x3ecreate\x3c\/code\x3e\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3ea DOM element has been created based on a vnode （vnode转换为真实DOM节点时触发\x3c\/td\x3e\n\x3ctd align=\x22right\x22\x3e\x3ccode\x3eemptyVnode, vnode\x3c\/code\x3e\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3ccode\x3einsert\x3c\/code\x3e\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3ean element has been inserted into the DOM  （插入到DOM树时触发）\x3c\/td\x3e\n\x3ctd align=\x22right\x22\x3e\x3ccode\x3evnode\x3c\/code\x3e\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3ccode\x3eprepatch\x3c\/code\x3e\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3ean element is about to be patched  （元素准备patch前触发）\x3c\/td\x3e\n\x3ctd align=\x22right\x22\x3e\x3ccode\x3eoldVnode, vnode\x3c\/code\x3e\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3ccode\x3eupdate\x3c\/code\x3e\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3ean element is being updated         （元素更新时触发）\x3c\/td\x3e\n\x3ctd align=\x22right\x22\x3e\x3ccode\x3eoldVnode, vnode\x3c\/code\x3e\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3ccode\x3epostpatch\x3c\/code\x3e\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3ean element has been patched        （元素patch完触发）\x3c\/td\x3e\n\x3ctd align=\x22right\x22\x3e\x3ccode\x3eoldVnode, vnode\x3c\/code\x3e\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3ccode\x3edestroy\x3c\/code\x3e\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3ean element is directly or indirectly being removed （元素被删除时触发）\x3c\/td\x3e\n\x3ctd align=\x22right\x22\x3e\x3ccode\x3evnode\x3c\/code\x3e\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3ccode\x3eremove\x3c\/code\x3e\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3ean element is directly being removed from the DOM  （元素从父节点删除时触发，和destory略有不同，remove只影响到被移除节点中最顶层的节点）\x3c\/td\x3e\n\x3ctd align=\x22right\x22\x3e\x3ccode\x3evnode, removeCallback\x3c\/code\x3e\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3ctr\x3e\n\x3ctd\x3e\x3ccode\x3epost\x3c\/code\x3e\x3c\/td\x3e\n\x3ctd align=\x22center\x22\x3ethe patch process is done        （patch完成后触发）\x3c\/td\x3e\n\x3ctd align=\x22right\x22\x3enone\x3c\/td\x3e\n\x3c\/tr\x3e\n\x3c\/tbody\x3e\n\x3c\/table\x3e\n\x3cp\x3e然后，下面列出钩子对应的状态更新函数：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3ecreate =\x26gt; style,class,dataset,eventlistener,props,hero\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eupdate =\x26gt; style,class,dataset,eventlistener,props,hero\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eremove =\x26gt; style\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3edestory =\x26gt; eventlistener,style,hero\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3epre =\x26gt; hero\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3epost =\x26gt; hero\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e好了，简单的都看完了，接下来我们开始打大boss了，第一关就是init函数了\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3einit\x3c\/h3\x3e\n\x3cp\x3einit函数有两个参数modules和api，其中modules是init依赖的模块，如attribute、props\x3cbr\x3e、eventlistener这些模块,api则是对封装真实DOM操作的工具函数库，如果我们没有传入，则默认\x3cbr\x3e使用snabbdom提供的htmldomapi。init还包含了许多vnode和真实DOM之间的操作和注册全局钩子，\x3cbr\x3e还有patchVnode和updateChildren这两个重要功能，然后返回一个patch函数\x3c\/p\x3e\n\x3ch4\x3e注册全局钩子\x3c\/h4\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22     \/\/注册钩子的回调，在发生状态变更时，触发对应属性变更\n      for (i = 0; i \x3c hooks.length; \x2b\x2bi) {\n        cbs[hooks[i]] = [];\n        for (j = 0; j \x3c modules.length; \x2b\x2bj) {\n          if (modules[j][hooks[i]] !== undefined) cbs[hooks[i]].push(modules[j][hooks[i]]);\n        }\n      }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e     \x3cspan class=\x22hljs-comment\x22\x3e\/\/注册钩子的回调，在发生状态变更时，触发对应属性变更\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; hooks.length; \x2b\x2bi) {\n        cbs[hooks[i]] = [];\n        \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (j = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; j \x26lt; modules.length; \x2b\x2bj) {\n          \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (modules[j][hooks[i]] !== \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e) cbs[hooks[i]].push(modules[j][hooks[i]]);\n        }\n      }\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3eemptyNodeAt\x3c\/h4\x3e\n\x3cp\x3e这个函数主要的功能是将一个真实DOM节点转化成vnode形式，\x3cbr\x3e如\x3ccode\x3e\x26lt;div id=\x27a\x27 class=\x27b c\x27\x26gt;\x26lt;\/div\x26gt;\x3c\/code\x3e将转换为\x3ccode\x3e{sel:\x27div#a.b.c\x27,data:{},children:[],text:undefined,elm:\x26lt;div id=\x27a\x27 class=\x27b c\x27\x26gt;}\x3c\/code\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22     function emptyNodeAt(elm) {\n        var id = elm.id ? \x27#\x27 \x2b elm.id : \x27\x27;\n        var c = elm.className ? \x27.\x27 \x2b elm.className.split(\x27 \x27).join(\x27.\x27) : \x27\x27;\n        return VNode(api.tagName(elm).toLowerCase() \x2b id \x2b c, {}, [], undefined, elm);\n      }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e     \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eemptyNodeAt\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eelm\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e id = elm.id ? \x3cspan class=\x22hljs-string\x22\x3e\x27#\x27\x3c\/span\x3e \x2b elm.id : \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e c = elm.className ? \x3cspan class=\x22hljs-string\x22\x3e\x27.\x27\x3c\/span\x3e \x2b elm.className.split(\x3cspan class=\x22hljs-string\x22\x3e\x27 \x27\x3c\/span\x3e).join(\x3cspan class=\x22hljs-string\x22\x3e\x27.\x27\x3c\/span\x3e) : \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e VNode(api.tagName(elm).toLowerCase() \x2b id \x2b c, {}, [], \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e, elm);\n      }\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3ecreateRmCb\x3c\/h4\x3e\n\x3cp\x3e我们知道当我们需要remove一个vnode时，会触发remove钩子作拦截器，只有在所有remove钩子\x3cbr\x3e回调函数都触发完才会将节点从父节点删除，而这个函数提供的就是对remove钩子回调操作的计数功能\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function createRmCb(childElm, listeners) {\n    return function() {\n      if (--listeners === 0) {\n        var parent = api.parentNode(childElm);\n        api.removeChild(parent, childElm);\n      }\n    };\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecreateRmCb\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3echildElm, listeners\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (--listeners === \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e parent = api.parentNode(childElm);\n        api.removeChild(parent, childElm);\n      }\n    };\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3einvokeDestoryHook\x3c\/h4\x3e\n\x3cp\x3e这个函数用于手动触发destory钩子回调，主要步骤如下：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e先调用vnode上的destory\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e再调用全局下的destory\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e递归调用子vnode的destory\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function invokeDestroyHook(vnode) {\n  var i, j, data = vnode.data;\n  if (isDef(data)) {\n\/\/先触发该节点上的destory回调\nif (isDef(i = data.hook) \x26amp;\x26amp; isDef(i = i.destroy)) i(vnode);\n\/\/在触发全局下的destory回调\nfor (i = 0; i \x3c cbs.destroy.length; \x2b\x2bi) cbs.destroy[i](vnode);\n\/\/递归触发子节点的destory回调\nif (isDef(i = vnode.children)) {\n  for (j = 0; j \x3c vnode.children.length; \x2b\x2bj) {\n    invokeDestroyHook(vnode.children[j]);\n  }\n}\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3einvokeDestroyHook\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3evnode\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i, j, data = vnode.data;\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isDef(data)) {\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/先触发该节点上的destory回调\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isDef(i = data.hook) \x26amp;\x26amp; isDef(i = i.destroy)) i(vnode);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/在触发全局下的destory回调\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; cbs.destroy.length; \x2b\x2bi) cbs.destroy[i](vnode);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/递归触发子节点的destory回调\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isDef(i = vnode.children)) {\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (j = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; j \x26lt; vnode.children.length; \x2b\x2bj) {\n    invokeDestroyHook(vnode.children[j]);\n  }\n}\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch4\x3eremoveVnodes\x3c\/h4\x3e\n\x3cp\x3e这个函数主要功能是批量删除DOM节点，需要配合invokeDestoryHook和createRmCb服用，效果更佳\x3cbr\x3e主要步骤如下：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e调用invokeDestoryHook以触发destory回调\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e调用createRmCb来开始对remove回调进行计数\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e删除DOM节点\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  \/**\n   *\n   * @param parentElm 父节点\n   * @param vnodes  删除节点数组\n   * @param startIdx  删除起始坐标\n   * @param endIdx  删除结束坐标\n   *\/\nfunction removeVnodes(parentElm, vnodes, startIdx, endIdx) {\n  for (; startIdx \x3c= endIdx; \x2b\x2bstartIdx) {\nvar i, listeners, rm, ch = vnodes[startIdx];\nif (isDef(ch)) {\n  if (isDef(ch.sel)) {\n    \/\/调用destroy钩子\n    invokeDestroyHook(ch);\n    \/\/对全局remove钩子进行计数\n    listeners = cbs.remove.length \x2b 1;\n    rm = createRmCb(ch.elm, listeners);\n    \/\/调用全局remove回调函数，并每次减少一个remove钩子计数\n    for (i = 0; i \x3c cbs.remove.length; \x2b\x2bi) cbs.remove[i](ch, rm);\n    \/\/调用内部vnode.data.hook中的remove钩子（只有一个）\n    if (isDef(i = ch.data) \x26amp;\x26amp; isDef(i = i.hook) \x26amp;\x26amp; isDef(i = i.remove)) {\n      i(ch, rm);\n    } else {\n      \/\/如果没有内部remove钩子，需要调用rm，确保能够remove节点\n      rm();\n    }\n  } else { \/\/ Text node\n    api.removeChild(parentElm, ch.elm);\n  }\n}\n  }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs php\x22\x3e\x3ccode class=\x22javascirpt\x22\x3e  \x3cspan class=\x22hljs-comment\x22\x3e\/**\n   *\n   * \x3cspan class=\x22hljs-doctag\x22\x3e@param\x3c\/span\x3e parentElm 父节点\n   * \x3cspan class=\x22hljs-doctag\x22\x3e@param\x3c\/span\x3e vnodes  删除节点数组\n   * \x3cspan class=\x22hljs-doctag\x22\x3e@param\x3c\/span\x3e startIdx  删除起始坐标\n   * \x3cspan class=\x22hljs-doctag\x22\x3e@param\x3c\/span\x3e endIdx  删除结束坐标\n   *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eremoveVnodes\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(parentElm, vnodes, startIdx, endIdx)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (; startIdx \x26lt;= endIdx; \x2b\x2bstartIdx) {\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i, listeners, rm, ch = vnodes[startIdx];\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isDef(ch)) {\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isDef(ch.sel)) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/调用destroy钩子\x3c\/span\x3e\n    invokeDestroyHook(ch);\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/对全局remove钩子进行计数\x3c\/span\x3e\n    listeners = cbs.remove.length \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n    rm = createRmCb(ch.elm, listeners);\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/调用全局remove回调函数，并每次减少一个remove钩子计数\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; cbs.remove.length; \x2b\x2bi) cbs.remove[i](ch, rm);\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/调用内部vnode.data.hook中的remove钩子（只有一个）\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isDef(i = ch.data) \x26amp;\x26amp; isDef(i = i.hook) \x26amp;\x26amp; isDef(i = i.remove)) {\n      i(ch, rm);\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果没有内部remove钩子，需要调用rm，确保能够remove节点\x3c\/span\x3e\n      rm();\n    }\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Text node\x3c\/span\x3e\n    api.removeChild(parentElm, ch.elm);\n  }\n}\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch4\x3ecreateElm\x3c\/h4\x3e\n\x3cp\x3e就如太极有阴就有阳一样，既然我们有remove操作，肯定也有createelm的操作，这个函数主要功能\x3cbr\x3e如下：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e初始化vnode，调用init钩子\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e创建对应tagname的DOM element节点，并将vnode.sel中的id名和class名挂载上去\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e如果有子vnode，递归创建DOM element节点，并添加到父vnode对应的element节点上去，\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22否则如果有text属性，则创建text节点，并添加到父vnode对应的element节点上去\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs livecodeserver\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e否则如果有\x3cspan class=\x22hljs-keyword\x22\x3etext\x3c\/span\x3e属性，则创建\x3cspan class=\x22hljs-keyword\x22\x3etext\x3c\/span\x3e节点，并添加到父vnode对应的\x3cspan class=\x22hljs-keyword\x22\x3eelement\x3c\/span\x3e节点上去\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3evnode转换成dom节点操作完成后，调用create钩子\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e如果vnode上有insert钩子，那么就将这个vnode放入insertedVnodeQueue中作记录，到时\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22再在全局批量调用insert钩子回调\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs mipsasm\x22\x3e\x3ccode\x3e再在全局批量调用\x3cspan class=\x22hljs-keyword\x22\x3einsert钩子回调\n\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function createElm(vnode, insertedVnodeQueue) {\n   var i, data = vnode.data;\n   if (isDef(data)) {\n \/\/当节点上存在hook而且hook中有init钩子时，先调用init回调，对刚创建的vnode进行处理\n if (isDef(i = data.hook) \x26amp;\x26amp; isDef(i = i.init)) {\n   i(vnode);\n   \/\/获取init钩子修改后的数据\n   data = vnode.data;\n }\n   }\n   var elm, children = vnode.children, sel = vnode.sel;\n   if (isDef(sel)) {\n \/\/ Parse selector\n var hashIdx = sel.indexOf(\x27#\x27);\n \/\/先id后class\n var dotIdx = sel.indexOf(\x27.\x27, hashIdx);\n var hash = hashIdx \x3e 0 ? hashIdx : sel.length;\n var dot = dotIdx \x3e 0 ? dotIdx : sel.length;\n var tag = hashIdx !== -1 || dotIdx !== -1 ? sel.slice(0, Math.min(hash, dot)) : sel;\n \/\/创建一个DOM节点引用，并对其属性实例化\n elm = vnode.elm = isDef(data) \x26amp;\x26amp; isDef(i = data.ns) ? api.createElementNS(i, tag): api.createElement(tag);\n  \/\/获取id名 #a --\x3e a\n if (hash \x3c dot) elm.id = sel.slice(hash \x2b 1, dot);\n \/\/获取类名，并格式化  .a.b --\x3e a b\n if (dotIdx \x3e 0) elm.className = sel.slice(dot \x2b 1).replace(\/\\.\/g, \x27 \x27);\n \/\/如果存在子元素Vnode节点，则递归将子元素节点插入到当前Vnode节点中，并将已插入的子元素节点在insertedVnodeQueue中作记录\n if (is.array(children)) {\n   for (i = 0; i \x3c children.length; \x2b\x2bi) {\n     api.appendChild(elm, createElm(children[i], insertedVnodeQueue));\n   }\n   \/\/如果存在子文本节点，则直接将其插入到当前Vnode节点\n } else if (is.primitive(vnode.text)) {\n   api.appendChild(elm, api.createTextNode(vnode.text));\n }\n \/\/当创建完毕后，触发全局create钩子回调\n for (i = 0; i \x3c cbs.create.length; \x2b\x2bi) cbs.create[i](emptyNode, vnode);\n i = vnode.data.hook; \/\/ Reuse variable\n if (isDef(i)) {\n   if (i.create) i.create(emptyNode, vnode);\n   \/\/如果有insert钩子，则推进insertedVnodeQueue中作记录，从而实现批量插入触发insert回调\n   if (i.insert) insertedVnodeQueue.push(vnode);\n }\n   }\n   \/\/如果没声明选择器，则说明这个是一个text节点\n   else {\n elm = vnode.elm = api.createTextNode(vnode.text);\n   }\n   return vnode.elm;\n }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecreateElm\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3evnode, insertedVnodeQueue\x3c\/span\x3e) \x3c\/span\x3e{\n   \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i, data = vnode.data;\n   \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isDef(data)) {\n \x3cspan class=\x22hljs-comment\x22\x3e\/\/当节点上存在hook而且hook中有init钩子时，先调用init回调，对刚创建的vnode进行处理\x3c\/span\x3e\n \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isDef(i = data.hook) \x26amp;\x26amp; isDef(i = i.init)) {\n   i(vnode);\n   \x3cspan class=\x22hljs-comment\x22\x3e\/\/获取init钩子修改后的数据\x3c\/span\x3e\n   data = vnode.data;\n }\n   }\n   \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e elm, children = vnode.children, sel = vnode.sel;\n   \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isDef(sel)) {\n \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Parse selector\x3c\/span\x3e\n \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e hashIdx = sel.indexOf(\x3cspan class=\x22hljs-string\x22\x3e\x27#\x27\x3c\/span\x3e);\n \x3cspan class=\x22hljs-comment\x22\x3e\/\/先id后class\x3c\/span\x3e\n \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e dotIdx = sel.indexOf(\x3cspan class=\x22hljs-string\x22\x3e\x27.\x27\x3c\/span\x3e, hashIdx);\n \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e hash = hashIdx \x26gt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e ? hashIdx : sel.length;\n \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e dot = dotIdx \x26gt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e ? dotIdx : sel.length;\n \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e tag = hashIdx !== \x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e || dotIdx !== \x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e ? sel.slice(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3eMath\x3c\/span\x3e.min(hash, dot)) : sel;\n \x3cspan class=\x22hljs-comment\x22\x3e\/\/创建一个DOM节点引用，并对其属性实例化\x3c\/span\x3e\n elm = vnode.elm = isDef(data) \x26amp;\x26amp; isDef(i = data.ns) ? api.createElementNS(i, tag): api.createElement(tag);\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/获取id名 #a --\x26gt; a\x3c\/span\x3e\n \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (hash \x26lt; dot) elm.id = sel.slice(hash \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, dot);\n \x3cspan class=\x22hljs-comment\x22\x3e\/\/获取类名，并格式化  .a.b --\x26gt; a b\x3c\/span\x3e\n \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (dotIdx \x26gt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) elm.className = sel.slice(dot \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e).replace(\x3cspan class=\x22hljs-regexp\x22\x3e\/\\.\/g\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27 \x27\x3c\/span\x3e);\n \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果存在子元素Vnode节点，则递归将子元素节点插入到当前Vnode节点中，并将已插入的子元素节点在insertedVnodeQueue中作记录\x3c\/span\x3e\n \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (is.array(children)) {\n   \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; children.length; \x2b\x2bi) {\n     api.appendChild(elm, createElm(children[i], insertedVnodeQueue));\n   }\n   \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果存在子文本节点，则直接将其插入到当前Vnode节点\x3c\/span\x3e\n } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (is.primitive(vnode.text)) {\n   api.appendChild(elm, api.createTextNode(vnode.text));\n }\n \x3cspan class=\x22hljs-comment\x22\x3e\/\/当创建完毕后，触发全局create钩子回调\x3c\/span\x3e\n \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; cbs.create.length; \x2b\x2bi) cbs.create[i](emptyNode, vnode);\n i = vnode.data.hook; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Reuse variable\x3c\/span\x3e\n \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isDef(i)) {\n   \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (i.create) i.create(emptyNode, vnode);\n   \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果有insert钩子，则推进insertedVnodeQueue中作记录，从而实现批量插入触发insert回调\x3c\/span\x3e\n   \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (i.insert) insertedVnodeQueue.push(vnode);\n }\n   }\n   \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果没声明选择器，则说明这个是一个text节点\x3c\/span\x3e\n   \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n elm = vnode.elm = api.createTextNode(vnode.text);\n   }\n   \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e vnode.elm;\n }\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch4\x3eaddVnodes\x3c\/h4\x3e\n\x3cp\x3e这个函数十分简单，就是将vnode转换后的dom节点插入到dom树的指定位置中去\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function addVnodes(parentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n    for (; startIdx \x3c= endIdx; \x2b\x2bstartIdx) {\n      api.insertBefore(parentElm, createElm(vnodes[startIdx], insertedVnodeQueue), before);\n    }\n  }\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eaddVnodes\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eparentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (; startIdx \x26lt;= endIdx; \x2b\x2bstartIdx) {\n      api.insertBefore(parentElm, createElm(vnodes[startIdx], insertedVnodeQueue), before);\n    }\n  }\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e说完上面的节点工具函数之后，我们就开始看如何进行patch操作了，首先我们从patch，也就是init\x3cbr\x3e 返回的函数开始\x3c\/p\x3e\n\x3ch4\x3epatch\x3c\/h4\x3e\n\x3cp\x3e首先我们需要明确的一个是，如果按照传统的diff算法，那么为了找到最小变化，需要逐层逐层的去\x3cbr\x3e搜索比较，这样时间复杂度将会达到 O(n^3)的级别，代价十分高，考虑到节点变化很少是跨层次的，\x3cbr\x3evdom采取的是一种简化的思路，只比较同层节点，如果不同，那么即使该节点的子节点没变化，我们\x3cbr\x3e也不复用，直接将从父节点开始的子树全部删除，然后再重新创建节点添加到新的位置。如果父节点\x3cbr\x3e没变化，我们就比较所有同层的子节点，对这些子节点进行删除、创建、移位操作。有了这个思想，\x3cbr\x3e理解patch也十分简单了。patch只需要对两个vnode进行判断是否相似，如果相似，则对他们进行\x3cbr\x3epatchVnode操作，否则直接用vnode替换oldvnode。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22return function(oldVnode, vnode) {\n    var i, elm, parent;\n    \/\/记录被插入的vnode队列，用于批触发insert\n    var insertedVnodeQueue = [];\n    \/\/调用全局pre钩子\n    for (i = 0; i \x3c cbs.pre.length; \x2b\x2bi) cbs.pre[i]();\n    \/\/如果oldvnode是dom节点，转化为oldvnode\n    if (isUndef(oldVnode.sel)) {\n      oldVnode = emptyNodeAt(oldVnode);\n    }\n    \/\/如果oldvnode与vnode相似，进行更新\n    if (sameVnode(oldVnode, vnode)) {\n      patchVnode(oldVnode, vnode, insertedVnodeQueue);\n    } else {\n      \/\/否则，将vnode插入，并将oldvnode从其父节点上直接删除\n      elm = oldVnode.elm;\n      parent = api.parentNode(elm);\n\n      createElm(vnode, insertedVnodeQueue);\n\n      if (parent !== null) {\n        api.insertBefore(parent, vnode.elm, api.nextSibling(elm));\n        removeVnodes(parent, [oldVnode], 0, 0);\n      }\n    }\n    \/\/插入完后，调用被插入的vnode的insert钩子\n    for (i = 0; i \x3c insertedVnodeQueue.length; \x2b\x2bi) {\n      insertedVnodeQueue[i].data.hook.insert(insertedVnodeQueue[i]);\n    }\n    \/\/然后调用全局下的post钩子\n    for (i = 0; i \x3c cbs.post.length; \x2b\x2bi) cbs.post[i]();\n    \/\/返回vnode用作下次patch的oldvnode\n    return vnode;\n  };\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eoldVnode, vnode\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i, elm, parent;\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/记录被插入的vnode队列，用于批触发insert\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e insertedVnodeQueue = [];\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/调用全局pre钩子\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; cbs.pre.length; \x2b\x2bi) cbs.pre[i]();\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果oldvnode是dom节点，转化为oldvnode\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isUndef(oldVnode.sel)) {\n      oldVnode = emptyNodeAt(oldVnode);\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果oldvnode与vnode相似，进行更新\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (sameVnode(oldVnode, vnode)) {\n      patchVnode(oldVnode, vnode, insertedVnodeQueue);\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/否则，将vnode插入，并将oldvnode从其父节点上直接删除\x3c\/span\x3e\n      elm = oldVnode.elm;\n      parent = api.parentNode(elm);\n\n      createElm(vnode, insertedVnodeQueue);\n\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (parent !== \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n        api.insertBefore(parent, vnode.elm, api.nextSibling(elm));\n        removeVnodes(parent, [oldVnode], \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n      }\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/插入完后，调用被插入的vnode的insert钩子\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; insertedVnodeQueue.length; \x2b\x2bi) {\n      insertedVnodeQueue[i].data.hook.insert(insertedVnodeQueue[i]);\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/然后调用全局下的post钩子\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; cbs.post.length; \x2b\x2bi) cbs.post[i]();\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/返回vnode用作下次patch的oldvnode\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e vnode;\n  };\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3epatchVnode\x3c\/h4\x3e\n\x3cp\x3e真正对vnode内部patch的还是得靠patchVnode。让我们看看他到底做了什么？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function patchVnode(oldVnode, vnode, insertedVnodeQueue) {\n    var i, hook;\n    \/\/在patch之前，先调用vnode.data的prepatch钩子\n    if (isDef(i = vnode.data) \x26amp;\x26amp; isDef(hook = i.hook) \x26amp;\x26amp; isDef(i = hook.prepatch)) {\n      i(oldVnode, vnode);\n    }\n    var elm = vnode.elm = oldVnode.elm, oldCh = oldVnode.children, ch = vnode.children;\n    \/\/如果oldvnode和vnode的引用相同，说明没发生任何变化直接返回，避免性能浪费\n    if (oldVnode === vnode) return;\n    \/\/如果oldvnode和vnode不同，说明vnode有更新\n    \/\/如果vnode和oldvnode不相似则直接用vnode引用的DOM节点去替代oldvnode引用的旧节点\n    if (!sameVnode(oldVnode, vnode)) {\n      var parentElm = api.parentNode(oldVnode.elm);\n      elm = createElm(vnode, insertedVnodeQueue);\n      api.insertBefore(parentElm, elm, oldVnode.elm);\n      removeVnodes(parentElm, [oldVnode], 0, 0);\n      return;\n    }\n    \/\/如果vnode和oldvnode相似，那么我们要对oldvnode本身进行更新\n    if (isDef(vnode.data)) {\n      \/\/首先调用全局的update钩子，对vnode.elm本身属性进行更新\n      for (i = 0; i \x3c cbs.update.length; \x2b\x2bi) cbs.update[i](oldVnode, vnode);\n      \/\/然后调用vnode.data里面的update钩子,再次对vnode.elm更新\n      i = vnode.data.hook;\n      if (isDef(i) \x26amp;\x26amp; isDef(i = i.update)) i(oldVnode, vnode);\n    }\n    \/\/如果vnode不是text节点\n    if (isUndef(vnode.text)) {\n      \/\/如果vnode和oldVnode都有子节点\n      if (isDef(oldCh) \x26amp;\x26amp; isDef(ch)) {\n        \/\/当Vnode和oldvnode的子节点不同时，调用updatechilren函数，diff子节点\n        if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue);\n      }\n      \/\/如果vnode有子节点，oldvnode没子节点\n      else if (isDef(ch)) {\n        \/\/oldvnode是text节点，则将elm的text清除\n        if (isDef(oldVnode.text)) api.setTextContent(elm, \x27\x27);\n        \/\/并添加vnode的children\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n      }\n      \/\/如果oldvnode有children，而vnode没children，则移除elm的children\n      else if (isDef(oldCh)) {\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n      }\n      \/\/如果vnode和oldvnode都没chidlren，且vnode没text，则删除oldvnode的text\n      else if (isDef(oldVnode.text)) {\n        api.setTextContent(elm, \x27\x27);\n      }\n    }\n\n    \/\/如果oldvnode的text和vnode的text不同，则更新为vnode的text\n    else if (oldVnode.text !== vnode.text) {\n      api.setTextContent(elm, vnode.text);\n    }\n    \/\/patch完，触发postpatch钩子\n    if (isDef(hook) \x26amp;\x26amp; isDef(i = hook.postpatch)) {\n      i(oldVnode, vnode);\n    }\n  }\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3epatchVnode\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eoldVnode, vnode, insertedVnodeQueue\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i, hook;\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/在patch之前，先调用vnode.data的prepatch钩子\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isDef(i = vnode.data) \x26amp;\x26amp; isDef(hook = i.hook) \x26amp;\x26amp; isDef(i = hook.prepatch)) {\n      i(oldVnode, vnode);\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e elm = vnode.elm = oldVnode.elm, oldCh = oldVnode.children, ch = vnode.children;\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果oldvnode和vnode的引用相同，说明没发生任何变化直接返回，避免性能浪费\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (oldVnode === vnode) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果oldvnode和vnode不同，说明vnode有更新\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果vnode和oldvnode不相似则直接用vnode引用的DOM节点去替代oldvnode引用的旧节点\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!sameVnode(oldVnode, vnode)) {\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e parentElm = api.parentNode(oldVnode.elm);\n      elm = createElm(vnode, insertedVnodeQueue);\n      api.insertBefore(parentElm, elm, oldVnode.elm);\n      removeVnodes(parentElm, [oldVnode], \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果vnode和oldvnode相似，那么我们要对oldvnode本身进行更新\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isDef(vnode.data)) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/首先调用全局的update钩子，对vnode.elm本身属性进行更新\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; cbs.update.length; \x2b\x2bi) cbs.update[i](oldVnode, vnode);\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/然后调用vnode.data里面的update钩子,再次对vnode.elm更新\x3c\/span\x3e\n      i = vnode.data.hook;\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isDef(i) \x26amp;\x26amp; isDef(i = i.update)) i(oldVnode, vnode);\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果vnode不是text节点\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isUndef(vnode.text)) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果vnode和oldVnode都有子节点\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isDef(oldCh) \x26amp;\x26amp; isDef(ch)) {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/当Vnode和oldvnode的子节点不同时，调用updatechilren函数，diff子节点\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue);\n      }\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果vnode有子节点，oldvnode没子节点\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isDef(ch)) {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/oldvnode是text节点，则将elm的text清除\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isDef(oldVnode.text)) api.setTextContent(elm, \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e);\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/并添加vnode的children\x3c\/span\x3e\n        addVnodes(elm, \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e, ch, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, ch.length - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, insertedVnodeQueue);\n      }\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果oldvnode有children，而vnode没children，则移除elm的children\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isDef(oldCh)) {\n        removeVnodes(elm, oldCh, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, oldCh.length - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\n      }\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果vnode和oldvnode都没chidlren，且vnode没text，则删除oldvnode的text\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isDef(oldVnode.text)) {\n        api.setTextContent(elm, \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e);\n      }\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果oldvnode的text和vnode的text不同，则更新为vnode的text\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (oldVnode.text !== vnode.text) {\n      api.setTextContent(elm, vnode.text);\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/patch完，触发postpatch钩子\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isDef(hook) \x26amp;\x26amp; isDef(i = hook.postpatch)) {\n      i(oldVnode, vnode);\n    }\n  }\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3eupdateChildren\x3c\/h4\x3e\n\x3cp\x3e对于同层的子节点，snabbdom主要有删除、创建的操作，同时通过移位的方法，达到最大复用存在\x3cbr\x3e节点的目的，其中需要维护四个索引，分别是：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eoldStartIdx =\x26gt; 旧头索引\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eoldEndIdx =\x26gt; 旧尾索引\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3enewStartIdx =\x26gt;  新头索引\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3enewEndIdx =\x26gt; 新尾索引\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e然后开始将旧子节点组和新子节点组进行逐一比对，直到遍历完任一子节点组，比对策略有5种：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eoldStartVnode和newStartVnode进行比对，如果相似，则进行patch，然后新旧头索引都后移\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eoldEndVnode和newEndVnode进行比对，如果相似，则进行patch，然后新旧尾索引前移\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3eoldStartVnode和newEndVnode进行比对，如果相似，则进行patch，将旧节点移位到最后\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22然后旧头索引后移，尾索引前移，为什么要这样做呢？我们思考一种情况，如旧节点为【5,1,2,3,4】\n，新节点为【1,2,3,4,5】，如果缺乏这种判断，意味着需要先将5-\x3e1,1-\x3e2,2-\x3e3,3-\x3e4,4-\x3e5五\n次删除插入操作，即使是有了key-index来复用，也会出现也会出现【5,1,2,3,4】-\x3e\n【1,5,2,3,4】-\x3e【1,2,5,3,4】-\x3e【1,2,3,5,4】-\x3e【1,2,3,4,5】共4次操作，如果\n有了这种判断，我们只需要将5插入到旧尾索引后面即可，从而实现右移\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lsl\x22\x3e\x3ccode\x3e然后旧头索引后移，尾索引前移，为什么要这样做呢？我们思考一种情况，如旧节点为【\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e】\n，新节点为【\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e】，如果缺乏这种判断，意味着需要先将\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e-\x26gt;\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e-\x26gt;\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e-\x26gt;\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e-\x26gt;\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e-\x26gt;\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e五\n次删除插入操作，即使是有了\x3cspan class=\x22hljs-type\x22\x3ekey\x3c\/span\x3e-index来复用，也会出现也会出现【\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e】-\x26gt;\n【\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e】-\x26gt;【\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e】-\x26gt;【\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e】-\x26gt;【\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e】共\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e次操作，如果\n有了这种判断，我们只需要将\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e插入到旧尾索引后面即可，从而实现右移\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eoldEndVnode和newStartVnode进行比对，处理和上面类似，只不过改为左移\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e如果以上情况都失败了，我们就只能复用key相同的节点了。首先我们要通过createKeyToOldIdx\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22创建key-index的映射，如果新节点在旧节点中不存在，我们将它插入到旧头索引节点前，\n然后新头索引向后；如果新节点在就旧节点组中存在，先找到对应的旧节点，然后patch，并将\n旧节点组中对应节点设置为undefined,代表已经遍历过了，不再遍历，否则可能存在重复\n插入的问题，最后将节点移位到旧头索引节点之前，新头索引向后\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs glsl\x22\x3e\x3ccode\x3e创建key-\x3cspan class=\x22hljs-keyword\x22\x3eindex\x3c\/span\x3e的映射，如果新节点在旧节点中不存在，我们将它插入到旧头索引节点前，\n然后新头索引向后；如果新节点在就旧节点组中存在，先找到对应的旧节点，然后\x3cspan class=\x22hljs-keyword\x22\x3epatch\x3c\/span\x3e，并将\n旧节点组中对应节点设置为undefined,代表已经遍历过了，不再遍历，否则可能存在重复\n插入的问题，最后将节点移位到旧头索引节点之前，新头索引向后\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e遍历完之后，将剩余的新Vnode添加到最后一个新节点的位置后或者删除多余的旧节点\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/**\n   *\n     * @param parentElm 父节点\n     * @param oldCh 旧节点数组\n     * @param newCh 新节点数组\n     * @param insertedVnodeQueue\n     *\/\n  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue) {\n\n    var oldStartIdx = 0, newStartIdx = 0;\n    var oldEndIdx = oldCh.length - 1;\n    var oldStartVnode = oldCh[0];\n    var oldEndVnode = oldCh[oldEndIdx];\n    var newEndIdx = newCh.length - 1;\n    var newStartVnode = newCh[0];\n    var newEndVnode = newCh[newEndIdx];\n    var oldKeyToIdx, idxInOld, elmToMove, before;\n\n    while (oldStartIdx \x3c= oldEndIdx \x26amp;\x26amp; newStartIdx \x3c= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[\x2b\x2boldStartIdx]; \/\/ Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      }\n      \/\/如果旧头索引节点和新头索引节点相同，\n      else if (sameVnode(oldStartVnode, newStartVnode)) {\n        \/\/对旧头索引节点和新头索引节点进行diff更新， 从而达到复用节点效果\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n        \/\/旧头索引向后\n        oldStartVnode = oldCh[\x2b\x2boldStartIdx];\n        \/\/新头索引向后\n        newStartVnode = newCh[\x2b\x2bnewStartIdx];\n      }\n      \/\/如果旧尾索引节点和新尾索引节点相似，可以复用\n      else if (sameVnode(oldEndVnode, newEndVnode)) {\n        \/\/旧尾索引节点和新尾索引节点进行更新\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n        \/\/旧尾索引向前\n        oldEndVnode = oldCh[--oldEndIdx];\n        \/\/新尾索引向前\n        newEndVnode = newCh[--newEndIdx];\n      }\n        \/\/如果旧头索引节点和新头索引节点相似，可以通过移动来复用\n        \/\/如旧节点为【5,1,2,3,4】，新节点为【1,2,3,4,5】，如果缺乏这种判断，意味着\n        \/\/那样需要先将5-\x3e1,1-\x3e2,2-\x3e3,3-\x3e4,4-\x3e5五次删除插入操作，即使是有了key-index来复用，\n        \/\/ 也会出现【5,1,2,3,4】-\x3e【1,5,2,3,4】-\x3e【1,2,5,3,4】-\x3e【1,2,3,5,4】-\x3e【1,2,3,4,5】\n        \/\/ 共4次操作，如果有了这种判断，我们只需要将5插入到最后一次操作即可\n      else if (sameVnode(oldStartVnode, newEndVnode)) { \/\/ Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n        api.insertBefore(parentElm, oldStartVnode.elm, api.nextSibling(oldEndVnode.elm));\n        oldStartVnode = oldCh[\x2b\x2boldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n      }\n      \/\/原理与上面相同\n      else if (sameVnode(oldEndVnode, newStartVnode)) { \/\/ Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n        api.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[\x2b\x2bnewStartIdx];\n      }\n      \/\/如果上面的判断都不通过，我们就需要key-index表来达到最大程度复用了\n      else {\n        \/\/如果不存在旧节点的key-index表，则创建\n        if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n        \/\/找到新节点在旧节点组中对应节点的位置\n        idxInOld = oldKeyToIdx[newStartVnode.key];\n        \/\/如果新节点在旧节点中不存在，我们将它插入到旧头索引节点前，然后新头索引向后\n        if (isUndef(idxInOld)) { \/\/ New element\n          api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);\n          newStartVnode = newCh[\x2b\x2bnewStartIdx];\n        } else {\n          \/\/如果新节点在就旧节点组中存在，先找到对应的旧节点\n          elmToMove = oldCh[idxInOld];\n          \/\/先将新节点和对应旧节点作更新\n          patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n          \/\/然后将旧节点组中对应节点设置为undefined,代表已经遍历过了，不在遍历，否则可能存在重复插入的问题\n\n          oldCh[idxInOld] = undefined;\n          \/\/插入到旧头索引节点之前\n          api.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);\n          \/\/新头索引向后\n          newStartVnode = newCh[\x2b\x2bnewStartIdx];\n        }\n      }\n    }\n    \/\/当旧头索引大于旧尾索引时，代表旧节点组已经遍历完，将剩余的新Vnode添加到最后一个新节点的位置后\n    if (oldStartIdx \x3e oldEndIdx) {\n      before = isUndef(newCh[newEndIdx\x2b1]) ? null : newCh[newEndIdx\x2b1].elm;\n      addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n    }\n    \/\/如果新节点组先遍历完，那么代表旧节点组中剩余节点都不需要，所以直接删除\n    else if (newStartIdx \x3e newEndIdx) {\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/**\n   *\n     * @param parentElm 父节点\n     * @param oldCh 旧节点数组\n     * @param newCh 新节点数组\n     * @param insertedVnodeQueue\n     *\/\x3c\/span\x3e\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eupdateChildren\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eparentElm, oldCh, newCh, insertedVnodeQueue\x3c\/span\x3e) \x3c\/span\x3e{\n\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e oldStartIdx = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, newStartIdx = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e oldEndIdx = oldCh.length - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e oldStartVnode = oldCh[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e];\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e oldEndVnode = oldCh[oldEndIdx];\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e newEndIdx = newCh.length - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e newStartVnode = newCh[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e];\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e newEndVnode = newCh[newEndIdx];\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e oldKeyToIdx, idxInOld, elmToMove, before;\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (oldStartIdx \x26lt;= oldEndIdx \x26amp;\x26amp; newStartIdx \x26lt;= newEndIdx) {\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[\x2b\x2boldStartIdx]; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Vnode has been moved left\x3c\/span\x3e\n      } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      }\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果旧头索引节点和新头索引节点相同，\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (sameVnode(oldStartVnode, newStartVnode)) {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/对旧头索引节点和新头索引节点进行diff更新， 从而达到复用节点效果\x3c\/span\x3e\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/旧头索引向后\x3c\/span\x3e\n        oldStartVnode = oldCh[\x2b\x2boldStartIdx];\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/新头索引向后\x3c\/span\x3e\n        newStartVnode = newCh[\x2b\x2bnewStartIdx];\n      }\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果旧尾索引节点和新尾索引节点相似，可以复用\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (sameVnode(oldEndVnode, newEndVnode)) {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/旧尾索引节点和新尾索引节点进行更新\x3c\/span\x3e\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/旧尾索引向前\x3c\/span\x3e\n        oldEndVnode = oldCh[--oldEndIdx];\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/新尾索引向前\x3c\/span\x3e\n        newEndVnode = newCh[--newEndIdx];\n      }\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果旧头索引节点和新头索引节点相似，可以通过移动来复用\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/如旧节点为【5,1,2,3,4】，新节点为【1,2,3,4,5】，如果缺乏这种判断，意味着\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/那样需要先将5-\x26gt;1,1-\x26gt;2,2-\x26gt;3,3-\x26gt;4,4-\x26gt;5五次删除插入操作，即使是有了key-index来复用，\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 也会出现【5,1,2,3,4】-\x26gt;【1,5,2,3,4】-\x26gt;【1,2,5,3,4】-\x26gt;【1,2,3,5,4】-\x26gt;【1,2,3,4,5】\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 共4次操作，如果有了这种判断，我们只需要将5插入到最后一次操作即可\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (sameVnode(oldStartVnode, newEndVnode)) { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Vnode moved right\x3c\/span\x3e\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n        api.insertBefore(parentElm, oldStartVnode.elm, api.nextSibling(oldEndVnode.elm));\n        oldStartVnode = oldCh[\x2b\x2boldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n      }\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/原理与上面相同\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (sameVnode(oldEndVnode, newStartVnode)) { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Vnode moved left\x3c\/span\x3e\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n        api.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[\x2b\x2bnewStartIdx];\n      }\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果上面的判断都不通过，我们就需要key-index表来达到最大程度复用了\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果不存在旧节点的key-index表，则创建\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/找到新节点在旧节点组中对应节点的位置\x3c\/span\x3e\n        idxInOld = oldKeyToIdx[newStartVnode.key];\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果新节点在旧节点中不存在，我们将它插入到旧头索引节点前，然后新头索引向后\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isUndef(idxInOld)) { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ New element\x3c\/span\x3e\n          api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);\n          newStartVnode = newCh[\x2b\x2bnewStartIdx];\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果新节点在就旧节点组中存在，先找到对应的旧节点\x3c\/span\x3e\n          elmToMove = oldCh[idxInOld];\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/先将新节点和对应旧节点作更新\x3c\/span\x3e\n          patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/然后将旧节点组中对应节点设置为undefined,代表已经遍历过了，不在遍历，否则可能存在重复插入的问题\x3c\/span\x3e\n\n          oldCh[idxInOld] = \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e;\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/插入到旧头索引节点之前\x3c\/span\x3e\n          api.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/新头索引向后\x3c\/span\x3e\n          newStartVnode = newCh[\x2b\x2bnewStartIdx];\n        }\n      }\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/当旧头索引大于旧尾索引时，代表旧节点组已经遍历完，将剩余的新Vnode添加到最后一个新节点的位置后\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (oldStartIdx \x26gt; oldEndIdx) {\n      before = isUndef(newCh[newEndIdx\x2b\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e]) ? \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e : newCh[newEndIdx\x2b\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e].elm;\n      addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果新节点组先遍历完，那么代表旧节点组中剩余节点都不需要，所以直接删除\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (newStartIdx \x26gt; newEndIdx) {\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e至此，snabbdom的主要功能就分析完了\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>vue2源码学习开胃菜——snabbdom源码学习（二）</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000009017349">https://segmentfault.com/a/1190000009017349</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/vvx7lu683hc/" target="_blank">https://alili.tech/archive/vvx7lu683hc/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>