<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="vue生命周期探究（一）"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>vue生命周期探究（一） | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/xyndkboi83/",
				"appid": "1613049289050283", 
				"title": "vue生命周期探究（一） | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-17T02:30:25"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/srfd58hlpe/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/vvx7lu683hc/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fxyndkboi83%2f&text=vue%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e6%8e%a2%e7%a9%b6%ef%bc%88%e4%b8%80%ef%bc%89"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fxyndkboi83%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fxyndkboi83%2f&text=vue%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e6%8e%a2%e7%a9%b6%ef%bc%88%e4%b8%80%ef%bc%89"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fxyndkboi83%2f&title=vue%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e6%8e%a2%e7%a9%b6%ef%bc%88%e4%b8%80%ef%bc%89"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fxyndkboi83%2f&is_video=false&description=vue%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e6%8e%a2%e7%a9%b6%ef%bc%88%e4%b8%80%ef%bc%89"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=vue%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e6%8e%a2%e7%a9%b6%ef%bc%88%e4%b8%80%ef%bc%89&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fxyndkboi83%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fxyndkboi83%2f&title=vue%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e6%8e%a2%e7%a9%b6%ef%bc%88%e4%b8%80%ef%bc%89"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fxyndkboi83%2f&title=vue%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e6%8e%a2%e7%a9%b6%ef%bc%88%e4%b8%80%ef%bc%89"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fxyndkboi83%2f&title=vue%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e6%8e%a2%e7%a9%b6%ef%bc%88%e4%b8%80%ef%bc%89"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fxyndkboi83%2f&title=vue%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f%e6%8e%a2%e7%a9%b6%ef%bc%88%e4%b8%80%ef%bc%89"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">vue生命周期探究（一）</h1><div class="meta"><div class="postdate"><time datetime="2019-01-17" itemprop="datePublished">2019-01-17</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e\x3ca href=\x22https:\/\/cn.vuejs.org\/v2\/guide\/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3evue官方文档---实例生命周期\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22https:\/\/router.vuejs.org\/zh-cn\/advanced\/navigation-guards.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3evue-router2.3版文档---路由勾子\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22https:\/\/cn.vuejs.org\/v2\/guide\/custom-directive.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3evue官方文档---指令及其绑定周期\x3c\/a\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e前言\x3c\/h2\x3e\n\x3cp\x3e在使用vue开发的过程中，我们经常会接触到生命周期的问题。那么你知道，一个标准的工程项目中，会有多少个生命周期勾子吗？让我们来一起来盘点一下：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e根组件实例：8个 (beforeCreate、created、beforeMount、mounted、beforeUpdate、updated、beforeDestroy、destroyed)\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e组件实例：8个 (beforeCreate、created、beforeMount、mounted、beforeUpdate、updated、beforeDestroy、destroyed)\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e全局路由钩子：2个 (beforeEach、afterEach)\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e组件路由钩子：3个 (beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave)\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e指令的周期： 5个 (bind、inserted、update、componentUpdated、unbind)\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ebeforeRouteEnter的next所对应的周期\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3enextTick所对应的周期\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e吓到了吗？合计竟然一共有28个周期，是否看得头昏眼花了呢？接下来让我们一起来介绍一下各个周期的通常用途与使用细节吧\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e组件实例周期\x3c\/h2\x3e\n\x3cp\x3e这一块vue2的官方文档有一张图示，我们简要提一下用法和注意\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3ebeforeCreate\x3c\/h3\x3e\n\x3cp\x3e在实例初始化之后，数据观测(data observer) 和 event\/watcher 事件配置之前被调用。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22tip：\n\n此时组件的选项还未挂载，因此无法访问methods，data,computed上的方法或数据\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs haskell\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-title\x22\x3etip\x3c\/span\x3e：\n\n此时组件的选项还未挂载，因此无法访问methods，\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e,computed上的方法或数据\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3ecreated\x3c\/h3\x3e\n\x3cp\x3e实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch\/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。\x3c\/p\x3e\n\x3cp\x3e这是一个常用的生命周期，因为你可以调用methods中的方法、改变data中的数据，并且修改可以通过vue的响应式绑定体现在页面上、获取computed中的计算属性等等。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22tip:\n\n通常我们可以在这里对实例进行预处理。\n也有一些童鞋喜欢在这里发ajax请求，值得注意的是，这个周期中是没有什么方法来对实例化过程进行拦截的。\n因此假如有某些数据必须获取才允许进入页面的话，并不适合在这个页面发请求。\n建议在组件路由勾子beforeRouteEnter中来完成。\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs avrasm\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-symbol\x22\x3etip:\x3c\/span\x3e\n\n通常我们可以在这里对实例进行预处理。\n也有一些童鞋喜欢在这里发ajax请求，值得注意的是，这个周期中是没有什么方法来对实例化过程进行拦截的。\n因此假如有某些数据必须获取才允许进入页面的话，并不适合在这个页面发请求。\n建议在组件路由勾子beforeRouteEnter中来完成。\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3ebeforeMonut\x3c\/h3\x3e\n\x3cp\x3e在挂载开始之前被调用：相关的 render 函数首次被调用。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3emounted\x3c\/h3\x3e\n\x3cp\x3eel 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22tip:\n\n1.在这个周期内，对data的改变可以生效。但是要进下一轮的dom更新，dom上的数据才会更新。\n2.这个周期可以获取 dom。 之前的论断有误，感谢@冯银超 和 @AnHour的提醒\n3.beforeRouteEnter的next的勾子比mounted触发还要靠后\n4.指令的生效在mounted周期之前\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs less\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-attribute\x22\x3etip\x3c\/span\x3e:\n\n\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e.在这个周期内，对data的改变可以生效。但是要进下一轮的dom更新，dom上的数据才会更新。\n\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e.这个周期可以获取 dom。 之前的论断有误，感谢@冯银超 和 \x3cspan class=\x22hljs-variable\x22\x3e@AnHour\x3c\/span\x3e的提醒\n\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e.beforeRouteEnter的next的勾子比mounted触发还要靠后\n\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e.指令的生效在mounted周期之前\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3ebeforeUpdate\x3c\/h3\x3e\n\x3cp\x3e数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3eupdated\x3c\/h3\x3e\n\x3cp\x3e由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3ebeforeDestroy\x3c\/h3\x3e\n\x3cp\x3e实例销毁之前调用。在这一步，实例仍然完全可用。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22tip:\n\n1.这一步还可以用this来获取实例。\n2.一般在这一步做一些重置的操作。比如清除掉组件中的 定时器 和 监听的dom事件\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs groovy\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-string\x22\x3etip:\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-number\x22\x3e1.\x3c\/span\x3e这一步还可以用\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e来获取实例。\n\x3cspan class=\x22hljs-number\x22\x3e2.\x3c\/span\x3e一般在这一步做一些重置的操作。比如清除掉组件中的 定时器 和 监听的dom事件\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3edestroyed\x3c\/h3\x3e\n\x3cp\x3eVue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader10\x22\x3e全局路由钩子\x3c\/h2\x3e\n\x3cp\x3e作用于所有路由切换，一般在main.js里面定义\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader11\x22\x3erouter.beforeEach\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22示例\nrouter.beforeEach((to, from, next) =\x3e {\n  console.log(\x27路由全局勾子：beforeEach -- 有next方法\x27)\n  next()\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs moonscript\x22\x3e\x3ccode\x3e示例\nrouter.beforeEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(to, \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3enext\x3c\/span\x3e)\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  console.log(\x3cspan class=\x22hljs-string\x22\x3e\x27路由全局勾子：beforeEach -- 有next方法\x27\x3c\/span\x3e)\n  \x3cspan class=\x22hljs-built_in\x22\x3enext\x3c\/span\x3e()\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e一般在这个勾子的回调中，对路由进行拦截。\x3cbr\x3e比如，未登录的用户，直接进入了需要登录才可见的页面，那么可以用next(false)来拦截，使其跳回原页面。\x3cbr\x3e值得注意的是，如果没有调用next方法，那么页面将卡在那。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22next的四种用法\n1.next() 跳入下一个页面\n2.next(\x27\/path\x27) 改变路由的跳转方向，使其跳到另一个路由\n3.next(false)  返回原来的页面\n4.next((vm)=\x3e{})  仅在beforeRouteEnter中可用，vm是组件实例。\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs moonscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-built_in\x22\x3enext\x3c\/span\x3e的四种用法\n\x3cspan class=\x22hljs-number\x22\x3e1.\x3c\/span\x3e\x3cspan class=\x22hljs-built_in\x22\x3enext\x3c\/span\x3e() 跳入下一个页面\n\x3cspan class=\x22hljs-number\x22\x3e2.\x3c\/span\x3e\x3cspan class=\x22hljs-built_in\x22\x3enext\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27\/path\x27\x3c\/span\x3e) 改变路由的跳转方向，使其跳到另一个路由\n\x3cspan class=\x22hljs-number\x22\x3e3.\x3c\/span\x3e\x3cspan class=\x22hljs-built_in\x22\x3enext\x3c\/span\x3e(\x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e)  返回原来的页面\n\x3cspan class=\x22hljs-number\x22\x3e4.\x3c\/span\x3e\x3cspan class=\x22hljs-built_in\x22\x3enext\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(vm)\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{})  仅在beforeRouteEnter中可用，vm是组件实例。\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader12\x22\x3erouter.afterEach\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22示例\nrouter.afterEach((to, from) =\x3e {\n  console.log(\x27路由全局勾子：afterEach --- 没有next方法\x27)\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs yaml\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-string\x22\x3e示例\x3c\/span\x3e\n\x3cspan class=\x22hljs-string\x22\x3erouter.afterEach((to,\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3efrom)\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e=\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e{\x3c\/span\x3e\n  \x3cspan class=\x22hljs-string\x22\x3econsole.log(\x27路由全局勾子：afterEach\x3c\/span\x3e \x3cspan class=\x22hljs-meta\x22\x3e---\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e没有next方法\x27)\x3c\/span\x3e\n\x3cspan class=\x22hljs-string\x22\x3e})\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在所有路由跳转结束的时候调用，和beforeEach是类似的，但是它没有next方法\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader13\x22\x3e组件路由勾子\x3c\/h2\x3e\n\x3cp\x3e和全局勾子不同的是，它仅仅作用于某个组件，一般在.vue文件中去定义。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader14\x22\x3ebeforeRouteEnter\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22示例\n  beforeRouteEnter (to, from, next) {\n    console.log(this)  \/\/undefined，不能用this来获取vue实例\n    console.log(\x27组件路由勾子：beforeRouteEnter\x27)\n    next(vm =\x3e {\n      console.log(vm)  \/\/vm为vue的实例\n      console.log(\x27组件路由勾子beforeRouteEnter的next\x27)\n    })\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e示例\n  beforeRouteEnter (to, \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e, next) {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e)  \x3cspan class=\x22hljs-comment\x22\x3e\/\/undefined，不能用this来获取vue实例\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27组件路由勾子：beforeRouteEnter\x27\x3c\/span\x3e)\n    next(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3evm\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(vm)  \x3cspan class=\x22hljs-comment\x22\x3e\/\/vm为vue的实例\x3c\/span\x3e\n      \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27组件路由勾子beforeRouteEnter的next\x27\x3c\/span\x3e)\n    })\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这个是一个很不同的勾子。因为beforeRouterEnter在组件创建之前调用，所以它无法直接用this来访问组件实例。\x3cbr\x3e为了弥补这一点，vue-router开发人员，给他的next方法加了特技，可以传一个回调，回调的第一个参数即是组件实例。\x3cbr\x3e一般我们可以利用这点，对实例上的数据进行修改，调用实例上的方法。\x3c\/p\x3e\n\x3cp\x3e我们可以在这个方法去请求数据，在数据获取到之后，再调用next就能保证你进页面的时候，数据已经获取到了。没错，这里next有阻塞的效果。你没调用的话，就会一直卡在那\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22tip:\n\nnext(vm=\x3e{console.log(\x27next\x27)  })\n这个里面的代码是很晚执行的，在组件mounted周期之后。没错，这是一个坑。你要注意。\nbeforeRouteEnter的代码时很早执行的，在组件beforeCreate之前；\n但是next里面回调的执行，很晚，在mounted之后，可以说是目前我找到的，离dom渲染最近的一个周期。\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs vim\x22\x3e\x3ccode\x3etip:\n\n\x3cspan class=\x22hljs-keyword\x22\x3enext\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evm\x3c\/span\x3e=\x26gt;{console.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27next\x27\x3c\/span\x3e)  })\n这个里面的代码是很晚执行的，在组件mounted周期之后。没错，这是一个坑。你要注意。\nbeforeRouteEnter的代码时很早执行的，在组件beforeCreate之前；\n但是\x3cspan class=\x22hljs-keyword\x22\x3enext\x3c\/span\x3e里面回调的执行，很晚，在mounted之后，可以说是目前我找到的，离dom渲染最近的一个周期。\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader15\x22\x3ebeforeRouteLeave\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  beforeRouteLeave (to, from, next) {\n    console.log(this)    \/\/可以访问vue实例\n    console.log(\x27组件路由勾子：beforeRouteLeave\x27)\n    next()\n  },\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs autoit\x22\x3e\x3ccode\x3e  beforeRouteLeave (\x3cspan class=\x22hljs-keyword\x22\x3eto\x3c\/span\x3e, from, \x3cspan class=\x22hljs-keyword\x22\x3enext\x3c\/span\x3e) {\n    console.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(this)    \/\/可以访问vue实例\n    console.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27组件路由勾子：beforeRouteLeave\x27\x3c\/span\x3e)\n    \x3cspan class=\x22hljs-keyword\x22\x3enext\x3c\/span\x3e()\n  },\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在离开路由时调用。可以用this来访问组件实例。但是next中不能传回调。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader16\x22\x3ebeforeRouteUpdate\x3c\/h3\x3e\n\x3cp\x3e这个方法是vue-router2.2版本加上的。因为原来的版本中，如果一个在两个子路由之间跳转，是不触发beforeRouteLeave的。这会导致某些重置操作，没地方触发。在之前，我们都是用watch $route来hack的。但是通过这个勾子，我们有了更好的方式。\x3c\/p\x3e\n\x3cp\x3e老实讲，我没用过这个勾子，所以各位可以查看一下文章之前的文档，去尝试一下，再和我交流交流。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader17\x22\x3e指令周期\x3c\/h2\x3e\n\x3cp\x3e绑定自定义指令的时候也会有对应的周期。\x3cbr\x3e这几个周期，我比较常用的，一般是只有bind。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader18\x22\x3ebind\x3c\/h3\x3e\n\x3cp\x3e只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个在绑定时执行一次的初始化动作。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader19\x22\x3einserted\x3c\/h3\x3e\n\x3cp\x3e被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中）。\x3cbr\x3e实际上是插入vnode的时候调用。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader20\x22\x3eupdate\x3c\/h3\x3e\n\x3cp\x3e被绑定元素所在的模板更新时调用，而不论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新。\x3cbr\x3e慎用，如果在指令里绑定事件，并且用这个周期的，记得把事件注销\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader21\x22\x3ecomponentUpdated\x3c\/h3\x3e\n\x3cp\x3e被绑定元素所在模板完成一次更新周期时调用。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader22\x22\x3eunbind\x3c\/h3\x3e\n\x3cp\x3e只调用一次， 指令与元素解绑时调用。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader23\x22\x3eVue.nextTick、vm.$nextTick\x3c\/h2\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22示例：\n  created () {\n    this.$nextTick(() =\x3e {\n      console.log(\x27nextTick\x27)  \/\/回调里的函数一直到真实的dom渲染结束后，才执行\n    })\n    console.log(\x27组件：created\x27)\n  },\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3e示例：\n  created () {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$nextTick(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27nextTick\x27\x3c\/span\x3e)  \x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e回调里的函数一直到真实的dom渲染结束后，才执行\n    })\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27组件：created\x27\x3c\/span\x3e)\n  },\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3enextTick方法的回调会在dom更新后再执行，因此可以和一些dom操作搭配一起用，如 ref。\x3cbr\x3e非常好用，可以解决很多疑难杂症。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22场景：\n你用ref获得一个输入框，用v-model绑定。\n在某个方法里改变绑定的值，在这个方法里用ref去获取dom并取值，你会发现dom的值并没有改变。\n因为此时vue的方法，还没去触发dom的改变。\n因此你可以把获取dom值的操作放在vm.$nextTick的回调里，就可以了。\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs perl\x22\x3e\x3ccode\x3e场景：\n你用\x3cspan class=\x22hljs-keyword\x22\x3eref\x3c\/span\x3e获得一个输入框，用v-model绑定。\n在某个方法里改变绑定的值，在这个方法里用\x3cspan class=\x22hljs-keyword\x22\x3eref\x3c\/span\x3e去获取dom并取值，你会发现dom的值并没有改变。\n因为此时vue的方法，还没去触发dom的改变。\n因此你可以把获取dom值的操作放在vm.$nextTick的回调里，就可以了。\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000008923105\x22\x3evue生命周期探究（二）\x3c\/a\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>vue生命周期探究（一）</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000008879966">https://segmentfault.com/a/1190000008879966</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/xyndkboi83/" target="_blank">https://alili.tech/archive/xyndkboi83/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>