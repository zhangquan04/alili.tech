<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="Tutorial: GraphQL 订阅服务器消息"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>Tutorial: GraphQL 订阅服务器消息 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/adx3hvnq4us/",
				"appid": "1613049289050283", 
				"title": "Tutorial: GraphQL 订阅服务器消息 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-20T02:30:11"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/sj37smizrni/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/1nf1tbzevji/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fadx3hvnq4us%2f&text=Tutorial%3a%20GraphQL%20%e8%ae%a2%e9%98%85%e6%9c%8d%e5%8a%a1%e5%99%a8%e6%b6%88%e6%81%af"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fadx3hvnq4us%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fadx3hvnq4us%2f&text=Tutorial%3a%20GraphQL%20%e8%ae%a2%e9%98%85%e6%9c%8d%e5%8a%a1%e5%99%a8%e6%b6%88%e6%81%af"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fadx3hvnq4us%2f&title=Tutorial%3a%20GraphQL%20%e8%ae%a2%e9%98%85%e6%9c%8d%e5%8a%a1%e5%99%a8%e6%b6%88%e6%81%af"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fadx3hvnq4us%2f&is_video=false&description=Tutorial%3a%20GraphQL%20%e8%ae%a2%e9%98%85%e6%9c%8d%e5%8a%a1%e5%99%a8%e6%b6%88%e6%81%af"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=Tutorial%3a%20GraphQL%20%e8%ae%a2%e9%98%85%e6%9c%8d%e5%8a%a1%e5%99%a8%e6%b6%88%e6%81%af&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fadx3hvnq4us%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fadx3hvnq4us%2f&title=Tutorial%3a%20GraphQL%20%e8%ae%a2%e9%98%85%e6%9c%8d%e5%8a%a1%e5%99%a8%e6%b6%88%e6%81%af"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fadx3hvnq4us%2f&title=Tutorial%3a%20GraphQL%20%e8%ae%a2%e9%98%85%e6%9c%8d%e5%8a%a1%e5%99%a8%e6%b6%88%e6%81%af"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fadx3hvnq4us%2f&title=Tutorial%3a%20GraphQL%20%e8%ae%a2%e9%98%85%e6%9c%8d%e5%8a%a1%e5%99%a8%e6%b6%88%e6%81%af"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fadx3hvnq4us%2f&title=Tutorial%3a%20GraphQL%20%e8%ae%a2%e9%98%85%e6%9c%8d%e5%8a%a1%e5%99%a8%e6%b6%88%e6%81%af"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">Tutorial: GraphQL 订阅服务器消息</h1><div class="meta"><div class="postdate"><time datetime="2019-01-20" itemprop="datePublished">2019-01-20</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n            \x3ch2\x3eFull-stack GraphQL \x2b React Tutorial — Part 6\x3c\/h2\x3e\n\x3cp\x3e这是全栈Graph\x2bReact手册里面的第六部分，该系列将指导你创建一个消息应用。并且每一部分都是独立的，并且聚焦于一些新的话题，所以你可以跳跃到吸引你的某一部分开始阅读，或者你也可以从头到尾阅读，下面是该手册的其他部分：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/dev-blog.apollodata.com\/full-stack-react-graphql-tutorial-582ac8d24e3b\x22\x3ePart 1: 创建一个简单的客户端\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/dev-blog.apollodata.com\/react-graphql-tutorial-part-2-server-99d0528c7928\x22\x3ePart 2: 创建一个简单的服务器\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/dev-blog.apollodata.com\/react-graphql-tutorial-mutations-764d7ec23c15\x22\x3ePart 3: 编写Mutation并保持客户端同步\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/dev-blog.apollodata.com\/tutorial-graphql-mutations-optimistic-ui-and-store-updates-f7b6b66bf0e2\x22\x3ePart 4: 良好的用户界面和客户端存储更新\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/dev-blog.apollodata.com\/tutorial-graphql-input-types-and-client-caching-f11fa0421cfd\x22\x3ePart 5: 输入类型和自定义解析器\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3ePart 6: 服务器端订阅 (当前)\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/dev-blog.apollodata.com\/tutorial-graphql-subscriptions-client-side-40e185e4be76\x22\x3ePart 7: 客户端上的GraphQL订阅\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/dev-blog.apollodata.com\/tutorial-pagination-d1c3b3ee2823\x22\x3ePart 8: 分页\x3c\/a\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3chr\x3e\n\x3cp\x3e在本教程中，我们将介绍如何将GraphQL订阅添加到我们的服务器的过程。 在第5部分中，我们添加了消息的概念，并在客户端实现了channel Detail的视图，以在每个channel中显示消息。 但现在，消息不会跨客户端同步，因为服务器无法通知客户端已添加新消息。\x3c\/p\x3e\n\x3cp\x3e与许多其他应用程序一样，我们的消息应用程序需要对某些功能进行实时更新，因此在本教程中，我们将构建服务器端逻辑，以使我们的客户端能够实时显示新消息，这归功于GraphQL订阅。 如果您想深入了解订阅如何工作，请查看[本博客文章]（\x3ca href=\x22https:\/\/dev-blog.apollodata.com\/graphql-subscriptions-in-apollo-client-9a2457f015fb），介绍Apollo客户支持\x22\x3ehttps:\/\/dev-blog.apollodata.com\/graphql-subscriptions-in-apollo-client-9a2457f015fb），介绍Apollo客户支持\x3c\/a\x3e 订阅和\x3ca href=\x22https:\/\/github.com\/facebook\/graphql\/blob\/master\/rfcs\/Subscriptions.md\x22\x3e请求评论\x3c\/a\x3e 来添加对GraphQL规范的订阅。\x3c\/p\x3e\n\x3chr\x3e\n\x3cp\x3e我们先开始克隆git仓库并且安装依赖包\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs crmsh\x22\x3egit \x3cspan class=\x22hljs-keyword\x22\x3eclone\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ehttps\x3c\/span\x3e:\/\/github.com\/apollographql\/graphql-tutorial.gitcd graphql-tutorialgit checkout t6-startcd server \x26amp;\x26amp; npm installcd ..\/client \x26amp;\x26amp; npm install\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e首先我们得确认客户端和服务端都正常运行\x3c\/p\x3e\n\x3cp\x3e在一个命令行终端我们开启一个运行在4000端口的服务端服务\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs dos\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3ecd\x3c\/span\x3e servernpm \x3cspan class=\x22hljs-built_in\x22\x3estart\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e在另一个终端我们开启一个运行在3000端口的客户端\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs dos\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3ecd\x3c\/span\x3e clientnpm \x3cspan class=\x22hljs-built_in\x22\x3estart\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e当你在你的浏览器地址栏输入\x3ca href=\x22http:\/\/localhost:3000\x22\x3ehttp:\/\/localhost:3000\x3c\/a\x3e，其中有一个用户创建的channel列表。 点击其中一个频道，您将看到我们在最后一部分创建的detail视图，您可以在该频道中添加新消息。\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/p0.ssl.qhimg.com\/t019758a4f4a761f61f.gif\x22 alt=\x22\x22\x3e\x3c\/p\x3e\n\x3cp\x3e我们不会在本教程中编写任何客户端代码，但我们将使用客户端UI来插入消息以测试我们的订阅实现。\x3c\/p\x3e\n\x3ch4\x3eGraphQL 订阅\x3c\/h4\x3e\n\x3cp\x3e要将消息添加到channel时通知客户端，我们将使用GraphQL订阅，这使得客户端可以进行查询，并在特定的服务器端事件的情况下通知新的结果。 在我们的服务器实现中，我们将使用带有WebSockets的Express服务器将更新推送到客户端。\x3c\/p\x3e\n\x3cp\x3e在本教程中，我们将首先添加一个订阅，通知客户端有新消息。 接下来，我们将向我们的GraphQL模式添加一个字段并为订阅实现一个解析器。 最后，我们将使用内存中的pub-sub对象来处理传递有关添加消息的通知。 总之，消息创建和订阅通知的流程如下所示：\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/p0.ssl.qhimg.com\/t0125463a2210df4ca8.png\x22 alt=\x22\x22\x3e\x3c\/p\x3e\n\x3cp\x3e现在让我们通过添加一个订阅来监听消息添加到我们的服务器端模式！ 在server \/ src \/ schema.js中的GraphQL模式的最后，我们添加了一个新的根类型的Subscription，它与Query和Mutation处于同一级别。 该根类型包含messageAdded（channelId：ID！），该字段表示客户端可以侦听的主题，以通知添加到特定channel的消息。 总之，我们补充道：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs elm\x22\x3e\/\/ server\/src\/schema.js\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eSubscription\x3c\/span\x3e {  messageAdded(channelId: \x3cspan class=\x22hljs-type\x22\x3eID\x3c\/span\x3e!): \x3cspan class=\x22hljs-type\x22\x3eMessage\x3c\/span\x3e}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e随着我们继续实现订阅，我们的模式现在为我们提供了坚实的参考。\x3c\/p\x3e\n\x3ch4\x3e添加订阅解析器\x3c\/h4\x3e\n\x3cp\x3e现在我们有一个模式来定义客户端可以请求哪些订阅，下一步是允许事件发送到订阅。 为了简单起见，我们将使用graphql-subscriptions包中的内存PubSub系统实现我们的订阅模型。 我们还需要使用来自同一个包的withFilter帮助程序来分解他们用于哪个channel的事件。 在server \/ src \/ resolvers.js中，我们有必要开始添加一些导入语句\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs awk\x22\x3e\x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e server\x3cspan class=\x22hljs-regexp\x22\x3e\/src\/\x3c\/span\x3eresolvers.jsimport { PubSub, withFilter } from ‘graphql-subscriptions’;\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e接下来，我们将构建一个PubSub实例来处理我们应用程序的订阅主题。 在我们定义解析器之前，我们将添加此实例，在创建消息时我们需要使用该实例生成事件。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs actionscript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e pubsub = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e PubSub();\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs cpp\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e resolvers = {\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e一旦我们设置了订阅管理器，我们需要用它发布消息！ 使用PubSub类，这与调用pubsub.publish（topic，data）一样简单。 对于我们的应用程序，我们将每条新消息发布到messageAdded主题以及一个携带channel ID的附加属性（本教程稍后将更加重要）。 有一点需要注意：主题名称不必与订阅名称匹配; 我们在这里使用了相同的名称来保持简单。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3eaddMessage: \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eroot, { message }\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e channel = channels.find(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3echannel\x3c\/span\x3e =\x26gt;\x3c\/span\x3e channel.id ===message.channelId);\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(!channel)    \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(“Channel does not exist”);\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs arduino\x22\x3e  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e newMessage = { id: \x3cspan class=\x22hljs-keyword\x22\x3eString\x3c\/span\x3e(nextMessageId\x2b\x2b), \x3cspan class=\x22hljs-built_in\x22\x3etext\x3c\/span\x3e: message.\x3cspan class=\x22hljs-built_in\x22\x3etext\x3c\/span\x3e };\nchannel.messages.push(newMessage);\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs css\x22\x3e  \x3cspan class=\x22hljs-selector-tag\x22\x3epubsub\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.publish\x3c\/span\x3e(‘\x3cspan class=\x22hljs-selector-tag\x22\x3emessageAdded\x3c\/span\x3e’, { \x3cspan class=\x22hljs-attribute\x22\x3emessageAdded\x3c\/span\x3e: newMessage, channelId: message.channelId });\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs haxe\x22\x3e  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eMessage\x3c\/span\x3e;}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e接下来，让我们使用发布的事件来解析订阅查询！ 通过graphql-subscriptions包，这非常容易。 我们在解析器中设置嵌套对象，就像我们通常会那样，而不是在最后返回一个对象，我们返回一个异步迭代器，它将发送消息发送到客户端。 由于messageAdded主题包含\x3cem\x3eall\x3c\/em\x3e channels的事件，因此我们还使用前面导入的withFilter函数来节省资源。 这将过滤事件以仅选择查询中指定的通道的事件。 当使用withFilter时，第一个参数是一个返回我们正在过滤的异步迭代器的函数。 第二个参数是一个条件，指定事件是否应通过给定事件数据和查询变量的过滤器。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs css\x22\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3eSubscription\x3c\/span\x3e: {  \x3cspan class=\x22hljs-attribute\x22\x3emessageAdded\x3c\/span\x3e: {    subscribe: \x3cspan class=\x22hljs-built_in\x22\x3ewithFilter\x3c\/span\x3e(      () =\x26gt; pubsub.\x3cspan class=\x22hljs-built_in\x22\x3easyncIterator\x3c\/span\x3e(‘messageAdded’),      (payload, variables) =\x26gt; {        return payload.channelId === variables.channelId;\n}    )  \x22}}\x22\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e这就是解决GraphQL订阅查询所需的全部内容！\x3c\/p\x3e\n\x3ch4\x3e用于订阅的WebSocket传输\x3c\/h4\x3e\n\x3cp\x3e本教程的最后一步是通过WebSockets为我们的GraphQL服务器添加订阅支持，因为我们无法通过HTTP将频繁的更新从服务器推送到客户端。 感谢subscriptions-transport-ws包，这非常简单！ 首先，让我们开始在server \/ server.js中添加必要的导入语句\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs puppet\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { execute, \x3cspan class=\x22hljs-literal\x22\x3esubscribe\x3c\/span\x3e } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e ‘graphql’;\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { createServer } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e ‘http’;\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { SubscriptionServer } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e ‘subscriptions-transport-ws’;\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e接下来，我们可以在我们的GraphQL服务器中打开WebSocket。 我们分两步执行此操作：首先用createServer包装Express服务器，然后使用包装的服务器设置WebSocket来侦听GraphQL订阅。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs 1c\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Wrap the Express serverconst ws = createServer(server);\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs coffeescript\x22\x3ews.listen(PORT, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(GraphQL Server \x3cspan class=\x22hljs-keyword\x22\x3eis\x3c\/span\x3e now running \x3cspan class=\x22hljs-literal\x22\x3eon\x3c\/span\x3e http:\x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3elocalhost:${PORT});\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs lua\x22\x3e  \/\/ Set up the WebSocket \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e handling GraphQL subscriptions  new SubscriptionServer({    \x3cspan class=\x22hljs-built_in\x22\x3eexecute\x3c\/span\x3e,    subscribe,    schema  }, {    server: ws,    \x3cspan class=\x22hljs-built_in\x22\x3epath\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27\/subscriptions\x27\x3c\/span\x3e,  });});\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e接下来，我们将Graph_i_QL配置为使用我们刚刚设置的订阅WebSocket。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs groovy\x22\x3eserver.use(\x3cspan class=\x22hljs-string\x22\x3e\x27\/graphiql\x27\x3c\/span\x3e, graphiqlExpress({  \x3cspan class=\x22hljs-string\x22\x3eendpointURL:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27\/graphql\x27\x3c\/span\x3e,  \x3cspan class=\x22hljs-string\x22\x3esubscriptionsEndpoint:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3ews:\x3c\/span\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/localhost:4000\/subscriptions}));\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e与此同时，我们的服务器已准备就绪！ 要试用它，我们可以在\x3ca href=\x22http:\/\/localhost:4000\/graphiql\x22\x3ehttp:\/\/localhost:4000\/graphiql\x3c\/a\x3e 上打开GraphiQL并运行以下查询\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs applescript\x22\x3esubscription {  messageAdded(channelId: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e) {    \x3cspan class=\x22hljs-built_in\x22\x3eid\x3c\/span\x3e    \x3cspan class=\x22hljs-built_in\x22\x3etext\x3c\/span\x3e  \x22}}\x22\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e当您运行查询时，您应该看到类似下面的这样一条消息\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs smalltalk\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\x22Your subscription data will appear here after server publication!\x22\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3eGraph_i_QL现在正在监听新消息的创建，我们可以通过在客户端创建消息来触发该消息。 因为我们只在收听channel1，所以请务必导航到客户端的第一个channel（或直接将浏览器指向\x3ca href=\x22http:\/\/localhost:3000\/channel\/1\x22\x3ehttp:\/\/localhost:3000\/channel\/1\x3c\/a\x3e).当你创建一条新消息时，你应该看到它立即显示在你的Graph_i_QL窗口中！\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/p0.ssl.qhimg.com\/t011a43227d4cdb94e9.gif\x22 alt=\x22\x22\x3e\x3c\/p\x3e\n\x3ch4\x3e总结\x3c\/h4\x3e\n\x3cp\x3e万岁！ 您现在已经实现了GraphQL订阅的服务器端部分，方法是向模式添加订阅类型并通过WebSockets实现订阅传输！ 通过对客户端进行一些更改（将在[下一个教程]（\x3ca href=\x22https:\/\/dev-blog.apollodata.com\/tutorial-graphql-subscriptions-client-side-40e185e4be76）\x22\x3ehttps:\/\/dev-blog.apollodata.com\/tutorial-graphql-subscriptions-client-side-40e185e4be76）\x3c\/a\x3e\n中进行解释）我们的客户端将能够几乎实时查看消息添加。\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3e如果您喜欢本教程并希望继续学习Apollo和GraphQL，请务必点击下面的“关注”按钮，然后在Twitter上关注我们\x3ca href=\x22https:\/\/twitter.com\/apollographql\x22\x3e@apollographql\x3c\/a\x3e 和作者 \x3ca href=\x22http:\/\/twitter.com\/shadajl\x22\x3e@ShadajL\x3c\/a\x3e.\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e感谢我的导师, \x3ca href=\x22https:\/\/medium.com\/@helfer\x22\x3eJonas Helfer\x3c\/a\x3e, 感谢他在我写这篇文章时的所做的支持!\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22https:\/\/p0.ssl.qhimg.com\/t014fc6606574d991f5.jpg\x22 alt=\x22\x22\x3e\x3c\/p\x3e\n\n          \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>Tutorial: GraphQL 订阅服务器消息</p><h2 id="原文链接">原文链接</h2><p><a href="https://www.zcfy.cc/article/tutorial-graphql-subscriptions-server-side">https://www.zcfy.cc/article/tutorial-graphql-subscriptions-server-side</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/adx3hvnq4us/" target="_blank">https://alili.tech/archive/adx3hvnq4us/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>