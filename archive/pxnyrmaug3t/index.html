<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="实例PK(Vue服务端渲染 VS Vue浏览器端渲染)"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>实例PK(Vue服务端渲染 VS Vue浏览器端渲染) | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/pxnyrmaug3t/",
				"appid": "1613049289050283", 
				"title": "实例PK(Vue服务端渲染 VS Vue浏览器端渲染) | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-18T02:30:34"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/egacrwxdo3p/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/lctu101vc3q/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fpxnyrmaug3t%2f&text=%e5%ae%9e%e4%be%8bPK%28Vue%e6%9c%8d%e5%8a%a1%e7%ab%af%e6%b8%b2%e6%9f%93%20VS%20Vue%e6%b5%8f%e8%a7%88%e5%99%a8%e7%ab%af%e6%b8%b2%e6%9f%93%29"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fpxnyrmaug3t%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fpxnyrmaug3t%2f&text=%e5%ae%9e%e4%be%8bPK%28Vue%e6%9c%8d%e5%8a%a1%e7%ab%af%e6%b8%b2%e6%9f%93%20VS%20Vue%e6%b5%8f%e8%a7%88%e5%99%a8%e7%ab%af%e6%b8%b2%e6%9f%93%29"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fpxnyrmaug3t%2f&title=%e5%ae%9e%e4%be%8bPK%28Vue%e6%9c%8d%e5%8a%a1%e7%ab%af%e6%b8%b2%e6%9f%93%20VS%20Vue%e6%b5%8f%e8%a7%88%e5%99%a8%e7%ab%af%e6%b8%b2%e6%9f%93%29"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fpxnyrmaug3t%2f&is_video=false&description=%e5%ae%9e%e4%be%8bPK%28Vue%e6%9c%8d%e5%8a%a1%e7%ab%af%e6%b8%b2%e6%9f%93%20VS%20Vue%e6%b5%8f%e8%a7%88%e5%99%a8%e7%ab%af%e6%b8%b2%e6%9f%93%29"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e5%ae%9e%e4%be%8bPK%28Vue%e6%9c%8d%e5%8a%a1%e7%ab%af%e6%b8%b2%e6%9f%93%20VS%20Vue%e6%b5%8f%e8%a7%88%e5%99%a8%e7%ab%af%e6%b8%b2%e6%9f%93%29&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fpxnyrmaug3t%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fpxnyrmaug3t%2f&title=%e5%ae%9e%e4%be%8bPK%28Vue%e6%9c%8d%e5%8a%a1%e7%ab%af%e6%b8%b2%e6%9f%93%20VS%20Vue%e6%b5%8f%e8%a7%88%e5%99%a8%e7%ab%af%e6%b8%b2%e6%9f%93%29"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fpxnyrmaug3t%2f&title=%e5%ae%9e%e4%be%8bPK%28Vue%e6%9c%8d%e5%8a%a1%e7%ab%af%e6%b8%b2%e6%9f%93%20VS%20Vue%e6%b5%8f%e8%a7%88%e5%99%a8%e7%ab%af%e6%b8%b2%e6%9f%93%29"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fpxnyrmaug3t%2f&title=%e5%ae%9e%e4%be%8bPK%28Vue%e6%9c%8d%e5%8a%a1%e7%ab%af%e6%b8%b2%e6%9f%93%20VS%20Vue%e6%b5%8f%e8%a7%88%e5%99%a8%e7%ab%af%e6%b8%b2%e6%9f%93%29"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fpxnyrmaug3t%2f&title=%e5%ae%9e%e4%be%8bPK%28Vue%e6%9c%8d%e5%8a%a1%e7%ab%af%e6%b8%b2%e6%9f%93%20VS%20Vue%e6%b5%8f%e8%a7%88%e5%99%a8%e7%ab%af%e6%b8%b2%e6%9f%93%29"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">实例PK(Vue服务端渲染 VS Vue浏览器端渲染)</h1><div class="meta"><div class="postdate"><time datetime="2019-01-18" itemprop="datePublished">2019-01-18</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3eVue 2.0 开始支持服务端渲染的功能，所以本文章也是基于vue 2.0以上版本。网上对于服务端渲染的资料还是比较少，最经典的莫过于Vue作者尤雨溪大神的 vue-hacker-news。本人在公司做Vue项目的时候，一直苦于产品、客户对首屏加载要求，SEO的诉求，也想过很多解决方案，本次也是针对浏览器渲染不足之处，采用了服务端渲染，并且做了两个一样的Demo作为比较，更能直观的对比Vue前后端的渲染。\x3cbr\x3e话不多说，我们分别来看两个Demo:（欢迎star 欢迎pull request）\x3c\/p\x3e\n\x3cp\x3e1.浏览器端渲染Demo: \x3ca href=\x22https:\/\/github.com\/monkeyWangs\/doubanMovie\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/monkeyWang...\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e2.服务端渲染Demo:\x3ca href=\x22https:\/\/github.com\/monkeyWangs\/doubanMovie-SSR\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/monkeyWang...\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e两套代码运行结果都是为了展示豆瓣电影的，运行效果也都是差不多，下面我们来分别简单的阐述一下项目的机理：\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e一、浏览器端渲染豆瓣电影\x3c\/h2\x3e\n\x3cp\x3e首先我们用官网的脚手架搭建起来一个vue项目\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22npm install -g vue-cli\nvue init webpack doubanMovie\ncd doubanMovie\nnpm install\nnpm run dev\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-built_in\x22\x3enpm\x3c\/span\x3e install -g vue-cli\nvue init webpack doubanMovie\ncd doubanMovie\n\x3cspan class=\x22hljs-built_in\x22\x3enpm\x3c\/span\x3e install\n\x3cspan class=\x22hljs-built_in\x22\x3enpm\x3c\/span\x3e run dev\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样便可以简单地打起来一个cli框架，下面我们要做的事情就是分别配置 vue-router, vuex,然后配置我们的webpack proxyTable 让他支持代理访问豆瓣API。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e1.配置Vue-router\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e我们需要三个导航页：正在上映、即将上映、Top250；一个详情页，一个搜索页。这里我给他们分别配置了各自的路由。在 router\/index.js 下配置以下信息：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import Vue from \x27vue\x27\nimport Router from \x27vue-router\x27\nimport Moving from \x27@\/components\/moving\x27\nimport Upcoming from \x27@\/components\/upcoming\x27\nimport Top250 from \x27@\/components\/top250\x27\nimport MoviesDetail from \x27@\/components\/common\/moviesDetail\x27\n\nimport Search from \x27@\/components\/searchList\x27\n\nVue.use(Router)\n\/**\n * 路由信息配置\n *\/\nexport default new Router({\n  routes: [\n    {\n      path: \x27\/\x27,\n      name: \x27Moving\x27,\n      component: Moving\n    },\n    {\n      path: \x27\/upcoming\x27,\n      name: \x27upcoming\x27,\n      component: Upcoming\n    },\n    {\n      path: \x27\/top250\x27,\n      name: \x27Top250\x27,\n      component: Top250\n    },\n    {\n      path: \x27\/search\x27,\n      name: \x27Search\x27,\n      component: Search\n    },\n    {\n      path: \x27\/moviesDetail\x27,\n      name: \x27moviesDetail\x27,\n      component: MoviesDetail\n    }\n\n  ]\n})\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e Vue \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27vue\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e Router \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27vue-router\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e Moving \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27@\/components\/moving\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e Upcoming \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27@\/components\/upcoming\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e Top250 \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27@\/components\/top250\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e MoviesDetail \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27@\/components\/common\/moviesDetail\x27\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e Search \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27@\/components\/searchList\x27\x3c\/span\x3e\n\nVue.use(Router)\n\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * 路由信息配置\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Router({\n  \x3cspan class=\x22hljs-attr\x22\x3eroutes\x3c\/span\x3e: [\n    {\n      \x3cspan class=\x22hljs-attr\x22\x3epath\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27\/\x27\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Moving\x27\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-attr\x22\x3ecomponent\x3c\/span\x3e: Moving\n    },\n    {\n      \x3cspan class=\x22hljs-attr\x22\x3epath\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27\/upcoming\x27\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27upcoming\x27\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-attr\x22\x3ecomponent\x3c\/span\x3e: Upcoming\n    },\n    {\n      \x3cspan class=\x22hljs-attr\x22\x3epath\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27\/top250\x27\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Top250\x27\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-attr\x22\x3ecomponent\x3c\/span\x3e: Top250\n    },\n    {\n      \x3cspan class=\x22hljs-attr\x22\x3epath\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27\/search\x27\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Search\x27\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-attr\x22\x3ecomponent\x3c\/span\x3e: Search\n    },\n    {\n      \x3cspan class=\x22hljs-attr\x22\x3epath\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27\/moviesDetail\x27\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27moviesDetail\x27\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-attr\x22\x3ecomponent\x3c\/span\x3e: MoviesDetail\n    }\n\n  ]\n})\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样我们的路由信息配置好了，然后每次切换路由的时候，尽量避免不要重复请求数据，所以我们还需要配置一下组件的keep-alive：在app.vue组件里面。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3ckeep-alive exclude=\x26quot;moviesDetail\x26quot;\x3e\n   \x3crouter-view\x3e\x3c\/router-view\x3e\n\x3c\/keep-alive\x3e\n这样一个基本的vue-router就配置好了。\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs xml\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ekeep-alive\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eexclude\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22moviesDetail\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n   \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3erouter-view\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3erouter-view\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ekeep-alive\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n这样一个基本的vue-router就配置好了。\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e2.引入vuex\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3eVuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。\x3c\/p\x3e\n\x3cp\x3e简而言之：Vuex 相当于某种意义上设置了读写权限的全局变量，将数据保存保存到该“全局变量”下，并通过一定的方法去读写数据。\x3c\/p\x3e\n\x3cp\x3eVuex 并不限制你的代码结构。但是，它规定了一些需要遵守的规则：\x3c\/p\x3e\n\x3cp\x3e应用层级的状态应该集中到单个 store 对象中。\x3c\/p\x3e\n\x3cp\x3e提交 mutation 是更改状态的唯一方法，并且这个过程是同步的。\x3c\/p\x3e\n\x3cp\x3e异步逻辑都应该封装到 action 里面。\x3c\/p\x3e\n\x3cp\x3e对于大型应用我们会希望把 Vuex 相关代码分割到模块中。下面是项目结构示例：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22├── index.html\n├── main.js\n├── api\n│   └── ... # 抽取出API请求\n├── components\n│   ├── App.vue\n│   └── ...\n└── store\n    ├── index.js          # 我们组装模块并导出 store 的地方\n    └── moving            # 电影模块\n        ├── index.js      # 模块内组装，并导出模块的地方\n        ├── actions.js    # 模块基本 action\n        ├── getters.js    # 模块级别 getters\n        ├── mutations.js  # 模块级别 mutations\n        └── types.js      # 模块级别 types\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs mipsasm\x22\x3e\x3ccode\x3e├── index.html\n├── main.\x3cspan class=\x22hljs-keyword\x22\x3ejs\n\x3c\/span\x3e├── api\n│   └── ... \x3cspan class=\x22hljs-comment\x22\x3e# 抽取出API请求\x3c\/span\x3e\n├── components\n│   ├── App.vue\n│   └── ...\n└── store\n    ├── index.\x3cspan class=\x22hljs-keyword\x22\x3ejs \x3c\/span\x3e         \x3cspan class=\x22hljs-comment\x22\x3e# 我们组装模块并导出 store 的地方\x3c\/span\x3e\n    └── moving            \x3cspan class=\x22hljs-comment\x22\x3e# 电影模块\x3c\/span\x3e\n        ├── index.\x3cspan class=\x22hljs-keyword\x22\x3ejs \x3c\/span\x3e     \x3cspan class=\x22hljs-comment\x22\x3e# 模块内组装，并导出模块的地方\x3c\/span\x3e\n        ├── actions.\x3cspan class=\x22hljs-keyword\x22\x3ejs \x3c\/span\x3e   \x3cspan class=\x22hljs-comment\x22\x3e# 模块基本 action\x3c\/span\x3e\n        ├── getters.\x3cspan class=\x22hljs-keyword\x22\x3ejs \x3c\/span\x3e   \x3cspan class=\x22hljs-comment\x22\x3e# 模块级别 getters\x3c\/span\x3e\n        ├── mutations.\x3cspan class=\x22hljs-keyword\x22\x3ejs \x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e# 模块级别 mutations\x3c\/span\x3e\n        └── types.\x3cspan class=\x22hljs-keyword\x22\x3ejs \x3c\/span\x3e     \x3cspan class=\x22hljs-comment\x22\x3e# 模块级别 types\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e所以我们开始在我们的src目录下新建一个名为store 的文件夹 为了后期考虑 我们新建了moving 文件夹，用来组织电影，考虑到所有的action,getters,mutations,都写在一起，文件太混乱，所以我又给他们分别提取出来。\x3c\/p\x3e\n\x3cp\x3estroe文件夹建好，我们要开始在main.js里面引用vuex实例：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import store from \x27.\/store\x27\nnew Vue({\n  el: \x27#app\x27,\n  router,\n  store,\n  template: \x27\x3cApp\/\x3e\x27,\n  components: { App }\n})\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs arduino\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e store from \x3cspan class=\x22hljs-string\x22\x3e\x27.\/store\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Vue({\n  el: \x3cspan class=\x22hljs-string\x22\x3e\x27#app\x27\x3c\/span\x3e,\n  router,\n  store,\n  \x3cspan class=\x22hljs-keyword\x22\x3etemplate\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27\x26lt;App\/\x26gt;\x27\x3c\/span\x3e,\n  components: { App }\n})\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样，我们便可以在所有的子组件里通过 this.$store 来使用vuex了。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e3.webpack proxyTable 代理跨域\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3ewebpack 开发环境可以使用proxyTable 来代理跨域，生产环境的话可以根据各自的服务器进行配置代理跨域就行了。在我们的项目config\/index.js 文件下可以看到有一个proxyTable的属性，我们对其简单的改写\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22proxyTable: {\n      \x27\/api\x27: {\n        target: \x27http:\/\/api.douban.com\/v2\x27,\n        changeOrigin: true,\n        pathRewrite: {\n          \x27^\/api\x27: \x27\x27\n        }\n      }\n    }\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs less\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-attribute\x22\x3eproxyTable\x3c\/span\x3e: {\n      \x3cspan class=\x22hljs-string\x22\x3e\x27\/api\x27\x3c\/span\x3e: {\n        \x3cspan class=\x22hljs-attribute\x22\x3etarget\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27http:\/\/api.douban.com\/v2\x27\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attribute\x22\x3echangeOrigin\x3c\/span\x3e: true,\n        \x3cspan class=\x22hljs-attribute\x22\x3epathRewrite\x3c\/span\x3e: {\n          \x3cspan class=\x22hljs-string\x22\x3e\x27^\/api\x27\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e\n        }\n      }\n    }\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样当我们访问\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22localhost:8080\/api\/movie\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs dts\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-symbol\x22\x3elocalhost:\x3c\/span\x3e\x3cspan class=\x22hljs-number\x22\x3e8080\x3c\/span\x3e\x3cspan class=\x22hljs-meta-keyword\x22\x3e\/api\/\x3c\/span\x3emovie\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e的时候 其实我们访问的是\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22http:\/\/api.douban.com\/v2\/movie\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs armasm\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-symbol\x22\x3ehttp\x3c\/span\x3e:\/\/api.douban.com\/\x3cspan class=\x22hljs-built_in\x22\x3ev2\x3c\/span\x3e\/\x3cspan class=\x22hljs-keyword\x22\x3emovie\n\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样便达到了一种跨域请求的方案。\x3c\/p\x3e\n\x3cp\x3e至此，浏览器端的主要配置已经介绍完了，下面我们来看看运行的结果：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVK4ad?w=4544\x26amp;h=3028\x22 src=\x22https:\/\/static.alili.tech\/img\/bVK4ad?w=4544\x26amp;h=3028\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e为了介绍浏览器渲染是怎么回事，我们运行一下\x3ccode\x3enpm run build\x3c\/code\x3e 看看我们的发布版本的文件，到底是什么鬼东西....\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3erun build\x3c\/code\x3e 后会都出一个dist目录 ，我们可以看到里面有个index.html，这个便是我们最终页面将要展示的html，我们打开，可以看到下面：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVK4bs?w=600\x26amp;h=286\x22 src=\x22https:\/\/static.alili.tech\/img\/bVK4bs?w=600\x26amp;h=286\x22 alt=\x22v2-e62449d29c714b7161301469cc2a68cc_b.png\x22 title=\x22v2-e62449d29c714b7161301469cc2a68cc_b.png\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e观察好的小伙伴可以发现，我们并没有多余的dom元素，就只有一个div，那么页面要怎么呈现呢？答案是js append，对，下面的那些js会负责innerHTML。而js是由浏览器解释执行的，所以呢，我们称之为浏览器渲染，这有几个致命的缺点：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22**1.js放在dom结尾，如果js文件过大，那么必然造成页面阻塞。用户体验明显不好（这也是我我在公司反复被产品逼问的事情）**\n\n**2.不利于SEO**\n\n**3.客户端运行在老的JavaScript引擎上**\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs asciidoc\x22\x3e\x3ccode\x3e*\x3cspan class=\x22hljs-strong\x22\x3e*1.js放在dom结尾，如果js文件过大，那么必然造成页面阻塞。用户体验明显不好（这也是我我在公司反复被产品逼问的事情）*\x3c\/span\x3e*\n\n*\x3cspan class=\x22hljs-strong\x22\x3e*2.不利于SEO*\x3c\/span\x3e*\n\n*\x3cspan class=\x22hljs-strong\x22\x3e*3.客户端运行在老的JavaScript引擎上*\x3c\/span\x3e*\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e对于世界上的一些地区人，可能只能用1998年产的电脑访问互联网的方式使用计算机。而Vue只能运行在IE9以上的浏览器，你可能也想为那些老式浏览器提供基础内容 - 或者是在命令行中使用 Lynx的时髦的黑客\x3c\/p\x3e\n\x3cp\x3e基于以上的一些问题，服务端渲染呼之欲出....\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e二、服务器端渲染豆瓣电影\x3c\/h2\x3e\n\x3cp\x3e先看一张Vue官网的服务端渲染示意图\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVK4bE?w=600\x26amp;h=275\x22 src=\x22https:\/\/static.alili.tech\/img\/bVK4bE?w=600\x26amp;h=275\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e从图上可以看出，ssr 有两个入口文件，client.js 和 server.js， 都包含了应用代码，webpack 通过两个入口文件分别打包成给服务端用的 server bundle 和给客户端用的 client bundle. 当服务器接收到了来自客户端的请求之后，会创建一个渲染器 bundleRenderer，这个 bundleRenderer 会读取上面生成的 server bundle 文件，并且执行它的代码， 然后发送一个生成好的 html 到浏览器，等到客户端加载了 client bundle 之后，会和服务端生成的DOM 进行 Hydration(判断这个DOM 和自己即将生成的DOM 是否相同，如果相同就将客户端的vue实例挂载到这个DOM上， 否则会提示警告)。\x3c\/p\x3e\n\x3cp\x3e具体实现：\x3c\/p\x3e\n\x3cp\x3e我们需要vuex，需要router，需要服务器，需要服务缓存，需要代理跨域....不急我们慢慢来。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e1.建立nodejs服务\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e首先我们需要一个服务器，那么对于nodejs，express是很好地选择。我们来建立一个server.js\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const port = process.env.PORT || 8080\napp.listen(port, () =\x3e {\n  console.log(`server started at localhost:${port}`)\n})\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e port = process.env.PORT || \x3cspan class=\x22hljs-number\x22\x3e8080\x3c\/span\x3e\napp.listen(port, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e`server started at localhost:\x3cspan class=\x22hljs-subst\x22\x3e${port}\x3c\/span\x3e`\x3c\/span\x3e)\n})\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里用来启动服务监听 8080 端口。\x3c\/p\x3e\n\x3cp\x3e然后我们开始处理所有的get请求，当请求页面的时候，我们需要渲染页面\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22app.get(\x27*\x27, (req, res) =\x3e {\n  if (!renderer) {\n    return res.end(\x27waiting for compilation... refresh in a moment.\x27)\n  }\n\n  const s = Date.now()\n\n  res.setHeader(\x26quot;Content-Type\x26quot;, \x26quot;text\/html\x26quot;)\n  res.setHeader(\x26quot;Server\x26quot;, serverInfo)\n\n  const errorHandler = err =\x3e {\n    if (err \x26amp;\x26amp; err.code === 404) {\n      res.status(404).end(\x27404 | Page Not Found\x27)\n    } else {\n      \/\/ Render Error Page or Redirect\n      res.status(500).end(\x27500 | Internal Server Error\x27)\n      console.error(`error during render : ${req.url}`)\n      console.error(err)\n    }\n  }\n\n  renderer.renderToStream({ url: req.url })\n    .on(\x27error\x27, errorHandler)\n    .on(\x27end\x27, () =\x3e console.log(`whole request: ${Date.now() - s}ms`))\n    .pipe(res)\n})\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3eapp.get(\x3cspan class=\x22hljs-string\x22\x3e\x27*\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3ereq, res\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!renderer) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e res.end(\x3cspan class=\x22hljs-string\x22\x3e\x27waiting for compilation... refresh in a moment.\x27\x3c\/span\x3e)\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e s = \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e.now()\n\n  res.setHeader(\x3cspan class=\x22hljs-string\x22\x3e\x22Content-Type\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22text\/html\x22\x3c\/span\x3e)\n  res.setHeader(\x3cspan class=\x22hljs-string\x22\x3e\x22Server\x22\x3c\/span\x3e, serverInfo)\n\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e errorHandler = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (err \x26amp;\x26amp; err.code === \x3cspan class=\x22hljs-number\x22\x3e404\x3c\/span\x3e) {\n      res.status(\x3cspan class=\x22hljs-number\x22\x3e404\x3c\/span\x3e).end(\x3cspan class=\x22hljs-string\x22\x3e\x27404 | Page Not Found\x27\x3c\/span\x3e)\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Render Error Page or Redirect\x3c\/span\x3e\n      res.status(\x3cspan class=\x22hljs-number\x22\x3e500\x3c\/span\x3e).end(\x3cspan class=\x22hljs-string\x22\x3e\x27500 | Internal Server Error\x27\x3c\/span\x3e)\n      \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.error(\x3cspan class=\x22hljs-string\x22\x3e`error during render : \x3cspan class=\x22hljs-subst\x22\x3e${req.url}\x3c\/span\x3e`\x3c\/span\x3e)\n      \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.error(err)\n    }\n  }\n\n  renderer.renderToStream({ url: req.url })\n    .on(\x3cspan class=\x22hljs-string\x22\x3e\x27error\x27\x3c\/span\x3e, errorHandler)\n    .on(\x3cspan class=\x22hljs-string\x22\x3e\x27end\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e`whole request: \x3cspan class=\x22hljs-subst\x22\x3e${Date.now() - s}\x3c\/span\x3ems`\x3c\/span\x3e))\n    .pipe(res)\n})\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e然后我们需要代理请求，这样才能进行跨域，我们引入\x3ccode\x3ehttp-proxy-middleware\x3c\/code\x3e模块：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const proxy = require(\x27http-proxy-middleware\x27);\/\/引入代理中间件\n\/**\n * proxy middleware options\n * 代理跨域配置\n * @type \x22{{\x22target: string, changeOrigin: boolean, pathRewrite: {^\/api: string\x22}}\x22}\n *\/\nvar options = {\n  target: \x27http:\/\/api.douban.com\/v2\x27, \/\/ target host\n  changeOrigin: true,               \/\/ needed for virtual hosted sites\n  pathRewrite: {\n    \x27^\/api\x27: \x27\x27\n  }\n};\n\nvar exampleProxy = proxy(options);\napp.use(\x27\/api\x27, exampleProxy);\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs php\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e proxy = \x3cspan class=\x22hljs-keyword\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27http-proxy-middleware\x27\x3c\/span\x3e);\x3cspan class=\x22hljs-comment\x22\x3e\/\/引入代理中间件\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * proxy middleware options\n * 代理跨域配置\n * \x3cspan class=\x22hljs-doctag\x22\x3e@type\x3c\/span\x3e \x22{{\x22target: string, changeOrigin: boolean, pathRewrite: {^\/api: string\x22}}\x22}\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e options = {\n  target: \x3cspan class=\x22hljs-string\x22\x3e\x27http:\/\/api.douban.com\/v2\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ target host\x3c\/span\x3e\n  changeOrigin: \x3cspan class=\x22hljs-keyword\x22\x3etrue\x3c\/span\x3e,               \x3cspan class=\x22hljs-comment\x22\x3e\/\/ needed for virtual hosted sites\x3c\/span\x3e\n  pathRewrite: {\n    \x3cspan class=\x22hljs-string\x22\x3e\x27^\/api\x27\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e\n  }\n};\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e exampleProxy = proxy(options);\napp.\x3cspan class=\x22hljs-keyword\x22\x3euse\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27\/api\x27\x3c\/span\x3e, exampleProxy);\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样我们的服务端server.js便配置完成。接下来 我们需要配置服务端入口文件，还有客户端入口文件，首先来配置一下客户端文件，新建src\/entry-client.js\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import \x27es6-promise\/auto\x27\nimport { app, store, router } from \x27.\/app\x27\n\n\/\/ prime the store with server-initialized state.\n\/\/ the state is determined during SSR and inlined in the page markup.\nif (window.__INITIAL_STATE__) {\n  store.replaceState(window.__INITIAL_STATE__)\n}\n\n\/**\n * 异步组件\n *\/\nrouter.onReady(() =\x3e {\n  \/\/ 开始挂载到dom上\n  app.$mount(\x27#app\x27)\n})\n\n\/\/ service worker\nif (process.env.NODE_ENV === \x27production\x27 \x26amp;\x26amp; \x27serviceWorker\x27 in navigator) {\n  navigator.serviceWorker.register(\x27\/service-worker.js\x27)\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27es6-promise\/auto\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { app, store, router } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/app\x27\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ prime the store with server-initialized state.\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ the state is determined during SSR and inlined in the page markup.\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.__INITIAL_STATE__) {\n  store.replaceState(\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.__INITIAL_STATE__)\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * 异步组件\n *\/\x3c\/span\x3e\nrouter.onReady(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 开始挂载到dom上\x3c\/span\x3e\n  app.$mount(\x3cspan class=\x22hljs-string\x22\x3e\x27#app\x27\x3c\/span\x3e)\n})\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ service worker\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (process.env.NODE_ENV === \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e \x26amp;\x26amp; \x3cspan class=\x22hljs-string\x22\x3e\x27serviceWorker\x27\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e navigator) {\n  navigator.serviceWorker.register(\x3cspan class=\x22hljs-string\x22\x3e\x27\/service-worker.js\x27\x3c\/span\x3e)\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e客户端入口文件很简单，同步服务端发送过来的数据，然后把 vue 实例挂载到服务端渲染的 DOM 上。\x3c\/p\x3e\n\x3cp\x3e再配置一下服务端入口文件：src\/entry-server.js\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import { app, router, store } from \x27.\/app\x27\n\nconst isDev = process.env.NODE_ENV !== \x27production\x27\n\n\/\/ This exported function will be called by `bundleRenderer`.\n\/\/ This is where we perform data-prefetching to determine the\n\/\/ state of our application before actually rendering it.\n\/\/ Since data fetching is async, this function is expected to\n\/\/ return a Promise that resolves to the app instance.\nexport default context =\x3e {\n  const s = isDev \x26amp;\x26amp; Date.now()\n\n  return new Promise((resolve, reject) =\x3e {\n    \/\/ set router\x27s location\n    router.push(context.url)\n\n    \/\/ wait until router has resolved possible async hooks\n    router.onReady(() =\x3e {\n      const matchedComponents = router.getMatchedComponents()\n      \/\/ no matched routes\n      if (!matchedComponents.length) {\n        reject({ code: 404 })\n      }\n      \/\/ Call preFetch hooks on components matched by the route.\n      \/\/ A preFetch hook dispatches a store action and returns a Promise,\n      \/\/ which is resolved when the action is complete and store state has been\n      \/\/ updated.\n      Promise.all(matchedComponents.map(component =\x3e {\n        return component.preFetch \x26amp;\x26amp; component.preFetch(store)\n      })).then(() =\x3e {\n        isDev \x26amp;\x26amp; console.log(`data pre-fetch: ${Date.now() - s}ms`)\n        \/\/ After all preFetch hooks are resolved, our store is now\n        \/\/ filled with the state needed to render the app.\n        \/\/ Expose the state on the render context, and let the request handler\n        \/\/ inline the state in the HTML response. This allows the client-side\n        \/\/ store to pick-up the server-side state without having to duplicate\n        \/\/ the initial data fetching on the client.\n        context.state = store.state\n        resolve(app)\n      }).catch(reject)\n    })\n  })\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { app, router, store } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/app\x27\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e isDev = process.env.NODE_ENV !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ This exported function will be called by `bundleRenderer`.\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ This is where we perform data-prefetching to determine the\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ state of our application before actually rendering it.\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Since data fetching is async, this function is expected to\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ return a Promise that resolves to the app instance.\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e context =\x26gt; {\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e s = isDev \x26amp;\x26amp; \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e.now()\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve, reject\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ set router\x27s location\x3c\/span\x3e\n    router.push(context.url)\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ wait until router has resolved possible async hooks\x3c\/span\x3e\n    router.onReady(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e matchedComponents = router.getMatchedComponents()\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ no matched routes\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!matchedComponents.length) {\n        reject({ \x3cspan class=\x22hljs-attr\x22\x3ecode\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e404\x3c\/span\x3e })\n      }\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Call preFetch hooks on components matched by the route.\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ A preFetch hook dispatches a store action and returns a Promise,\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ which is resolved when the action is complete and store state has been\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ updated.\x3c\/span\x3e\n      \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.all(matchedComponents.map(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3ecomponent\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e component.preFetch \x26amp;\x26amp; component.preFetch(store)\n      })).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n        isDev \x26amp;\x26amp; \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e`data pre-fetch: \x3cspan class=\x22hljs-subst\x22\x3e${\x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e.now() - s}\x3c\/span\x3ems`\x3c\/span\x3e)\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ After all preFetch hooks are resolved, our store is now\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ filled with the state needed to render the app.\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Expose the state on the render context, and let the request handler\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ inline the state in the HTML response. This allows the client-side\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ store to pick-up the server-side state without having to duplicate\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ the initial data fetching on the client.\x3c\/span\x3e\n        context.state = store.state\n        resolve(app)\n      }).catch(reject)\n    })\n  })\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eserver.js 返回一个函数，该函数接受一个从服务端传递过来的 context 的参数，将 vue 实例通过 promise 返回。context 一般包含 当前页面的url，首先我们调用 vue-router 的 router.push(url) 切换到到对应的路由， 然后调用 getMatchedComponents 方法返回对应要渲染的组件， 这里会检查组件是否有 fetchServerData 方法，如果有就会执行它。\x3c\/p\x3e\n\x3cp\x3e下面这行代码将服务端获取到的数据挂载到 context 对象上，后面会把这些数据直接发送到浏览器端与客户端的vue 实例进行数据(状态)同步。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22context.state = store.state\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs pf\x22\x3e\x3ccode\x3econtext.\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e = store.\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e然后我们分别配置客户端和服务端webpack，这里可以在我的github上fork下来参考配置，里面每一步都有注释，这里不再赘述。\x3c\/p\x3e\n\x3cp\x3e接着我们需要创建app.js:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import Vue from \x27vue\x27\nimport App from \x27.\/App.vue\x27\nimport store from \x27.\/store\x27\nimport router from \x27.\/router\x27\nimport { sync } from \x27vuex-router-sync\x27\nimport Element from \x27element-ui\x27\nVue.use(Element)\n\n\/\/ sync the router with the vuex store.\n\/\/ this registers `store.state.route`\nsync(store, router)\n\n\/**\n * 创建vue实例\n * 在这里注入 router  store 到所有的子组件\n * 这样就可以在任何地方使用 `this.$router` and `this.$store`\n * @type {Vue$2}\n *\/\nconst app = new Vue({\n  router,\n  store,\n  render: h =\x3e h(App)\n})\n\n\/**\n * 导出 router and store.\n * 在这里不需要挂载到app上。这里和浏览器渲染不一样\n *\/\nexport { app, router, store }\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e Vue \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27vue\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e App \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/App.vue\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e store \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/store\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e router \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/router\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { sync } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27vuex-router-sync\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e Element \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27element-ui\x27\x3c\/span\x3e\nVue.use(Element)\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ sync the router with the vuex store.\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ this registers `store.state.route`\x3c\/span\x3e\nsync(store, router)\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * 创建vue实例\n * 在这里注入 router  store 到所有的子组件\n * 这样就可以在任何地方使用 `this.$router` and `this.$store`\n * @type {Vue$2}\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e app = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Vue({\n  router,\n  store,\n  \x3cspan class=\x22hljs-attr\x22\x3erender\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eh\x3c\/span\x3e =\x26gt;\x3c\/span\x3e h(App)\n})\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * 导出 router and store.\n * 在这里不需要挂载到app上。这里和浏览器渲染不一样\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e { app, router, store }\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样 服务端入口文件和客户端入口文件便有了一个公共实例Vue, 和我们以前写的vue实例差别不大，但是我们不会在这里将app mount到DOM上，因为这个实例也会在服务端去运行，这里直接将 app 暴露出去。\x3c\/p\x3e\n\x3cp\x3e接下来创建路由router，创建vuex跟客户端都差不多。详细的可以参考我的项目...\x3c\/p\x3e\n\x3cp\x3e到此，服务端渲染配置 就简单介绍完了，下面我们启动项目简单的看下：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVK39C?w=1200\x26amp;h=872\x22 src=\x22https:\/\/static.alili.tech\/img\/bVK39C?w=1200\x26amp;h=872\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3cbr\x3e这里跟服务端界面一样，不一样的是url已经不是之前的 #\/而变成了请求形式 \/\x3c\/p\x3e\n\x3cp\x3e这样每当浏览器发送一个页面的请求，会有服务器渲染出一个dom字符串返回，直接在浏览器段显示，这样就避免了浏览器端渲染的很多问题。\x3c\/p\x3e\n\x3cp\x3e说起SSR，其实早在SPA (Single Page Application) 出现之前，网页就是在服务端渲染的。服务器接收到客户端请求后，将数据和模板拼接成完整的页面响应到客户端。 客户端直接渲染， 此时用户希望浏览新的页面，就必须重复这个过程， 刷新页面. 这种体验在Web技术发展的当下是几乎不能被接受的，于是越来越多的技术方案涌现，力求 实现无页面刷新或者局部刷新来达到优秀的交互体验。但是SEO却是致命的，所以一切看应用场景，这里只为大家提供技术思路，为vue开发提供多一种可能的方案。\x3cbr\x3e最后再加一下前后端渲染build后 把netWork切到3G网络下进行响应对比：\x3cbr\x3e先看看浏览器端：加载dom页面花了大约800s\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVK71o?w=1948\x26amp;h=1148\x22 src=\x22https:\/\/static.alili.tech\/img\/bVK71o?w=1948\x26amp;h=1148\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e在对比一下服务端渲染：加载dom页面只花了8ms 整整快了10倍，用户可能在网络比较慢的情况下从远处访问网站 - 或者通过比较差的带宽。 这些情况下，尽量减少页面请求数量，来保证用户尽快看到基本的内容。\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVK71M?w=1946\x26amp;h=1140\x22 src=\x22https:\/\/static.alili.tech\/img\/bVK71M?w=1946\x26amp;h=1140\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e补充一下一：一般高复杂度项目都会使用webpack的拆分，实现异步组件，按需加载，这样可以有效提高时间。二：服务器渲染如此快有部分原因来自serviceworker，但是排除这部分，还是比浏览器端要快至少几倍。 当然，我们可以考虑首屏采用服务端渲染的方式，因为完全服务端渲染会考虑到很多问题，比如复杂均衡等等等\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>实例PK(Vue服务端渲染 VS Vue浏览器端渲染)</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000008795113">https://segmentfault.com/a/1190000008795113</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/pxnyrmaug3t/" target="_blank">https://alili.tech/archive/pxnyrmaug3t/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>