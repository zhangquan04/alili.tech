<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="高仿腾讯QQ Xplan（X计划）的H5页面（2）：动画控制"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>高仿腾讯QQ Xplan（X计划）的H5页面（2）：动画控制 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/ylh7ujztqle/",
				"appid": "1613049289050283", 
				"title": "高仿腾讯QQ Xplan（X计划）的H5页面（2）：动画控制 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-13T02:30:11"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/qs56jjusz2/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/r7bch07pkkf/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fylh7ujztqle%2f&text=%e9%ab%98%e4%bb%bf%e8%85%be%e8%ae%afQQ%20Xplan%ef%bc%88X%e8%ae%a1%e5%88%92%ef%bc%89%e7%9a%84H5%e9%a1%b5%e9%9d%a2%ef%bc%882%ef%bc%89%ef%bc%9a%e5%8a%a8%e7%94%bb%e6%8e%a7%e5%88%b6"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fylh7ujztqle%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fylh7ujztqle%2f&text=%e9%ab%98%e4%bb%bf%e8%85%be%e8%ae%afQQ%20Xplan%ef%bc%88X%e8%ae%a1%e5%88%92%ef%bc%89%e7%9a%84H5%e9%a1%b5%e9%9d%a2%ef%bc%882%ef%bc%89%ef%bc%9a%e5%8a%a8%e7%94%bb%e6%8e%a7%e5%88%b6"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fylh7ujztqle%2f&title=%e9%ab%98%e4%bb%bf%e8%85%be%e8%ae%afQQ%20Xplan%ef%bc%88X%e8%ae%a1%e5%88%92%ef%bc%89%e7%9a%84H5%e9%a1%b5%e9%9d%a2%ef%bc%882%ef%bc%89%ef%bc%9a%e5%8a%a8%e7%94%bb%e6%8e%a7%e5%88%b6"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fylh7ujztqle%2f&is_video=false&description=%e9%ab%98%e4%bb%bf%e8%85%be%e8%ae%afQQ%20Xplan%ef%bc%88X%e8%ae%a1%e5%88%92%ef%bc%89%e7%9a%84H5%e9%a1%b5%e9%9d%a2%ef%bc%882%ef%bc%89%ef%bc%9a%e5%8a%a8%e7%94%bb%e6%8e%a7%e5%88%b6"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e9%ab%98%e4%bb%bf%e8%85%be%e8%ae%afQQ%20Xplan%ef%bc%88X%e8%ae%a1%e5%88%92%ef%bc%89%e7%9a%84H5%e9%a1%b5%e9%9d%a2%ef%bc%882%ef%bc%89%ef%bc%9a%e5%8a%a8%e7%94%bb%e6%8e%a7%e5%88%b6&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fylh7ujztqle%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fylh7ujztqle%2f&title=%e9%ab%98%e4%bb%bf%e8%85%be%e8%ae%afQQ%20Xplan%ef%bc%88X%e8%ae%a1%e5%88%92%ef%bc%89%e7%9a%84H5%e9%a1%b5%e9%9d%a2%ef%bc%882%ef%bc%89%ef%bc%9a%e5%8a%a8%e7%94%bb%e6%8e%a7%e5%88%b6"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fylh7ujztqle%2f&title=%e9%ab%98%e4%bb%bf%e8%85%be%e8%ae%afQQ%20Xplan%ef%bc%88X%e8%ae%a1%e5%88%92%ef%bc%89%e7%9a%84H5%e9%a1%b5%e9%9d%a2%ef%bc%882%ef%bc%89%ef%bc%9a%e5%8a%a8%e7%94%bb%e6%8e%a7%e5%88%b6"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fylh7ujztqle%2f&title=%e9%ab%98%e4%bb%bf%e8%85%be%e8%ae%afQQ%20Xplan%ef%bc%88X%e8%ae%a1%e5%88%92%ef%bc%89%e7%9a%84H5%e9%a1%b5%e9%9d%a2%ef%bc%882%ef%bc%89%ef%bc%9a%e5%8a%a8%e7%94%bb%e6%8e%a7%e5%88%b6"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fylh7ujztqle%2f&title=%e9%ab%98%e4%bb%bf%e8%85%be%e8%ae%afQQ%20Xplan%ef%bc%88X%e8%ae%a1%e5%88%92%ef%bc%89%e7%9a%84H5%e9%a1%b5%e9%9d%a2%ef%bc%882%ef%bc%89%ef%bc%9a%e5%8a%a8%e7%94%bb%e6%8e%a7%e5%88%b6"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">高仿腾讯QQ Xplan（X计划）的H5页面（2）：动画控制</h1><div class="meta"><div class="postdate"><time datetime="2019-01-13" itemprop="datePublished">2019-01-13</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000009667320\x22\x3e上一篇\x3c\/a\x3e知道如何制作threejs地球之后，就正式coding了，当然还是使用最心爱的Vue。本篇会有一些代码，但是都是十几行的独立片段，相信你不用担心。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e布局\x3c\/h2\x3e\n\x3cp\x3e在进入本篇主题前，要简单看一下xplan中的自适应解决方案，即如何在不同尺寸设备中，都保证地球最合适的大小和位置，并且与其配套的一些图片（虚线的椭圆轨道、正中心白色的圆环等）都不会显示的错位。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22http:\/\/ofkyhrvda.bkt.clouddn.com\/post\/image\/o_1bhtj1nndhok1r1918ba1tclu07r.jpeg\x22 src=\x22https:\/\/static.alili.techhttp:\/\/ofkyhrvda.bkt.clouddn.com\/post\/image\/o_1bhtj1nndhok1r1918ba1tclu07r.jpeg\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3explan用的方式简单直接，固定大小内作布局，然后针对不同的设备尺寸进行缩放。\x3c\/p\x3e\n\x3cp\x3e固定画布大小（375 * 600），所有和地球相关的元素都可以在这个范围内绝对定位，之后scale一下，保证在设备实际尺寸中是被包含（contain）的。这种方式比REM等其他的自适应方式更适合这个项目，毕竟threejs中不能使用REM单位。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22http:\/\/ofkyhrvda.bkt.clouddn.com\/post\/image\/o_1bhtjns3m1858cnf55213ti1o591f.jpeg\x22 src=\x22https:\/\/static.alili.techhttp:\/\/ofkyhrvda.bkt.clouddn.com\/post\/image\/o_1bhtjns3m1858cnf55213ti1o591f.jpeg\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e感谢Vue，我得以将上面这个自行缩放的逻辑写成一个\x3ca href=\x22https:\/\/github.com\/JackGit\/xplan\/blob\/master\/src\/components\/Page.vue\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ePage组件\x3c\/a\x3e，之后再也不用操心布局问题了。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e动画\x3c\/h2\x3e\n\x3cp\x3explan中的动画是最吸引我的地方，特别是地球放大，穿越云层的那一刻，想想还有点小激动。\x3c\/p\x3e\n\x3cp\x3e其实之前看到过一些项目有做从外太空俯冲进地球表面的动画，但是那些基本都是纯图片制作的SpriteSheet Animation，动画的前进后退控制都很容易。但xplan项目中则不同，动画过程中需要控制多个动画对象，还要配合其他资源（音频和视频）。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22http:\/\/ofkyhrvda.bkt.clouddn.com\/post\/image\/o_1bhti5m6pei11ntm1jcc35t1kl2h.gif\x22 src=\x22https:\/\/static.alili.techhttp:\/\/ofkyhrvda.bkt.clouddn.com\/post\/image\/o_1bhti5m6pei11ntm1jcc35t1kl2h.gif\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e分析\x3c\/h3\x3e\n\x3cp\x3explan中动画的逻辑是，在地球自转过程中，长按按钮，会依次发生：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e地球旋转到目的坐标\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e地球放大（相机推进）到该坐标\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e到足够近的时候，播放云层穿越动画\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e云层穿越结束后，展示对应坐标的视频内容\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e任何时刻松开长按按钮，动画都会回退到地球自转的状态\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e为了方便讨论，将上面分析到的动画阶段命名一下：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e地球自转过程：\x3cstrong\x3eidle\x3c\/strong\x3e阶段\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e地球转动到指定坐标的过程：\x3cstrong\x3erotating\x3c\/strong\x3e阶段\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e地球距离被拉近拉远的过程：\x3cstrong\x3ezooming\x3c\/strong\x3e阶段\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e穿越云层的过程：\x3cstrong\x3ediving\x3c\/strong\x3e阶段\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e云层过后的视频展示：\x3cstrong\x3epresenting\x3c\/strong\x3e阶段\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e具体分析几个过程：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22http:\/\/ofkyhrvda.bkt.clouddn.com\/post\/image\/o_1bhu3fcjn1778i4ibdo1gt61tm931.jpeg\x22 src=\x22https:\/\/static.alili.techhttp:\/\/ofkyhrvda.bkt.clouddn.com\/post\/image\/o_1bhu3fcjn1778i4ibdo1gt61tm931.jpeg\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e在idle阶段，只要touchstart，就算你只长按了0.1s，那么rotating的动画就会完整的触发，然后状态跳回idle（rotating没有反向旋转）。如上示意图。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22http:\/\/ofkyhrvda.bkt.clouddn.com\/post\/image\/o_1bhu3oqm91m1o15na4q7802bm93b.jpeg\x22 src=\x22https:\/\/static.alili.techhttp:\/\/ofkyhrvda.bkt.clouddn.com\/post\/image\/o_1bhu3oqm91m1o15na4q7802bm93b.jpeg\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e如果长按至了zooming阶段，松开手指之后，zooming动画会立刻反向播放，直至回到idle阶段。如上示意图。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22http:\/\/ofkyhrvda.bkt.clouddn.com\/post\/image\/o_1bhu2ruu4ki01vl41louu2n1f7s2n.jpeg\x22 src=\x22https:\/\/static.alili.techhttp:\/\/ofkyhrvda.bkt.clouddn.com\/post\/image\/o_1bhu2ruu4ki01vl41louu2n1f7s2n.jpeg\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e如果zooming过程松开手指后，但是在离开zooming阶段前再次按下去，那么zooming动画会再一次正向播放。如上示意图。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22http:\/\/ofkyhrvda.bkt.clouddn.com\/post\/image\/o_1bhu3rn2h2f55o6ir81bmg1rk13l.jpeg\x22 src=\x22https:\/\/static.alili.techhttp:\/\/ofkyhrvda.bkt.clouddn.com\/post\/image\/o_1bhu3rn2h2f55o6ir81bmg1rk13l.jpeg\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3ediving阶段貌似又回到了和rotating类似的行为，就算中途结束，也会完成当前阶段的动画。但是和rotating不一样的是，diving阶段是有反向动画的。因此可以看到上面的示意图。\x3c\/p\x3e\n\x3cp\x3e我在考虑的过程中，阴差阳错的误以为还有一个条件：即除了rotating阶段外，其他动画过程都可以随时进和退（上面的GIF就是我最终完成的动画控制）。这个给自己添加额外的难度，困扰了我很久。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e分步实现：地球\x3c\/h3\x3e\n\x3cp\x3e我创建了一个\x3ca href=\x22https:\/\/github.com\/JackGit\/xplan\/tree\/master\/src\/assets\/js\/earth\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eEarth类\x3c\/a\x3e，负责3D地球（包括光线，光晕，地表的云，浮动坐标点等）的创建和渲染，同时向外提供几个public方法：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3esetCameraPosition()\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3egetCameraPosition()\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3estartAutoRotation()\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3estopAutoRotation()\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e地球旋转到指定坐标点，其实就是设置camera的position来完成了。要有流畅动画的感觉，就使用\x3ca href=\x22https:\/\/www.npmjs.com\/package\/tween.js\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3etween\x3c\/a\x3e去做position的更新。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22new TWEEN.Tween(\n  earth.getCameraPosition()\n).to(\n  targetCameraPosition,\n  1000\n).onUpdate(function () {\n  earth.setCameraPosition(this.x, this.y, this.z)\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e TWEEN.Tween(\n  earth.getCameraPosition()\n).to(\n  targetCameraPosition,\n  \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e\n).onUpdate(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n  earth.setCameraPosition(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.x, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.y, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.z)\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e关于tween和threejs动画，这里有\x3ca href=\x22http:\/\/learningthreejs.com\/blog\/2011\/08\/17\/tweenjs-for-smooth-animation\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e教程\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3e其实最开始，这个Earth类没有这么纯粹，我在里面加了\x3ccode\x3etargetLocation\x3c\/code\x3e代表当前要转到的目标地点；还将tween的逻辑写在了这个类里面，让earth知道自己的目的地，控制自己的旋转动画。但后面发现对于这个项目中动画可控制的灵活性，这样封装在内部的动画逻辑，将很难写成清晰的代码，让其能和后面的云层动画统一来控制起来。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e分步实现：云层\x3c\/h3\x3e\n\x3cp\x3e决定使用SpriteSheet Animation类似的方法做云层动画。其实有这样的库，比如\x3ca href=\x22http:\/\/tgideas.github.io\/motion\/doc\/data\/component\/mo.Film.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eFilm\x3c\/a\x3e（这个好像也是qq下面的团队做的），但是我还是更想从npm中install一个，由于没有找到合适的，就索性自己写一个好了，于是就发布了一个小工具——\x3ca href=\x22https:\/\/github.com\/JackGit\/image-sprite\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eimage-sprite\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3e操作由ImageSprite类创建云层对象，只用到了两个public方法，主要控制播放前一帧和后一帧：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eimageSprite.next()\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eimageSprite.prev()\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e其实应该使用自动播放（play）和暂停（pause）应该也能完成，anyway\x3c\/p\x3e\n\x3cp\x3e云层动画功能单一，想把它写的不纯粹也难。个人觉得coding的艺术就在于如何去划分这个纯粹。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e第一印象\x3c\/h3\x3e\n\x3cp\x3e上面两个关键动画对象都实现了，用户的行为也很简单，只有touchstart和touchend，那么用一个\x3ccode\x3etouchDown\x3c\/code\x3e标志位记录一下就可以了。所以可以有一个中控器（controller），根据用户产生的状态，来调用不同的动画对象播放动画。\x3c\/p\x3e\n\x3cp\x3e最先开始，脑子里面第一印象是下面这样的解决方案：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function handleTouchDown () {\n  touchDown = true\n\n    if (currentState is idle) {\n        playRotatingForwardAnimation(handleAnimationComplete)\n    } else if (currentState is rotating) {\n        playZoomingForwardAnimation(handleAnimationComplete)\n    } else if (currentState is zooming) {\n        playDivingForwardAnimation(handleAnimationComplete)\n    } else if (currentState is diving) {\n        playPresentingForwardAnimation(handleAnimationComplete)\n    } else if (currentState is presenting) {\n        \/\/ nothing to do\n    }\n}\n\nfunction handleTouchEnd () {\n    touchDown = false\n}\n\nfunction handleAnimationComplete () {\n    if (touchDown) {\n        \/\/ 找到下一个阶段，正向播放动画\n        findNextState()\n        play\x3cnextstate\x3eForwardAnimation(handleAnimationComplete)\n    } else {\n        \/\/ 找到上一个阶段，反向播放动画 \n        findPrevState()\n        play\x3cprevstate\x3eBackwardAnimation(handleAnimationComplete)\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ehandleTouchDown\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  touchDown = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (currentState is idle) {\n        playRotatingForwardAnimation(handleAnimationComplete)\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (currentState is rotating) {\n        playZoomingForwardAnimation(handleAnimationComplete)\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (currentState is zooming) {\n        playDivingForwardAnimation(handleAnimationComplete)\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (currentState is diving) {\n        playPresentingForwardAnimation(handleAnimationComplete)\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (currentState is presenting) {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ nothing to do\x3c\/span\x3e\n    }\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ehandleTouchEnd\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    touchDown = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ehandleAnimationComplete\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (touchDown) {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 找到下一个阶段，正向播放动画\x3c\/span\x3e\n        findNextState()\n        play\x26lt;nextstate\x26gt;ForwardAnimation(handleAnimationComplete)\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 找到上一个阶段，反向播放动画 \x3c\/span\x3e\n        findPrevState()\n        play\x26lt;prevstate\x26gt;BackwardAnimation(handleAnimationComplete)\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样的方案能解决动画的大方向，即动画阶段之间的前进和后退，无法控制阶段内的每一帧的方向。而且也能看到，上面有太多的if判断，\x3ccode\x3ehandleTouchDown\x3c\/code\x3e函数中的那种if情况，一定要避免，否则大项目中代码很难维护。这样的情况使用有限状态机模式或者策略模式都是很容易解决的。\x3c\/p\x3e\n\x3cp\x3e第一印象告诉我：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e要使用状态机设计模式\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e要从帧级别去做控制\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e状态机\x3c\/h3\x3e\n\x3cp\x3e写代码过程中肯定会遇到状态，最常见的状态会被记录成布尔值或者字符串常量，然后在做某个行为的时候对状态变量进行if-else判断。如果只有2个状态，还行，但是状态如果会变多，那么这样的代码就很难维护，将在主体中引入越来越多的if-else，越来越多的与特定状态相关的变量和逻辑。\x3c\/p\x3e\n\x3cp\x3e个人非常喜欢状态机模式或者策略模式，它们本质都一样，都是使用组合代替继承，完成统一接口下的行为的多样性。最开心的是，这个模式将混杂在主体中的状态量和行为抽离出来，单独封装，让主体变的清清爽爽；还有，在JS中，你甚至连接口类都不用写！\x3c\/p\x3e\n\x3cp\x3e举个简单的例子，上一篇中谈到的\x3ca href=\x22https:\/\/github.com\/JackGit\/image-sprite\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eImageSprite\x3c\/a\x3e，用来将一系列图片进行播放，本质上就是绘制图片而已。但是我这里提供两种模式，一种绘制在canvas里，一种绘制在dom里（即image展示）。\x3c\/p\x3e\n\x3cp\x3e不使用模式，可以简单的写成这样：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class ImageSprite {\n    constructor () {\n        this.renderMode = \x27canvas\x27\n        this.context = null\n        this.imageElement = null\n        this.images = []\n    }\n    drawImage () {\n        if (this.renderMode === \x27canvas\x27) {\n            this.context.drawImage()\n        } else if (this.rendererMode === \x27dom\x27) {\n            this.imageElement.src = \x27...\x27\n        }\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eImageSprite\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e () {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.renderMode = \x3cspan class=\x22hljs-string\x22\x3e\x27canvas\x27\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.context = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.imageElement = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.images = []\n    }\n    drawImage () {\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.renderMode === \x3cspan class=\x22hljs-string\x22\x3e\x27canvas\x27\x3c\/span\x3e) {\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.context.drawImage()\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.rendererMode === \x3cspan class=\x22hljs-string\x22\x3e\x27dom\x27\x3c\/span\x3e) {\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.imageElement.src = \x3cspan class=\x22hljs-string\x22\x3e\x27...\x27\x3c\/span\x3e\n        }\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e使用了状态机模式（这里的场景来看，叫策略模式更贴切，渲染策略不同）：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class ImageSprite {\n    constructor () {\n        this.renderer = new CanvasRenderer(this)\n        this.images = []\n    }\n    drawImage () {\n        this.renderer.drawImage()\n    }\n}\n\nclass CanvasRenderer {\n    constructor (imageSprite) {\n        this.imageSprite = imageSprite\n        this.context = null\n    }\n    drawImage () {\n        this.context.drawImage()\n    }\n}\n\nclass DomRenderer {\n    constructor (imageSprite) {\n        this.imageSprite = imageSprite\n        this.imageElement = null\n    }\n    drawImage () {\n        this.imageElement.src = \x27...\x27\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eImageSprite\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e () {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.renderer = new CanvasRenderer(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e)\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.images = []\n    }\n    drawImage () {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.renderer.drawImage()\n    }\n}\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eCanvasRenderer\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e (imageSprite) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.imageSprite = imageSprite\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.context = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e\n    }\n    drawImage () {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.context.drawImage()\n    }\n}\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eDomRenderer\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e (imageSprite) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.imageSprite = imageSprite\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.imageElement = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e\n    }\n    drawImage () {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.imageElement.src = \x3cspan class=\x22hljs-string\x22\x3e\x27...\x27\x3c\/span\x3e\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可以看到使用了模式之后，\x3ccode\x3econtext\x3c\/code\x3e和\x3ccode\x3eimageElement\x3c\/code\x3e这样的和状态相关的变量，还有绘制canvas图片和绘制dom图片的不同代码，都从主体ImageSprite中抽离出去，单独的封装到了不同的状态对象中去了。\x3c\/p\x3e\n\x3cp\x3e想想一下如果有第三种渲染模式，比如渲染在webgl中去，在不使用模式的代码中，要添加变量，要修改\x3ccode\x3edrawImage\x3c\/code\x3e函数；但是在使用了模式的代码中，现有代码都不用改变，只需要添加一个新类\x3ccode\x3eWebglRenderer\x3c\/code\x3e就可以了。这就是代码的可扩展性和可维护性的体现。（在Java中，还能省去代码的重新编译的过程）\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e整合\x3c\/h3\x3e\n\x3cp\x3e回到xplan的动画中去。在前面分析动画阶段的时候，其实就得到了每个状态，这些状态的统一接口就是向前帧动画（forward）和向后帧动画（backward）。\x3c\/p\x3e\n\x3cp\x3e先不管每个state中逻辑该怎样，有了约定的接口，就可以把我们的中控器（Controller）写个基本框架了：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Controller {\n    constructor (earth, cloud) {\n        this.earth = earth\n        this.cloud = cloud\n        this.touchDown = false\n        this.state = new IdleState(this) \/\/ 初始状态为IdleState\n        this._init()\n    }\n    _loop () {\n        requestAnimationFrame(this._loop.bind(this))\n        if (this.touchDown) { \/\/ 如果touchDown，则向前一帧\n            this.state.forward()\n        } else { \/\/ 否则，向后一帧\n            this.state.backward()\n    }\n    handleTouchStart () {\n        this.touchDown = true\n    }\n    handleTouchEnd () {\n        this.touchDown = false\n    }\n    \n    \/\/ ...\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eController\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e (earth, cloud) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.earth = earth\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.cloud = cloud\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.touchDown = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e IdleState(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 初始状态为IdleState\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._init()\n    }\n    _loop () {\n        requestAnimationFrame(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._loop.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e))\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.touchDown) { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果touchDown，则向前一帧\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.forward()\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 否则，向后一帧\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.backward()\n    }\n    handleTouchStart () {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.touchDown = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n    }\n    handleTouchEnd () {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.touchDown = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n    }\n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e因为要做到帧级别的控制，因此这里用到requestAnimationFrame来制作渲染循环。代码是不是很清晰简单！在渲染循环中，根本不在乎动画逻辑怎么执行，只知道touchDown了，就做向前动画，否则做向后动画，其他的都在各自的状态类里去实现。\x3c\/p\x3e\n\x3cp\x3e下面拿两个状态类举例，其他的请移步\x3ca href=\x22https:\/\/github.com\/JackGit\/xplan\/blob\/master\/src\/assets\/js\/controller.js\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e这里\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3eIdleState\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class IdleState {\n    constructor (controller) {\n        this.controller = controller\n    }\n    forward () {\n        this.controller.state = new RotatingState(this.controller)\n    }\n    backward () {\n        \/\/ do nothing\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eIdleState\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e (controller) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.controller = controller\n    }\n    forward () {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.controller.state = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e RotatingState(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.controller)\n    }\n    backward () {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ do nothing\x3c\/span\x3e\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里IdleState没有向后的动画，因此\x3ccode\x3ebackward()\x3c\/code\x3e里面是空的；而该状态下的touchDown都会让earth开始旋转到指定坐标，而这个过程我们知道是RotatingState该做的，所以在RotatingState的‘forward()`里会去实现旋转控制。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3eDivingState\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class DivingState {\n    constructor (controller) {\n        this.controller = controller\n    }\n    forward () {\n        let cloud = this.controller.cloud\n        if (cloud.currentFrame is last frame) {  \/\/ 最后一帧时，进入下一个状态\n            this.controller.state = new PresentingState(this.controller)\n        } else {\n            cloud.next() \/\/ 播放下一帧\n        }\n    }\n    backward () {\n        let cloud = this.controller.cloud\n        if (cloud.currentFrame is first frame) {  \/\/ 回退到第一帧时，进入上一个状态\n            this.controller.state = new ZoomingState(this.controller)\n        } else {\n            cloud.prev() \/\/ 播放前一帧\n        }\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eDivingState\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e (controller) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.controller = controller\n    }\n    forward () {\n        \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e cloud = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.controller.cloud\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (cloud.currentFrame is last frame) {  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 最后一帧时，进入下一个状态\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.controller.state = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e PresentingState(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.controller)\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n            cloud.next() \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 播放下一帧\x3c\/span\x3e\n        }\n    }\n    backward () {\n        \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e cloud = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.controller.cloud\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (cloud.currentFrame is first frame) {  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 回退到第一帧时，进入上一个状态\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.controller.state = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e ZoomingState(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.controller)\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n            cloud.prev() \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 播放前一帧\x3c\/span\x3e\n        }\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e还记得么，diving是指穿越云层的那个过程。因此它往前（forward）是presenting，往后（backward）是zooming。而什么时候切换到下一个或者前一个状态，和往前或者往后的每一帧动画该如何执行，都只有这个DivingState知道，完美的逻辑封装。\x3c\/p\x3e\n\x3cp\x3e完整的动画逻辑里，还包含着一些音频和视频的控制逻辑。比如地球自转时播放背景音乐，动画一旦开始则停止；穿越云层后播放视频，其他时候视频是停止的。这些逻辑，能够很容易的添加到上面的状态中去。比如在IdleState的contructor中播放音乐，在RotatingState的contructor中停止播放音乐；在PresentingState的constructor中播放视频，在DivingState的contructor中停止视频。\x3c\/p\x3e\n\x3cp\x3e所以，一旦逻辑清晰了，代码清晰了，添加功能时显得很容易。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e意外收获\x3c\/h3\x3e\n\x3cp\x3e完成上面的所有动画状态之后，我发现地球其实还有一个动画，那就是开场的逆向旋转并放大的入场动画。在上面做动画分析的时候，是把这个开场动画分开来设想的，但是上面的controller用上状态机之后，意外的发现这个入场动画可以以另外一个state放进来。\x3c\/p\x3e\n\x3cp\x3e入场动画状态类：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class EnteringState {\n  constructor (controller) {\n    this.controller = controller\n    this.tween = new TWEEN.Tween({\n      \/\/ 起点位置\n    }).to({\n      \/\/ 终点位置\n    }, 1600).onUpdate(function () {\n      \/\/ 设置earth的缩放和旋转\n    }).onComplete(function () {\n      this.controller.state = new IdleState(this.controller) \/\/ 完成后进入IdleState\n    }).easing(TWEEN.Easing.Cubic.Out).start()\n  }\n  forward () {\n    TWEEN.update()\n  }\n    backward () {\n        \/\/ do nothing\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eEnteringState\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e (controller) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.controller = controller\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.tween = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e TWEEN.Tween({\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 起点位置\x3c\/span\x3e\n    }).to({\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 终点位置\x3c\/span\x3e\n    }, \x3cspan class=\x22hljs-number\x22\x3e1600\x3c\/span\x3e).onUpdate(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 设置earth的缩放和旋转\x3c\/span\x3e\n    }).onComplete(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.controller.state = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e IdleState(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.controller) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 完成后进入IdleState\x3c\/span\x3e\n    }).easing(TWEEN.Easing.Cubic.Out).start()\n  }\n  forward () {\n    TWEEN.update()\n  }\n    backward () {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ do nothing\x3c\/span\x3e\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e最后将Controller初始化时的第一个state赋值改为\x3ccode\x3eEnteringState\x3c\/code\x3e即可。这真算是一个意外的收获，本来是打算单独（在controller之外）去实现的。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader9\x22\x3e小结\x3c\/h2\x3e\n\x3cp\x3e到这里就差不多了，xplan主要的东西都讲到了，高（shan）仿（zhai）的过程还不错，了解了three，顺便还publish了几个小的工具库；有不足、也有超越。这个h5看似复杂，但是技术也没有多高深，主要还是创意，还是要给xplan点个赞！\x3c\/p\x3e\n\x3cp\x3e最后，个人接h5，有没有个人或者公司啊，不要不好意思联系我~\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>高仿腾讯QQ Xplan（X计划）的H5页面（2）：动画控制</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000009679590">https://segmentfault.com/a/1190000009679590</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/ylh7ujztqle/" target="_blank">https://alili.tech/archive/ylh7ujztqle/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>