<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="Chromium Blog: Chrome 66 Beta: CSS Typed Object Model, Async Clipboard API, AudioWorklet"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>Chromium Blog: Chrome 66 Beta: CSS Typed Object Model, Async Clipboard API, AudioWorklet | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/5wvfux6qfld/",
				"appid": "1613049289050283", 
				"title": "Chromium Blog: Chrome 66 Beta: CSS Typed Object Model, Async Clipboard API, AudioWorklet | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-19T02:30:10"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/09vt69zeeoac/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/bot7kfnns7/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f5wvfux6qfld%2f&text=Chromium%20Blog%3a%20Chrome%2066%20Beta%3a%20CSS%20Typed%20Object%20Model%2c%20Async%20Clipboard%20API%2c%20AudioWorklet"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f5wvfux6qfld%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f5wvfux6qfld%2f&text=Chromium%20Blog%3a%20Chrome%2066%20Beta%3a%20CSS%20Typed%20Object%20Model%2c%20Async%20Clipboard%20API%2c%20AudioWorklet"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f5wvfux6qfld%2f&title=Chromium%20Blog%3a%20Chrome%2066%20Beta%3a%20CSS%20Typed%20Object%20Model%2c%20Async%20Clipboard%20API%2c%20AudioWorklet"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f5wvfux6qfld%2f&is_video=false&description=Chromium%20Blog%3a%20Chrome%2066%20Beta%3a%20CSS%20Typed%20Object%20Model%2c%20Async%20Clipboard%20API%2c%20AudioWorklet"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=Chromium%20Blog%3a%20Chrome%2066%20Beta%3a%20CSS%20Typed%20Object%20Model%2c%20Async%20Clipboard%20API%2c%20AudioWorklet&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f5wvfux6qfld%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f5wvfux6qfld%2f&title=Chromium%20Blog%3a%20Chrome%2066%20Beta%3a%20CSS%20Typed%20Object%20Model%2c%20Async%20Clipboard%20API%2c%20AudioWorklet"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f5wvfux6qfld%2f&title=Chromium%20Blog%3a%20Chrome%2066%20Beta%3a%20CSS%20Typed%20Object%20Model%2c%20Async%20Clipboard%20API%2c%20AudioWorklet"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f5wvfux6qfld%2f&title=Chromium%20Blog%3a%20Chrome%2066%20Beta%3a%20CSS%20Typed%20Object%20Model%2c%20Async%20Clipboard%20API%2c%20AudioWorklet"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f5wvfux6qfld%2f&title=Chromium%20Blog%3a%20Chrome%2066%20Beta%3a%20CSS%20Typed%20Object%20Model%2c%20Async%20Clipboard%20API%2c%20AudioWorklet"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">Chromium Blog: Chrome 66 Beta: CSS Typed Object Model, Async Clipboard API, AudioWorklet</h1><div class="meta"><div class="postdate"><time datetime="2019-01-19" itemprop="datePublished">2019-01-19</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n            \x3ch1\x3eChrome 66 Beta: CSS Typed Object Model, Async Clipboard API, AudioWorklet\x3c\/h1\x3e\n\x3cp\x3e除非额外注明，以下描述的更新皆适用于 Android, Chrome OS，Linux，macOS 和 Windows 平台 Chrome Beta 渠道的最新发布。Chrome 66 的全部功能列表在 \x3ca href=\x22https:\/\/www.chromestatus.com\/features#milestone%3D66\x22\x3eChromeStatus\x3c\/a\x3e 上可以查看到。\x3c\/p\x3e\n\x3ch3\x3eImageBitMap Rendering Context \x3ccode\x3e\x26lt;canvas\x26gt;\x3c\/code\x3e\x3c\/h3\x3e\n\x3cp\x3e以前把一张图片渲染到 canvas 上要包含两个部分，首先创建一个\x3ccode\x3e\x26lt;img\x26gt;\x3c\/code\x3e 标签，然后把其内容渲染到 canvas 上。这就导致内存中存在图片的多份拷贝。\x3ca href=\x22https:\/\/www.chromestatus.com\/features\/5709799995998208\x22\x3e一种新的 rendering context\x3c\/a\x3e 通过避免内存复制简化了 \x3ccode\x3eImageBitMap\x3c\/code\x3e 对象的显示步骤，提高了渲染效率。本例展示了如何使用 \x3ccode\x3eImageBitmapRenderingContext\x3c\/code\x3e. 本质上它只是转移图片像素的所有权。该例子把图片像素从一个 blob 转移到一个 \x3ccode\x3e\x26lt;canvas\x26gt;\x3c\/code\x3e，其实像素也能在 \x3ccode\x3e\x26lt;canvas\x26gt;\x3c\/code\x3e 元素之间转移。值得注意的是这个 blob 是被压缩过的所以它在内存中并不是一份全量的拷贝。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e image = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e createImageBitmap(imageBlob);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e canvas = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.createElement(\x3cspan class=\x22hljs-string\x22\x3e\x27canvas\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e context = canvas.getContext(\x3cspan class=\x22hljs-string\x22\x3e\x27bitmaprenderer\x27\x3c\/span\x3e);\ncontext.transferFromImageBitmap(image);\ncanvas.toBlob(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eoutputJPEGBlob\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e\n{ \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Do something with outputJPEGBlob. }, \x27image\/jpeg\x27);\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e如果这里不使用 \x3ccode\x3ecreateImageBitmap()\x3c\/code\x3e，\x3ccode\x3eimageBlob\x3c\/code\x3e 将会延迟解码，这将导致卡顿。另一方面，\x3ccode\x3ecreateImageBitmap()\x3c\/code\x3e  是异步的，使用之前已经完全解码了，避免了卡顿。例如一个 WebGL 游戏可以使用这个功能在游戏进行中一边在后台加载新的贴图。\x3c\/p\x3e\n\x3ch3\x3eCSS Typed Object Model\x3c\/h3\x3e\n\x3cp\x3e以前开发者想要操作 CSS 属性不得不操作浏览器返回的字符串，然后浏览器再把字符串转化回类型化表示。让事情更糟的是，当开发者尝试用 JavaScript 读取 CSS 属性值时，这个类型化的值被转成了一个字符串。在 66 版中，\x3ca href=\x22https:\/\/www.chromestatus.com\/features\/5682491075592192\x22\x3eChrome 实现\x3c\/a\x3e 了 \x3ca href=\x22https:\/\/www.chromestatus.com\/features\/5682491075592192\x22\x3eCSS Typed Object Model ( OM ) Level 1\x3c\/a\x3e ，\x3ca href=\x22https:\/\/developers.google.com\/web\/updates\/2016\/05\/houdini\x22\x3eHoudini\x3c\/a\x3e 的一部分，\x3ca href=\x22https:\/\/chromium.googlesource.com\/chromium\/src\/\x2b\/master\/third\\_party\/WebKit\/Source\/core\/css\/cssom\/README.md\x22\x3eCSS properties 的子集\x3c\/a\x3e。Typed OM 通过把 CSS 值暴露为类型化 JavaScript 对象而非字符串，减少了开发者和浏览器的负担。Typed OM 在允许高性能操作 CSS 属性值的同时，也使得开发者能写出维护性更高的更易于理解的代码。这个简短的例子阐释了这一点。之前如果我想设置一个元素的不透明度我会这样做：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs maxima\x22\x3eel.\x3cspan class=\x22hljs-built_in\x22\x3estyle\x3c\/span\x3e.\x3cspan class=\x22hljs-built_in\x22\x3eopacity\x3c\/span\x3e = \x3cspan class=\x22hljs-number\x22\x3e0.3\x3c\/span\x3e;\nel.\x3cspan class=\x22hljs-built_in\x22\x3estyle\x3c\/span\x3e.\x3cspan class=\x22hljs-built_in\x22\x3eopacity\x3c\/span\x3e === \x3cspan class=\x22hljs-string\x22\x3e\x220.3\x22\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e有了 CSSOM:\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs routeros\x22\x3eel.attributeStyleMap.\x3cspan class=\x22hljs-builtin-name\x22\x3eset\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22opacity\x22\x3c\/span\x3e, CSS.number(\x3cspan class=\x22hljs-string\x22\x3e\x220.3\x22\x3c\/span\x3e));\nel.attributeStyleMap.\x3cspan class=\x22hljs-builtin-name\x22\x3eget\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22opacity\x22\x3c\/span\x3e).value === 0.3 \n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e上面返回的值类型是 \x3ccode\x3eCSSUnitValue\x3c\/code\x3e, 它比字符串更容易操作。\x3c\/p\x3e\n\x3ch3\x3eAsynchronous Clipboard API\x3c\/h3\x3e\n\x3cp\x3e新的\x3ca href=\x22https:\/\/developers.google.com\/web\/updates\/2018\/03\/clipboardapi\x22\x3e异步剪贴板 API\x3c\/a\x3e 提供了一种基于 promise 的方式来读写剪贴板。它比\x3ca href=\x22https:\/\/www.chromestatus.com\/feature\/5223997243392000\x22\x3e在 Chrome 43 中发布的老的 \x3ccode\x3eexecCommand(\x27copy\x27)\x3c\/code\x3e API \x3c\/a\x3e 更加容易，同时还集成了 \x3ca href=\x22https:\/\/www.chromestatus.com\/feature\/6376494003650560\x22\x3ePermissions API\x3c\/a\x3e。在未来的 Chrome 发布中，富类型数据，包括图片，也将得到支持。让我们做一些简单的文本读写操作来品一品这个 API。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs coffeescript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e { \n    \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e navigator.clipboard.writeText(\x3cspan class=\x22hljs-string\x22\x3e\x22Hello, clipboard.\x22\x3c\/span\x3e);\n} \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e { \n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.error(\x3cspan class=\x22hljs-string\x22\x3e\x22Unable to write to clipboard.\x22\x3c\/span\x3e);\n} \n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e相似地，读取文本:\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs haskell\x22\x3e\x3cspan class=\x22hljs-title\x22\x3econst\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e = await navigator.clipboard.readText();\x3c\/span\x3e\n\x3cspan class=\x22hljs-title\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22From the clipboard:\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e);\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e要获取更多信息，包括如何使用 API 的安全性和授权，阅读 \x3ca href=\x22https:\/\/developers.google.com\/web\/updates\/2018\/03\/clipboardapi\x22\x3eUnblocking Clipboard Access\x3c\/a\x3e ，查看我们的\x3ca href=\x22https:\/\/github.com\/GoogleChrome\/samples\/tree\/gh-pages\/async-clipboard\x22\x3e样例\x3c\/a\x3e.\x3c\/p\x3e\n\x3ch3\x3eAudioWorklet\x3c\/h3\x3e\n\x3cp\x3e老的 \x3ccode\x3eScriptProcessorNode\x3c\/code\x3e  是异步的，并且需要线程切换，这会导致音频输出不稳定。\x3ccode\x3eAudioWorklet\x3c\/code\x3e 对象提供了一种新的同步 Javascript 执行上下文，允许开发者以编程方式无延迟地控制音频，使音频输出有更高的稳定性。在 \x3ca href=\x22https:\/\/googlechromelabs.github.io\/web-audio-samples\/audio-worklet\/\x22\x3eGoogle Chrome Labs\x3c\/a\x3e 你可以看到代码示例。除 AudioWorklet 之外，还提供了其他的 worklet API。 Chrome 65\/Opera 52 发布了 \x3ccode\x3ePaintWorklet\x3c\/code\x3e，\x3ccode\x3eAnimationWorklet\x3c\/code\x3e 也在计划中。在 \x3ccode\x3eAudioWorklet\x3c\/code\x3e 发布后的某个时候，\x3ccode\x3eScriptProcessorNode\x3c\/code\x3e 将被废除。\x3c\/p\x3e\n\x3ch3\x3eOther Features in this Release\x3c\/h3\x3e\n\x3ch4\x3eBlink \x26gt; Animation\x3c\/h4\x3e\n\x3cp\x3e\x3ccode\x3eadd\x3c\/code\x3e 和 \x3ccode\x3eaccumulate\x3c\/code\x3e 组合操作旨在构建模块化动画。\x3ccode\x3eadd\x3c\/code\x3e 和 \x3ccode\x3eaccumulate\x3c\/code\x3e 关键字即将在 Chrome 中得到支持。那时它们不再会抛出错误。这是为了与 Firefox 和其他实现保持兼容性。\x3c\/p\x3e\n\x3ch4\x3eBlink \x26gt; CSS\x3c\/h4\x3e\n\x3cp\x3eCSS 有两个新特性。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e根据 \x3ca href=\x22https:\/\/drafts.csswg.org\/css-values-4\/#calc-notation\x22\x3eCSS Values and Units Module Level 4\x3c\/a\x3e标准，数学表达式 \x3ccode\x3ecalc(),\x3c\/code\x3e \x3ccode\x3emin()\x3c\/code\x3e, 和 \x3ccode\x3emax()\x3c\/code\x3e 现在在媒体查询中得到了支持。这个更新使函数表达式与其他类型的规则一致，在允许数字的地方，也允许使用这些函数。\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3ergb()\x3c\/code\x3e 和 \x3ccode\x3ergba()\x3c\/code\x3e 函数现在支持浮点数值。\x3c\/p\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch4\x3eBlink \x26gt; Feature Policy\x3c\/h4\x3e\n\x3cp\x3e默认地，\x3ccode\x3edeviceorientation\x3c\/code\x3e, \x3ccode\x3edeviceorientationabsolute\x3c\/code\x3e, 和 \x3ccode\x3edevicemotion\x3c\/code\x3e 事件现在限制在顶级文档或者同源的子 frame 中触发，效果和在 \x3ca href=\x22https:\/\/github.com\/WICG\/feature-policy\/blob\/gh-pages\/features.md\x22\x3efeature policy\x3c\/a\x3e 中把这些特性设置为 \x3ccode\x3e\x27self\x27\x3c\/code\x3e 一样。要修改这个行为表现，需要显式地\x3ca href=\x22https:\/\/github.com\/WICG\/feature-policy\/blob\/gh-pages\/features.md#sensor-features\x22\x3e启用或禁用相关的特性\x3c\/a\x3e。\x3c\/p\x3e\n\x3ch4\x3eBlink \x26gt; File API\x3c\/h4\x3e\n\x3cp\x3e如果尝试从无效的或者不存在的 blob URL 读取内容，\x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/API\/File\x22\x3eFile API\x3c\/a\x3e 现在会得到网络错误而非404 错误。\x3c\/p\x3e\n\x3ch4\x3eBlink \x26gt; Forms\x3c\/h4\x3e\n\x3cp\x3eHTML forms 有两个特性。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e根据规范要求 \x3ccode\x3e\x26lt;textarea\x26gt;\x3c\/code\x3e 元素和 \x3ccode\x3e\x26lt;select\x26gt;\x3c\/code\x3e 元素现在支持 \x3ccode\x3eautocomplete\x3c\/code\x3e 属性。\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/html.spec.whatwg.org\/#checkbox-state-(type=checkbox\x22\x3e根据 HTML 规范要求\x3c\/a\x3e), 可更改的 checkbox 现在会触发3次事件，一次 \x3ccode\x3eclick\x3c\/code\x3e 事件, 接着一次 \x3ccode\x3einput\x3c\/code\x3e 事件，然后触发一次  \x3ccode\x3echange\x3c\/code\x3e 事件。之前只会触发 \x3ccode\x3eclick\x3c\/code\x3e 和 \x3ccode\x3echange\x3c\/code\x3e 事件。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch4\x3eBlink \x26gt; Fullscreen\x3c\/h4\x3e\n\x3cp\x3e如果全屏模式下的页面打开了一个弹窗并调用 \x3ccode\x3ewindow.focus()\x3c\/code\x3e 获得焦点，\x3ca href=\x22https:\/\/www.chromestatus.com\/feature\/5732193850621952\x22\x3e页面将退出全屏模式\x3c\/a\x3e。如果弹窗通过其他方式获得焦点则页面不会退出全屏。\x3c\/p\x3e\n\x3ch4\x3eBlink \x26gt; GetUserMedia\x3c\/h4\x3e\n\x3cp\x3e\x3ccode\x3eMediaStreamTrack\x3c\/code\x3e 接口上新增了名为 \x3ccode\x3egetCapabilities()\x3c\/code\x3e 的方法，它会返回 \x3ccode\x3eMediaTrackCapabilities\x3c\/code\x3e 对象，指明了每个可约束属性的值或者值的范围。结果因设备而异。\x3c\/p\x3e\n\x3ch4\x3eBlink \x26gt; JavaScript\x3c\/h4\x3e\n\x3cp\x3eJavascript 有数个改变。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eFunction.prototype.toString()\x3c\/code\x3e 函数现在能精确地返回源码中的内容。它包含空格和其他可能未被使用的文本。例如，如果 function 关键字和函数名字之间有注释，注释同时也会被返回。\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/tc39\/proposal-json-superset\x22\x3eJSON 现在是 ECMAScript 的语法子集\x3c\/a\x3e，字符串中允许出现行分隔符 (U\x2b2028)和段落分隔符 (U\x2b2029)。\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3etry\x3c\/code\x3e 语句的 \x3ccode\x3ecatch\x3c\/code\x3e 从句现在支持\x3ca href=\x22https:\/\/tc39.github.io\/proposal-optional-catch-binding\/\x22\x3e无参数形式\x3c\/a\x3e了。\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e除已经实现的 \x3ccode\x3eString.prototype.trim()\x3c\/code\x3e 外，现在 \x3ccode\x3eString.prototype.trimStart()\x3c\/code\x3e and \x3ccode\x3eString.prototype.trimLeft()\x3c\/code\x3e 可以使用了，是修剪字符串前后空白的标准方法。为保持后向兼容，非标准的 \x3ccode\x3etrimLeft()\x3c\/code\x3e 和 \x3ccode\x3etrimRight()\x3c\/code\x3e 作为别名保留了下来。\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\x3ccode\x3eArray.prototype.values()\x3c\/code\x3e 返回一个新的包含数组中的索引值的迭代对象。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch4\x3eBlink \x26gt; Layout\x3c\/h4\x3e\n\x3cp\x3eLayout 有两个新特性。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eCSS gutter 属性移除了 grid 前缀：\x3cul\x3e\n\x3cli\x3e\x3ccode\x3egrid-gap\x3c\/code\x3e 变成 \x3ccode\x3egap\x3c\/code\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ccode\x3egrid-row-gap\x3c\/code\x3e 变成 \x3ccode\x3erow-gap\x3c\/code\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ccode\x3egrid-column-gap\x3c\/code\x3e 变成 \x3ccode\x3ecolumn-gap\x3c\/code\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cblockquote\x3e\n\x3cp\x3e这三个属性的默认值都是 \x3ccode\x3enormal\x3c\/code\x3e，带前缀的属性变成新属性的别名。值得注意的是，\x3ccode\x3ecolumn-gap\x3c\/code\x3e 是一个已经存在的属性，在 \x3ccode\x3ecss-multicol\x3c\/code\x3e 中就已经使用了。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cul\x3e\n\x3cli\x3edisplay 属性是 \x3ccode\x3etable-row\x3c\/code\x3e, \x3ccode\x3etable-row-group\x3c\/code\x3e, \x3ccode\x3etable-header-group\x3c\/code\x3e, \x3ccode\x3etable-footer-group\x3c\/code\x3e, \x3ccode\x3etable-cell\x3c\/code\x3e, 和 \x3ccode\x3etable-caption\x3c\/code\x3e 并且拥有 transform 属性的元素现在是固定定位元素的包含块了。Blink 目前还没有使\x3ccode\x3e\x26lt;tr\x26gt;\x3c\/code\x3e, \x3ccode\x3e\x26lt;tbody\x26gt;\x3c\/code\x3e, \x3ccode\x3e\x26lt;tfoot\x26gt;\x3c\/code\x3e, and \x3ccode\x3e\x26lt;thead\x26gt;\x3c\/code\x3e 成为固定定位元素的包含块。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch4\x3eBlink \x26gt; Media\x3c\/h4\x3e\n\x3cp\x3eMedia 有两个新特性。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e正如\x3ca href=\x22https:\/\/blog.chromium.org\/2017\/09\/unified-autoplay.html\x22\x3e早先声明\x3c\/a\x3e的，\x3ccode\x3eautoplay\x3c\/code\x3e \x3ca href=\x22https:\/\/developers.google.com\/web\/updates\/2017\/09\/autoplay-policy-changes\x22\x3e目前只有在\x3c\/a\x3e 视频不会播放声音，在用户点击或者触摸之后，或者（对于桌面系统）当用户之前在此站点表露了播放媒体的兴趣的情况下有效。这将减少首次打开一个网页时意料之外地播放带声音的视频的情况。\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/www.chromestatus.com\/feature\/5869632707624960\x22\x3e媒体性能和解码信息 API\x3c\/a\x3e 允许网站获取更多的关于客户端解码能力的信息。这使得网站可以给用户提供更有信息感知能力的媒体流，避免一些糟糕场景的发生，例如网站只根据带宽和屏幕尺寸而错误地选择了客户端无法流畅地高效能解码的分辨率。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch4\x3eBlink \x26gt; Network\x3c\/h4\x3e\n\x3cp\x3eFetch API 有两个新特性。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3eRequest 对象目前支持 \x3ccode\x3ekeepalive\x3c\/code\x3e 属性，允许在 tab 关闭后继续 fetch 请求。通过传递布尔值给构造器初始化对象，可以启用这个特性。其值可以通过 request 对象本身读取。该属性还可以和\x3ccode\x3esendBeacon()\x3c\/code\x3e 一起使用。\x3c\/li\x3e\n\x3cli\x3e新的 \x3ccode\x3eAbortSignal\x3c\/code\x3e 和 \x3ccode\x3eAbortController\x3c\/code\x3e 接口允许取消 fetch 请求。要实现这个功能，你需要创建一个 \x3ccode\x3eAbortController\x3c\/code\x3e 对象，把它的 signal 属性以 option 形式传递给 fetch ，通过调用 \x3ccode\x3eabortController.abort()\x3c\/code\x3e 即可取消 fetch。在我们的这篇文章\x3ca href=\x22https:\/\/developers.google.com\/web\/updates\/2017\/09\/abortable-fetch\x22\x3e可中止的 fetch \x3c\/a\x3e可以得到更多的信息。下方是一个小代码示例：\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs qml\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e controller = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e AbortController();\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3esignal\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e \x3c\/span\x3e= controller.signal;\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e requestPromise = fetch(\x3cspan class=\x22hljs-built_in\x22\x3eurl\x3c\/span\x3e, { \x3cspan class=\x22hljs-keyword\x22\x3esignal\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e })\x3c\/span\x3e;\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Abort the fetch: controller.abort();\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\x3ch4\x3eBlink \x26gt; ServiceWorker\x3c\/h4\x3e\n\x3cp\x3eService workers 有两个变化.\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e如果 request 是 \x3ccode\x3esame-origin\x3c\/code\x3e 模式，response 是 \x3ccode\x3eCORS\x3c\/code\x3e 类型，Service worker 不再允许对这种请求进行响应。这是最近 Fetch 规范添加的安全措施。\x3c\/li\x3e\n\x3cli\x3e当 \x3ccode\x3eFetchEvent.clientId\x3c\/code\x3e 未设值，现在将返回空字符串而非 null. 例如浏览器导航请求，就会发生这种情况。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch4\x3eBlink \x26gt; WebRTC\x3c\/h4\x3e\n\x3cp\x3e依照规范，Chrome 现在支持 \x3ccode\x3eRTCRtpSender.dtmf\x3c\/code\x3e 属性，用来替代 还未废除的 \x3ccode\x3eCreateDTMFSender()\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch3\x3e废弃和互用性提升\x3c\/h3\x3e\n\x3ch4\x3eBlink \x26gt; CSS\x3c\/h4\x3e\n\x3cp\x3e\x3ccode\x3eobject-position\x3c\/code\x3e 和 \x3ccode\x3eperspective-origin\x3c\/code\x3e 属性不再接受类似 \x3ccode\x3etop right 20%\x3c\/code\x3e 的这种三参数值。这种改变同样适用于基础形状和渐变。有效的位置值必须是1个、2个或者4个参数的值。\x3c\/p\x3e\n\x3ch4\x3eBlink \x26gt; HTML\x3c\/h4\x3e\n\x3cp\x3e应规范改变，\x3ccode\x3eImageCapture\x3c\/code\x3e 被移除。\x3c\/p\x3e\n\x3ch4\x3eBlink \x26gt; Input\x3c\/h4\x3e\n\x3cp\x3e应规范改变，\x3ccode\x3edocument.createTouch()\x3c\/code\x3e 和 \x3ccode\x3edocument.createTouchList()\x3c\/code\x3e 被移除。\x3c\/p\x3e\n\x3ch4\x3eBlink \x26gt; Web Audio\x3c\/h4\x3e\n\x3cp\x3e  应规范改变，\x3ccode\x3eAudioParam.prototype.value\x3c\/code\x3e 更改的自动解压缩从 Chrome 中被移除。如果你想对 \x3ccode\x3eAudioParam\x3c\/code\x3e 的更改平滑处理，使用 \x3ccode\x3eAudioParam.prorotype.setTargetAtTime()\x3c\/code\x3e。\x3c\/p\x3e\n\n          \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>Chromium Blog: Chrome 66 Beta: CSS Typed Object Model, Async Clipboard API, AudioWorklet</p><h2 id="原文链接">原文链接</h2><p><a href="https://www.zcfy.cc/article/chromium-blog-chrome-66-beta-css-typed-object-model-async-clipboard-api-audioworklet">https://www.zcfy.cc/article/chromium-blog-chrome-66-beta-css-typed-object-model-async-clipboard-api-audioworklet</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/5wvfux6qfld/" target="_blank">https://alili.tech/archive/5wvfux6qfld/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5ed53lrrg7e/">如何禁止浏览器自动填充<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/gij1sdp355j/">实践是检验程序员的唯一标准02：用户不想跟你说话并向你扔出一张图片 - 图片上传组件开发【开发篇】<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/y9eqaypgij/">123<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/4ho25kya1mg/">2018你成长了么？一份给你的前端技术清单<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/g2lx7wrrhy4/">Apache、Nginx 与 Node.js 之争 —— WordPress 与 Ghost 的性能大对决<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/dfejr0q89no/">CSS单位em是相对于父元素还是当前元素的字体大小？<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/cik25m3bh7m/">ES6 系列之 Babel 将 Generator 编译成了什么样子<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/vwkme203i7/">ES6 系列之异步处理实战<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/q2at4ffqrr/">Hola～ 一款基于Electron的聊天软件<aside class="dates">2019-02-15</aside></a></li><li><a href="/archive/t2mci6htsdn/">JavaScript 数组操作方法小结<aside class="dates">2019-02-15</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>